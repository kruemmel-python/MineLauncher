
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Documentation</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --sidebar-bg: #1e293b;
            --text-color: #e2e8f0;
            --link-color: #38bdf8;
            --link-hover: #7dd3fc;
            --border-color: #334155;
            --h2-color: #67e8f9;
            --h3-color: #a5f3fc;
            --code-bg: #1e293b;
        }
        html { scroll-behavior: smooth; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .sidebar {
            width: 300px;
            flex-shrink: 0;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            height: 100vh;
            overflow-y: auto;
            padding: 1.5rem;
            box-sizing: border-box;
        }
        .sidebar h1 {
            font-size: 1.25rem;
            margin-top: 0;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        .sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .sidebar li a {
            display: block;
            padding: 0.5rem 0;
            color: var(--link-color);
            text-decoration: none;
            font-size: 0.875rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: color 0.2s;
        }
        .sidebar li a:hover {
            color: var(--link-hover);
        }
        .main-content {
            flex-grow: 1;
            height: 100vh;
            overflow-y: auto;
            padding: 2rem 3rem;
            box-sizing: border-box;
        }
        section {
            padding-top: 2rem;
            margin-top: -2rem;
            margin-bottom: 3rem;
            border-bottom: 1px solid var(--border-color);
        }
        section:last-child {
            border-bottom: none;
        }
        h2 {
            font-size: 1.75rem;
            color: var(--h2-color);
            font-family: monospace;
        }
        h3 {
            font-size: 1.25rem;
            color: var(--h3-color);
            margin-top: 2rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }
        p { line-height: 1.6; }
        code {
            background-color: var(--code-bg);
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 6px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
        pre {
            background-color: var(--code-bg);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
        }
        pre code {
            padding: 0;
            background: none;
            font-size: 100%;
        }
        .error {
            color: #f87171;
            background-color: #450a0a;
            border: 1px solid #7f1d1d;
            padding: 1rem;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <aside class="sidebar">
        <h1>Project Files</h1>
        <ul>
            <li><a href="#admin_example.md">admin_example.md</a></li><li><a href="#admin_gui.md">admin_gui.md</a></li><li><a href="#dungeon.md">dungeon.md</a></li><li><a href="#enchant.md">enchant.md</a></li><li><a href="#License.md">License.md</a></li><li><a href="#MainForm.cs">MainForm.cs</a></li><li><a href="#Mobs_Enzyklopä.md">Mobs_Enzyklopä.md</a></li><li><a href="#Models/LauncherConfig.cs">Models/LauncherConfig.cs</a></li><li><a href="#npc_create.md">npc_create.md</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorContext.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorContext.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorStatus.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorStatus.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CastSkillNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CastSkillNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CompositeNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CompositeNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CooldownNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CooldownNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/FleeNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/FleeNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealSelfNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealSelfNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealthBelowNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealthBelowNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/InverterNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/InverterNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/MeleeAttackNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/MeleeAttackNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SelectorNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SelectorNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SequenceNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SequenceNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/TargetDistanceAboveNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/TargetDistanceAboveNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/WalkToTargetNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/WalkToTargetNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/command/AuctionCommand.java">plugins/RPGPlugin/src/main/java/com/example/rpg/command/AuctionCommand.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/command/BehaviorCommand.java">plugins/RPGPlugin/src/main/java/com/example/rpg/command/BehaviorCommand.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/command/DungeonCommand.java">plugins/RPGPlugin/src/main/java/com/example/rpg/command/DungeonCommand.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/command/GuildCommand.java">plugins/RPGPlugin/src/main/java/com/example/rpg/command/GuildCommand.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/command/LootChatCommand.java">plugins/RPGPlugin/src/main/java/com/example/rpg/command/LootChatCommand.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/command/PartyCommand.java">plugins/RPGPlugin/src/main/java/com/example/rpg/command/PartyCommand.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/command/PvpCommand.java">plugins/RPGPlugin/src/main/java/com/example/rpg/command/PvpCommand.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGAdminCommand.java">plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGAdminCommand.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGCommand.java">plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGCommand.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/command/TradeCommand.java">plugins/RPGPlugin/src/main/java/com/example/rpg/command/TradeCommand.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/command/VoiceChatCommand.java">plugins/RPGPlugin/src/main/java/com/example/rpg/command/VoiceChatCommand.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/db/DatabaseService.java">plugins/RPGPlugin/src/main/java/com/example/rpg/db/DatabaseService.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/db/PlayerDao.java">plugins/RPGPlugin/src/main/java/com/example/rpg/db/PlayerDao.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/db/SqlPlayerDao.java">plugins/RPGPlugin/src/main/java/com/example/rpg/db/SqlPlayerDao.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonGenerator.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonGenerator.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonInstance.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonInstance.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/JigsawRoomPlacer.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/JigsawRoomPlacer.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/RoomSocketTemplate.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/RoomSocketTemplate.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/RoomStructureLoader.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/RoomStructureLoader.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/RoomTemplate.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/RoomTemplate.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/SchematicRoomStructureLoader.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/SchematicRoomStructureLoader.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/BlockBuffer.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/BlockBuffer.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/Corridor.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/Corridor.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/CorridorRouter.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/CorridorRouter.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonBuilder.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonBuilder.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonDecorator.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonDecorator.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonGraph.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonGraph.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonPlan.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonPlan.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonPlanner.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonPlanner.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonSettings.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonSettings.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonValidator.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonValidator.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/LootPlacer.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/LootPlacer.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/Room.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/Room.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/RoomPlacer.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/RoomPlacer.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/RoomSocket.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/RoomSocket.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/RoomType.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/RoomType.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/SpawnPlacer.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/SpawnPlacer.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Direction.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Direction.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Pattern.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Pattern.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/PatternLoader.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/PatternLoader.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/RoomWfcFiller.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/RoomWfcFiller.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WaveGrid.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WaveGrid.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WfcGenerator.java">plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WfcGenerator.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/gui/BehaviorTreeEditorGui.java">plugins/RPGPlugin/src/main/java/com/example/rpg/gui/BehaviorTreeEditorGui.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiHolders.java">plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiHolders.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/gui/SkillTreeGui.java">plugins/RPGPlugin/src/main/java/com/example/rpg/gui/SkillTreeGui.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ArenaListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ArenaListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/BehaviorEditorListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/BehaviorEditorListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/BuildingPlacementListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/BuildingPlacementListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CombatListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CombatListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CustomMobListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CustomMobListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/DamageIndicatorListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/DamageIndicatorListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/GuiListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/GuiListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ItemStatListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ItemStatListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/MobHealthBarListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/MobHealthBarListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcProtectionListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcProtectionListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/PlayerListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/PlayerListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ProfessionListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ProfessionListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/SkillHotbarListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/SkillHotbarListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ZoneListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ZoneListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ArenaManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ArenaManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/AuctionHouseManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/AuctionHouseManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/BehaviorTreeManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/BehaviorTreeManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/BuildingManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/BuildingManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ClassManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ClassManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/CraftingOrderManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/CraftingOrderManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/DungeonManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/DungeonManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/EnchantManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/EnchantManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/FactionManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/FactionManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/GuildManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/GuildManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ItemStatManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ItemStatManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/LootManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/LootManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/MobManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/MobManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/NpcManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/NpcManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PartyManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PartyManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PlayerDataManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PlayerDataManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ProfessionManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ProfessionManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PvpSeasonManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PvpSeasonManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/QuestManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/QuestManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ResourceNodeManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ResourceNodeManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ShopManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ShopManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillHotbarManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillHotbarManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillSynergyManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillSynergyManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillTreeManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillTreeManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SpawnerManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SpawnerManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/TradeManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/TradeManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/VoiceChatManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/VoiceChatManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/WorldEventManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/WorldEventManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ZoneManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ZoneManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/Arena.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/Arena.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/ArenaStatus.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/ArenaStatus.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/AuctionListing.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/AuctionListing.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/BuildingCategory.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/BuildingCategory.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/BuildingDefinition.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/BuildingDefinition.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/ClassDefinition.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/ClassDefinition.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/CraftingOrder.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/CraftingOrder.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/DialogueNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/DialogueNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/DialogueOption.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/DialogueOption.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/EnchantmentRecipe.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/EnchantmentRecipe.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/EnchantRecipeType.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/EnchantRecipeType.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/EnchantTargetSlot.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/EnchantTargetSlot.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/Faction.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/Faction.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/FactionRank.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/FactionRank.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/FurnitureDefinition.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/FurnitureDefinition.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/Guild.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/Guild.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildMemberRole.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildMemberRole.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildQuest.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildQuest.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootEntry.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootEntry.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootTable.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootTable.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/MobDefinition.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/MobDefinition.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/Npc.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/Npc.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/NpcRole.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/NpcRole.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/Party.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/Party.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/PlayerProfile.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/PlayerProfile.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/Profession.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/Profession.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/PvpSeason.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/PvpSeason.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/Quest.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/Quest.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestProgress.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestProgress.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestReward.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestReward.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStep.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStep.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStepType.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStepType.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/Rarity.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/Rarity.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/ResourceNode.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/ResourceNode.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/RPGStat.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/RPGStat.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopDefinition.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopDefinition.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopItem.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopItem.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/Skill.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/Skill.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillCategory.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillCategory.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillSynergy.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillSynergy.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillType.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillType.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/Spawner.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/Spawner.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/TradeRequest.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/TradeRequest.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/WorldEvent.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/WorldEvent.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/model/Zone.java">plugins/RPGPlugin/src/main/java/com/example/rpg/model/Zone.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionAuditLog.java">plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionAuditLog.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionDecision.java">plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionDecision.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionExplanation.java">plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionExplanation.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionListener.java">plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionListener.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionRepository.java">plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionRepository.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionResolver.java">plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionResolver.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionService.java">plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionService.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PlayerRoles.java">plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PlayerRoles.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PostgresPermissionRepository.java">plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PostgresPermissionRepository.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/Role.java">plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/Role.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/RPGPlugin.java">plugins/RPGPlugin/src/main/java/com/example/rpg/RPGPlugin.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/BlockEntityApplier.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/BlockEntityApplier.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/BlockPalette.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/BlockPalette.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/EntitySpawner.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/EntitySpawner.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtByte.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtByte.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtByteArray.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtByteArray.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtCompound.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtCompound.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtDouble.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtDouble.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtFloat.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtFloat.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtInt.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtInt.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtIntArray.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtIntArray.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtList.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtList.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtLong.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtLong.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtLongArray.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtLongArray.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtShort.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtShort.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtString.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtString.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtTag.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtTag.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtType.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtType.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/NbtIO.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/NbtIO.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/Schematic.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/Schematic.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/SchematicPaster.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/SchematicPaster.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/SchematicSaver.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/SchematicSaver.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/SpongeSchemLoader.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/SpongeSchemLoader.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/Transform.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/Transform.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/UndoBuffer.java">plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/UndoBuffer.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/AggroEffect.java">plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/AggroEffect.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/DamageEffect.java">plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/DamageEffect.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/HealEffect.java">plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/HealEffect.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ParticleEffect.java">plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ParticleEffect.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/PotionStatusEffect.java">plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/PotionStatusEffect.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ProjectileEffect.java">plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ProjectileEffect.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/SoundEffect.java">plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/SoundEffect.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/VelocityEffect.java">plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/VelocityEffect.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/XpEffect.java">plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/XpEffect.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffect.java">plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffect.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectConfig.java">plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectConfig.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectRegistry.java">plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectRegistry.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectType.java">plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectType.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/util/AuditLog.java">plugins/RPGPlugin/src/main/java/com/example/rpg/util/AuditLog.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/util/EloCalculator.java">plugins/RPGPlugin/src/main/java/com/example/rpg/util/EloCalculator.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemBuilder.java">plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemBuilder.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemGenerator.java">plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemGenerator.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/util/PromptManager.java">plugins/RPGPlugin/src/main/java/com/example/rpg/util/PromptManager.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/util/Text.java">plugins/RPGPlugin/src/main/java/com/example/rpg/util/Text.java</a></li><li><a href="#plugins/RPGPlugin/src/main/java/com/example/rpg/util/WorldUtils.java">plugins/RPGPlugin/src/main/java/com/example/rpg/util/WorldUtils.java</a></li><li><a href="#plugins/WorldCreatorPlugin/README.md">plugins/WorldCreatorPlugin/README.md</a></li><li><a href="#plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/FixedBiomeProvider.java">plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/FixedBiomeProvider.java</a></li><li><a href="#plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/SkyIslandsChunkGenerator.java">plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/SkyIslandsChunkGenerator.java</a></li><li><a href="#plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/VoidChunkGenerator.java">plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/VoidChunkGenerator.java</a></li><li><a href="#plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WaterChunkGenerator.java">plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WaterChunkGenerator.java</a></li><li><a href="#plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldCreatorPlugin.java">plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldCreatorPlugin.java</a></li><li><a href="#plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldTypeOption.java">plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldTypeOption.java</a></li><li><a href="#Program.cs">Program.cs</a></li><li><a href="#README.md">README.md</a></li><li><a href="#RPG_Handbuch.md">RPG_Handbuch.md</a></li><li><a href="#rpg_yaml_dashboard.md">rpg_yaml_dashboard.md</a></li><li><a href="#rpg_yaml_dashboard.py">rpg_yaml_dashboard.py</a></li><li><a href="#Services/ClientLauncherService.cs">Services/ClientLauncherService.cs</a></li><li><a href="#Services/ConfigService.cs">Services/ConfigService.cs</a></li><li><a href="#Services/DownloadService.cs">Services/DownloadService.cs</a></li><li><a href="#Services/LauncherService.cs">Services/LauncherService.cs</a></li><li><a href="#Services/ServerService.cs">Services/ServerService.cs</a></li><li><a href="#skill.md">skill.md</a></li><li><a href="#Wiki.html">Wiki.html</a></li>
        </ul>
    </aside>
    <main class="main-content">
        <section id="admin_example.md">
    <h2>admin_example.md</h2>
    <p>Dieses Dokument dient als umfassendes <strong>Admin-Handbuch</strong> für das MineLauncher RPG-System. Es beschreibt die Installation, Konfiguration und Verwaltung eines MMORPG-Servers auf Basis von PaperMC. Die Datei fungiert als Leitfaden für Administratoren, um Spielinhalte wie Klassen, Skills, NPCs, Quests und Dungeons zu erstellen.</p>

    <h3>Kernkomponenten & Abschnitte</h3>

    <h4>1. Voraussetzungen & Installation</h4>
    <p>Beschreibt die technische Basis, die für den Betrieb des Plugins erforderlich ist:</p>
    <ul>
        <li><strong>Server:</strong> PaperMC 1.20.4 oder neuer.</li>
        <li><strong>Java:</strong> JDK 17+.</li>
        <li><strong>Datenbank:</strong> PostgreSQL (zwingend erforderlich für die Persistenz von Spielerdaten).</li>
        <li><strong>Konfiguration:</strong> Einrichtung der <code>config.yml</code> mit Datenbank-Zugangsdaten.</li>
    </ul>

    <h4>2. Gameplay-Systeme (Konfiguration via YAML)</h4>
    <p>Detaillierte Anleitungen zur Definition von Spielinhalten in den Konfigurationsdateien:</p>
    <ul>
        <li><strong>Skills (<code>skills.yml</code>):</strong> Definition von aktiven Fähigkeiten (z. B. Feuerball, Wuchtschlag) mit Effekten wie Projektilen, Sound, Schaden und Partikeln.</li>
        <li><strong>Klassen (<code>classes.yml</code>):</strong> Zuweisung von Start-Skills zu RPG-Klassen wie Magier oder Krieger.</li>
        <li><strong>Wirtschaft (<code>loot.yml</code>, <code>shops.yml</code>):</strong> Erstellung von Beutetabellen für Monster und Einrichtung von Händlershops.</li>
        <li><strong>Custom Mobs (<code>mobs.yml</code>):</strong> Definition von benutzerdefinierten Monstern mit spezifischen Attributen, Beute und KI-Verhalten.</li>
        <li><strong>Gebäude (<code>buildings.yml</code>):</strong> Konfiguration von prozeduralen oder statischen Gebäuden basierend auf WorldEdit-Schematics.</li>
    </ul>

    <h4>3. In-Game Management (Admin-Befehle)</h4>
    <p>Dokumentation der administrativen Werkzeuge zur Weltgestaltung:</p>
    <ul>
        <li><strong>Zonen-System:</strong> Erstellung von Regionen mit Level-Beschränkungen mittels eines Markierungswerkzeugs (Wand).</li>
        <li><strong>NPC-Verwaltung:</strong> Erstellung von NPCs mit Rollen wie <code>VENDOR</code> (Händler) oder <code>QUESTGIVER</code> (Questgeber) und Verknüpfung mit Dialogen.</li>
        <li><strong>Quest-System:</strong> In-Game Erstellung von Quests mit verschiedenen Schritten (Kill, Collect).</li>
        <li><strong>Spawner-System:</strong> Einrichtung von automatischen Spawn-Punkten für Custom Mobs innerhalb von Zonen.</li>
    </ul>

    <h4>4. Fortgeschrittene Systeme</h4>
    <ul>
        <li><strong>Behavior-Editor:</strong> Ein grafisches Tool (Behavior Tree Editor) zur Gestaltung komplexer KI-Verhaltensweisen für Mobs (z. B. Bosse).</li>
        <li><strong>Dungeon-System:</strong> Instanziierte Welten, die prozedural (z. B. via Wave Function Collapse) generiert werden können.</li>
        <li><strong>Permissions-System:</strong> Ein integriertes Rollen- und Berechtigungssystem mit GUI-Unterstützung und Audit-Logs.</li>
        <li><strong>Social-Features:</strong> Verwaltung von Partys, Gilden (mit Banken und Quests) und Auktionshäusern.</li>
    </ul>

    <h3>Wichtige Befehlsübersichten</h3>
    <p>Das Handbuch enthält tabellarische Auflistungen aller relevanten Befehle:</p>
    <ul>
        <li><code>/rpgadmin</code>: Das Hauptmenü für Administratoren (Zonen, NPCs, Quests, Skills, Mobs, Spawner, Bau-Manager).</li>
        <li><code>/rpg</code>: Das Hauptmenü für Spieler (Charakterwerte, Skills, Berufe).</li>
        <li><code>/behavior edit &lt;tree&gt;</code>: Öffnet den KI-Editor für Mobs.</li>
        <li><code>/guild</code> &amp; <code>/party</code>: Befehle für soziale Interaktionen.</li>
        <li><code>/dungeon generate</code>: Erstellt neue Dungeon-Instanzen.</li>
    </ul>

    <h3>Technischer Hinweis</h3>
    <p>Die Dokumentation betont die Wichtigkeit der PostgreSQL-Anbindung, da das Plugin beim Start automatisch Tabellen wie <code>rpg_players</code> und <code>rpg_skills</code> anlegt, um eine persistente Spielerfahrung zu gewährleisten.</p>
</section>
<section id="admin_gui.md">
    <h2>admin_gui.md</h2>
    <p>Diese Dokumentation beschreibt die Benutzeroberfläche für Administratoren (Admin-GUI) des RPG-Plugins. Sie dient als Schritt-für-Schritt-Anleitung für Administratoren zur Verwaltung von Zonen, NPCs, Quests, Loot-Tabellen, Skills und Klassen direkt im Spiel.</p>

    <h3>Allgemeine Bedienungshinweise</h3>
    <ul>
        <li><strong>Voraussetzung:</strong> Berechtigung <code>rpg.editor</code>.</li>
        <li><strong>Editor-Wand (Stick):</strong> Linksklick für Pos1, Rechtsklick für Pos2 (wichtig für Zonen).</li>
        <li><strong>Hauptbefehl:</strong> <code>/rpgadmin</code> öffnet das zentrale Admin-Menü.</li>
        <li><strong>Interaktions-Schema:</strong>
            <ul>
                <li><strong>Linksklick:</strong> Eintrag bearbeiten.</li>
                <li><strong>Rechtsklick:</strong> Eintrag löschen.</li>
                <li><strong>Grüner Block (Slot 53):</strong> Neuen Eintrag erstellen.</li>
            </ul>
        </li>
    </ul>

    <h3>Kernkomponenten & Editoren</h3>

    <h3>1. Zonen-Editor</h3>
    <p>Ermöglicht das Erstellen und Verwalten von Gebieten mit spezifischen Eigenschaften.</p>
    <ul>
        <li><strong>Erstellen:</strong> Erfordert gesetzte Bounds mit der Editor-Wand. Eingabe der <code>&lt;id&gt;</code>.</li>
        <li><strong>Aktionen:</strong>
            <ul>
                <li><code>name &lt;neuerName&gt;</code>: Ändert den Anzeigenamen.</li>
                <li><code>level &lt;min&gt; &lt;max&gt;</code>: Setzt den Level-Bereich der Zone.</li>
                <li><code>mod &lt;slow&gt; &lt;damage&gt;</code>: Setzt Multiplikatoren für Geschwindigkeit und Schaden.</li>
                <li><code>bounds</code>: Übernimmt die aktuell mit der Wand markierten Koordinaten.</li>
                <li><code>world &lt;weltname&gt;</code>: Verschiebt die Zone in eine andere Welt.</li>
            </ul>
        </li>
    </ul>

    <h3>2. NPC-Editor</h3>
    <p>Verwaltet Nicht-Spieler-Charaktere, deren Rollen, Dialoge und Shops.</p>
    <ul>
        <li><strong>Erstellen:</strong> Manuelle Eingabe von <code>&lt;id&gt; &lt;role&gt; [shopId]</code> oder Nutzung von <strong>Shop-Vorlagen</strong> (Waffenhändler, Rüstungshändler, etc.).</li>
        <li><strong>Aktionen:</strong>
            <ul>
                <li><code>role &lt;rolle&gt;</code>: Ändert die Funktion (z.B. VENDOR, QUESTGIVER).</li>
                <li><code>dialog &lt;text&gt;</code>: Setzt den Begrüßungstext.</li>
                <li><code>quest &lt;questId|none&gt;</code>: Verknüpft eine Quest mit dem NPC.</li>
                <li><code>shop &lt;shopId|none&gt;</code>: Verknüpft ein Shop-Inventar.</li>
                <li><code>move</code>: Teleportiert den NPC zur aktuellen Position des Admins.</li>
            </ul>
        </li>
    </ul>

    <h3>3. Quest-Editor</h3>
    <p>Konfiguration von Aufgabenketten für Spieler.</p>
    <ul>
        <li><strong>Erstellen:</strong> Eingabe von <code>&lt;id&gt; &lt;name&gt;</code>.</li>
        <li><strong>Aktionen:</strong>
            <ul>
                <li><code>desc &lt;text&gt;</code>: Setzt die Questbeschreibung.</li>
                <li><code>minlevel &lt;level&gt;</code>: Setzt die Level-Voraussetzung.</li>
                <li><code>repeatable &lt;true|false&gt;</code>: Legt fest, ob die Quest wiederholbar ist.</li>
                <li><code>addstep &lt;type&gt; &lt;target&gt; &lt;amount&gt;</code>: Fügt ein Quest-Ziel hinzu (z.B. Mobs töten).</li>
            </ul>
        </li>
    </ul>

    <h3>4. Loot-Tabellen</h3>
    <p>Definiert Beute-Drops für bestimmte Entitäten.</p>
    <ul>
        <li><strong>Erstellen:</strong> Eingabe von <code>&lt;id&gt; &lt;appliesTo&gt;</code> (z.B. ZOMBIE).</li>
        <li><strong>Aktionen:</strong>
            <ul>
                <li><code>addentry &lt;material&gt; &lt;chance&gt; &lt;min&gt; &lt;max&gt; &lt;rarity&gt;</code>: Fügt einen Gegenstand zur Tabelle hinzu.</li>
                <li><code>clear</code>: Löscht alle Einträge der Tabelle.</li>
            </ul>
        </li>
    </ul>

    <h3>5. Skills &amp; Klassen</h3>
    <p>Verwaltung des RPG-Kampfsystems.</p>
    <ul>
        <li><strong>Skill-Aktionen:</strong> <code>cooldown</code>, <code>mana</code>, <code>category</code>, <code>type</code>, sowie <code>addeffect</code> (z.B. <code>addeffect DAMAGE amount:6 radius:4</code>).</li>
        <li><strong>Klassen-Aktionen:</strong> <code>addskill</code> / <code>removeskill</code> zur Definition von Start-Fähigkeiten einer Klasse.</li>
    </ul>

    <h3>6. Weitere Funktionen</h3>
    <ul>
        <li><strong>Debug Overlay:</strong> Schaltet technische Informationen im HUD an/aus.</li>
        <li><strong>Bau-Manager:</strong> Zugriff auf Gebäude-Kategorien und Schematics.</li>
        <li><strong>Permissions:</strong> Verwaltung von Rollen, Spieler-Zuweisungen und Einsicht in das Audit Log.</li>
    </ul>
</section>
<section id="dungeon.md">
    <h2>dungeon.md</h2>
    <p>
        Diese Datei dient als technische und administrative Dokumentation für das <strong>Dungeon-Generierungssystem</strong> des RPG-Plugins. Sie beschreibt einen hybriden Ansatz, der Makro-Strukturen (Jigsaw-Algorithmus) mit Mikro-Details (Wave Function Collapse - WFC) kombiniert.
    </p>

    <h3>Kernkonzepte</h3>
    <ul>
        <li>
            <strong>Jigsaw-System (Makro):</strong> Verbindet vordefinierte Räume (Schematics) über definierte Anschlusspunkte (Sockets).
        </li>
        <li>
            <strong>WFC-Füllung (Mikro):</strong> Füllt das Innere der platzierten Räume optional mit prozedural generierten Details basierend auf Mustern.
        </li>
        <li>
            <strong>Theme-System:</strong> Organisiert Ressourcen (Schematics und Patterns) in themenbasierten Unterordnern (z. B. <code>crypt</code>, <code>forest</code>).
        </li>
    </ul>

    <h3>Komponenten & Arbeitsabläufe</h3>

    <h4>1. Struktur-Definition (Jigsaw-Räume)</h4>
    <p>
        Räume werden als Minecraft-Schematics (<code>.schem</code>) im Verzeichnis <code>plugins/RPGPlugin/dungeon_rooms/&lt;theme&gt;/</code> hinterlegt. Das System erkennt Raumtypen automatisch anhand von Schlüsselwörtern im Dateinamen:
    </p>
    <ul>
        <li><code>start</code>: Startpunkt des Dungeons.</li>
        <li><code>boss</code>: Endboss-Raum.</li>
        <li><code>loot</code>: Schatzkammern.</li>
        <li><code>combat</code> / <code>elite</code>: Räume für Kämpfe.</li>
        <li><code>exit</code>: Ausgangsbereich.</li>
    </ul>

    <h4>2. Jigsaw-Sockets</h4>
    <p>
        Die Verbindung zwischen Räumen erfolgt über <strong>Jigsaw-Blöcke</strong>. 
        Das System liest das NBT-Feld <code>name</code> des Blocks aus. Räume werden nur verbunden, wenn die Socket-Namen (z. B. <code>corridor_ns</code>) übereinstimmen.
    </p>

    <h4>3. Konfiguration (config.yml)</h4>
    <p>
        Steuert die globalen Parameter der Generierung:
    </p>
    <ul>
        <li><code>dungeon.jigsaw.enabled</code>: Aktiviert oder deaktiviert die raumbasierte Generierung.</li>
        <li><code>dungeon.jigsaw.wfcFill</code>: Bestimmt, ob innerhalb der Jigsaw-Räume der WFC-Algorithmus zur Detailgenerierung ausgeführt wird.</li>
        <li><code>dungeon.jigsaw.wfcTheme</code>: Definiert ein spezifisches WFC-Set, falls dieses vom Dungeon-Theme abweichen soll.</li>
    </ul>

    <h4>4. Administrative Befehle & GUI</h4>
    <p>
        Die Steuerung erfolgt primär über das In-Game-Menü <code>/rpgadmin</code>:
    </p>
    <ul>
        <li><strong>Wand-Tool:</strong> Auswahl von Bereichen zur Erstellung neuer Raum-Schematics.</li>
        <li><strong>Schematic speichern:</strong> Exportiert markierte Bereiche direkt in den korrekten Theme-Ordner.</li>
        <li><strong>Dungeon generieren:</strong> Initiiert den Bauprozess, erstellt eine neue Instanz und teleportiert den Administrator.</li>
    </ul>

    <h3>Fehlerbehebung (Troubleshooting)</h3>
    <ul>
        <li><strong>Leere Dungeons:</strong> Überprüfung der Pfade unter <code>dungeon_rooms/&lt;theme&gt;/</code>.</li>
        <li><strong>Fehlende Verbindungen:</strong> Validierung der NBT-Daten der Jigsaw-Blöcke auf Namensgleichheit.</li>
        <li><strong>WFC ohne Funktion:</strong> Prüfung, ob Pattern-Dateien im entsprechenden WFC-Theme-Ordner existieren.</li>
    </ul>
</section>
<section id="enchant.md">
    <h2>enchant.md</h2>
    <p>Diese Dokumentation beschreibt das <strong>EnchantSystem</strong> des RPG-Plugins. Es dient dazu, RPG-Gegenstände durch Stat-Upgrades oder das Hinzufügen von Affixen zu verbessern.</p>

    <h3>Kernfunktionen des Systems</h3>
    <ul>
        <li><strong>Stat-Verbesserung (STAT_UPGRADE):</strong> Erhöht gezielt Basiswerte wie Stärke oder Geschicklichkeit.</li>
        <li><strong>Affix-Zuweisung (AFFIX):</strong> Fügt dem Gegenstand spezielle Eigenschaften oder Titel hinzu.</li>
        <li><strong>Kostenmanagement:</strong> Verarbeitet Goldwährung und Materialkosten (Items).</li>
        <li><strong>Validierung:</strong> Prüft Spielerlevel, Item-Typ und Slot-Kompatibilität.</li>
    </ul>

    <h3>Benutzeroberfläche (GUI)</h3>
    <p>Das System wird über den Befehl <code>/rpg enchant</code> gesteuert. Die GUI-Struktur ist wie folgt aufgeteilt:</p>
    <ul>
        <li><strong>Slot 10:</strong> Ziel-Item (standardmäßig das Item in der Haupthand).</li>
        <li><strong>Slots 0–8:</strong> Liste der verfügbaren Rezepte (gefiltert nach Level und Typ).</li>
        <li><strong>Slots 14–15:</strong> Anzeige der benötigten Ressourcen (Gold und Materialien).</li>
        <li><strong>Slot 22:</strong> Button zum Ausführen der Verzauberung.</li>
        <li><strong>Slot 26:</strong> Schließen des Menüs.</li>
    </ul>

    <h3>Konfigurationskomponenten (enchantments.yml)</h3>
    <p>Rezepte werden in der <code>enchantments.yml</code> definiert. Ein Rezept besteht aus folgenden Parametern:</p>
    <ul>
        <li><code>type</code>: Bestimmt den Modus (<code>STAT_UPGRADE</code> oder <code>AFFIX</code>).</li>
        <li><code>targetSlot</code>: Definiert die Kompatibilität (z. B. <code>HAND</code>, <code>ARMOR_CHEST</code>, <code>SHIELD</code>).</li>
        <li><code>statToImprove</code>: Der zu steigernde <code>RPGStat</code> (z. B. <code>STRENGTH</code>, <code>DEXTERITY</code>).</li>
        <li><code>affix</code>: Der Name des Affixes, der hinzugefügt werden soll.</li>
        <li><code>minLevel</code>: Das erforderliche Mindestlevel des Spielers.</li>
        <li><code>costGold</code>: Die Kosten in Spielwährung.</li>
        <li><code>costItem</code>: Benötigtes Material im Format <code>MATERIAL:MENGE</code> (z. B. <code>IRON_NUGGET:1</code>).</li>
        <li><code>effects</code>: Optionale visuelle oder auditive Rückmeldungen (z. B. <code>SOUND</code>).</li>
    </ul>

    <h3>Technischer Ablauf (Workflow)</h3>
    <ol>
        <li><strong>Initialisierung:</strong> Das System prüft beim Öffnen der GUI, ob der Spieler ein gültiges RPG-Item hält.</li>
        <li><strong>Rezeptauswahl:</strong> Der Spieler wählt ein Rezept; das System validiert die <code>targetSlot</code>-Kompatibilität.</li>
        <li><strong>Ressourcen-Check:</strong> Prüfung, ob ausreichend Gold und die geforderten Material-Items im Inventar vorhanden sind.</li>
        <li><strong>Datenpersistenz:</strong> Bei Erfolg werden die neuen Werte im <code>PersistentDataContainer</code> des Items gespeichert.</li>
        <li><strong>Lore-Update:</strong> Die Beschreibung (Lore) des Items wird automatisch aktualisiert, um die neuen Stats und Affixe anzuzeigen.</li>
    </ol>

    <h3>Fehlerbehebung (Troubleshooting)</h3>
    <p>Sollten keine Rezepte erscheinen oder die Verzauberung fehlschlagen, sind folgende Punkte zu prüfen:</p>
    <ul>
        <li>Ist das Item ein echtes RPG-Plugin-Item (NBT-Tags vorhanden)?</li>
        <li>Entspricht der Item-Typ dem <code>targetSlot</code> des Rezepts?</li>
        <li>Verfügt der Spieler über das notwendige <code>minLevel</code>?</li>
        <li>Sind die Materialkosten exakt im Inventar vorhanden?</li>
    </ul>
</section>
<section id="License.md">
    <h2>License.md</h2>
    <p>
        Diese Datei enthält die rechtlichen Bestimmungen, unter denen die Software dieses Projekts lizenziert ist. Es handelt sich um die <strong>MIT-Lizenz</strong>, eine permissive Open-Source-Lizenz.
    </p>

    <h3>Kernkomponenten</h3>
    <ul>
        <li>
            <strong>Lizenztyp:</strong> MIT License
        </li>
        <li>
            <strong>Urheberrechtshalter:</strong> Ralf Krümmel (Copyright © 2025)
        </li>
        <li>
            <strong>Zweck:</strong> Festlegung der Nutzungsrechte, Vervielfältigung, Modifikation und Haftungsausschlüsse für das gesamte Repository.
        </li>
    </ul>

    <h3>Rechtliche Bestimmungen</h3>
    <p>Die Lizenz gliedert sich in folgende wesentliche Abschnitte:</p>
    <ul>
        <li>
            <strong>Nutzungsrechte:</strong> Jedem Nutzer wird unentgeltlich die Erlaubnis erteilt, die Software uneingeschränkt zu nutzen, zu kopieren, zu modifizieren, zu fusionieren, zu veröffentlichen, zu verbreiten, zu unterlizenzieren und/oder zu verkaufen.
        </li>
        <li>
            <strong>Bedingungen:</strong> Die einzige Bedingung für die Nutzung ist, dass der oben genannte Urheberrechtshinweis sowie dieser Erlaubnishinweis in allen Kopien oder wesentlichen Teilen der Software enthalten sein müssen.
        </li>
        <li>
            <strong>Haftungsausschluss:</strong> Die Software wird "wie besehen" (AS IS) bereitgestellt, ohne jegliche ausdrückliche oder implizite Gewährleistung. Dies umfasst insbesondere die Marktgängigkeit, die Eignung für einen bestimmten Zweck und die Nichtverletzung von Rechten Dritter. Die Autoren oder Urheberrechtshalter sind in keinem Fall für Ansprüche, Schäden oder andere Haftungen haftbar.
        </li>
    </ul>
</section>
<section id="MainForm.cs">
    <h2>MainForm.cs</h2>
    <p>
        Die Klasse <code>MainForm</code> stellt das Hauptfenster der C_launcher-Anwendung dar. Sie ist als <code>sealed class</code> implementiert und erbt von <code>Form</code>. Diese Komponente dient als grafische Benutzeroberfläche (GUI) zur Verwaltung von Minecraft-Servern und -Clients, einschließlich Konfiguration, Download und Startvorgängen.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        <strong>Name:</strong> <code>MainForm</code><br>
        <strong>Namespace:</strong> <code>CLauncher</code><br>
        <strong>Zweck:</strong> Zentrale Steuerungseinheit für die Benutzerinteraktion. Sie koordiniert verschiedene Dienste (Services), um die Logik des Launchers visuell darzustellen.
    </p>

    <h3>Konstruktor</h3>
    <p>
        <code>public MainForm(string basePath, ConfigService configService, DownloadService downloadService, ServerService serverService, LauncherService launcherService, ClientLauncherService clientLauncherService)</code>
    </p>
    <ul>
        <li><strong>basePath:</strong> Der Basispfad für die Anwendungsdaten.</li>
        <li><strong>Dienste:</strong> Verschiedene injizierte Services für Konfiguration, Downloads, Server-Handling und Client-Start.</li>
        <li><strong>Initialisierung:</strong> Setzt das UI-Layout (Dark Mode Design), initialisiert Buttons, Textboxen für Status und Konfigurations-Editor und lädt die aktuelle Konfiguration.</li>
    </ul>

    <h3>Wichtige Methoden</h3>
    <ul>
        <li>
            <code>private async Task RunActionAsync(Func&lt;Task&gt; action)</code>
            <p>Eine Hilfsmethode, die Buttons während asynchroner Operationen deaktiviert und eine konsistente Fehlerbehandlung sowie Statusaktualisierung bietet.</p>
        </li>
        <li>
            <code>private async Task DownloadServerAsync()</code>
            <p>Verantwortlich für das Herunterladen der Server-JAR-Datei (Paper oder Vanilla) basierend auf der aktuellen Konfiguration. Erstellt zudem notwendige Dateien wie die <code>eula.txt</code> und <code>server.properties</code>.</p>
        </li>
        <li>
            <code>private async Task LaunchServerAsync()</code>
            <p>Prüft die Existenz der Server-Dateien (startet ggf. den Download) und führt den Server-Prozess über den <code>LauncherService</code> aus.</p>
        </li>
        <li>
            <code>private async Task LaunchClientAsync()</code>
            <p>Startet den Minecraft-Client unter Verwendung des konfigurierten Benutzernamens und der Version.</p>
        </li>
        <li>
            <code>private void SaveConfigFromEditor()</code>
            <p>Liest den Text aus dem integrierten Editor (<code>_configEditor</code>), validiert/deserialisiert diesen und speichert die Änderungen über den <code>ConfigService</code>.</p>
        </li>
        <li>
            <code>private void AppendStatus(string message)</code>
            <p>Fügt der Status-Textbox (<code>_statusBox</code>) eine Nachricht mit aktuellem Zeitstempel hinzu.</p>
        </li>
        <li>
            <code>private static void StyleButton(Button button)</code>
            <p>Statische Hilfsmethode zur Anwendung eines einheitlichen visuellen Stils auf die UI-Buttons (Farben, Schriftarten, Hover-Effekte).</p>
        </li>
    </ul>

    <h3>UI-Komponenten</h3>
    <ul>
        <li><strong>_statusBox:</strong> Eine schreibgeschützte TextBox zur Anzeige von Log-Informationen und Prozessstatus.</li>
        <li><strong>_configEditor:</strong> Eine mehrzeilige TextBox, die es dem Benutzer ermöglicht, die <code>LauncherConfig</code> direkt in der GUI zu bearbeiten.</li>
        <li><strong>buttonPanel:</strong> Ein <code>FlowLayoutPanel</code> am oberen Rand, das die Steuerungselemente (Config laden, Server starten, etc.) enthält.</li>
        <li><strong>contentPanel:</strong> Ein <code>SplitContainer</code>, der den Platz zwischen Status-Log und Konfigurations-Editor aufteilt.</li>
    </ul>
</section>
<section id="Mobs_Enzyklopä.md">
    <h2>Mobs_Enzyklopä.md</h2>
    <p>Dieses Dokument dient als umfassende Enzyklopädie und technischer Leitfaden für das Mob-System des RPG-Plugins. Es beschreibt die Fähigkeiten, Skalierungen und Verhaltensmuster der verschiedenen Kreaturen-Klassen, von Standard-Gegnern bis hin zu Welt-Bossen.</p>

    <h3>1. Skill-Lexikon (Mob-Fähigkeiten)</h3>
    <p>Die Mobs nutzen ein dynamisches Skill-System, um im Kampf taktisch zu agieren. Die folgende Liste beschreibt die identifizierten Spezialangriffe und Zauber:</p>
    <ul>
        <li><code>divine_blessing</code>: Heilung oder kurzzeitiger Buff zur Stärkung des Mobs.</li>
        <li><code>frost_bolt</code>: Fernkampf-Projektil, das Ziele potenziell verlangsamt.</li>
        <li><code>execute</code>: Mächtiger Schadens-Skill, der bevorzugt bei niedriger Gesundheit des Ziels oder Mobs eingesetzt wird.</li>
        <li><code>fortify</code>: Temporäre Erhöhung der Verteidigungswerte.</li>
        <li><code>power_strike</code>: Ein schwerer Nahkampf- oder Zauberschlag.</li>
        <li><code>heal_pulse</code>: Selbstheilung über einen Flächeneffekt (AoE).</li>
        <li><code>ember_shot</code>: Ein feuriger Projektilangriff.</li>
        <li><code>shield_wall</code>: Defensive Haltung, die oft kurzzeitige Unverwundbarkeit gewährt.</li>
        <li><code>bleed_strike</code>: Verursacht Blutungsschaden über Zeit (DoT).</li>
        <li><code>poison_cloud</code>: Erzeugt eine Zone, die Giftschaden verursacht.</li>
        <li><code>swamp_snare</code>: Verlangsamt oder fesselt Spieler (Crowd Control).</li>
        <li><code>venom_bite</code>: Giftangriff mit Schaden über Zeit.</li>
        <li><code>frost_howl</code>: Spezifischer Wolf-Skill mit Kälte-Debuff-Areal.</li>
        <li><code>tidal_strike</code>: Mächtiger Angriff der Ertrunkenen (Drowned).</li>
        <li><code>screech</code>: Phantom-Angriff mit potenziellem Betäubungseffekt.</li>
        <li><code>arcane_burst</code>: Magischer Flächenschaden.</li>
        <li><code>deflect</code>: Reduziert eingehenden Schaden oder reflektiert Projektile.</li>
        <li><code>mining_focus</code>: Einzigartiger Skill zur Block-Interaktion oder Resilienz-Steigerung.</li>
    </ul>

    <h3>2. Mob-Kategorien und Skalierung</h3>
    <p>Die Schwierigkeit der Mobs skaliert über 30 Level hinweg, wobei HP, Schaden und Erfahrungspunkte (XP) linear ansteigen.</p>
    
    <h4>Standard-Mobs (Level 1 - 30)</h4>
    <ul>
        <li><strong>Level 1:</strong> 24 HP, 3 DMG, 26 XP (Ausrüstung: Gold/Eisen).</li>
        <li><strong>Level 10:</strong> 60 HP, 8 DMG, 80 XP (Ausrüstung: Leder/Gold/Eisen/Diamant).</li>
        <li><strong>Level 20:</strong> 100 HP, 13 DMG, 140 XP (LootTable: <code>dungeon_mobs</code>).</li>
        <li><strong>Level 30:</strong> 140 HP, 18 DMG, 200 XP (LootTable: <code>elite_mobs</code>).</li>
    </ul>

    <h4>Spezialisten (Unique Mobs)</h4>
    <p>Einzigartige Gegner mit festen Rollen und speziellen Skill-Kombinationen:</p>
    <ul>
        <li><strong>Seuchenbringer (Boss):</strong> Zombie-Typ, nutzt <code>ember_shot</code> und <code>whirlwind</code>.</li>
        <li><strong>Skelettkönig (Boss):</strong> Skelett-Typ, nutzt <code>shield_wall</code> und <code>ember_shot</code> (180 XP).</li>
        <li><strong>Waldbandit:</strong> Pillager-Typ, nutzt Armbrüste und <code>power_strike</code>.</li>
        <li><strong>Sumpfhexe:</strong> Hexe-Typ, spezialisiert auf CC durch <code>poison_cloud</code> und <code>swamp_snare</code>.</li>
    </ul>

    <h3>3. Boss-Systeme</h3>
    <p>Bosse stellen die höchste Herausforderungsstufe dar und sind in zwei Kategorien unterteilt:</p>

    <h4>A. Standard-Level-Bosse (Level 5 - 100)</h4>
    <p>Meist <code>WITHER_SKELETON</code>-Varianten, die taktisch auf <code>shield_wall</code> und <code>execute</code> setzen.</p>
    <ul>
        <li><strong>Level 5-10:</strong> Bis zu 280 HP und 700 XP Belohnung.</li>
        <li><strong>Level 91-100:</strong> Bis zu 1000 HP, 45 DMG und 2500 XP Belohnung.</li>
    </ul>

    <h4>B. Welt-Bosse (Level 120 - 169)</h4>
    <p>Die ultimative Endstufe des Spiels (Typ: <code>WITHER</code>).</p>
    <ul>
        <li><strong>Attribute:</strong> 2000 - 2490 HP, 50 - 62 DMG.</li>
        <li><strong>Ausrüstung:</strong> Vollständige Netherite-Rüstung.</li>
        <li><strong>Belohnung:</strong> Bis zu 7070 XP und Zugriff auf <code>world_boss_loot</code>.</li>
        <li><strong>Verhalten:</strong> Nutzen komplexe Behavior Trees (z.B. <code>lvl01_behavior_001.yml</code>), skaliert auf Boss-Werte, mit Fokus auf Defensive (<code>fortify</code>) und Finishing-Moves (<code>execute</code>).</li>
    </ul>
</section>
<section id="Models/LauncherConfig.cs">
    <h2>Models/LauncherConfig.cs</h2>
    <p>
        Diese Datei definiert die Datenstrukturen für die Konfiguration des Launchers. Sie verwendet C#-Klassen, um die Einstellungen für den Server, die Java-Laufzeitumgebung und den Spiel-Client zu strukturieren. Diese Modelle dienen primär der Serialisierung und Deserialisierung (z. B. von JSON-Dateien).
    </p>

    <h3>Klasse: <code>LauncherConfig</code></h3>
    <p>
        Die Hauptkonfigurationsklasse, die alle Unterbereiche des Launchers zusammenfasst.
    </p>
    <ul>
        <li><strong>InstallRoot</strong> (<code>string</code>): Das Basisverzeichnis, in dem Server-Installationen gespeichert werden. Standardwert: <code>"servers"</code>.</li>
        <li><strong>Server</strong> (<code>ServerConfig</code>): Enthält die spezifischen Einstellungen für die Server-Instanz.</li>
        <li><strong>Java</strong> (<code>JavaConfig</code>): Definiert die Parameter für die Java-Laufzeitumgebung.</li>
        <li><strong>Game</strong> (<code>GameConfig</code>): Enthält Konfigurationen für den Spiel-Client.</li>
    </ul>

    <h3>Klasse: <code>ServerConfig</code></h3>
    <p>
        Verwaltet die technischen Details und Metadaten des Minecraft-Servers.
    </p>
    <ul>
        <li><strong>Name</strong> (<code>string</code>): Der Anzeigename des Servers.</li>
        <li><strong>Type</strong> (<code>string</code>): Der Server-Typ. Mögliche Werte sind <code>vanilla</code>, <code>paper</code>, <code>bukkit</code> oder <code>craftbukkit</code>.</li>
        <li><strong>Version</strong> (<code>string</code>): Die Zielversion von Minecraft (z. B. "1.20.4").</li>
        <li><strong>PaperBuild</strong> (<code>int?</code>): Die spezifische Build-Nummer, falls Paper als Server-Typ verwendet wird.</li>
        <li><strong>OnlineMode</strong> (<code>bool</code>): Gibt an, ob der Server die Authentifizierung über die Mojang-Server erzwingt.</li>
        <li><strong>Port</strong> (<code>int</code>): Der Netzwerk-Port, auf dem der Server lauscht. Standard: <code>25565</code>.</li>
        <li><strong>AcceptEula</strong> (<code>bool</code>): Bestätigt die Annahme der Minecraft End User License Agreement (EULA).</li>
        <li><strong>JarFileName</strong> (<code>string</code>): Der Name der ausführbaren JAR-Datei des Servers.</li>
    </ul>

    <h3>Klasse: <code>JavaConfig</code></h3>
    <p>
        Konfiguriert die Java-Umgebung, die zum Starten des Servers oder Clients benötigt wird.
    </p>
    <ul>
        <li><strong>Path</strong> (<code>string</code>): Der Pfad zur Java-Executable. Standardmäßig <code>"java"</code> (System-Variable).</li>
        <li><strong>MinMemory</strong> (<code>string</code>): Der initiale Arbeitsspeicher (Xms), z. B. <code>"1G"</code>.</li>
        <li><strong>MaxMemory</strong> (<code>string</code>): Der maximale Arbeitsspeicher (Xmx), z. B. <code>"2G"</code>.</li>
    </ul>

    <h3>Klasse: <code>GameConfig</code></h3>
    <p>
        Definiert die Einstellungen für den lokalen Spiel-Client.
    </p>
    <ul>
        <li><strong>ClientVersion</strong> (<code>string</code>): Die zu startende Version des Clients.</li>
        <li><strong>GameDirectory</strong> (<code>string</code>): Das Verzeichnis, in dem Spieldaten (Assets, Welten etc.) abgelegt werden.</li>
        <li><strong>MaxMemoryMb</strong> (<code>int</code>): Die maximale Arbeitsspeicherzuweisung für den Client in Megabyte.</li>
        <li><strong>OfflineMode</strong> (<code>bool</code>): Bestimmt, ob das Spiel im Offline-Modus gestartet werden soll.</li>
        <li><strong>OfflineUsername</strong> (<code>string</code>): Der zu verwendende Benutzername, wenn der Offline-Modus aktiv ist.</li>
    </ul>
</section>
<section id="npc_create.md">
    <h2>npc_create.md</h2>
    <p>Diese Dokumentation beschreibt die Erstellung und Konfiguration von Non-Player Characters (NPCs) innerhalb des RPG-Plugins. Sie deckt sowohl die grundlegenden Befehle als auch die spezialisierten Rollen für Händler und Questgeber ab.</p>

    <h3>Kernkomponenten der NPC-Verwaltung</h3>

    <h4>1. Basis-Erstellung</h4>
    <p>NPCs werden über administrative Befehle direkt im Spiel an der aktuellen Position des Spielers erzeugt.</p>
    <ul>
        <li><strong>Befehl:</strong> <code>/rpgadmin npc create &lt;id&gt; &lt;role&gt;</code></li>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>id</code>: Eindeutiger Bezeichner für den NPC (wird in der <code>npcs.yml</code> gespeichert).</li>
                <li><code>role</code>: Definiert das Verhalten und den Typ des NPCs.</li>
            </ul>
        </li>
    </ul>

    <h4>2. NPC-Rollen (Roles)</h4>
    <p>Die Rolle bestimmt, welche Interaktionsmöglichkeiten der NPC bietet:</p>
    <ul>
        <li><code>QUESTGIVER</code>: Vergabe und Abschluss von Quests.</li>
        <li><code>VENDOR</code>: Verweist auf einen statischen Shop, der in der <code>shops.yml</code> definiert ist.</li>
        <li><code>WEAPON_VENDOR</code>: Dynamischer Händler für RPG-Waffen (Schwerter, Bögen) mit skalierenden Werten.</li>
        <li><code>ARMOR_VENDOR</code>: Dynamischer Händler für RPG-Rüstungen.</li>
        <li><code>ITEM_VENDOR</code>: Händler für Verbrauchsgegenstände wie Tränke und Nahrung.</li>
        <li><code>RESOURCE_VENDOR</code>: Händler für Rohstoffe (z. B. Erze, Diamanten).</li>
    </ul>

    <h4>3. Dialogsystem</h4>
    <p>NPCs unterstützen einfache Chat-Dialoge sowie komplexe, verzweigte Dialogbäume.</p>
    <ul>
        <li><strong>Einfacher Dialog:</strong> Über <code>/rpgadmin npc dialog &lt;id&gt;</code> kann eine einzelne Nachricht gesetzt werden.</li>
        <li><strong>Branching-Dialoge:</strong> Werden manuell in der <code>npcs.yml</code> konfiguriert. Sie unterstützen:
            <ul>
                <li><code>nextId</code>: Verknüpfung zu weiteren Dialogknoten.</li>
                <li><code>grantQuestId</code>: Automatisches Starten einer Quest bei Auswahl einer Option.</li>
            </ul>
        </li>
    </ul>

    <h4>4. Fraktions- und Rang-Gating</h4>
    <p>Interaktionen können an den Ruf des Spielers bei einer bestimmten Fraktion gebunden werden.</p>
    <ul>
        <li><code>/rpgadmin npc faction &lt;npcId&gt; &lt;factionId&gt;</code>: Weist den NPC einer Fraktion zu.</li>
        <li><code>/rpgadmin npc rank &lt;npcId&gt; &lt;rankId&gt;</code>: Setzt den benötigten Mindestrang für Interaktionen (z. B. <code>revered</code>).</li>
    </ul>

    <h4>5. Dynamische RPG-Shops</h4>
    <p>Die neuen Händler-Rollen (Weapon, Armor, Item) nutzen ein dynamisches Generierungssystem:</p>
    <ul>
        <li><strong>Level-Skalierung:</strong> Die angebotenen Items basieren auf dem Level des Spielers, der den Shop öffnet.</li>
        <li><strong>RPG-Attribute:</strong> Generierte Items enthalten Affixe und Werte, die mit dem <code>EnchantSystem</code> kompatibel sind.</li>
        <li><strong>GUI-Integration:</strong> Der Handel erfolgt über ein spezialisiertes Inventar-Interface.</li>
    </ul>

    <h3>Zusammenfassung der Befehle</h3>
    <table border="1">
        <thead>
            <tr>
                <th>Befehl</th>
                <th>Zweck</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>/rpgadmin npc linkquest &lt;id&gt; &lt;questId&gt;</code></td>
                <td>Verknüpft einen QUESTGIVER mit einer spezifischen Quest.</td>
            </tr>
            <tr>
                <td><code>/rpgadmin npc linkshop &lt;id&gt; &lt;shopId&gt;</code></td>
                <td>Verknüpft einen VENDOR mit einem Shop aus der Konfiguration.</td>
            </tr>
        </tbody>
    </table>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorContext.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorContext.java</h2>
    <p>
        Die Klasse <code>BehaviorContext</code> dient als Datencontainer und Zustandsverwaltung für das Behavior-Tree-System (Verhaltensbäume) der Mobs im RPG-Plugin. 
        Sie kapselt alle relevanten Informationen, die ein Verhaltensknoten (<code>BehaviorNode</code>) benötigt, um Entscheidungen zu treffen oder Aktionen auszuführen.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Diese Klasse speichert die Referenz auf das Plugin, die Instanz des Mobs in der Spielwelt, dessen Definition sowie den aktuellen Status von Abklingzeiten (Cooldowns) und das aktuelle Ziel (Target).
    </p>

    <h3>Konstruktor</h3>
    <ul>
        <li>
            <code>BehaviorContext(RPGPlugin plugin, LivingEntity mob, MobDefinition definition)</code>: 
            Initialisiert den Kontext mit den Basisdaten des Mobs.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>plugin()</code>: 
            Gibt die Instanz des <code>RPGPlugin</code> zurück, um Zugriff auf globale Manager und Dienste zu ermöglichen.
            <br><strong>Rückgabewert:</strong> <code>RPGPlugin</code>
        </li>
        <li>
            <code>mob()</code>: 
            Gibt die Bukkit-Entität (<code>LivingEntity</code>) zurück, die dieses Verhalten ausführt.
            <br><strong>Rückgabewert:</strong> <code>LivingEntity</code>
        </li>
        <li>
            <code>definition()</code>: 
            Gibt die <code>MobDefinition</code> zurück, welche die statischen Attribute und Konfigurationen des Mobs enthält.
            <br><strong>Rückgabewert:</strong> <code>MobDefinition</code>
        </li>
        <li>
            <code>target()</code>: 
            Liefert den aktuellen Spieler, den der Mob als Ziel ausgewählt hat.
            <br><strong>Rückgabewert:</strong> <code>Player</code> (kann null sein)
        </li>
        <li>
            <code>setTarget(Player target)</code>: 
            Setzt oder aktualisiert das aktuelle Ziel des Mobs.
            <br><strong>Parameter:</strong> <code>Player target</code> - Der anvisierte Spieler.
        </li>
        <li>
            <code>cooldowns()</code>: 
            Gibt eine Map zurück, die Zeitstempel für verschiedene Aktionen speichert, um Abklingzeiten zu verwalten.
            <br><strong>Rückgabewert:</strong> <code>Map&lt;String, Long&gt;</code>
        </li>
        <li>
            <code>mobId()</code>: 
            Hilfsmethode zur schnellen Abfrage der eindeutigen ID (UUID) des Mobs.
            <br><strong>Rückgabewert:</strong> <code>UUID</code>
        </li>
    </ul>

    <h3>Wichtige Felder</h3>
    <ul>
        <li><code>cooldowns</code>: Eine <code>HashMap</code>, die Aktionsnamen (Strings) auf Millisekunden-Zeitstempel (Long) abbildet, um zu prüfen, wann eine Fähigkeit erneut eingesetzt werden darf.</li>
        <li><code>target</code>: Speichert die Referenz auf ein <code>Player</code>-Objekt, was für Navigations- und Angriffsknoten essenziell ist.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorNode.java</h2>
    <p>
        Die Klasse <code>BehaviorNode</code> ist die abstrakte Basisklasse für alle Knoten innerhalb eines Behavior Trees (Verhaltensbaums). 
        Sie definiert das grundlegende Framework für die Ausführung von KI-Logik für Entitäten im RPG-System.
    </p>

    <h3>Klasse: BehaviorNode</h3>
    <p><strong>Typ:</strong> <code>abstract class</code></p>
    <p>
        Diese Klasse dient als Vorlage für spezifische Verhaltensknoten wie Selektoren, Sequenzen oder Blattknoten (Aktionen/Bedingungen). 
        Jeder Knoten besitzt eine eindeutige Identifikation und eine Methode zur Ausführung der Logik pro Tick.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>protected BehaviorNode(String id)</code>: Initialisiert den Knoten mit einer eindeutigen ID. 
            Da die Klasse abstrakt ist, wird dieser Konstruktor nur von Unterklassen aufgerufen.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public String id()</code>
            <p>Gibt die eindeutige Kennung dieses Knotens zurück.</p>
            <p><strong>Rückgabewert:</strong> <code>String</code> - Die ID des Knotens.</p>
        </li>
        <li>
            <code>public abstract BehaviorStatus tick(BehaviorContext context)</code>
            <p>
                Die Kernmethode des Knotens. Sie wird regelmäßig aufgerufen, um die Logik des Knotens zu verarbeiten.
            </p>
            <p><strong>Parameter:</strong></p>
            <ul>
                <li><code>context</code> (BehaviorContext): Der aktuelle Kontext der Ausführung, der Informationen über die Entität und die Umgebung enthält.</li>
            </ul>
            <p><strong>Rückgabewert:</strong> <code>BehaviorStatus</code> - Der Status nach der Ausführung (z. B. SUCCESS, FAILURE oder RUNNING).</p>
        </li>
        <li>
            <code>protected String key(UUID entityId)</code>
            <p>
                Hilfsmethode zur Erzeugung eines eindeutigen Schlüssels für eine bestimmte Entität. 
                Dies ist nützlich, um zustandsbehaftete Informationen in einem globalen Speicher (Blackboard) zu hinterlegen, die spezifisch für diesen Knoten und diese Entität sind.
            </p>
            <p><strong>Parameter:</strong></p>
            <ul>
                <li><code>entityId</code> (UUID): Die Unique ID der Entität.</li>
            </ul>
            <p><strong>Rückgabewert:</strong> <code>String</code> - Ein kombinierter Schlüssel im Format <code>id:entityId</code>.</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorStatus.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorStatus.java</h2>

    <p>
        Die Datei definiert das Enum <code>BehaviorStatus</code>, welches die grundlegenden Zustände für die Knoten (Nodes) innerhalb eines Behavior Trees (Verhaltensbaums) festlegt. Diese Zustände steuern den Kontrollfluss des KI-Verhaltens im RPG-System.
    </p>

    <h3>Enum: BehaviorStatus</h3>
    <p>
        Dieses Enum repräsentiert das Ergebnis der Auswertung eines <code>BehaviorNode</code>. Es ermöglicht komplexen Entscheidungsstrukturen zu bestimmen, ob ein Pfad fortgesetzt, abgebrochen oder im nächsten Tick erneut evaluiert werden muss.
    </p>

    <h4>Konstanten</h4>
    <ul>
        <li>
            <code>SUCCESS</code>: 
            Gibt an, dass die Ausführung des Knotens erfolgreich abgeschlossen wurde. In einer Sequenz würde dies den nächsten Knoten triggern.
        </li>
        <li>
            <code>FAILURE</code>: 
            Gibt an, dass die Bedingung des Knotens nicht erfüllt wurde oder die Aktion fehlgeschlagen ist. In einem Selektor würde dies dazu führen, dass der nächste alternative Knoten geprüft wird.
        </li>
        <li>
            <code>RUNNING</code>: 
            Gibt an, dass der Knoten noch aktiv ist und seine Aufgabe noch nicht beendet hat. Der Behavior Tree wird diesen Knoten im nächsten Update-Zyklus erneut aufrufen, anstatt von der Wurzel neu zu starten oder zum nächsten Geschwisterknoten zu springen.
        </li>
    </ul>

    <h4>Zusammenhang im System</h4>
    <p>
        Dieses Enum ist eine Kernkomponente für die Implementierung von KI-Logiken, wie sie in den Klassen <code>SelectorNode</code>, <code>SequenceNode</code> und verschiedenen Aktions-Knoten (z.B. <code>WalkToTargetNode</code>) verwendet werden.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CastSkillNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CastSkillNode.java</h2>

    <p>
        Die Klasse <code>CastSkillNode</code> ist ein spezialisierter Verhaltensknoten (Behavior Node) innerhalb eines Behavior Tree Systems. 
        Ihr Hauptzweck ist es, eine spezifische Fertigkeit (Skill) durch ein Mob (NPC/Monster) auf ein Ziel ausführen zu lassen.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.behavior</code></li>
        <li><strong>Basisklasse:</strong> <code>BehaviorNode</code></li>
    </ul>

    <h3>Konstruktor</h3>
    <p><code>public CastSkillNode(String id, String skillId)</code></p>
    <ul>
        <li><code>id</code>: Die eindeutige Identifikationsnummer des Knotens im Verhaltensbaum.</li>
        <li><code>skillId</code>: Die ID der Fertigkeit, die ausgeführt werden soll (referenziert üblicherweise Einträge in der <code>skills.yml</code>).</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>public BehaviorStatus tick(BehaviorContext context)</code></h4>
    <p>
        Diese Methode wird bei jedem Update-Zyklus des Verhaltensbaums aufgerufen. Sie steuert die Logik zur Aktivierung der Fertigkeit.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>context</code>: Das <code>BehaviorContext</code>-Objekt, das Informationen über das ausführende Mob, das aktuelle Ziel und die Plugin-Instanz enthält.</li>
            </ul>
        </li>
        <li><strong>Logik:</strong>
            <ol>
                <li>Prüft, ob ein gültiges Ziel (Player) im Kontext vorhanden ist.</li>
                <li>Falls kein Ziel existiert, schlägt der Knoten fehl (<code>FAILURE</code>).</li>
                <li>Ruft die Methode <code>useMobSkill</code> des Plugins auf, um die Fertigkeit <code>skillId</code> vom Mob auf das Ziel zu wirken.</li>
                <li>Gibt <code>SUCCESS</code> zurück, wenn die Fertigkeit erfolgreich ausgelöst wurde, andernfalls <code>FAILURE</code>.</li>
            </ol>
        </li>
        <li><strong>Rückgabewert:</strong> <code>BehaviorStatus</code> (SUCCESS oder FAILURE).</li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>org.bukkit.entity.Player</code>: Repräsentiert das Ziel der Fertigkeit.</li>
        <li><code>BehaviorContext</code>: Liefert die notwendigen Laufzeitdaten für die Ausführung.</li>
        <li><code>BehaviorStatus</code>: Definiert den Status nach der Ausführung des Knotens.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CompositeNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CompositeNode.java</h2>

    <p>
        Die Klasse <code>CompositeNode</code> ist eine abstrakte Basisklasse innerhalb des Behavior-Tree-Systems (Verhaltensbaum). 
        Sie dient als strukturelles Element, das mehrere Kind-Knoten (<code>BehaviorNode</code>) verwalten kann. 
        In einem Verhaltensbaum steuern Composite-Knoten den Kontrollfluss, indem sie entscheiden, welcher ihrer Kind-Knoten als Nächstes ausgeführt wird.
    </p>

    <h3>Klasse: CompositeNode</h3>
    <p><strong>Typ:</strong> <code>public abstract class</code></p>
    <p><strong>Erbt von:</strong> <code>BehaviorNode</code></p>

    <h4>Beschreibung</h4>
    <p>
        Diese Klasse stellt die Infrastruktur bereit, um eine Liste von untergeordneten Knoten zu speichern und darauf zuzugreifen. 
        Konkrete Implementierungen dieser Klasse (wie zum Beispiel <code>SelectorNode</code> oder <code>SequenceNode</code>) definieren die Logik, 
        wie diese Kinder verarbeitet werden.
    </p>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>protected CompositeNode(String id)</code>: 
            Initialisiert einen neuen Composite-Knoten mit einer eindeutigen Identifikationsnummer (ID). 
            Da die Klasse abstrakt ist, wird dieser Konstruktor nur von Unterklassen aufgerufen.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public List&lt;BehaviorNode&gt; children()</code>
            <ul>
                <li><strong>Zweck:</strong> Gibt die Liste aller diesem Knoten untergeordneten Kind-Knoten zurück.</li>
                <li><strong>Rückgabewert:</strong> Eine <code>List</code> von <code>BehaviorNode</code>-Objekten.</li>
            </ul>
        </li>
    </ul>

    <h4>Interne Felder</h4>
    <ul>
        <li><code>private final List&lt;BehaviorNode&gt; children</code>: Eine interne Liste (ArrayList), die die Kind-Knoten speichert.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CooldownNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CooldownNode.java</h2>

    <p>Die Klasse <code>CooldownNode</code> ist ein spezialisierter Knoten innerhalb eines Behavior Tree (Verhaltensbaum), der dazu dient, die Ausführungshäufigkeit eines untergeordneten Knotens basierend auf einer Zeitspanne (Cooldown) zu begrenzen.</p>

    <h3>Klassenübersicht</h3>
    <p><strong>Paket:</strong> <code>com.example.rpg.behavior</code></p>
    <p><strong>Vererbung:</strong> Erbt von <code>BehaviorNode</code></p>

    <h3>Konstruktor</h3>
    <p>Initialisiert einen neuen Cooldown-Knoten mit einer spezifischen ID, einem Kind-Knoten und der gewünschten Wartezeit.</p>
    <ul>
        <li><code>id</code> (String): Die eindeutige Kennung des Knotens.</li>
        <li><code>child</code> (BehaviorNode): Der untergeordnete Knoten, dessen Ausführung kontrolliert wird.</li>
        <li><code>cooldownMillis</code> (long): Die Cooldown-Zeit in Millisekunden.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>tick(BehaviorContext context)</code></h4>
    <p>Führt die Logik des Knotens aus. Die Methode prüft zuerst, ob die Cooldown-Zeit seit der letzten erfolgreichen Ausführung bereits verstrichen ist.</p>
    <ul>
        <li><strong>Parameter:</strong> 
            <ul>
                <li><code>context</code> (BehaviorContext): Der aktuelle Kontext der Verhaltenssteuerung, der Informationen über den Mob und bestehende Cooldowns enthält.</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> <code>BehaviorStatus</code>
            <ul>
                <li><code>FAILURE</code>: Wenn der Cooldown noch aktiv ist.</li>
                <li>Status des Kind-Knotens: Wenn der Cooldown abgelaufen ist, wird der Kind-Knoten ausgeführt und dessen Status zurückgegeben.</li>
            </ul>
        </li>
        <li><strong>Logik:</strong> Wenn der Kind-Knoten den Status <code>SUCCESS</code> zurückgibt, wird der Zeitstempel für den Cooldown im Kontext aktualisiert.</li>
    </ul>

    <h3>Funktionsweise</h3>
    <p>Der Knoten nutzt eine Kombination aus der Mob-ID und der Knoten-ID, um einen eindeutigen Schlüssel für die Cooldown-Verwaltung im <code>BehaviorContext</code> zu generieren. Dies stellt sicher, dass verschiedene Mobs oder verschiedene Cooldown-Knoten sich nicht gegenseitig beeinflussen.</p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/FleeNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/FleeNode.java</h2>

    <p>
        Die Klasse <code>FleeNode</code> ist ein spezialisierter Verhaltensknoten (Behavior Node) innerhalb eines Behavior Tree Systems. 
        Ihr Hauptzweck besteht darin, eine Fluchtlogik für ein Entity (Mob) zu implementieren, wenn ein Ziel (Player) vorhanden ist.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.behavior</code></li>
        <li><strong>Basisklasse:</strong> <code>BehaviorNode</code></li>
        <li><strong>Abhängigkeiten:</strong> <code>org.bukkit.Location</code>, <code>org.bukkit.entity.Player</code>, <code>org.bukkit.util.Vector</code></li>
    </ul>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code><strong>FleeNode(String id)</strong></code>: 
            Initialisiert eine neue Instanz des Fluchtknotens mit einer eindeutigen Identifikationsnummer.
        </li>
    </ul>

    <h3>Methoden</h3>
    <div class="method-documentation">
        <h4><code>public BehaviorStatus tick(BehaviorContext context)</code></h4>
        <p>
            Führt die Logik des Knotens im aktuellen Tick des Behavior Trees aus. Die Methode berechnet einen Vektor, der vom Ziel wegführt, und wendet diesen auf die Geschwindigkeit des Mobs an.
        </p>
        
        <strong>Parameter:</strong>
        <ul>
            <li><code>context</code> (BehaviorContext): Der aktuelle Kontext, der Informationen über den ausführenden Mob und das aktuelle Ziel enthält.</li>
        </ul>

        <strong>Rückgabewerte:</strong>
        <ul>
            <li><code>BehaviorStatus.FAILURE</code>: Wenn kein Ziel vorhanden ist oder die Positionen von Mob und Ziel identisch sind (Vektorlänge Null).</li>
            <li><code>BehaviorStatus.RUNNING</code>: Wenn die Fluchtbewegung erfolgreich eingeleitet wurde.</li>
        </ul>

        <strong>Funktionsweise:</strong>
        <ol>
            <li>Prüft, ob ein Ziel-Spieler im <code>context</code> existiert.</li>
            <li>Berechnet die Differenz zwischen der Position des Mobs und der Position des Spielers.</li>
            <li>Normalisiert den resultierenden Richtungsvektor (um eine gleichmäßige Richtung zu erhalten).</li>
            <li>Multipliziert den Vektor mit einem Faktor von <code>0.35</code>, um die Fluchtgeschwindigkeit festzulegen.</li>
            <li>Setzt die Velocity (Geschwindigkeit) des Mobs auf diesen Vektor, sodass er sich vom Spieler wegbewegt.</li>
        </ol>
    </div>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealSelfNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealSelfNode.java</h2>

    <p>Die Klasse <code>HealSelfNode</code> ist eine spezialisierte Implementierung eines <code>BehaviorNode</code> innerhalb des Behavior-Tree-Systems. Ihr Hauptzweck ist es, die Lebenspunkte (HP) des ausführenden Mobs um einen definierten Wert zu erhöhen.</p>

    <h3>Klasse: HealSelfNode</h3>
    <p><strong>Erbt von:</strong> <code>BehaviorNode</code></p>
    <p>Diese Klasse stellt eine Blatt-Aktion (Action Node) dar, die eine Selbstheilung durchführt.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>HealSelfNode(String id, double amount)</code>: Initialisiert den Knoten.
            <ul>
                <li><code>id</code>: Eine eindeutige Zeichenfolge zur Identifizierung des Knotens.</li>
                <li><code>amount</code>: Der Fließkommawert, um den der Mob geheilt werden soll.</li>
            </ul>
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public BehaviorStatus tick(BehaviorContext context)</code>
            <p>Führt die Heilungslogik aus, wenn der Knoten vom Behavior Tree aufgerufen wird.</p>
            <p><strong>Logik:</strong></p>
            <ol>
                <li>Ermittelt das maximale Leben des Mobs aus der Definition (mindestens 1, um Divisionen durch Null oder ungültige Zustände zu vermeiden).</li>
                <li>Berechnet die neue Gesundheit, indem der <code>amount</code> zum aktuellen Wert addiert wird, wobei das Maximum nicht überschritten werden kann (<code>Math.min</code>).</li>
                <li>Aktualisiert die Gesundheit des Mobs im <code>context</code>.</li>
            </ol>
            <p><strong>Rückgabewert:</strong> Gibt immer <code>BehaviorStatus.SUCCESS</code> zurück, da die Heilung als erfolgreich abgeschlossen betrachtet wird, sobald die Werte aktualisiert wurden.</p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>BehaviorContext</code>: Liefert Informationen über den aktuellen Zustand des Mobs und dessen Definition.</li>
        <li><code>BehaviorStatus</code>: Definiert den Rückgabestatus der Operation.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealthBelowNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealthBelowNode.java</h2>

    <p>Die Klasse <code>HealthBelowNode</code> ist ein spezialisierter Verhaltensknoten (Behavior Node) innerhalb des Behavior-Tree-Systems des RPG-Plugins. Sie dient als Bedingungsknoten, der prüft, ob die aktuelle Gesundheit eines Mobs einen definierten prozentualen Schwellenwert unterschritten hat.</p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.behavior</code></li>
        <li><strong>Basisklasse:</strong> <code>BehaviorNode</code></li>
        <li><strong>Zweck:</strong> Überprüfung des Gesundheitszustands eines Mobs für logische Verzweigungen (z. B. Fluchtverhalten oder Selbstheilung bei niedrigen Lebenspunkten).</li>
    </ul>

    <h3>Konstruktor</h3>
    <p><code>public HealthBelowNode(String id, double threshold)</code></p>
    <ul>
        <li><code>id</code>: Eine eindeutige Identifikation für diesen Knoten.</li>
        <li><code>threshold</code>: Der Schwellenwert als Dezimalzahl (z. B. <code>0.3</code> für 30% Gesundheit).</li>
    </ul>

    <h3>Methoden</h3>
    <h4><code>tick(BehaviorContext context)</code></h4>
    <p>Diese Methode führt die Logik des Knotens aus und wird regelmäßig vom Behavior-Tree-System aufgerufen.</p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>context</code>: Das <code>BehaviorContext</code>-Objekt, das Informationen über den Mob und dessen Definition enthält.</li>
            </ul>
        </li>
        <li><strong>Logik:</strong>
            <ol>
                <li>Ermittelt die maximale Gesundheit aus der Mob-Definition (stellt sicher, dass der Wert mindestens 1 beträgt, um Divisionen durch Null zu vermeiden).</li>
                <li>Ruft die aktuelle Gesundheit des Mobs ab.</li>
                <li>Berechnet das Verhältnis von aktueller zu maximaler Gesundheit.</li>
                <li>Vergleicht das Verhältnis mit dem konfigurierten <code>threshold</code>.</li>
            </ol>
        </li>
        <li><strong>Rückgabewerte (BehaviorStatus):</strong>
            <ul>
                <li><code>SUCCESS</code>: Wenn die aktuelle Gesundheit unter dem Schwellenwert liegt.</li>
                <li><code>FAILURE</code>: Wenn die aktuelle Gesundheit über oder gleich dem Schwellenwert liegt.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/InverterNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/InverterNode.java</h2>

    <p>Die Klasse <code>InverterNode</code> ist ein spezialisierter Knoten innerhalb eines Behavior Tree (Verhaltensbaum). Sie fungiert als Dekorator-Knoten, der das Ergebnis seines Kind-Knotens umkehrt (invertiert).</p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.behavior</code></li>
        <li><strong>Basisklasse:</strong> <code>BehaviorNode</code></li>
        <li><strong>Zweck:</strong> Invertierung des Status-Ergebnisses eines untergeordneten Knotens (SUCCESS wird zu FAILURE und umgekehrt).</li>
    </ul>

    <h3>Konstruktor</h3>
    <p><code>public InverterNode(String id, BehaviorNode child)</code></p>
    <ul>
        <li><strong>id:</strong> Eine eindeutige Identifikation für diesen Knoten.</li>
        <li><strong>child:</strong> Der untergeordnete <code>BehaviorNode</code>, dessen Ergebnis invertiert werden soll.</li>
    </ul>

    <h3>Methoden</h3>
    <h4><code>tick(BehaviorContext context)</code></h4>
    <p>Führt die Logik des Knotens aus, indem der <code>tick</code> des Kind-Knotens aufgerufen und dessen Rückgabewert transformiert wird.</p>
    <ul>
        <li><strong>Parameter:</strong> <code>BehaviorContext context</code> – Der aktuelle Kontext, in dem das Verhalten ausgeführt wird (enthält z. B. Informationen über das Entity oder die Welt).</li>
        <li><strong>Rückgabewert:</strong> <code>BehaviorStatus</code> – Der resultierende Status nach der Invertierung:
            <ul>
                <li>Gibt <code>FAILURE</code> zurück, wenn das Kind <code>SUCCESS</code> liefert.</li>
                <li>Gibt <code>SUCCESS</code> zurück, wenn das Kind <code>FAILURE</code> liefert.</li>
                <li>Gibt <code>RUNNING</code> zurück, wenn das Kind weiterhin aktiv ist (keine Invertierung während der Laufzeit).</li>
            </ul>
        </li>
    </ul>

    <h3>Logik-Tabelle</h3>
    <table border="1" style="border-collapse: collapse; width: 100%; text-align: left;">
        <thead>
            <tr style="background-color: #f2f2f2;">
                <th style="padding: 8px;">Status des Kind-Knotens</th>
                <th style="padding: 8px;">Resultat des InverterNode</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="padding: 8px;"><code>SUCCESS</code></td>
                <td style="padding: 8px;"><code>FAILURE</code></td>
            </tr>
            <tr>
                <td style="padding: 8px;"><code>FAILURE</code></td>
                <td style="padding: 8px;"><code>SUCCESS</code></td>
            </tr>
            <tr>
                <td style="padding: 8px;"><code>RUNNING</code></td>
                <td style="padding: 8px;"><code>RUNNING</code></td>
            </tr>
        </tbody>
    </table>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/MeleeAttackNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/MeleeAttackNode.java</h2>

    <p>Die Klasse <code>MeleeAttackNode</code> ist ein spezialisierter Verhaltensknoten (Behavior Node) innerhalb eines Behavior-Tree-Systems für das RPG-Plugin. Ihre primäre Aufgabe ist die Ausführung eines Nahkampfangriffs durch einen Mob auf ein Ziel (Spieler).</p>

    <h3>Klassenübersicht</h3>
    <p><strong>Name:</strong> <code>MeleeAttackNode</code></p>
    <p><strong>Basisklasse:</strong> <code>BehaviorNode</code></p>
    <p><strong>Zweck:</strong> Überprüfung der Reichweite und Durchführung eines Schadensereignisses an einem Ziel-Spieler.</p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>MeleeAttackNode(String id)</code>: Initialisiert den Knoten mit einer eindeutigen Identifikationsnummer.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong>Methode:</strong> <code>tick(BehaviorContext context)</code>
            <p><strong>Beschreibung:</strong> Diese Methode wird bei jedem Update-Zyklus des Verhaltensbaums aufgerufen. Sie prüft die Bedingungen für einen Angriff und führt diesen gegebenenfalls aus.</p>
            <p><strong>Logik:</strong></p>
            <ol>
                <li>Ruft das aktuelle Ziel aus dem <code>BehaviorContext</code> ab.</li>
                <li>Gibt <code>BehaviorStatus.FAILURE</code> zurück, wenn kein Ziel vorhanden ist.</li>
                <li>Berechnet die quadratische Distanz zwischen dem Mob und dem Ziel. Wenn die Distanz größer als 9 (entspricht 3 Blöcken) ist, schlägt der Knoten fehl (<code>FAILURE</code>).</li>
                <li>Wenn das Ziel in Reichweite ist, wird dem Ziel Schaden zugefügt. Die Schadenshöhe wird aus der Mob-Definition (<code>context.definition().damage()</code>) bezogen.</li>
                <li>Gibt nach erfolgreichem Angriff <code>BehaviorStatus.SUCCESS</code> zurück.</li>
            </ol>
            <p><strong>Parameter:</strong></p>
            <ul>
                <li><code>context</code> (BehaviorContext): Der aktuelle Kontext, der Informationen über den Mob, das Ziel und die Definitionen enthält.</li>
            </ul>
            <p><strong>Rückgabewert:</strong> <code>BehaviorStatus</code> – SUCCESS bei erfolgreichem Angriff, FAILURE wenn kein Ziel vorhanden oder außer Reichweite ist.</p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>org.bukkit.entity.Player</code>: Repräsentiert das Ziel des Angriffs.</li>
        <li><code>com.example.rpg.behavior.BehaviorContext</code>: Liefert die notwendigen Umgebungsdaten für die Entscheidungsfindung.</li>
        <li><code>com.example.rpg.behavior.BehaviorStatus</code>: Definiert den Status der Knotenausführung.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SelectorNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SelectorNode.java</h2>

    <p>Die Klasse <code>SelectorNode</code> ist ein fundamentaler Bestandteil des Behavior-Tree-Systems (Verhaltensbaum) innerhalb des RPG-Plugins. Sie fungiert als logisches "ODER"-Gatter für das Verhalten von Entitäten.</p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>SelectorNode</code> erbt von <code>CompositeNode</code>. Ein Selector (auch "Fallback" genannt) führt seine Kindknoten nacheinander aus, bis einer von ihnen entweder erfolgreich ist (<code>SUCCESS</code>) oder sich noch in der Ausführung befindet (<code>RUNNING</code>).
    </p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code><strong>SelectorNode(String id)</strong></code>: Erstellt eine neue Instanz des Selector-Knotens mit einer eindeutigen Identifikation.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code><strong>BehaviorStatus tick(BehaviorContext context)</strong></code>
            <p>
                Diese Methode steuert die Logik des Knotens während eines Spiel-Ticks.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>context</code> - Der aktuelle <code>BehaviorContext</code>, der Informationen über die Entität und die Umgebung enthält.</li>
                <li><strong>Funktionsweise:</strong>
                    Die Methode iteriert durch alle zugewiesenen Kindknoten (<code>children()</code>). 
                    Sobald ein Kindknoten den Status <code>SUCCESS</code> oder <code>RUNNING</code> zurückgibt, bricht der Selector die Iteration ab und gibt diesen Status sofort an den übergeordneten Knoten zurück. 
                    Nur wenn <em>alle</em> Kindknoten fehlschlagen (<code>FAILURE</code>), gibt der Selector selbst <code>FAILURE</code> zurück.
                </li>
                <li><strong>Rückgabewert:</strong> 
                    <code>BehaviorStatus.SUCCESS</code> oder <code>BehaviorStatus.RUNNING</code>, wenn ein Kindknoten erfolgreich ist oder arbeitet; 
                    <code>BehaviorStatus.FAILURE</code>, wenn kein Kindknoten erfolgreich war.
                </li>
            </ul>
        </li>
    </ul>

    <h3>Zusammenhang im System</h3>
    <p>
        In der Praxis wird der <code>SelectorNode</code> verwendet, um Prioritäten festzulegen. Beispielsweise könnte ein NPC zuerst prüfen, ob er sich heilen muss (Kind 1), dann ob er angreifen kann (Kind 2) und schließlich, ob er patrouillieren soll (Kind 3). Der Selector stellt sicher, dass die erste ausführbare Aktion mit der höchsten Priorität gewählt wird.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SequenceNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SequenceNode.java</h2>

    <p>
        Die Klasse <code>SequenceNode</code> ist ein fundamentaler Bestandteil des Behavior-Tree-Systems (Verhaltensbaum) innerhalb des RPG-Plugins. 
        Sie fungiert als ein <strong>Composite-Knoten</strong>, der eine logische "UND"-Verknüpfung seiner Kindknoten implementiert.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>SequenceNode</code> erweitert die abstrakte Klasse <code>CompositeNode</code>. Ihr Hauptzweck ist es, eine Reihe von Aktionen oder Bedingungen nacheinander auszuführen. 
        Die Ausführung wird so lange fortgesetzt, wie die Kindknoten erfolgreich (<code>SUCCESS</code>) zurückkehren. Sobald ein Kind fehlschlägt oder noch in Arbeit ist, wird die Sequenz unterbrochen.
    </p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>public SequenceNode(String id)</code>: Erstellt eine neue Instanz des Sequence-Knotens mit einer eindeutigen Identifikationsnummer (ID).
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong>Name:</strong> <code>tick</code><br>
            <strong>Beschreibung:</strong> Führt die Logik des Knotens im aktuellen Frame/Zyklus aus. Die Methode iteriert über alle registrierten Kindknoten.<br>
            <strong>Parameter:</strong>
            <ul>
                <li><code>BehaviorContext context</code>: Der Kontext, der Informationen über die Umgebung, den ausführenden Mob oder das Ziel enthält.</li>
            </ul>
            <strong>Rückgabewert (<code>BehaviorStatus</code>):</strong>
            <ul>
                <li><code>BehaviorStatus.FAILURE</code>: Wird sofort zurückgegeben, wenn ein Kindknoten fehlschlägt. Die restlichen Kinder werden nicht mehr ausgeführt.</li>
                <li><code>BehaviorStatus.RUNNING</code>: Wird zurückgegeben, wenn ein Kindknoten signalisiert, dass seine Aktion noch andauert. Die Sequenz pausiert an dieser Stelle.</li>
                <li><code>BehaviorStatus.SUCCESS</code>: Wird nur zurückgegeben, wenn <strong>alle</strong> Kindknoten erfolgreich abgeschlossen wurden.</li>
            </ul>
        </li>
    </ul>

    <h3>Logik-Zusammenfassung</h3>
    <p>
        In der Spielwelt wird dieser Knoten oft verwendet, um komplexe Verhaltensketten zu definieren, wie zum Beispiel: 
        <code>Prüfe Distanz</code> &rarr; <code>Bewege zum Ziel</code> &rarr; <code>Führe Angriff aus</code>. 
        Schlägt die Distanzprüfung fehl, wird der Angriff gar nicht erst versucht.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/TargetDistanceAboveNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/TargetDistanceAboveNode.java</h2>

    <p>
        Die Klasse <code>TargetDistanceAboveNode</code> ist ein spezialisierter Verhaltensknoten (Behavior Node) innerhalb eines Behavior-Tree-Systems. 
        Ihre primäre Aufgabe ist es, als Bedingung (Condition) zu fungieren, die prüft, ob die räumliche Distanz zwischen einem Mob und seinem aktuellen Ziel einen definierten Schwellenwert überschreitet.
    </p>

    <h3>Klasse: TargetDistanceAboveNode</h3>
    <p><strong>Erbt von:</strong> <code>BehaviorNode</code></p>

    <h4>Beschreibung</h4>
    <p>
        Dieser Knoten wird verwendet, um Entscheidungen basierend auf der Entfernung zum Ziel zu treffen. Er ist nützlich für KI-Logiken, 
        bei denen ein Mob beispielsweise erst eine Verfolgung aufnimmt oder einen Fernkampfangriff startet, wenn das Ziel weit genug entfernt ist.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>TargetDistanceAboveNode(String id, double distance)</code>: 
            Initialisiert den Knoten mit einer ID und dem Distanz-Schwellenwert.
            <ul>
                <li><code>id</code>: Eine eindeutige Zeichenfolge zur Identifizierung des Knotens.</li>
                <li><code>distance</code>: Der numerische Wert (in Blöcken/Metern), gegen den die aktuelle Entfernung geprüft wird.</li>
            </ul>
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public BehaviorStatus tick(BehaviorContext context)</code>
            <p>
                Führt die Logik des Knotens im aktuellen Tick aus.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>context</code> - Der <code>BehaviorContext</code>, der Informationen über den ausführenden Mob und das aktuelle Ziel enthält.</li>
                <li>
                    <strong>Rückgabewerte:</strong>
                    <ul>
                        <li><code>BehaviorStatus.SUCCESS</code>: Wenn ein Ziel existiert und die Entfernung zum Mob größer als der im Konstruktor festgelegte Wert ist.</li>
                        <li><code>BehaviorStatus.FAILURE</code>: Wenn kein Ziel vorhanden ist (null) oder die Entfernung kleiner oder gleich dem Schwellenwert ist.</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>

    <h4>Logik-Details</h4>
    <p>
        Die Methode berechnet die Distanz zwischen der <code>Location</code> des Ziels (Spieler) und der <code>Location</code> des Mobs. 
        Sollte im Kontext kein Ziel hinterlegt sein, schlägt der Knoten sofort fehl, um Fehler bei der Distanzberechnung zu vermeiden.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/WalkToTargetNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/WalkToTargetNode.java</h2>

    <p>
        Die Klasse <code>WalkToTargetNode</code> ist ein spezialisierter Verhaltensknoten (Behavior Node) innerhalb eines Behavior Tree Systems. 
        Ihre primäre Aufgabe ist es, eine Entität (Mob) dazu zu veranlassen, sich aktiv auf ein definiertes Ziel (Player) zuzubewegen.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.behavior</code></li>
        <li><strong>Basisklasse:</strong> <code>BehaviorNode</code></li>
        <li><strong>Abhängigkeiten:</strong> <code>org.bukkit.entity.Mob</code>, <code>org.bukkit.entity.Player</code></li>
    </ul>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>WalkToTargetNode(String id)</code>: Erstellt eine neue Instanz des Knotens mit einer eindeutigen Identifikationsnummer.
        </li>
    </ul>

    <h3>Methoden</h3>
    <div class="method-documentation">
        <h4><code>tick(BehaviorContext context)</code></h4>
        <p>
            Diese Methode wird in jedem Tick des Behavior Trees aufgerufen, um die Logik des Knotens auszuführen.
        </p>
        <ul>
            <li><strong>Parameter:</strong> 
                <ul>
                    <li><code>context</code> (BehaviorContext): Der aktuelle Kontext, der Informationen über den ausführenden Mob und das aktuelle Ziel enthält.</li>
                </ul>
            </li>
            <li><strong>Rückgabewert:</strong> 
                <ul>
                    <li><code>BehaviorStatus.FAILURE</code>: Wenn kein Ziel im Kontext vorhanden ist oder die Entität kein valider <code>Mob</code> ist.</li>
                    <li><code>BehaviorStatus.RUNNING</code>: Wenn der Pfadfindungs-Prozess erfolgreich gestartet wurde und der Mob sich in Bewegung setzt.</li>
                </ul>
            </li>
            <li><strong>Logik:</strong>
                <ol>
                    <li>Prüft, ob ein Ziel-Spieler im <code>BehaviorContext</code> gesetzt ist.</li>
                    <li>Validiert, ob die ausführende Entität eine Instanz von <code>Mob</code> ist.</li>
                    <li>Setzt das Ziel des Mobs mittels <code>setTarget(target)</code>.</li>
                    <li>Nutzt den Bukkit-Pathfinder (<code>getPathfinder().moveTo(target)</code>), um die Wegfindung zum Spieler zu initiieren.</li>
                </ol>
            </li>
        </ul>
    </div>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/command/AuctionCommand.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/command/AuctionCommand.java</h2>
    <p>
        Die Klasse <code>AuctionCommand</code> implementiert den <code>CommandExecutor</code> für das Auktionshaus-System des RPG-Plugins. 
        Sie ermöglicht es Spielern, Gegenstände zum Verkauf anzubieten, verfügbare Auktionen aufzulisten und Gegenstände von anderen Spielern zu erwerben.
    </p>

    <h3>Klasse: AuctionCommand</h3>
    <p><strong>Beschreibung:</strong> Hauptklasse für die Verarbeitung des <code>/auction</code> Befehls.</p>
    
    <h4>Konstruktor</h4>
    <ul>
        <li><code>AuctionCommand(RPGPlugin plugin)</code>: Initialisiert den Command-Handler mit einer Instanz des Haupt-Plugins, um Zugriff auf Manager wie das Auktionshaus und die Spielerdaten zu erhalten.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Verarbeitet die eingehenden Befehle. Überprüft, ob der Sender ein Spieler ist und leitet die Anfrage basierend auf den Argumenten (list, sell, buy) an die entsprechende private Methode weiter.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>sender</code>, <code>command</code>, <code>label</code>, <code>args</code></li>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> (true, wenn der Befehl verarbeitet wurde)</li>
            </ul>
        </li>
        <li>
            <code>listAuctions(Player player)</code>
            <p>Listet alle aktuell im <code>AuctionHouseManager</code> registrierten Auktionen für den Spieler im Chat auf. Zeigt die Auktions-ID und den Preis in Gold an.</p>
        </li>
        <li>
            <code>sellAuction(Player player, String[] args)</code>
            <p>Erstellt eine neue Auktion. Der Spieler muss ein Item in der Haupthand halten und einen gültigen Preis angeben.</p>
            <ul>
                <li><strong>Logik:</strong> Validiert den Preis, serialisiert das Item-Stack-Objekt, generiert eine eindeutige 8-stellige ID und entfernt das Item aus dem Inventar des Spielers.</li>
            </ul>
        </li>
        <li>
            <code>buyAuction(Player player, String[] args)</code>
            <p>Verarbeitet den Kauf eines Gegenstands aus dem Auktionshaus.</p>
            <ul>
                <li><strong>Logik:</strong> Prüft die Existenz der Auktion, validiert das Gold-Guthaben des Käufers, deserialisiert das Item und fügt es dem Inventar hinzu. Der Verkäufer erhält den Goldbetrag gutgeschrieben, sofern er online ist.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Zugriff auf Manager-Klassen.</li>
        <li><code>AuctionHouseManager</code>: Verwaltung der <code>AuctionListing</code> Objekte und Item-Serialisierung.</li>
        <li><code>PlayerDataManager</code>: Verwaltung von Gold und Spielerprofilen.</li>
        <li><code>Text</code>: Utility-Klasse zur Formatierung von Chat-Nachrichten (MiniMessage).</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/command/BehaviorCommand.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/command/BehaviorCommand.java</h2>

    <p>
        Die Klasse <code>BehaviorCommand</code> ist ein Command-Executor für das RPG-Plugin. 
        Sie dient primär dazu, Spielern den Zugriff auf den grafischen Editor für Verhaltensbäume (Behavior Trees) zu ermöglichen. 
        Diese Verhaltensbäume steuern die Logik von NPCs oder Mobs innerhalb des Spiels.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Name:</strong> <code>BehaviorCommand</code></li>
        <li><strong>Schnittstelle:</strong> <code>CommandExecutor</code></li>
        <li><strong>Paket:</strong> <code>com.example.rpg.command</code></li>
    </ul>

    <h3>Konstruktor</h3>
    <p>
        <code>public BehaviorCommand(RPGPlugin plugin)</code>
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>plugin</code> (RPGPlugin): Eine Instanz des Haupt-Plugins, um auf Manager und GUI-Komponenten zuzugreifen.</li>
            </ul>
        </li>
    </ul>

    <h3>Methoden</h3>
    
    <h4>onCommand</h4>
    <p>
        Diese Methode verarbeitet den eingegebenen Befehl <code>/behavior</code>.
    </p>
    <ul>
        <li><strong>Signatur:</strong> <code>public boolean onCommand(CommandSender sender, Command command, String label, String[] args)</code></li>
        <li><strong>Funktionsweise:</strong>
            <ol>
                <li>Prüft, ob der Absender ein Spieler ist. Falls nicht, wird die Nachricht "Nur Spieler." ausgegeben.</li>
                <li>Validiert die Argumente. Der Befehl erwartet das Unterargument <code>edit</code> gefolgt vom Namen eines Verhaltensbaums (z. B. <code>/behavior edit lvl01_behavior_001</code>).</li>
                <li>Bei korrekter Eingabe wird über den <code>GuiManager</code> (via <code>behaviorTreeEditorGui()</code>) das entsprechende Bearbeitungsmenü für den Spieler geöffnet.</li>
            </ol>
        </li>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>sender</code>: Der Ausführende des Befehls (muss ein <code>Player</code> sein).</li>
                <li><code>command</code>: Das ausgeführte Kommando-Objekt.</li>
                <li><code>label</code>: Der Alias des Befehls.</li>
                <li><code>args</code>: Die Argumente des Befehls (erwartet: <code>edit &lt;treeName&gt;</code>).</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> <code>boolean</code> - Gibt <code>true</code> zurück, um anzuzeigen, dass der Befehl verarbeitet wurde.</li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Zugriff auf die Plugin-Logik.</li>
        <li><code>BehaviorTreeEditorGui</code>: Zum Öffnen der Benutzeroberfläche.</li>
        <li><code>Text</code>: Utility-Klasse zur Formatierung von Chat-Nachrichten (MiniMessage).</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/command/DungeonCommand.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/command/DungeonCommand.java</h2>
    <p>
        Die Klasse <code>DungeonCommand</code> implementiert den <code>CommandExecutor</code> für den zentralen Dungeon-Befehl des RPG-Systems. 
        Sie dient als Schnittstelle für Spieler, um Instanzen zu betreten, zu verlassen, die Warteschlange zu nutzen oder Rollen für das Gruppenspiel festzulegen.
    </p>

    <h3>Klasse: DungeonCommand</h3>
    <p><strong>Zweck:</strong> Verarbeitung aller Sub-Befehle unter <code>/dungeon</code>.</p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Hauptmethode zur Befehlsverarbeitung. Validiert, ob der Absender ein Spieler ist, und delegiert die Anfrage basierend auf dem ersten Argument an die entsprechenden privaten Methoden.</p>
            <p><strong>Parameter:</strong> <code>sender</code>, <code>command</code>, <code>label</code>, <code>args</code>.</p>
            <p><strong>Rückgabewert:</strong> <code>boolean</code> (true, wenn der Befehl verarbeitet wurde).</p>
        </li>
        <li>
            <code>enterDungeon(Player player)</code>
            <p>Ermöglicht einem Spieler den Zutritt zum Standard-Dungeon. Prüft die Konfiguration des Eingangs sowie den Ruf (Faction Access) des Spielers.</p>
        </li>
        <li>
            <code>leaveDungeon(Player player)</code>
            <p>Entfernt den Spieler aus der aktuellen Dungeon-Instanz über den <code>DungeonManager</code>.</p>
        </li>
        <li>
            <code>generateDungeon(Player player, String[] args)</code>
            <p>Initiiert die prozedurale Generierung eines Dungeons basierend auf einem Thema (Theme). Berücksichtigt dabei die aktuelle Gruppe (Party) des Spielers, um alle Mitglieder gemeinsam in die Instanz zu teleportieren.</p>
        </li>
        <li>
            <code>queueDungeon(Player player, String[] args)</code>
            <p>Fügt den Spieler der Warteschlange für ein spezifisches Dungeon-Thema hinzu.</p>
        </li>
        <li>
            <code>setRole(Player player, String[] args)</code>
            <p>Setzt die bevorzugte Dungeon-Rolle des Spielers im Profil. Gültige Rollen sind: <code>TANK</code>, <code>HEAL</code>, <code>DPS</code>.</p>
        </li>
    </ul>

    <h3>Verfügbare Sub-Befehle:</h3>
    <ul>
        <li><code>/dungeon enter</code>: Betritt den Standard-Dungeon.</li>
        <li><code>/dungeon leave</code>: Verlässt den aktuellen Dungeon.</li>
        <li><code>/dungeon generate &lt;theme&gt;</code>: Generiert eine neue Instanz für die Gruppe.</li>
        <li><code>/dungeon queue &lt;theme&gt;</code>: Tritt der Warteschlange bei.</li>
        <li><code>/dungeon leavequeue</code>: Verlässt die Warteschlange.</li>
        <li><code>/dungeon role &lt;tank|heal|dps&gt;</code>: Ändert die zugewiesene Rolle für das Matchmaking.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/command/GuildCommand.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/command/GuildCommand.java</h2>
    <p>Die Klasse <code>GuildCommand</code> implementiert den <code>CommandExecutor</code> für das Gilden-System des RPG-Plugins. Sie ermöglicht Spielern das Erstellen, Verwalten und Interagieren innerhalb von Gilden, einschließlich Gilden-Chat, Bankwesen, Quests und dem Ausbau einer Gildenhalle.</p>

    <h3>Hauptklasse</h3>
    <ul>
        <li><strong>Name:</strong> <code>GuildCommand</code></li>
        <li><strong>Zweck:</strong> Verarbeitung aller Befehle, die mit dem Präfix <code>/guild</code> oder dem Kürzel <code>/g</code> (für den Chat) beginnen.</li>
        <li><strong>Schnittstellen:</strong> <code>CommandExecutor</code></li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Der Haupteinstiegspunkt für die Befehlsverarbeitung. Prüft, ob der Sender ein Spieler ist, und leitet die Argumente an die entsprechenden Unterfunktionen weiter.</p>
        </li>
        <li>
            <code>createGuild(Player player, String[] args)</code>
            <p>Erstellt eine neue Gilde mit einer eindeutigen ID und einem Namen. Der Ersteller wird automatisch zum Leiter ernannt.</p>
        </li>
        <li>
            <code>invitePlayer(Player player, String[] args)</code>
            <p>Lädt einen anderen Spieler in die aktuelle Gilde ein. Erfordert Offiziers- oder Leiter-Rechte.</p>
        </li>
        <li>
            <code>acceptInvite(Player player)</code>
            <p>Akzeptiert eine ausstehende Gildeneinladung.</p>
        </li>
        <li>
            <code>leaveGuild(Player player)</code>
            <p>Ermöglicht es einem Spieler, seine aktuelle Gilde zu verlassen.</p>
        </li>
        <li>
            <code>disbandGuild(Player player)</code>
            <p>Löst die Gilde vollständig auf. Nur für den Gildenleiter verfügbar.</p>
        </li>
        <li>
            <code>guildInfo(Player player)</code>
            <p>Zeigt Informationen über die Gilde an, einschließlich Mitgliederliste und aktuellem Bankguthaben.</p>
        </li>
        <li>
            <code>guildChat(Player player, String[] args)</code>
            <p>Sendet eine Nachricht an alle online befindlichen Mitglieder der eigenen Gilde.</p>
        </li>
        <li>
            <code>bankCommand(Player player, String[] args)</code>
            <p>Verwaltet Gildenbank-Aktionen wie <code>balance</code> (Kontostand), <code>deposit</code> (Einzahlen) und <code>withdraw</code> (Abheben).</p>
        </li>
        <li>
            <code>questCommand(Player player, String[] args)</code>
            <p>Verwaltet Gilden-Quests. Unterbefehle umfassen das Auflisten, Erstellen, Fortschreiben und Abschließen von Quests.</p>
        </li>
        <li>
            <code>hallCommand(Player player, String[] args)</code>
            <p>Verwaltet die Gildenhalle. Ermöglicht das Setzen des Standorts, den Teleport zur Halle (sofern freigeschaltet) und den Kauf von Upgrades.</p>
        </li>
        <li>
            <code>upgradeHall(Player player, Guild guild, String[] args)</code>
            <p>Führt Upgrades für die Gildenhalle aus (z.B. Handwerk, Teleport, Buffs) und zieht die Kosten vom Gildenbank-Konto ab.</p>
        </li>
    </ul>

    <h3>Hilfsfunktionen</h3>
    <ul>
        <li><code>isOfficerOrLeader(Guild guild, UUID member)</code>: Prüft, ob ein Mitglied über administrative Rechte (Offizier oder Leiter) innerhalb der Gilde verfügt.</li>
        <li><code>parseAmount(Player player, String input)</code>: Validiert numerische Eingaben für Goldbeträge oder Questziele.</li>
        <li><code>join(String[] args, int start)</code>: Verbindet Array-Elemente ab einem bestimmten Index zu einem einzelnen String (nützlich für Namen oder Nachrichten).</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/command/LootChatCommand.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/command/LootChatCommand.java</h2>

    <p>Die Klasse <code>LootChatCommand</code> ist ein Command-Executor für das Bukkit-Framework. Sie ermöglicht es Spielern oder Administratoren, die Anzeige von Beute-Benachrichtigungen (Loot-Chat) in der Konfiguration des Plugins dynamisch ein- oder auszuschalten.</p>

    <h3>Klasse: LootChatCommand</h3>
    <p><strong>Paket:</strong> <code>com.example.rpg.command</code></p>
    <p><strong>Implementiert:</strong> <code>CommandExecutor</code></p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>LootChatCommand(RPGPlugin plugin)</code>: Initialisiert die Klasse und speichert die Referenz auf die Hauptinstanz des Plugins, um auf die Konfigurationsdateien zugreifen zu können.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public boolean onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Verarbeitet den eingehenden Chat-Befehl (standardmäßig <code>/lootchat</code>).</p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>sender</code>: Das Objekt, das den Befehl ausgeführt hat (Spieler oder Konsole).</li>
                        <li><code>command</code>: Der ausgeführte Befehl.</li>
                        <li><code>label</code>: Der Alias des Befehls, der verwendet wurde.</li>
                        <li><code>args</code>: Argumente des Befehls. Wenn ein Argument übergeben wird, wird versucht, dieses als Boolean (true/false) zu interpretieren. Ohne Argument wird der aktuelle Status umgeschaltet (Toggle).</li>
                    </ul>
                </li>
                <li><strong>Logik:</strong>
                    <ol>
                        <li>Liest den aktuellen Status von <code>lootchat.enabled</code> aus der <code>config.yml</code>.</li>
                        <li>Bestimmt den nächsten Status basierend auf den Argumenten oder durch Invertierung des aktuellen Wertes.</li>
                        <li>Speichert den neuen Wert in der Konfiguration und führt <code>plugin.saveConfig()</code> aus.</li>
                        <li>Sendet eine formatierte Nachricht (grün für aktiviert, rot für deaktiviert) an den Ausführenden unter Verwendung der <code>Text.mm</code> Utility (MiniMessage).</li>
                    </ol>
                </li>
                <li><strong>Rückgabewert:</strong> <code>true</code>, um anzuzeigen, dass der Befehl erfolgreich verarbeitet wurde.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/command/PartyCommand.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/command/PartyCommand.java</h2>
    <p>
        Die Klasse <code>PartyCommand</code> implementiert das Party-System für das RPG-Plugin. Sie ermöglicht es Spielern, Gruppen zu bilden, Einladungen zu versenden, beizutreten und innerhalb der Gruppe zu kommunizieren. Die Klasse nutzt das Bukkit-Framework zur Befehlsverarbeitung.
    </p>

    <h3>Klassen-Definition</h3>
    <p><strong>Name:</strong> <code>PartyCommand</code></p>
    <p><strong>Interface:</strong> <code>CommandExecutor</code></p>
    <p><strong>Beschreibung:</strong> Verarbeitet alle Unterbefehle des Hauptbefehls <code>/party</code>.</p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Der Haupteinstiegspunkt für den Befehl. Validiert, ob der Sender ein Spieler ist, und leitet die Argumente an die entsprechenden privaten Methoden weiter.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>sender</code>, <code>command</code>, <code>label</code>, <code>args</code></li>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> (true bei Erfolg)</li>
            </ul>
        </li>
        <li>
            <code>createParty(Player player)</code>
            <p>Erstellt eine neue Party für den aufrufenden Spieler, sofern dieser noch nicht Mitglied einer anderen Party ist.</p>
        </li>
        <li>
            <code>invitePlayer(Player player, String[] args)</code>
            <p>Sendet eine Einladung an einen anderen Online-Spieler. Erfordert, dass der Absender bereits in einer Party ist.</p>
            <ul>
                <li><strong>Argumente:</strong> <code>args[1]</code> (Name des Zielspielers)</li>
            </ul>
        </li>
        <li>
            <code>joinParty(Player player, String[] args)</code>
            <p>Ermöglicht es einem Spieler, der Party eines Leaders beizutreten. Prüft die Existenz der Party und den aktuellen Status des Spielers.</p>
            <ul>
                <li><strong>Argumente:</strong> <code>args[1]</code> (Name des Party-Leaders)</li>
            </ul>
        </li>
        <li>
            <code>leaveParty(Player player)</code>
            <p>Entfernt den Spieler aus seiner aktuellen Party über den <code>PartyManager</code>.</p>
        </li>
        <li>
            <code>partyChat(Player player, String[] args)</code>
            <p>Sendet eine Nachricht an alle Mitglieder der aktuellen Party des Spielers.</p>
            <ul>
                <li><strong>Argumente:</strong> <code>args[1..n]</code> (Die zu sendende Nachricht)</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Zugriff auf den <code>PartyManager</code>.</li>
        <li><code>PartyManager</code>: Logik zur Verwaltung der Party-Instanzen und Mitglieder.</li>
        <li><code>Text</code>: Utility-Klasse zur Formatierung von Nachrichten (MiniMessage).</li>
        <li><code>Bukkit API</code>: Interaktion mit dem Minecraft-Server und Spielern.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/command/PvpCommand.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/command/PvpCommand.java</h2>
    <p>
        Die Klasse <code>PvpCommand</code> implementiert das Interface <code>CommandExecutor</code> für Bukkit und dient als zentraler Einstiegspunkt für alle spielerseitigen PvP-Befehle (Player versus Player). Sie ermöglicht es Spielern, Warteschlangen beizutreten, Ranglisten einzusehen und Informationen über die aktuelle Saison abzurufen.
    </p>

    <h3>Klassen-Definition</h3>
    <p><strong>Name:</strong> <code>PvpCommand</code></p>
    <p><strong>Zweck:</strong> Verarbeitung des <code>/pvp</code> Befehls und Koordination mit dem <code>ArenaManager</code> sowie dem <code>PvpSeasonManager</code>.</p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Verarbeitet die eingegebenen Befehle. Überprüft, ob der Sender ein Spieler ist und leitet die Anfrage basierend auf den Argumenten weiter.</p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>sender</code>: Der Absender des Befehls (muss ein <code>Player</code> sein).</li>
                        <li><code>args</code>: Argumente des Befehls (<code>join</code>, <code>top</code>, <code>season</code>).</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> - Gibt <code>true</code> zurück, wenn der Befehl erfolgreich verarbeitet wurde.</li>
            </ul>
        </li>
        <li>
            <code>showTop(Player player)</code>
            <p>Ruft die Top 10 Spieler basierend auf ihrem Elo-Wert ab und gibt diese als formatierte Rangliste im Chat des Spielers aus.</p>
            <ul>
                <li><strong>Logik:</strong> Nutzt den <code>ArenaManager</code>, um die Profile zu laden, und löst UUIDs in Spielernamen auf.</li>
            </ul>
        </li>
        <li>
            <code>showSeason(Player player)</code>
            <p>Zeigt dem Spieler Informationen über die aktuell laufende PvP-Saison an.</p>
            <ul>
                <li><strong>Logik:</strong> Fragt den <code>PvpSeasonManager</code> nach der aktuellen Saison ab und gibt deren Namen aus oder eine Fehlermeldung, falls keine Saison aktiv ist.</li>
            </ul>
        </li>
    </ul>

    <h3>Unterstützte Unterbefehle</h3>
    <ul>
        <li><code>/pvp join</code>: Fügt den Spieler der Warteschlange für ein PvP-Match hinzu.</li>
        <li><code>/pvp top</code>: Zeigt die aktuelle Elo-Rangliste der besten 10 Spieler.</li>
        <li><code>/pvp season</code>: Zeigt Details zur aktuellen PvP-Saison an.</li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Haupt-Plugin-Instanz für den Zugriff auf Manager-Klassen.</li>
        <li><code>ArenaManager</code>: Verwaltung der Warteschlangen und Ranglisten-Daten.</li>
        <li><code>PvpSeasonManager</code>: Verwaltung der Saison-Informationen.</li>
        <li><code>Text</code>: Utility-Klasse zur Formatierung von Chat-Nachrichten (MiniMessage).</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGAdminCommand.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGAdminCommand.java</h2>
    <p>
        Die Klasse <code>RPGAdminCommand</code> ist der zentrale Command-Executor für administrative Aufgaben innerhalb des RPG-Plugins. 
        Sie implementiert das <code>CommandExecutor</code>-Interface von Bukkit und bietet eine umfangreiche Palette an Unterbefehlen zur Verwaltung von Zonen, NPCs, Quests, Loot-Tabellen, Skills, Mobs und Berechtigungen.
    </p>

    <h3>Hauptkomponenten</h3>

    <h4>Klasse: <code>RPGAdminCommand</code></h4>
    <p>
        Verwaltet die Logik für den Hauptbefehl <code>/rpgadmin</code>. Der Zugriff ist auf Spieler mit der Berechtigung <code>rpg.admin</code> beschränkt.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Einstiegspunkt für den Befehl. Prüft Berechtigungen und delegiert die Ausführung basierend auf dem ersten Argument an spezialisierte Handler-Methoden.</p>
        </li>
        <li>
            <code>handlePerms(Player player, String[] args)</code>
            <p>Verwaltet das Berechtigungssystem. Ermöglicht das Öffnen der GUI oder die manuelle Konfiguration von Rollen (<code>role</code>) und Benutzern (<code>user</code>).</p>
        </li>
        <li>
            <code>giveWand(Player player)</code>
            <p>Gibt dem Spieler einen "Editor Wand" (Zauberstab), der zur Markierung von Positionen (Pos1/Pos2) für Zonen oder Schematics verwendet wird.</p>
        </li>
        <li>
            <code>handleZone(Player player, String[] args)</code>
            <p>Handler für Zonen-Operationen: Erstellen von Zonen, Festlegen von Levelbereichen und Modifikatoren (Schaden/Geschwindigkeit).</p>
        </li>
        <li>
            <code>handleNpc(Player player, String[] args)</code>
            <p>Ermöglicht die Verwaltung von NPCs, einschließlich Erstellung, Dialogkonfiguration und Verknüpfung mit Quests, Shops oder Fraktionen.</p>
        </li>
        <li>
            <code>handleQuest(Player player, String[] args)</code>
            <p>Dient zum Erstellen von Quests, Hinzufügen von Quest-Schritten (Steps) und Neuladen der Quest-Konfiguration.</p>
        </li>
        <li>
            <code>handleLoot(Player player, String[] args)</code>
            <p>Verwaltet Loot-Tabellen. Erlaubt das Erstellen neuer Tabellen und das Hinzufügen von Einträgen mit spezifischen Wahrscheinlichkeiten und Seltenheitsgraden.</p>
        </li>
        <li>
            <code>handleSkill(Player player, String[] args)</code>
            <p>Konfiguriert RPG-Skills. Unterstützt das Setzen von Abklingzeiten, Manakosten, Kategorien und das Hinzufügen von Skill-Effekten via Parameter-Strings.</p>
        </li>
        <li>
            <code>handleMob(Player player, String[] args)</code>
            <p>Erlaubt das manuelle Spawnen von benutzerdefinierten Mobs basierend auf deren ID.</p>
        </li>
        <li>
            <code>handleSpawner(Player player, String[] args)</code>
            <p>Verwaltet Mob-Spawner in der Welt, inklusive Spawn-Limits und Wahrscheinlichkeiten für verschiedene Mob-Typen.</p>
        </li>
        <li>
            <code>handleEvent(Player player, String[] args)</code>
            <p>Steuert Welt-Events: Erstellung, Start/Stopp, Belohnungen und Freischaltung von Quests nach Abschluss.</p>
        </li>
        <li>
            <code>handleNode(Player player, String[] args)</code>
            <p>Erstellt Ressourcen-Knoten (z.B. für Bergbau), die an Berufe gebunden sind und nach einer bestimmten Zeit respawnen.</p>
        </li>
        <li>
            <code>handleBuild(Player player, String[] args)</code>
            <p>Schnittstelle zum <code>BuildingManager</code>. Ermöglicht das Platzieren von Gebäuden, Rückgängigmachen von Aktionen und Verschieben von Schematics.</p>
        </li>
    </ul>

    <h3>Hilfsmethoden (Parsing)</h3>
    <p>Die Klasse enthält diverse statische Hilfsmethoden für ein sicheres Parsing von Benutzereingaben:</p>
    <ul>
        <li><code>parseInt(String raw)</code>: Wandelt Strings sicher in Integer um (gibt null bei Fehlern zurück).</li>
        <li><code>parseDouble(String raw)</code>: Wandelt Strings sicher in Double um.</li>
        <li><code>parseEnum(Class&lt;E&gt; type, String raw)</code>: Versucht einen String einem Enum-Wert zuzuordnen.</li>
        <li><code>parseParamValue(String raw)</code>: Erkennt automatisch, ob ein Parameter ein Double, Integer oder String ist.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGCommand.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGCommand.java</h2>
    <p>Die Klasse <code>RPGCommand</code> implementiert das zentrale Befehlssystem für das RPG-Plugin. Sie fungiert als <code>CommandExecutor</code> für den Hauptbefehl <code>/rpg</code> und delegiert verschiedene Unterbefehle an spezialisierte Handler-Methoden, um Spielerprofile, Quests, Fähigkeiten, Berufe und Wirtschaftssysteme zu verwalten.</p>

    <h3>Klassen-Definition</h3>
    <ul>
        <li><strong>Name:</strong> <code>RPGCommand</code></li>
        <li><strong>Schnittstelle:</strong> <code>CommandExecutor</code></li>
        <li><strong>Beschreibung:</strong> Verarbeitet alle Spieler-Interaktionen über die Befehlszeile, die das RPG-System betreffen.</li>
    </ul>

    <h3>Hauptmethoden</h3>
    
    <h4><code>onCommand(CommandSender sender, Command command, String label, String[] args)</code></h4>
    <p>Der Einstiegspunkt für alle <code>/rpg</code> Befehle. Prüft, ob der Sender ein Spieler ist, und leitet die Argumente an die entsprechenden Unterfunktionen weiter.</p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>sender</code>: Der Absender des Befehls (muss ein Spieler sein).</li>
                <li><code>args</code>: Die Argumente des Befehls (z.B. <code>skill</code>, <code>quest</code>, <code>money</code>).</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> <code>boolean</code> - Gibt <code>true</code> zurück, wenn der Befehl verarbeitet wurde.</li>
    </ul>

    <h3>Unterbefehl-Handler (Private Methoden)</h3>
    
    <h4><code>handleSkill(Player player, String[] args)</code></h4>
    <p>Ermöglicht es einem Spieler, eine spezifische Fähigkeit über deren ID auszuführen.</p>

    <h4><code>handleQuest(Player player, String[] args)</code></h4>
    <p>Verwaltet Quest-Aktionen wie das Auflisten (<code>list</code>), Abbrechen (<code>abandon</code>) oder Abschließen (<code>complete</code>) von Aufgaben.</p>

    <h4><code>handleRespec(Player player)</code></h4>
    <p>Setzt die gelernten Fähigkeiten und Statuswerte des Spielers zurück und erstattet die Skillpunkte basierend auf dem Level (Level * 2) zurück.</p>

    <h4><code>handleClass(Player player, String[] args)</code></h4>
    <p>Ermöglicht die Auswahl einer Charakterklasse (<code>choose</code>) oder das Auflisten verfügbarer Klassen (<code>list</code>).</p>

    <h4><code>handleBind(Player player, String[] args)</code></h4>
    <p>Bindet eine gelernte Fähigkeit an einen Hotbar-Slot (1-9). Unterstützt die Suche nach Skill-ID oder dem Anzeigenamen.</p>

    <h4><code>handleMoney(Player player)</code> und <code>handlePay(Player player, String[] args)</code></h4>
    <p>Verwaltet das Gold-System. <code>handleMoney</code> zeigt den Kontostand an, während <code>handlePay</code> Gold an andere Online-Spieler transferiert.</p>

    <h4><code>handleProfession(Player player, String[] args)</code></h4>
    <p>Zeigt die Level der Berufe des Spielers an oder erlaubt Administratoren (über das Plugin-System), Berufslevel zu setzen.</p>

    <h4><code>handleCombatLog(Player player, String[] args)</code></h4>
    <p>Schaltet die Anzeige von Kampf-Informationen im Chat (Schaden, Heilung etc.) für den Spieler ein oder aus.</p>

    <h4><code>handleEvent(Player player, String[] args)</code></h4>
    <p>Zeigt eine Liste aktiver Welt-Events oder den detaillierten Fortschritt eines spezifischen Events an.</p>

    <h4><code>handleOrder(Player player, String[] args)</code></h4>
    <p>Verwaltet das Crafting-Auftragssystem. Spieler können Aufträge erstellen (<code>create</code>), einsehen (<code>list</code>) oder durch Abgabe von Materialien erfüllen (<code>fulfill</code>).</p>

    <h4><code>handleHome(Player player, String[] args)</code></h4>
    <p>Verwaltet das Housing-System: Setzen des Heimpunkts (<code>set</code>), Teleportation (<code>go</code>) und das Kaufen von Upgrades (<code>upgrade</code>) für Handwerk, Teleport oder Buffs.</p>

    <h4><code>handleFaction(Player player)</code></h4>
    <p>Listet die Ruf-Werte (Reputation) des Spielers bei den verschiedenen Fraktionen der Welt auf.</p>

    <h3>Hilfsmethoden</h3>
    <ul>
        <li><code>resolveSkillByIdOrName(String input)</code>: Sucht eine Fähigkeit entweder über ihre technische ID oder ihren Anzeigenamen.</li>
        <li><code>parseAmount(Player player, String input)</code>: Validiert numerische Eingaben für Goldbeträge oder Mengen.</li>
        <li><code>countMaterial(Player player, Material material)</code>: Zählt die Anzahl eines bestimmten Materials im Inventar des Spielers.</li>
        <li><code>removeMaterial(Player player, Material material, int amount)</code>: Entfernt eine spezifische Menge eines Materials aus dem Inventar.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/command/TradeCommand.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/command/TradeCommand.java</h2>
    <p>
        Die Klasse <code>TradeCommand</code> implementiert den <code>CommandExecutor</code> für das Handelssystem des RPG-Plugins. 
        Sie ermöglicht es Spielern, Handelsanfragen an andere Spieler zu senden, Goldangebote zu unterbreiten und Transaktionen sicher abzuschließen.
    </p>

    <h3>Klasse: TradeCommand</h3>
    <p><strong>Beschreibung:</strong> Verarbeitet alle Unterbefehle des <code>/trade</code> Kommandos.</p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Der Haupteinstiegspunkt für den Befehl. Validiert, ob der Sender ein Spieler ist, und leitet die Argumente an die entsprechenden privaten Methoden weiter.</p>
        </li>
        <li>
            <code>requestTrade(Player player, String[] args)</code>
            <p>Initiiert eine Handelsanfrage an einen anderen Spieler. Erfordert den Namen des Zielspielers als Argument.</p>
        </li>
        <li>
            <code>acceptTrade(Player player)</code>
            <p>Akzeptiert eine eingehende Handelsanfrage, sofern eine vorhanden ist.</p>
        </li>
        <li>
            <code>offerGold(Player player, String[] args)</code>
            <p>Setzt den Goldbetrag fest, den der Spieler im aktuellen Handel anbieten möchte.</p>
        </li>
        <li>
            <code>requestGold(Player player, String[] args)</code>
            <p>Setzt den Goldbetrag fest, den der Spieler vom Handelspartner verlangt.</p>
        </li>
        <li>
            <code>readyTrade(Player player)</code>
            <p>Markiert den Spieler als bereit für den Abschluss des Handels. Wenn beide Parteien bereit sind, wird <code>completeTrade</code> aufgerufen.</p>
        </li>
        <li>
            <code>completeTrade(TradeRequest request)</code>
            <p>Führt die eigentliche Transaktion durch. Überprüft die Goldbestände beider Spieler in ihren Profilen und transferiert die Beträge bei Erfolg.</p>
        </li>
        <li>
            <code>cancelTrade(Player player)</code>
            <p>Bricht den aktuellen Handel oder die aktuelle Anfrage ab und bereinigt die Daten im <code>TradeManager</code>.</p>
        </li>
    </ul>

    <h3>Verfügbare Befehle (Syntax):</h3>
    <ul>
        <li><code>/trade request &lt;player&gt;</code> - Sendet eine Anfrage.</li>
        <li><code>/trade accept</code> - Nimmt eine Anfrage an.</li>
        <li><code>/trade offer &lt;gold&gt;</code> - Bietet Gold an.</li>
        <li><code>/trade requestgold &lt;gold&gt;</code> - Verlangt Gold.</li>
        <li><code>/trade ready</code> - Signalisiert Handelsbereitschaft.</li>
        <li><code>/trade cancel</code> - Bricht den Handel ab.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/command/VoiceChatCommand.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/command/VoiceChatCommand.java</h2>
    <p>
        Die Klasse <code>VoiceChatCommand</code> ist für die Verarbeitung von Chat-Befehlen zuständig, die das Voice-Chat-System des RPG-Plugins steuern. 
        Sie ermöglicht es Spielern, verschiedenen Voice-Kanälen (wie Party oder Gilde) beizutreten oder diese zu verlassen.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class VoiceChatCommand implements CommandExecutor</code>
    </p>
    <p>
        Diese Klasse implementiert das <code>CommandExecutor</code>-Interface von Bukkit, um Befehle im Spiel zu registrieren und zu verarbeiten.
    </p>

    <h3>Konstruktor</h3>
    <ul>
        <li>
            <code>VoiceChatCommand(RPGPlugin plugin)</code>: Initialisiert den Command-Handler mit einer Instanz des Haupt-Plugins, um Zugriff auf den <code>VoiceChatManager</code> zu erhalten.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong>onCommand</strong>
            <p>
                <code>public boolean onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            </p>
            <p>
                Verarbeitet den eingegebenen Befehl <code>/voicechat</code>.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>sender</code>: Der Absender des Befehls (muss ein Spieler sein).</li>
                        <li><code>command</code>: Das ausgeführte Kommando-Objekt.</li>
                        <li><code>label</code>: Der Alias des verwendeten Befehls.</li>
                        <li><code>args</code>: Die Argumente des Befehls (z. B. "party", "guild", "leave").</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> - Gibt <code>true</code> zurück, wenn der Befehl erfolgreich verarbeitet wurde.</li>
                <li><strong>Logik:</strong>
                    <ul>
                        <li>Prüft, ob der Sender ein Spieler ist. Falls nicht, wird eine Fehlermeldung ausgegeben.</li>
                        <li>Prüft die Anzahl der Argumente. Fehlen Argumente, wird die korrekte Syntax angezeigt.</li>
                        <li>Verwendet ein <code>switch</code>-Statement, um je nach Argument eine Aktion im <code>VoiceChatManager</code> auszulösen:
                            <ul>
                                <li><code>party</code>: Tritt dem Voice-Kanal der aktuellen Party bei.</li>
                                <li><code>guild</code>: Tritt dem Voice-Kanal der aktuellen Gilde bei.</li>
                                <li><code>leave</code>: Verlässt den aktuellen Voice-Kanal.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/db/DatabaseService.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/db/DatabaseService.java</h2>
    <p>
        Die Klasse <code>DatabaseService</code> ist die zentrale Komponente für die Datenbankverwaltung des RPG-Plugins. 
        Sie stellt eine Verbindung zu einer PostgreSQL-Datenbank her, nutzt HikariCP für das Connection-Pooling und 
        verwaltet die Initialisierung der erforderlichen Tabellenstrukturen.
    </p>

    <h3>Klasse: DatabaseService</h3>
    <p>
        Diese Klasse kapselt alle Low-Level-Datenbankoperationen und stellt einen Thread-Pool für asynchrone Datenbankzugriffe bereit.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>DatabaseService(JavaPlugin plugin)</code>: Initialisiert den Service. Liest die Konfiguration (Host, Port, Name, Benutzer, Passwort, Pool-Größe) aus der <code>config.yml</code> des Plugins aus, lädt den PostgreSQL-Treiber und konfiguriert die Hikari-Datenquelle.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>getConnection()</code>: 
            <p>Gibt eine aktive Verbindung aus dem Connection-Pool zurück.</p>
            <strong>Rückgabewert:</strong> <code>java.sql.Connection</code>
            <br><strong>Throws:</strong> <code>SQLException</code>
        </li>
        <li>
            <code>executor()</code>: 
            <p>Bietet Zugriff auf den <code>ExecutorService</code>, um Datenbankoperationen außerhalb des Haupt-Server-Threads auszuführen.</p>
            <strong>Rückgabewert:</strong> <code>ExecutorService</code>
        </li>
        <li>
            <code>initTables()</code>: 
            <p>Erstellt die notwendigen Tabellen für das RPG-System, falls diese noch nicht existieren. Dazu gehören:</p>
            <ul>
                <li><code>rpg_players</code>: Speichert Spielerstatistiken, Level, Gold, Gilden-IDs, ELO und JSON-Daten für Berufe, Quests und Inventar.</li>
                <li><code>rpg_skills</code>: Speichert spezifische Skill-Daten der Spieler.</li>
                <li><code>rpg_quests</code>: Speichert den Quest-Fortschritt.</li>
                <li><code>rpg_roles</code> &amp; <code>rpg_player_roles</code>: Verwalten das Berechtigungssystem und Rollenzuweisungen.</li>
                <li><code>rpg_audit_log</code>: Protokolliert administrative Aktionen und Änderungen.</li>
            </ul>
        </li>
        <li>
            <code>shutdown()</code>: 
            <p>Fährt den Executor-Service kontrolliert herunter und schließt die Hikari-Datenquelle.</p>
        </li>
        <li>
            <code>createDataSource(HikariConfig hikariConfig)</code> (privat): 
            <p>Versucht die Datenquelle zu initialisieren. Falls die Datenbank nicht existiert, wird versucht, sie automatisch anzulegen.</p>
        </li>
        <li>
            <code>createDatabase()</code> (privat): 
            <p>Verbindet sich mit der Standard-Datenbank <code>postgres</code>, um die im Konfigurationsfile definierte Ziel-Datenbank per SQL-Befehl zu erstellen.</p>
            <strong>Rückgabewert:</strong> <code>boolean</code> (Erfolg der Erstellung)
        </li>
    </ul>

    <h3>Wichtige Tabellenstrukturen (Auszug)</h3>
    <p>Die Datenbank nutzt intensiv den Datentyp <code>JSONB</code> von PostgreSQL, um flexible Datenstrukturen wie Quest-Fortschritte, Statistiken und Skill-Cooldowns effizient zu speichern.</p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/db/PlayerDao.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/db/PlayerDao.java</h2>
    <p>
        Das Interface <code>PlayerDao</code> definiert die Schnittstelle für den Datenzugriff (Data Access Object) auf Spielerprofile innerhalb des RPG-Systems. 
        Es stellt Methoden bereit, um Spielerdaten asynchron zu speichern und zu laden, wobei <code>CompletableFuture</code> verwendet wird, um die Haupt-Thread-Performance des Servers nicht zu beeinträchtigen.
    </p>

    <h3>Interface: PlayerDao</h3>
    <p><strong>Zweck:</strong> Definition des Vertrags für die Persistierung von Spielerdaten.</p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>CompletableFuture&lt;Void&gt; savePlayer(PlayerProfile profile)</code>
            <p>
                Speichert das übergebene Spielerprofil in der Datenbank.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>profile</code> (PlayerProfile) - Das zu speichernde Profil des Spielers.</li>
                <li><strong>Rückgabewert:</strong> Ein <code>CompletableFuture</code>, das abgeschlossen wird, wenn der Speichervorgang beendet ist.</li>
            </ul>
        </li>
        <li>
            <code>CompletableFuture&lt;PlayerProfile&gt; loadPlayer(UUID uuid)</code>
            <p>
                Lädt ein Spielerprofil basierend auf der eindeutigen Identifikationsnummer (UUID) des Spielers aus der Datenbank.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>uuid</code> (UUID) - Die eindeutige ID des Spielers.</li>
                <li><strong>Rückgabewert:</strong> Ein <code>CompletableFuture</code>, das nach Abschluss das geladene <code>PlayerProfile</code> enthält.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/db/SqlPlayerDao.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/db/SqlPlayerDao.java</h2>
    <p>
        Die Klasse <code>SqlPlayerDao</code> ist eine Implementierung des <code>PlayerDao</code>-Interfaces, die für die Persistenz von Spielerprofilen in einer SQL-Datenbank (optimiert für PostgreSQL mit JSONB-Unterstützung) verantwortlich ist. Sie nutzt <code>Gson</code> zur Serialisierung komplexer Java-Objekte in JSON-Formate und führt Datenbankoperationen asynchron mittels <code>CompletableFuture</code> aus.
    </p>

    <h3>Klasse: SqlPlayerDao</h3>
    <p><strong>Zweck:</strong> Verwaltung des Ladens und Speicherns von <code>PlayerProfile</code>-Daten in einer relationalen Datenbank.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>SqlPlayerDao(DatabaseService databaseService)</code>: Initialisiert den DAO mit dem angegebenen Datenbankdienst für die Verbindungsverwaltung.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>savePlayer(PlayerProfile profile)</code>
            <p><strong>Zweck:</strong> Speichert ein Spielerprofil asynchron in der Tabelle <code>rpg_players</code>. Verwendet ein <code>INSERT ... ON CONFLICT (uuid) DO UPDATE</code> Statement (Upsert), um bestehende Datensätze zu aktualisieren.</p>
            <p><strong>Parameter:</strong> <code>PlayerProfile profile</code> - Das zu speichernde Profil.</p>
            <p><strong>Rückgabewert:</strong> <code>CompletableFuture&lt;Void&gt;</code></p>
        </li>
        <li>
            <code>loadPlayer(UUID uuid)</code>
            <p><strong>Zweck:</strong> Lädt ein Spielerprofil asynchron anhand der UUID aus der Datenbank. Transformiert gespeicherte JSON-Daten zurück in die entsprechenden Java-Kollektionen (Maps, Sets, Listen).</p>
            <p><strong>Parameter:</strong> <code>UUID uuid</code> - Die eindeutige ID des Spielers.</p>
            <p><strong>Rückgabewert:</strong> <code>CompletableFuture&lt;PlayerProfile&gt;</code> - Das geladene Profil oder <code>null</code>, falls kein Eintrag gefunden wurde.</p>
        </li>
        <li>
            <code>statsToMap(Map&lt;RPGStat, Integer&gt; stats)</code>
            <p><strong>Zweck:</strong> Hilfsmethode zur Konvertierung der Enum-basierten Statistiken in eine String-basierte Map für die JSON-Serialisierung.</p>
        </li>
        <li>
            <code>questsToMap(Map&lt;String, QuestProgress&gt; quests)</code>
            <p><strong>Zweck:</strong> Konvertiert Quest-Fortschrittsdaten in eine verschachtelte Map-Struktur zur Speicherung als JSON.</p>
        </li>
        <li>
            <code>loadQuests(String json, PlayerProfile profile)</code>
            <p><strong>Zweck:</strong> Parst JSON-Daten und rekonstruiert die <code>QuestProgress</code>-Objekte für das Spielerprofil.</p>
        </li>
        <li>
            <code>applyMap(String json, Map&lt;String, T&gt; target, Type type)</code>
            <p><strong>Zweck:</strong> Generische Hilfsmethode, die JSON-Daten in eine Ziel-Map einliest.</p>
        </li>
        <li>
            <code>fromJson(String json, Type type)</code>
            <p><strong>Zweck:</strong> Wrapper für Gson zur Deserialisierung von JSON-Strings unter Berücksichtigung von Null-Werten und leeren Strings.</p>
        </li>
    </ul>

    <h4>Wichtige Felder</h4>
    <ul>
        <li><code>databaseService</code>: Der Dienst zur Bereitstellung von Datenbankverbindungen und Executoren.</li>
        <li><code>gson</code>: Instanz zur Handhabung von JSON-Konvertierungen.</li>
        <li><code>TypeToken</code> Definitionen: Verschiedene Typ-Definitionen (z.B. <code>mapStringInt</code>, <code>listString</code>), um die Typsicherheit bei der Deserialisierung generischer Kollektionen zu gewährleisten.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonGenerator.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonGenerator.java</h2>
    <p>Die Klasse <code>DungeonGenerator</code> ist eine zentrale Komponente des RPG-Systems, die für die prozedurale Erstellung von Dungeon-Instanzen verantwortlich ist. Sie kombiniert verschiedene Algorithmen wie Jigsaw-Placements und Wave Function Collapse (WFC), um komplexe, spielbare Welten mit Räumen, Korridoren, Spawnern und Bossen zu generieren.</p>

    <h3>Klasse: DungeonGenerator</h3>
    <p>Verwaltet den gesamten Lebenszyklus der Dungeon-Generierung, von der Erstellung der Welt bis hin zur Platzierung von Blöcken und Entitäten.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>DungeonGenerator(RPGPlugin plugin)</code>: Initialisiert den Generator, den WFC-Generator und den Loader für Raumstrukturen (Schematics).</li>
    </ul>

    <h4>Hauptmethoden</h4>
    <ul>
        <li>
            <code>generate(String theme, List&lt;Player&gt; party, Set&lt;UUID&gt; participants, double scale)</code>
            <p>Erstellt einen neuen Dungeon basierend auf einem Thema. Berechnet die benötigte Fläche, erstellt eine neue Bukkit-Welt, plant das Layout (DungeonPlan) und baut die physische Struktur auf. Gibt eine <code>DungeonInstance</code> zurück.</p>
        </li>
        <li>
            <code>generateWfc(String theme, List&lt;Player&gt; party, Set&lt;UUID&gt; participants, double scale, Consumer&lt;DungeonInstance&gt; callback)</code>
            <p>Führt eine asynchrone Generierung mittels Wave Function Collapse (WFC) durch. Nach Abschluss der Musterberechnung wird der Dungeon in der Welt aufgebaut und die Instanz über einen Callback zurückgegeben.</p>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>planDungeon(BoundingBox bounds, DungeonSettings settings, String theme)</code>
            <p>Nutzt den <code>DungeonPlanner</code>, um ein logisches Layout der Räume zu entwerfen. Versucht bis zu 5 Mal, einen validen Plan zu erstellen.</p>
        </li>
        <li>
            <code>buildFromPatterns(World world, Pattern[][][] patterns, int originY)</code>
            <p>Iteriert durch ein 3D-Array von WFC-Mustern und platziert die entsprechenden Blöcke in der Welt. Ermittelt zudem den am weitesten entfernten Punkt für den Boss-Raum.</p>
        </li>
        <li>
            <code>placePattern(World world, Pattern pattern, int baseX, int baseY, int baseZ)</code>
            <p>Platziert ein spezifisches 2x2x2 Block-Muster an den angegebenen Koordinaten.</p>
        </li>
        <li>
            <code>spawnSpawners(List&lt;Location&gt; roomCenters, String theme)</code>
            <p>Platziert Mob-Spawner oder Fallback-Zombies in den Zentren der generierten Räume basierend auf dem gewählten Thema.</p>
        </li>
        <li>
            <code>spawnBoss(Location bossRoom)</code>
            <p>Beschwört die Boss-Entität im dafür vorgesehenen Raum und fügt eine Textanzeige (Hologramm) hinzu.</p>
        </li>
        <li>
            <code>createGlassBoundary(World world, BoundingBox area, int wallHeight)</code>
            <p>Erzeugt eine physische Begrenzung aus Glas um den Dungeon herum, um Spieler innerhalb des generierten Bereichs zu halten.</p>
        </li>
        <li>
            <code>loadSettings()</code>
            <p>Liest die Dungeon-Konfiguration (Raumgrößen, Block-Materialien, Loot-Chancen, Mob-Einstellungen) aus der <code>config.yml</code> des Plugins aus.</p>
        </li>
        <li>
            <code>spawnSigns(Location start, Location bossRoom, String theme)</code>
            <p>Erstellt <code>TextDisplay</code>-Entitäten am Startpunkt und am Boss-Raum zur Orientierung der Spieler.</p>
        </li>
    </ul>

    <h4>Abhängigkeiten</h4>
    <ul>
        <li><code>WfcGenerator</code>: Zur Berechnung von Mustern nach dem Wave Function Collapse Prinzip.</li>
        <li><code>DungeonPlanner</code> &amp; <code>DungeonBuilder</code>: Zur Planung und zum physischen Bau der Raumstrukturen.</li>
        <li><code>RoomStructureLoader</code>: Zum Laden von vordefinierten Raum-Schematics.</li>
        <li><code>RPGPlugin</code>: Zugriff auf Konfigurationen und Manager (MobManager, SpawnerManager).</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonInstance.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonInstance.java</h2>
    <p>Die Klasse <code>DungeonInstance</code> repräsentiert eine aktive Instanz eines Dungeons innerhalb des RPG-Systems. Sie dient als Datencontainer für den Zustand, die Lokalisierung und die Teilnehmer eines spezifischen Dungeon-Laufs.</p>

    <h3>Klasse: DungeonInstance</h3>
    <p>Diese Klasse speichert alle relevanten Metadaten, die für die Verwaltung eines generierten Dungeons benötigt werden, einschließlich der Welt-Referenz, wichtiger Wegpunkte und der Skalierung.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>DungeonInstance(World world, Location start, Location bossRoom, Set&lt;UUID&gt; participants, double scale)</code>
            <p>Initialisiert eine neue Dungeon-Instanz mit den grundlegenden Parametern.</p>
            <ul>
                <li><code>world</code>: Die Bukkit-Welt, in der der Dungeon generiert wurde.</li>
                <li><code>start</code>: Der Startpunkt (Spawn) für Spieler innerhalb des Dungeons.</li>
                <li><code>bossRoom</code>: Die Position des Boss-Raums.</li>
                <li><code>participants</code>: Eine Menge von UUIDs der Spieler, die an dieser Instanz teilnehmen.</li>
                <li><code>scale</code>: Ein Skalierungsfaktor, der vermutlich für die Schwierigkeit oder die Belohnungen verwendet wird.</li>
            </ul>
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>world()</code>: Gibt die <code>World</code> zurück, in der sich diese Instanz befindet.
            <br><strong>Rückgabewert:</strong> <code>World</code>
        </li>
        <li>
            <code>start()</code>: Gibt den Startpunkt des Dungeons zurück.
            <br><strong>Rückgabewert:</strong> <code>Location</code>
        </li>
        <li>
            <code>bossRoom()</code>: Gibt die Position des Boss-Raums zurück.
            <br><strong>Rückgabewert:</strong> <code>Location</code>
        </li>
        <li>
            <code>participants()</code>: Gibt die Menge der teilnehmenden Spieler-UUIDs zurück.
            <br><strong>Rückgabewert:</strong> <code>Set&lt;UUID&gt;</code>
        </li>
        <li>
            <code>scale()</code>: Gibt den Skalierungsfaktor der Instanz zurück.
            <br><strong>Rückgabewert:</strong> <code>double</code>
        </li>
        <li>
            <code>noDeath()</code>: Prüft, ob der "No-Death"-Modus aktiv ist (standardmäßig <code>true</code>). Dies beeinflusst vermutlich, ob Spieler beim Sterben den Dungeon verlassen oder Items verlieren.
            <br><strong>Rückgabewert:</strong> <code>boolean</code>
        </li>
        <li>
            <code>setNoDeath(boolean noDeath)</code>: Ermöglicht das Aktivieren oder Deaktivieren des "No-Death"-Modus für diese Instanz.
            <br><strong>Parameter:</strong> <code>noDeath</code> (boolean)
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/JigsawRoomPlacer.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/JigsawRoomPlacer.java</h2>
    <p>
        Die Klasse <code>JigsawRoomPlacer</code> ist eine zentrale Komponente für die Generierung von Dungeons. 
        Sie ist dafür verantwortlich, Räume basierend auf vordefinierten Vorlagen (Templates) innerhalb eines 
        festgelegten Bereichs (BoundingBox) zu platzieren, ohne dass diese sich überschneiden.
    </p>

    <h3>Klasse: JigsawRoomPlacer</h3>
    <p>
        Diese Klasse implementiert einen Algorithmus zur zufälligen Platzierung von Räumen unter Berücksichtigung 
        von Raumtypen und Abstandsregeln.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>JigsawRoomPlacer(Random random)</code>: Initialisiert den Placer mit einer Instanz von <code>Random</code>, um deterministische oder zufällige Generierungen zu ermöglichen.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public List&lt;Room&gt; placeRooms(BoundingBox bounds, DungeonSettings settings, List&lt;RoomTemplate&gt; templates)</code>
            <p>
                Die Hauptmethode zur Platzierung der Räume. Sie erstellt eine Liste von Raumtypen basierend auf den Einstellungen, 
                wählt passende Vorlagen aus und versucht, diese innerhalb der Grenzen zu positionieren.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>bounds</code>: Die <code>BoundingBox</code>, die den maximalen Raum für den Dungeon definiert.</li>
                        <li><code>settings</code>: <code>DungeonSettings</code>, welche die Anzahl der Räume und Wahrscheinlichkeiten für Beute oder Elite-Gegner enthalten.</li>
                        <li><code>templates</code>: Eine Liste verfügbarer <code>RoomTemplate</code>-Objekte.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Eine Liste der erfolgreich platzierten <code>Room</code>-Objekte. Gibt eine leere Liste zurück, falls die Platzierung fehlschlägt.</li>
            </ul>
        </li>

        <li>
            <code>private List&lt;RoomType&gt; buildRoomTypes(DungeonSettings settings)</code>
            <p>
                Erstellt eine Liste von <code>RoomType</code>-Elementen, die im Dungeon vorhanden sein sollen. 
                Standardmäßig werden immer ein Start-, ein Ausgangs- und ein Boss-Raum hinzugefügt. 
                Weitere Räume (Combat, Loot, Elite) werden basierend auf den <code>settings</code> und Zufallswerten generiert.
            </p>
        </li>

        <li>
            <code>private Map&lt;RoomType, List&lt;RoomTemplate&gt;&gt; groupByType(List&lt;RoomTemplate&gt; templates)</code>
            <p>Gruppiert die verfügbaren Vorlagen nach ihrem <code>RoomType</code> in einer Map für einen schnelleren Zugriff.</p>
        </li>

        <li>
            <code>private RoomTemplate chooseTemplate(RoomType type, List&lt;RoomTemplate&gt; all, Map&lt;RoomType, List&lt;RoomTemplate&gt;&gt; byType)</code>
            <p>Wählt zufällig eine Vorlage aus, die dem gewünschten Typ entspricht. Falls keine spezifische Vorlage gefunden wird, wird auf die gesamte Liste zurückgegriffen.</p>
        </li>

        <li>
            <code>private BoundingBox randomBounds(BoundingBox bounds, RoomTemplate template, int padding)</code>
            <p>Berechnet eine zufällige Position innerhalb der Gesamtgrenzen für eine spezifische Raumvorlage unter Berücksichtigung eines Sicherheitsabstands (Padding).</p>
        </li>

        <li>
            <code>private boolean isOverlapping(BoundingBox candidate, List&lt;Room&gt; rooms, int padding)</code>
            <p>Prüft, ob ein neuer Raumkandidat mit bereits platzierten Räumen kollidiert. Hierbei wird das Padding einbezogen, um sicherzustellen, dass Räume nicht direkt aneinanderkleben.</p>
        </li>

        <li>
            <code>private int nextBetween(int min, int max)</code>
            <p>Hilfsmethode zur Generierung einer Zufallszahl innerhalb eines inklusiven Bereichs.</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/RoomSocketTemplate.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/RoomSocketTemplate.java</h2>

    <p>
        Die Datei definiert das Java-Record <code>RoomSocketTemplate</code>. Dieses dient als Datencontainer (Template) für die Definition von Anschlusspunkten (Sockets) innerhalb einer Raum-Struktur im Jigsaw-Dungeon-System. Es speichert die relativen Koordinaten eines Sockets innerhalb eines Raum-Blueprints.
    </p>

    <h3>Klasse: RoomSocketTemplate (Record)</h3>
    <p>
        Ein Record, das die grundlegenden Daten eines Sockets speichert, bevor dieser in der Spielwelt instanziiert wird.
    </p>

    <h4>Komponenten (Felder):</h4>
    <ul>
        <li><code>name</code> (String): Der Bezeichner des Sockets (z. B. "north_door" oder "corridor_end"). Dies wird verwendet, um passende Gegenstücke für die Verbindung von Räumen zu finden.</li>
        <li><code>x</code> (int): Die relative X-Koordinate des Sockets innerhalb der Raum-Struktur.</li>
        <li><code>y</code> (int): Die relative Y-Koordinate des Sockets innerhalb der Raum-Struktur.</li>
        <li><code>z</code> (int): Die relative Z-Koordinate des Sockets innerhalb der Raum-Struktur.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>toSocket(Location origin)</code></h4>
    <p>
        Konvertiert dieses Template in ein reales <code>RoomSocket</code>-Objekt, indem die relativen Koordinaten auf einen absoluten Ursprungspunkt in der Welt angewendet werden.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>origin</code> (Location): Der Basis-Standort (Nullpunkt) des Raumes in der Minecraft-Welt.</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> 
            <code>RoomSocket</code> - Eine neue Instanz eines Sockets mit der berechneten absoluten Position.
        </li>
        <li><strong>Logik:</strong> Die Methode klont den Ursprungspunkt und addiert die im Template definierten X-, Y- und Z-Werte hinzu.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/RoomStructureLoader.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/RoomStructureLoader.java</h2>
    <p>
        Das Interface <code>RoomStructureLoader</code> definiert die grundlegende Schnittstelle für das Laden von Raumvorlagen (RoomTemplates) innerhalb des Jigsaw-Dungeon-Generierungssystems. 
        Es ermöglicht eine abstrakte Handhabung verschiedener Lade-Mechanismen, wie beispielsweise das Laden aus Schematics oder Konfigurationsdateien.
    </p>

    <h3>Interface: RoomStructureLoader</h3>
    <p>
        Dieses Interface stellt sicher, dass verschiedene Implementierungen (z. B. für unterschiedliche Dateiformate oder Speicherorte) einheitlich genutzt werden können, um Räume basierend auf einem bestimmten Thema zu laden.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>List&lt;RoomTemplate&gt; loadRooms(JavaPlugin plugin, String theme)</code>
            <p>
                Diese Methode ist dafür verantwortlich, alle verfügbaren Raumvorlagen für ein spezifisches Dungeon-Thema einzulesen.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>plugin</code>: Die Instanz des <code>JavaPlugin</code>, die für den Zugriff auf Ressourcen oder Dateipfade benötigt wird.</li>
                        <li><code>theme</code>: Ein <code>String</code>, der das Thema des Dungeons repräsentiert (z. B. "Gothic", "Forest", "Desert"), um die entsprechenden Raumstrukturen zu filtern.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Eine Liste von <code>RoomTemplate</code>-Objekten, die die geladenen Raumdaten und deren Metadaten (wie Sockets für die Verbindung) enthalten.</li>
            </ul>
        </li>
    </ul>

    <h3>Zusammenhang im Projekt</h3>
    <p>
        Innerhalb der Projektstruktur wird dieses Interface beispielsweise von der Klasse <code>SchematicRoomStructureLoader</code> implementiert, um Räume aus <code>.schem</code>-Dateien zu laden. Es bildet die Brücke zwischen den physischen Daten auf der Festplatte und der logischen Platzierung durch den <code>JigsawRoomPlacer</code>.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/RoomTemplate.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/RoomTemplate.java</h2>

    <p>
        Die Klasse <code>RoomTemplate</code> ist als Java <code>record</code> implementiert und dient als Blaupause für einen Raum innerhalb des Jigsaw-Dungeon-Generierungssystems. Sie verknüpft die physischen Strukturdaten (Schematic) mit logischen Eigenschaften wie Raumtyp und Anschlusspunkten (Sockets).
    </p>

    <h3>Klassen-Definition</h3>
    <p><strong>Typ:</strong> <code>public record RoomTemplate</code></p>
    <p><strong>Zweck:</strong> Speicherung von Metadaten und strukturellen Informationen eines Raums, um diesen dynamisch in der Spielwelt zu platzieren.</p>

    <h4>Parameter (Record Components)</h4>
    <ul>
        <li><code>name</code> (String): Der eindeutige Name des Raum-Templates.</li>
        <li><code>type</code> (RoomType): Die Kategorie des Raums (z. B. Startraum, Bossraum, Flur).</li>
        <li><code>schematic</code> (Schematic): Die tatsächlichen Blockdaten und Dimensionen des Raums.</li>
        <li><code>sockets</code> (List&lt;RoomSocketTemplate&gt;): Eine Liste von vordefinierten Anschlusspunkten, an denen andere Räume andocken können.</li>
    </ul>

    <h3>Methoden</h3>

    <h4><code>boundsAt(Location origin)</code></h4>
    <p>
        Berechnet die räumliche Ausdehnung (BoundingBox) des Raums, wenn er an einer bestimmten Position in der Welt platziert würde.
    </p>
    <ul>
        <li><strong>Parameter:</strong> <code>origin</code> (Location) - Der Ursprungspunkt (Minimum-Ecke), an dem der Raum platziert werden soll.</li>
        <li><strong>Rückgabewert:</strong> <code>BoundingBox</code> - Ein Objekt, das die exakten Koordinatengrenzen des Raums im 3D-Raum darstellt.</li>
    </ul>

    <h4><code>socketsAt(Location origin)</code></h4>
    <p>
        Transformiert die relativen Anschlusspunkte des Templates in absolute Weltkoordinaten basierend auf einem Startpunkt.
    </p>
    <ul>
        <li><strong>Parameter:</strong> <code>origin</code> (Location) - Der Ursprungspunkt des Raums.</li>
        <li><strong>Rückgabewert:</strong> <code>List&lt;RoomSocket&gt;</code> - Eine Liste von <code>RoomSocket</code>-Objekten mit berechneten Weltkoordinaten, die für die Pfadfindung und Raumverbindung genutzt werden können.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/SchematicRoomStructureLoader.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/jigsaw/SchematicRoomStructureLoader.java</h2>
    <p>
        Die Klasse <code>SchematicRoomStructureLoader</code> ist eine Implementierung des <code>RoomStructureLoader</code>-Interfaces. 
        Ihre Hauptaufgabe besteht darin, Raumvorlagen (Templates) für das Jigsaw-Dungeon-System aus Minecraft-Schematic-Dateien (im Sponge-Format) zu laden. 
        Dabei werden nicht nur die Blöcke geladen, sondern auch Metadaten wie Raumtypen und Verbindungspunkte (Sockets) aus den NBT-Daten extrahiert.
    </p>

    <h3>Klassen-Komponenten</h3>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public List&lt;RoomTemplate&gt; loadRooms(JavaPlugin plugin, String theme)</code>
            <p>
                Lädt alle verfügbaren Raumvorlagen für ein bestimmtes Thema aus dem Dateisystem.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>plugin</code>: Die Instanz des JavaPlugins, um auf Konfigurationen und Datenordner zuzugreifen.</li>
                        <li><code>theme</code>: Der Name des Unterordners (Thema), aus dem die Räume geladen werden sollen.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Eine Liste von <code>RoomTemplate</code>-Objekten. Falls das Thema keine Räume enthält, wird versucht, Räume aus dem "default"-Ordner zu laden.</li>
            </ul>
        </li>

        <li>
            <code>private List&lt;RoomTemplate&gt; loadFromFolder(File folder)</code>
            <p>
                Sucht in einem spezifischen Verzeichnis nach Dateien mit der Endung <code>.schem</code> und versucht, diese als Raumvorlagen zu interpretieren.
            </p>
        </li>

        <li>
            <code>private RoomTemplate loadTemplate(File file) throws IOException</code>
            <p>
                Verarbeitet eine einzelne Datei. Sie lädt die <code>Schematic</code>-Daten, bestimmt den Raumtyp anhand des Dateinamens und extrahiert die Jigsaw-Sockets aus den NBT-Block-Entities.
            </p>
        </li>

        <li>
            <code>private RoomType deriveType(String name)</code>
            <p>
                Bestimmt den <code>RoomType</code> basierend auf Schlüsselwörtern im Dateinamen (case-insensitive).
            </p>
            <ul>
                <li>"start" &rarr; <code>RoomType.START</code></li>
                <li>"boss" &rarr; <code>RoomType.BOSS</code></li>
                <li>"exit" &rarr; <code>RoomType.EXIT</code></li>
                <li>"loot" / "treasure" &rarr; <code>RoomType.LOOT</code></li>
                <li>"elite" &rarr; <code>RoomType.ELITE</code></li>
                <li>Standard &rarr; <code>RoomType.COMBAT</code></li>
            </ul>
        </li>

        <li>
            <code>private List&lt;RoomSocketTemplate&gt; extractSockets(NbtCompound root)</code>
            <p>
                Analysiert die NBT-Struktur der Schematic-Datei nach "BlockEntities". Es sucht gezielt nach Einträgen, die als "jigsaw" identifiziert werden können, und extrahiert deren Position (X, Y, Z) sowie deren Namen, um sie als <code>RoomSocketTemplate</code> zu speichern. Diese Sockets dienen als Ankerpunkte für die Verbindung verschiedener Räume im Jigsaw-Algorithmus.
            </p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>SpongeSchemLoader</code>: Zum Parsen der binären Schematic-Daten.</li>
        <li><code>NbtIO</code>: Zum Auslesen der NBT-Struktur (Named Binary Tag) für Metadaten.</li>
        <li><code>RoomTemplate</code> / <code>RoomSocketTemplate</code>: Datenmodelle für die Repräsentation der geladenen Räume.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/BlockBuffer.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/BlockBuffer.java</h2>

    <p>
        Die Klasse <code>BlockBuffer</code> fungiert als effizienter Zwischenspeicher für Block-Manipulationen innerhalb der Dungeon-Generierung. 
        Anstatt jeden Block einzeln und sofort in der Spielwelt zu platzieren, werden die Änderungen in einer Map gesammelt und zu einem späteren Zeitpunkt gesammelt ("geflushed") angewendet. 
        Dies dient primär der Performance-Optimierung und der Entkopplung von Berechnungslogik und Welt-Interaktion.
    </p>

    <h3>Klasse: BlockBuffer</h3>
    <p>
        Diese Klasse verwaltet einen internen Puffer, der Koordinaten auf Bukkit-<code>Material</code>-Typen abbildet.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public void set(int x, int y, int z, Material material)</code>
            <p>
                Fügt dem Puffer eine Block-Änderung hinzu.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>x</code>, <code>y</code>, <code>z</code>: Die Welt-Koordinaten des Blocks.</li>
                        <li><code>material</code>: Das zu setzende Bukkit-Material.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code>public void flush(World world)</code>
            <p>
                Überträgt alle im Puffer gespeicherten Änderungen in die angegebene Minecraft-Welt. Nach der Ausführung wird der Puffer geleert. 
                Die Methode verwendet <code>setType(material, false)</code>, um die Blöcke ohne unnötige Physik-Updates zu platzieren, was die Generierungsgeschwindigkeit erhöht.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>world</code>: Die Bukkit-Welt, in der die Blöcke platziert werden sollen.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code>private long toKey(int x, int y, int z)</code>
            <p>
                Eine interne Hilfsmethode, die drei 32-Bit-Integer-Koordinaten (x, y, z) in einen einzigen 64-Bit-<code>long</code>-Wert packt. 
                Dies ermöglicht die Verwendung eines <code>long</code> als effizienten Key in der HashMap anstelle von komplexen Objekten.
            </p>
            <ul>
                <li><strong>Logik:</strong> Jede Koordinate erhält 21 Bits im Long-Wert (21 Bits für X, 21 für Y, 21 für Z), was für den Koordinatenbereich in Minecraft absolut ausreichend ist.</li>
                <li><strong>Rückgabewert:</strong> Ein eindeutiger Hash-Key für die spezifische Position.</li>
            </ul>
        </li>
    </ul>

    <h4>Technische Details</h4>
    <p>
        Die Verwendung einer <code>HashMap&lt;Long, Material&gt;</code> ist speichereffizienter als die Erstellung von Positions-Objekten für jeden einzelnen Block. 
        Durch das Bit-Shifting in <code>toKey</code> wird eine schnelle und kollisionsfreie Adressierung der Blöcke im Speicher gewährleistet.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/Corridor.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/Corridor.java</h2>

    <p>
        Die Klasse <code>Corridor</code> ist eine einfache Datenstruktur innerhalb des Dungeon-Generierungssystems. 
        Sie dient dazu, den Verlauf eines Ganges (Korridors) zu speichern, der verschiedene Räume oder Bereiche innerhalb eines Dungeon-Layouts miteinander verbindet.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class Corridor</code>
    </p>
    <p>
        Diese Klasse kapselt eine Liste von Koordinaten (Vektoren), die den physischen Pfad des Korridors in der Spielwelt repräsentieren. 
        Sie wird primär von Klassen wie dem <code>CorridorRouter</code> oder dem <code>DungeonBuilder</code> verwendet, um die Verbindungswege zwischen den Räumen zu definieren.
    </p>

    <h3>Attribute</h3>
    <ul>
        <li>
            <code>path</code> (private final <code>List&lt;Vector&gt;</code>): 
            Eine Liste von Bukkit-<code>Vector</code>-Objekten. Jeder Vektor in dieser Liste stellt einen Punkt (Block-Koordinate) dar, der Teil des Korridors ist.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public List&lt;Vector&gt; path()</code>
            <p><strong>Beschreibung:</strong> Getter-Methode für den Pfad des Korridors.</p>
            <p><strong>Rückgabewert:</strong> Eine Liste von <code>Vector</code>-Objekten, die die Wegpunkte des Korridors beschreiben.</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/CorridorRouter.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/CorridorRouter.java</h2>
    <p>
        Die Klasse <code>CorridorRouter</code> ist für die Wegfindung und Erstellung von Korridoren zwischen Räumen innerhalb eines generierten Dungeons zuständig. Sie nutzt Pfadfindungsalgorithmen, um Verbindungen zu berechnen, die Hindernisse (wie andere Räume) umgehen.
    </p>

    <h3>Hauptklasse: CorridorRouter</h3>
    <p>Verantwortlich für die Logik der Korridor-Routung unter Verwendung von A* (A-Stern) oder Manhattan-Fallback-Methoden.</p>
    <ul>
        <li><strong>Konstruktor:</strong> <code>CorridorRouter(Random random)</code> - Initialisiert den Router mit einer Zufallsinstanz für Variationen.</li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public List&lt;Corridor&gt; routeCorridors(BoundingBox bounds, List&lt;Room&gt; rooms, List&lt;RoomEdge&gt; edges)</code>
            <p>Berechnet Pfade für alle gegebenen Raumverbindungen (Edges). Sie wählt Start- und Endpunkte (Türen) an den Räumen aus und generiert die Pfad-Vektoren.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>bounds</code> (Grenzbereich des Dungeons), <code>rooms</code> (Liste aller Räume), <code>edges</code> (Liste der zu verbindenden Räume).</li>
                <li><strong>Rückgabewert:</strong> Eine Liste von <code>Corridor</code>-Objekten mit den berechneten Pfaden.</li>
            </ul>
        </li>
        <li>
            <code>private Location chooseDoor(Room from, Room to, Location targetDoor)</code>
            <p>Bestimmt die optimale Position für eine Tür an einem Raum. Wenn der Raum definierte <code>RoomSockets</code> besitzt, werden diese bevorzugt verwendet. Andernfalls wird eine Position an der Wand gewählt, die in Richtung des Zielraums zeigt.</p>
        </li>
        <li>
            <code>private List&lt;Vector&gt; findPath(BoundingBox bounds, List&lt;Room&gt; rooms, Location start, Location goal)</code>
            <p>Implementiert den A*-Algorithmus zur Pfadfindung zwischen zwei Punkten. Der Algorithmus vermeidet Kollisionen mit existierenden Räumen.</p>
            <ul>
                <li><strong>Logik:</strong> Nutzt eine <code>PriorityQueue</code> für die effiziente Suche und eine Heuristik (Manhattan-Distanz).</li>
            </ul>
        </li>
        <li>
            <code>private boolean isBlocked(List&lt;Room&gt; rooms, Point point, Point start, Point goal)</code>
            <p>Prüft, ob ein bestimmter Punkt auf der Karte durch einen Raum blockiert ist. Start- und Endpunkte sind von der Blockprüfung ausgenommen.</p>
        </li>
        <li>
            <code>private List&lt;Vector&gt; fallbackManhattan(Point start, Point goal)</code>
            <p>Eine einfache Ausweichmethode, falls der A*-Algorithmus keinen Pfad findet. Erzeugt einen direkten L-förmigen Pfad (zuerst X-Achse, dann Z-Achse).</p>
        </li>
    </ul>

    <h3>Interne Datenstrukturen</h3>
    <ul>
        <li><code>public record RoomEdge(Room a, Room b)</code>: Repräsentiert eine logische Verbindung zwischen zwei Räumen.</li>
        <li><code>private static class Point</code>: Eine einfache Hilfsklasse für 2D-Koordinaten (X, Z) im Raster.</li>
        <li><code>private static class Node</code>: Repräsentiert einen Knoten im A*-Suchbaum, inklusive Kostenwerten (g, h, f) und Verweis auf den Elternknoten.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonBuilder.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonBuilder.java</h2>
    <p>Die Klasse <code>DungeonBuilder</code> ist eine zentrale Komponente für die physische Generierung von Dungeons in der Spielwelt. Sie transformiert einen abstrakten <code>DungeonPlan</code> in tatsächliche Blöcke, platziert Strukturen, Mobs und Beute.</p>

    <h3>Klasse: DungeonBuilder</h3>
    <p>Verantwortlich für das "Aushöhlen" von Räumen und Korridoren, das Einfügen von Schematics sowie die Dekoration und das Spawning innerhalb eines Dungeons.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>DungeonBuilder(RPGPlugin plugin, Random random)</code>: Initialisiert den Builder mit den notwendigen Sub-Komponenten wie <code>DungeonDecorator</code>, <code>SpawnPlacer</code>, <code>LootPlacer</code> und dem <code>SchematicPaster</code>.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>void build(World world, DungeonPlan plan, DungeonSettings settings, String theme)</code>
            <p>Führt den vollständigen Bauprozess des Dungeons aus. Dies umfasst:</p>
            <ul>
                <li>Iterieren über alle Räume im Plan: Entweder wird eine Struktur (Schematic) eingefügt oder der Raum wird manuell generiert und dekoriert.</li>
                <li>Erstellung der Korridore basierend auf den Pfaden im Plan.</li>
                <li>Platzierung von Türen an den Verbindungspunkten.</li>
                <li>Anwendung von Wasser-Effekten (z. B. Kanäle oder überflutete Räume).</li>
                <li>Finalisierung der Blöcke über einen <code>BlockBuffer</code> zur Performance-Optimierung.</li>
                <li>Spawnen von Mobs und Platzieren von Loot-Containern nach Abschluss der Bauarbeiten.</li>
            </ul>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>carveRoom(BlockBuffer buffer, Room room, DungeonSettings settings)</code>
            <p>Erstellt einen einfachen rechteckigen Raum im Buffer, setzt den Boden und zieht Wände hoch.</p>
        </li>
        <li>
            <code>carveCorridor(BlockBuffer buffer, Corridor corridor, BoundingBox bounds, DungeonSettings settings)</code>
            <p>Iteriert über die Vektoren eines Korridor-Pfades und höhlt diesen basierend auf der konfigurierten Breite aus.</p>
        </li>
        <li>
            <code>applyDoors(BlockBuffer buffer, DungeonPlan plan, DungeonSettings settings)</code>
            <p>Setzt Türblöcke an den definierten <code>doorPoints</code> der Räume, sofern diese nicht auf Templates basieren.</p>
        </li>
        <li>
            <code>applyWater(BlockBuffer buffer, DungeonPlan plan, DungeonSettings settings)</code>
            <p>Fügt Wasser-Elemente hinzu. Dies beinhaltet eine Chance für Kanäle in Korridoren oder Wasser am Rand von Räumen.</p>
        </li>
        <li>
            <code>pasteRoomStructure(World world, Room room, DungeonSettings settings, String theme)</code>
            <p>Nutzt den <code>SchematicPaster</code>, um vordefinierte Raum-Strukturen (Templates) asynchron in die Welt zu laden.</p>
        </li>
        <li>
            <code>maybeFillRoom(World world, Room room, DungeonSettings settings, String theme)</code>
            <p>Optionaler Schritt, der den <code>RoomWfcFiller</code> (Wave Function Collapse) nutzt, um das Innere eines Raumes thematisch passend zu füllen.</p>
        </li>
    </ul>

    <h4>Abhängigkeiten</h4>
    <ul>
        <li><code>BlockBuffer</code>: Zur effizienten Batch-Verarbeitung von Block-Änderungen.</li>
        <li><code>SchematicPaster</code>: Zum Einfügen komplexer, vorgefertigter Gebäudeteile.</li>
        <li><code>SpawnPlacer</code> &amp; <code>LootPlacer</code>: Zur Bestückung des Dungeons mit Inhalten.</li>
        <li><code>RoomWfcFiller</code>: Zur prozeduralen Füllung von Räumen mittels WFC-Algorithmus.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonDecorator.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonDecorator.java</h2>
    <p>
        Die Klasse <code>DungeonDecorator</code> ist für die ästhetische Gestaltung und die Platzierung funktionaler Blöcke innerhalb der generierten Dungeon-Räume zuständig. Sie verarbeitet Details wie Bodenbeläge, Beleuchtung und strukturelle Elemente basierend auf dem Raumtyp und den Dungeon-Einstellungen.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Diese Klasse bietet Methoden zur Modifikation des <code>BlockBuffer</code>, bevor dieser in die Spielwelt übertragen wird. Sie unterstützt zudem einen Debug-Modus zur visuellen Unterscheidung von Raumtypen.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>decorateRoom(World world, BlockBuffer buffer, Room room, DungeonSettings settings, Random random)</code>
            <p>
                Hauptmethode zur Dekoration eines spezifischen Raums. Sie berechnet die Grenzen des Raums und führt folgende Schritte aus:
            </p>
            <ul>
                <li>Füllen des Bodens mit dem in den <code>DungeonSettings</code> definierten Material.</li>
                <li>Hinzufügen von Variationen (z. B. rissige Steine) mit einer Wahrscheinlichkeit von 8%, sofern der Debug-Modus deaktiviert ist.</li>
                <li>Platzierung von Lichtquellen in den Ecken des Raums.</li>
                <li>Erstellung von Säulen, falls es sich um einen Elite- oder Boss-Raum handelt.</li>
            </ul>
            <strong>Parameter:</strong>
            <ul>
                <li><code>world</code>: Die Bukkit-Welt, in der der Dungeon generiert wird.</li>
                <li><code>buffer</code>: Der <code>BlockBuffer</code>, der die zu setzenden Blöcke zwischenspeichert.</li>
                <li><code>room</code>: Das <code>Room</code>-Objekt, das die Position und den Typ des Raums definiert.</li>
                <li><code>settings</code>: Die Konfigurationseinstellungen des Dungeons (Materialien, Debug-Status).</li>
                <li><code>random</code>: Ein Zufallsgenerator für Variationen in der Dekoration.</li>
            </ul>
        </li>

        <li>
            <code>placeLights(BlockBuffer buffer, DungeonSettings settings, int y, int minX, int maxX, int minZ, int maxZ)</code>
            <p>
                Platziert Lichtblöcke an den vier Eckpunkten des Raums auf einer definierten Höhe.
            </p>
        </li>

        <li>
            <code>placePillars(BlockBuffer buffer, DungeonSettings settings, int y, int minX, int maxX, int minZ, int maxZ)</code>
            <p>
                Erzeugt eine vertikale Säule in der Mitte des Raums. Die Höhe der Säule beträgt standardmäßig 3 Blöcke.
            </p>
        </li>

        <li>
            <code>debugFloor(RoomType type)</code>
            <p>
                Gibt ein spezifisches Woll-Material basierend auf dem <code>RoomType</code> zurück. Dies dient der visuellen Analyse der Dungeon-Struktur während der Entwicklung.
            </p>
            <strong>Rückgabewert:</strong> Ein <code>Material</code> (z. B. <code>RED_WOOL</code> für Boss-Räume, <code>GREEN_WOOL</code> für Start-Räume).
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonGraph.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonGraph.java</h2>

    <p>
        Die Klasse <code>DungeonGraph</code> dient als Datenstruktur zur Repräsentation der topologischen Vernetzung eines Dungeons. 
        Sie implementiert einen ungerichteten Graphen, in dem Räume als Knoten und die Verbindungen (Korridore) zwischen ihnen als Kanten fungieren.
    </p>

    <h3>Klasse: DungeonGraph</h3>
    <p>
        Diese Klasse verwaltet die Nachbarschaftsbeziehungen zwischen <code>Room</code>-Objekten mithilfe einer Adjazenzliste.
    </p>

    <h4>Felder</h4>
    <ul>
        <li>
            <code>adjacency</code>: Eine <code>Map</code>, die jedem <code>Room</code> eine Liste von benachbarten <code>Room</code>-Objekten zuordnet.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>addEdge(Room a, Room b)</code>
            <p>
                Erstellt eine ungerichtete Verbindung zwischen zwei Räumen. Die Methode stellt sicher, dass beide Räume in die Adjazenzliste des jeweils anderen aufgenommen werden.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>a</code> - Der erste Raum der Verbindung.</li>
                <li><strong>Parameter:</strong> <code>b</code> - Der zweite Raum der Verbindung.</li>
            </ul>
        </li>
        <li>
            <code>adjacency()</code>
            <p>
                Gibt die gesamte Adjazenzliste des Graphen zurück.
            </p>
            <ul>
                <li><strong>Rückgabewert:</strong> Eine <code>Map&lt;Room, List&lt;Room&gt;&gt;</code>, die die aktuelle Struktur des Dungeons widerspiegelt.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonPlan.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonPlan.java</h2>
    <p>
        Die Klasse <code>DungeonPlan</code> dient als Datenmodell (Data Transfer Object), das den fertigen Entwurf eines generierten Dungeons repräsentiert. Sie kapselt alle strukturellen Informationen, die für den anschließenden Bauprozess (Building) und die Dekoration des Dungeons in der Spielwelt erforderlich sind.
    </p>

    <h3>Klasse: DungeonPlan</h3>
    <p><strong>Beschreibung:</strong> Ein unveränderliches Objekt, das das Layout, die Räume, die Verbindungen und die Metadaten eines Dungeons speichert.</p>

    <h4>Konstruktor</h4>
    <p><code>public DungeonPlan(long seed, BoundingBox bounds, List&lt;Room&gt; rooms, List&lt;Corridor&gt; corridors, DungeonGraph graph, Room startRoom, Room bossRoom, Room exitRoom)</code></p>
    <ul>
        <li><code>seed</code>: Der numerische Startwert, der für die prozedurale Generierung verwendet wurde.</li>
        <li><code>bounds</code>: Ein <code>BoundingBox</code>-Objekt, das die räumlichen Ausmaße des gesamten Dungeons definiert.</li>
        <li><code>rooms</code>: Eine Liste aller im Dungeon enthaltenen <code>Room</code>-Objekte.</li>
        <li><code>corridors</code>: Eine Liste der <code>Corridor</code>-Objekte, welche die Räume miteinander verbinden.</li>
        <li><code>graph</code>: Die logische Repräsentation des Dungeons als <code>DungeonGraph</code> (Knoten und Kanten).</li>
        <li><code>startRoom</code>: Der definierte Startpunkt für Spieler.</li>
        <li><code>bossRoom</code>: Der Raum, in dem der Endgegner platziert wird.</li>
        <li><code>exitRoom</code>: Der Raum, der den Ausgang oder das Ziel des Dungeons markiert.</li>
    </ul>

    <h4>Methoden (Getter)</h4>
    <ul>
        <li><code>seed()</code>: Gibt den verwendeten Seed zurück. (Rückgabewert: <code>long</code>)</li>
        <li><code>bounds()</code>: Gibt die räumliche Begrenzung des Dungeons zurück. (Rückgabewert: <code>BoundingBox</code>)</li>
        <li><code>rooms()</code>: Gibt die Liste aller Räume zurück. (Rückgabewert: <code>List&lt;Room&gt;</code>)</li>
        <li><code>corridors()</code>: Gibt die Liste aller Korridore zurück. (Rückgabewert: <code>List&lt;Corridor&gt;</code>)</li>
        <li><code>graph()</code>: Gibt den logischen Struktur-Graphen zurück. (Rückgabewert: <code>DungeonGraph</code>)</li>
        <li><code>startRoom()</code>: Gibt den Startraum zurück. (Rückgabewert: <code>Room</code>)</li>
        <li><code>bossRoom()</code>: Gibt den Bossraum zurück. (Rückgabewert: <code>Room</code>)</li>
        <li><code>exitRoom()</code>: Gibt den Ausgangsraum zurück. (Rückgabewert: <code>Room</code>)</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonPlanner.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonPlanner.java</h2>
    <p>
        Die Klasse <code>DungeonPlanner</code> ist eine zentrale Komponente des Dungeon-Generierungssystems. Sie koordiniert den gesamten Planungsprozess eines Dungeons, von der Platzierung der Räume über die Zuweisung von Raumtypen bis hin zur Erstellung der Korridorverbindungen.
    </p>

    <h3>Klasse: DungeonPlanner</h3>
    <p>
        Diese Klasse fungiert als Orchestrator, der verschiedene spezialisierte Sub-Komponenten (wie <code>RoomPlacer</code>, <code>CorridorRouter</code> und <code>JigsawRoomPlacer</code>) nutzt, um einen vollständigen <code>DungeonPlan</code> zu erstellen.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>DungeonPlanner(Random random)</code>: Initialisiert den Planner mit einer Instanz zur Zufallszahlengenerierung und bereitet die internen Helfer-Klassen vor.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public DungeonPlan plan(long seed, BoundingBox bounds, DungeonSettings settings, List&lt;RoomTemplate&gt; templates)</code>
            <p>
                Erstellt einen vollständigen Dungeon-Plan basierend auf den übergebenen Parametern.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>seed</code>: Der Seed für die Reproduzierbarkeit der Generierung.</li>
                        <li><code>bounds</code>: Der räumliche Bereich, in dem der Dungeon generiert werden darf.</li>
                        <li><code>settings</code>: Konfigurationseinstellungen (z. B. ob Jigsaw-Generierung oder Loot aktiviert ist).</li>
                        <li><code>templates</code>: Eine Liste von Raumvorlagen für das Jigsaw-System.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Ein validierter <code>DungeonPlan</code> oder <code>null</code>, falls die Generierung fehlschlägt oder die Validierung nicht bestanden wird.</li>
            </ul>
        </li>

        <li>
            <code>private void assignRoomTypes(List&lt;Room&gt; rooms, DungeonSettings settings)</code>
            <p>
                Weist den platzierten Räumen spezifische Rollen zu (z. B. START, BOSS, EXIT, LOOT, ELITE oder COMBAT). Die Zuweisung erfolgt basierend auf der Position (X-Koordinate) und den Wahrscheinlichkeiten in den <code>DungeonSettings</code>.
            </p>
        </li>

        <li>
            <code>private List&lt;RoomEdge&gt; buildEdges(List&lt;Room&gt; rooms)</code>
            <p>
                Berechnet die logischen Verbindungen (Kanten) zwischen den Räumen. Die Methode verwendet einen Algorithmus, der sicherstellt, dass alle Räume miteinander verbunden sind (ähnlich einem Minimum Spanning Tree), und fügt zusätzliche Schleifen hinzu, um den Dungeon weniger linear zu gestalten.
            </p>
        </li>

        <li>
            <code>private double centerDistanceSquared(Room a, Room b)</code>
            <p>
                Hilfsmethode zur Berechnung der quadratischen Distanz zwischen den Mittelpunkten zweier Räume auf der XZ-Ebene.
            </p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RoomPlacer</code> / <code>JigsawRoomPlacer</code>: Zuständig für die physische Positionierung der Räume.</li>
        <li><code>CorridorRouter</code>: Berechnet die Pfade für die Korridore zwischen den Räumen.</li>
        <li><code>DungeonValidator</code>: Überprüft, ob der generierte Plan spielbar und konsistent ist.</li>
        <li><code>DungeonPlan</code>: Das resultierende Datenmodell der Planung.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonSettings.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonSettings.java</h2>

    <p>Die Klasse <code>DungeonSettings</code> fungiert als Datencontainer (Data Object), der alle Konfigurationsparameter für die Generierung eines Dungeons speichert. Sie definiert sowohl strukturelle Eigenschaften (Größe, Räume, Korridore) als auch inhaltliche Aspekte (Mobs, Loot, Wasser-Features) und technische Generierungsmethoden (Jigsaw, WFC).</p>

    <h3>Klasse: DungeonSettings</h3>
    <p>Diese Klasse ist unveränderlich (immutable) konzipiert, wobei alle Felder über den Konstruktor gesetzt und über Getter-Methoden abgefragt werden.</p>

    <h4>Konstruktor</h4>
    <p>Initialisiert ein neues Einstellungs-Objekt mit einer Vielzahl von Parametern:</p>
    <ul>
        <li><code>roomCount</code> (int): Die Gesamtzahl der zu generierenden Räume.</li>
        <li><code>roomMinSize</code> (List&lt;Integer&gt;): Eine Liste mit zwei Werten für die minimale X- und Z-Größe eines Raums.</li>
        <li><code>roomMaxSize</code> (List&lt;Integer&gt;): Eine Liste mit zwei Werten für die maximale X- und Z-Größe eines Raums.</li>
        <li><code>corridorWidth</code> (int): Die Breite der Verbindungsgänge zwischen den Räumen.</li>
        <li><code>wallBlock</code>, <code>floorBlock</code>, <code>doorBlock</code>, <code>lightBlock</code> (Material): Die Bukkit-Materialien für Wände, Böden, Türen und Lichtquellen.</li>
        <li><code>waterEnabled</code> (boolean): Gibt an, ob Wasser-Features generiert werden sollen.</li>
        <li><code>canalChance</code> (double): Wahrscheinlichkeit für das Erscheinen von Kanälen.</li>
        <li><code>floodRoomChance</code> (double): Wahrscheinlichkeit, dass ein Raum geflutet wird.</li>
        <li><code>mobsEnabled</code> (boolean): Bestimmt, ob Monster im Dungeon erscheinen.</li>
        <li><code>mobsMin</code> / <code>mobsMax</code> (int): Bereich für die Anzahl der Mobs pro Raum.</li>
        <li><code>eliteChance</code> (double): Chance, dass ein erscheinender Mob ein Elite-Gegner ist.</li>
        <li><code>bossEnabled</code> (boolean): Legt fest, ob ein Boss-Raum generiert wird.</li>
        <li><code>lootEnabled</code> (boolean): Bestimmt, ob Beutetruhen platziert werden.</li>
        <li><code>lootMin</code> / <code>lootMax</code> (int): Bereich für die Anzahl der Loot-Objekte.</li>
        <li><code>lootTable</code> (String): Der Name der zu verwendenden Beutetabelle.</li>
        <li><code>debugEnabled</code> (boolean): Aktiviert zusätzliche Log-Ausgaben oder Visualisierungen für die Entwicklung.</li>
        <li><code>jigsawEnabled</code> (boolean): Aktiviert den Jigsaw-Algorithmus für die Raumplatzierung.</li>
        <li><code>wfcRoomFillEnabled</code> (boolean): Aktiviert "Wave Function Collapse" (WFC) zur Füllung der Räume.</li>
        <li><code>wfcRoomTheme</code> (String): Das thematische Set für den WFC-Algorithmus.</li>
    </ul>

    <h4>Wichtige Methoden (Getter)</h4>
    <p>Die Klasse bietet Zugriffsmethoden für alle oben genannten Felder. Beispiele für strukturelle Abfragen:</p>
    <ul>
        <li><code>roomMinSizeX()</code> / <code>roomMinSizeZ()</code>: Gibt die minimalen Dimensionen zurück (extrahiert aus der Liste im Konstruktor).</li>
        <li><code>roomMaxSizeX()</code> / <code>roomMaxSizeZ()</code>: Gibt die maximalen Dimensionen zurück.</li>
        <li><code>wfcRoomFillEnabled()</code>: Prüft, ob die WFC-Technik zur Detailgenerierung in Räumen genutzt werden soll.</li>
        <li><code>jigsawEnabled()</code>: Prüft, ob das Jigsaw-System für den strukturellen Aufbau verwendet wird.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonValidator.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/DungeonValidator.java</h2>
    <p>
        Die Klasse <code>DungeonValidator</code> ist eine Hilfskomponente innerhalb des Dungeon-Generierungssystems. 
        Ihre Hauptaufgabe besteht darin, die strukturelle Integrität eines generierten Dungeon-Plans zu überprüfen, 
        bevor dieser finalisiert oder in der Spielwelt platziert wird.
    </p>

    <h3>Klasse: DungeonValidator</h3>
    <p>
        Diese Klasse bietet Methoden zur Validierung der logischen Verbindungen innerhalb eines Dungeons. 
        Sie stellt sicher, dass ein Spieler den Dungeon theoretisch abschließen kann, indem sie die Erreichbarkeit 
        kritischer Räume prüft.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public boolean validate(DungeonPlan plan)</code>
            <p>
                Führt eine vollständige Validierung des übergebenen <code>DungeonPlan</code>-Objekts durch.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>DungeonPlan plan</code> - Der zu validierende Entwurf des Dungeons.</li>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> - Gibt <code>true</code> zurück, wenn der Plan gültig ist, andernfalls <code>false</code>.</li>
                <li>
                    <strong>Validierungsschritte:</strong>
                    <ol>
                        <li>Prüft, ob der Plan überhaupt Räume enthält.</li>
                        <li>Prüft, ob der Boss-Raum vom Start-Raum aus erreichbar ist.</li>
                        <li>Prüft, ob der Ausgangs-Raum vom Boss-Raum aus erreichbar ist.</li>
                    </ol>
                </li>
            </ul>
        </li>
        <li>
            <code>private boolean isReachable(Map&lt;Room, List&lt;Room&gt;&gt; graph, Room start, Room target)</code>
            <p>
                Eine interne Hilfsmethode, die einen Breadth-First Search (BFS) Algorithmus verwendet, um festzustellen, 
                ob ein Pfad zwischen zwei Räumen innerhalb des Dungeon-Graphen existiert.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>Map&lt;Room, List&lt;Room&gt;&gt; graph</code> - Die Adjazenzliste des Dungeon-Layouts.</li>
                        <li><code>Room start</code> - Der Ausgangspunkt der Suche.</li>
                        <li><code>Room target</code> - Der Zielraum, dessen Erreichbarkeit geprüft werden soll.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> - <code>true</code>, wenn ein Pfad existiert, ansonsten <code>false</code>.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/LootPlacer.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/LootPlacer.java</h2>
    <p>
        Die Klasse <code>LootPlacer</code> ist eine Hilfskomponente innerhalb des Dungeon-Generierungssystems. 
        Ihre Hauptaufgabe besteht darin, Beutetruhen (Loot Chests) in dafür vorgesehenen Räumen zu platzieren und diese mit vordefinierten Loot-Tabellen zu verknüpfen.
    </p>

    <h3>Klasse: LootPlacer</h3>
    <p>
        Verwaltet die Logik zur Verteilung von Beute in einem generierten Dungeon-Layout.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>LootPlacer(Random random)</code>: Initialisiert den Placer mit einem spezifischen <code>Random</code>-Objekt, um deterministische oder zufällige Platzierungen zu ermöglichen.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public void placeLoot(Room room, DungeonSettings settings, org.bukkit.World world)</code>
            <p>
                Platziert Truhen innerhalb eines Raumes. Die Methode prüft zunächst, ob Loot in den <code>DungeonSettings</code> aktiviert ist und ob der Raumtyp <code>RoomType.LOOT</code> entspricht.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>room</code>: Das <code>Room</code>-Objekt, in dem der Loot platziert werden soll.</li>
                        <li><code>settings</code>: Die Konfigurationseinstellungen des Dungeons (enthält Min/Max-Anzahl und Loot-Tabellen-Referenzen).</li>
                        <li><code>world</code>: Die Bukkit-Welt, in der die Blöcke gesetzt werden.</li>
                    </ul>
                </li>
            </ul>
        </li>

        <li>
            <code>private LootTable lookupTable(String tableKey, org.bukkit.World world)</code>
            <p>
                Sucht eine Bukkit-<code>LootTable</code> basierend auf einem String-Key. Unterstützt sowohl Minecraft-Standard-Namespaces als auch benutzerdefinierte Keys.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>tableKey</code> (String), <code>world</code> (World).</li>
                <li><strong>Rückgabewert:</strong> Das gefundene <code>LootTable</code>-Objekt oder <code>null</code>.</li>
            </ul>
        </li>

        <li>
            <code>private Location randomPoint(Room room, org.bukkit.World world)</code>
            <p>
                Berechnet eine zufällige <code>Location</code> innerhalb der Grenzen (BoundingBox) eines Raumes. Die Position wird um einen Block vom Rand nach innen versetzt und auf die Bodenhöhe des Raumes (MinY + 1) gesetzt.
            </p>
        </li>

        <li>
            <code>private int nextBetween(int min, int max)</code>
            <p>
                Hilfsmethode zur Generierung einer Zufallszahl innerhalb eines inklusiven Bereichs.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>min</code> (Untergrenze), <code>max</code> (Obergrenze).</li>
                <li><strong>Rückgabewert:</strong> Zufälliger Integer.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/Room.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/Room.java</h2>
    <p>
        Die Klasse <code>Room</code> repräsentiert eine einzelne Raumeinheit innerhalb eines generierten Dungeons. 
        Sie dient als Datencontainer für die räumlichen Abmessungen, den Raumtyp sowie spezifische Interaktionspunkte wie Türen, Spawnpunkte und Jigsaw-Sockets.
    </p>

    <h3>Klasse: Room</h3>
    <p><strong>Beschreibung:</strong> Verwaltet die Geometrie und die Metadaten eines Raums im Dungeon-Layout-System.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>Room(int id, BoundingBox bounds, RoomType type)</code>: 
            Initialisiert einen neuen Raum mit einer eindeutigen ID, seinen räumlichen Grenzen (BoundingBox) und einem spezifischen Raumtyp.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>int id()</code>: 
            Gibt die eindeutige Identifikationsnummer des Raums zurück.
        </li>
        <li>
            <code>BoundingBox bounds()</code>: 
            Gibt die <code>BoundingBox</code> zurück, die das Volumen des Raums in der Welt definiert.
        </li>
        <li>
            <code>void setBounds(BoundingBox bounds)</code>: 
            Aktualisiert die räumlichen Grenzen des Raums.
        </li>
        <li>
            <code>RoomType type()</code>: 
            Gibt den Typ des Raums zurück (z. B. Startraum, Bossraum, Schatzkammer).
        </li>
        <li>
            <code>void setType(RoomType type)</code>: 
            Legt den Typ des Raums fest.
        </li>
        <li>
            <code>List&lt;Location&gt; doorPoints()</code>: 
            Gibt eine Liste von Standorten zurück, an denen Türen oder Durchgänge zu anderen Räumen platziert werden können.
        </li>
        <li>
            <code>List&lt;Location&gt; spawnPoints()</code>: 
            Gibt eine Liste von Standorten zurück, die für das Spawnen von Entities (Mobs oder NPCs) vorgesehen sind.
        </li>
        <li>
            <code>List&lt;RoomSocket&gt; sockets()</code>: 
            Gibt die Liste der <code>RoomSocket</code>-Objekte zurück, die für das Jigsaw-Verbindungssystem verwendet werden.
        </li>
        <li>
            <code>RoomTemplate template()</code>: 
            Gibt das zugrunde liegende <code>RoomTemplate</code> zurück, falls der Raum auf einem vordefinierten Schema basiert.
        </li>
        <li>
            <code>void setTemplate(RoomTemplate template)</code>: 
            Verknüpft den Raum mit einem spezifischen Template.
        </li>
        <li>
            <code>Location center(org.bukkit.World world)</code>: 
            Berechnet den geografischen Mittelpunkt des Raums basierend auf der BoundingBox.
            <br><strong>Parameter:</strong> <code>world</code> - Die Bukkit-Welt, in der die Location erstellt werden soll.
            <br><strong>Rückgabewert:</strong> Eine <code>Location</code>, die auf das Zentrum des Bodens (MinY + 1) zeigt.
        </li>
    </ul>

    <h4>Attribute</h4>
    <ul>
        <li><code>id</code>: Eindeutiger Integer zur Identifizierung.</li>
        <li><code>bounds</code>: Ein <code>BoundingBox</code>-Objekt zur Kollisionsprüfung und Positionsbestimmung.</li>
        <li><code>type</code>: Ein Enum oder eine Klasse vom Typ <code>RoomType</code> zur Kategorisierung.</li>
        <li><code>doorPoints</code>: Liste von Koordinaten für Übergänge.</li>
        <li><code>spawnPoints</code>: Liste von Koordinaten für Spawns.</li>
        <li><code>sockets</code>: Liste von Anschlusspunkten für die prozedurale Generierung.</li>
        <li><code>template</code>: Referenz auf die strukturelle Vorlage des Raums.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/RoomPlacer.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/RoomPlacer.java</h2>
    <p>
        Die Klasse <code>RoomPlacer</code> ist eine zentrale Komponente des Dungeon-Generierungssystems. Ihre Hauptaufgabe besteht darin, Räume innerhalb eines definierten Bereichs (BoundingBox) zufällig zu platzieren, ohne dass diese sich überschneiden. Dabei werden Abstände (Padding) und spezifische Dungeon-Einstellungen berücksichtigt.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Name:</strong> <code>RoomPlacer</code></li>
        <li><strong>Paket:</strong> <code>com.example.rpg.dungeon.layout</code></li>
        <li><strong>Zweck:</strong> Algorithmus zur Platzierung von Räumen in einem dreidimensionalen Raum unter Einhaltung von Kollisionsregeln.</li>
    </ul>

    <h3>Konstruktor</h3>
    <p>
        <code>public RoomPlacer(Random random)</code><br>
        Initialisiert den RoomPlacer mit einem <code>Random</code>-Objekt, um eine deterministische oder zufällige Generierung basierend auf einem Seed zu ermöglichen.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public List&lt;Room&gt; placeRooms(BoundingBox bounds, DungeonSettings settings)</code>
            <p>
                Versucht, die in den <code>settings</code> definierte Anzahl an Räumen innerhalb der <code>bounds</code> zu platzieren.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>bounds</code>: Die äußere Begrenzung des Dungeons.</li>
                        <li><code>settings</code>: Konfigurationsobjekt, das Raumgrößen und die gewünschte Anzahl enthält.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Eine Liste der erfolgreich platzierten <code>Room</code>-Objekte.</li>
                <li><strong>Logik:</strong> Der Algorithmus nutzt eine "Brute-Force"-Annäherung mit einer maximalen Anzahl an Versuchen (Raumanzahl * 15). Er berechnet zufällige Positionen und Dimensionen und prüft diese gegen bereits existierende Räume.</li>
            </ul>
        </li>

        <li>
            <code>private boolean isOverlapping(BoundingBox candidate, List&lt;Room&gt; rooms, int padding)</code>
            <p>
                Prüft, ob ein neuer Raumkandidat mit bereits existierenden Räumen kollidiert.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>candidate</code>: Die BoundingBox des neuen Raums.</li>
                        <li><code>rooms</code>: Liste der bereits platzierten Räume.</li>
                        <li><code>padding</code>: Ein Pufferbereich um den Raum, um sicherzustellen, dass Räume nicht direkt Wand an Wand stehen.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> <code>true</code>, wenn eine Überschneidung vorliegt, ansonsten <code>false</code>.</li>
            </ul>
        </li>

        <li>
            <code>private int nextBetween(int min, int max)</code>
            <p>
                Hilfsmethode zur Generierung einer Zufallszahl innerhalb eines inklusiven Bereichs.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>min</code> (Untergrenze), <code>max</code> (Obergrenze).</li>
                <li><strong>Rückgabewert:</strong> Ein zufälliger Integer-Wert.</li>
            </ul>
        </li>
    </ul>

    <h3>Technische Details</h3>
    <p>
        Die Klasse verwendet die <code>BoundingBox</code>-Klasse der Bukkit-API zur räumlichen Berechnung. Standardmäßig werden neu erstellte Räume mit dem Typ <code>RoomType.COMBAT</code> markiert. Die vertikale Position (Y-Achse) wird aktuell fest auf den Minimalwert der Dungeon-Begrenzung gesetzt, während die Höhe der Räume im Code auf 5 Blöcke fixiert ist.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/RoomSocket.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/RoomSocket.java</h2>

    <p>
        Die Datei <code>RoomSocket.java</code> definiert eine Datenstruktur, die als Verbindungspunkt oder Anker innerhalb eines Dungeon-Raums dient. In der prozeduralen Generierung werden Sockets verwendet, um zu definieren, wo Räume aneinandergefügt werden können oder wo spezifische Objekte platziert werden sollen.
    </p>

    <h3>RoomSocket (Record)</h3>
    <p>
        <code>RoomSocket</code> ist als Java-Record implementiert, was eine kompakte und unveränderliche (immutable) Datenklasse darstellt. Sie dient primär dem Speichern von Metadaten über einen spezifischen Punkt innerhalb eines Raum-Layouts.
    </p>

    <h4>Komponenten (Felder):</h4>
    <ul>
        <li>
            <code>name</code> (String): Der Name oder Bezeichner des Sockets. Dies kann verwendet werden, um den Typ des Anschlusses zu bestimmen (z. B. "Nord-Tür", "Boss-Spawn" oder "Schatz-Anker").
        </li>
        <li>
            <code>location</code> (Location): Ein Objekt vom Typ <code>org.bukkit.Location</code>, das die genauen Koordinaten und die Welt des Sockets innerhalb der Minecraft-Umgebung speichert.
        </li>
    </ul>

    <h4>Zweck im System:</h4>
    <p>
        Innerhalb des <code>com.example.rpg.dungeon.layout</code> Pakets wird dieser Record wahrscheinlich vom <code>DungeonPlanner</code> oder <code>RoomPlacer</code> verwendet, um die logische Verknüpfung von Raumsegmenten zu berechnen. Da es sich um einen Record handelt, bietet er automatisch Implementierungen für <code>equals()</code>, <code>hashCode()</code> und <code>toString()</code>, was ihn ideal für die Verwendung in Kollektionen oder Vergleichen während des Generierungsprozesses macht.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/RoomType.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/RoomType.java</h2>

    <p>Die Datei <code>RoomType.java</code> definiert eine Enumeration (<code>enum</code>), die die verschiedenen Kategorien von Räumen innerhalb des prozeduralen Dungeon-Generierungssystems festlegt. Diese Typen werden vom <code>DungeonPlanner</code> und <code>DungeonBuilder</code> verwendet, um die Logik, das Layout und den Inhalt der einzelnen Räume zu bestimmen.</p>

    <h3>RoomType (Enum)</h3>
    <p>Diese Enumeration dient als Klassifizierung für die Rollen, die ein Raum innerhalb eines Dungeons einnehmen kann.</p>

    <h4>Verfügbare Werte:</h4>
    <ul>
        <li>
            <code>START</code>: Der initiale Einstiegspunkt für Spieler im Dungeon. In der Regel ein sicherer Bereich ohne Gegner.
        </li>
        <li>
            <code>COMBAT</code>: Ein Standard-Kampfraum, der normale Gegner-Spawns enthält.
        </li>
        <li>
            <code>LOOT</code>: Ein Raum, der primär auf Belohnungen ausgelegt ist, beispielsweise durch Schatztruhen oder seltene Gegenstände.
        </li>
        <li>
            <code>ELITE</code>: Ein Raum mit erhöhtem Schwierigkeitsgrad, der stärkere Gegner (Mini-Bosse) oder größere Gegnergruppen enthält.
        </li>
        <li>
            <code>BOSS</code>: Der finale Raum eines Dungeon-Abschnitts, in dem der Hauptboss erscheint.
        </li>
        <li>
            <code>EXIT</code>: Der Endpunkt des Dungeons, der es den Spielern ermöglicht, die Instanz zu verlassen oder in die nächste Ebene vorzudringen.
        </li>
        <li>
            <code>PUZZLE</code>: Ein Raum, der Interaktionen oder Rätsel erfordert, um Fortschritt zu erzielen oder Belohnungen freizuschalten.
        </li>
    </ul>

    <h4>Zusammenhang im System:</h4>
    <p>
        Die <code>RoomType</code>-Werte werden von Klassen wie <code>DungeonPlanner</code> genutzt, um eine logische Abfolge von Herausforderungen zu erstellen (z. B. Sicherstellen, dass ein <code>BOSS</code>-Raum erst nach einer gewissen Anzahl an <code>COMBAT</code>-Räumen erscheint). Zudem nutzt der <code>DungeonDecorator</code> diesen Typ, um spezifische Assets oder Loot-Tabellen zu platzieren.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/SpawnPlacer.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/layout/SpawnPlacer.java</h2>
    <p>
        Die Klasse <code>SpawnPlacer</code> ist für die Platzierung und das Spawnen von Entities (Mobs) innerhalb der generierten Dungeon-Räume verantwortlich. Sie berücksichtigt dabei die Raumtypen sowie die in den <code>DungeonSettings</code> definierten Parameter.
    </p>

    <h3>Klasse: SpawnPlacer</h3>
    <p>Verwaltet die Logik zur Verteilung von Gegnern in einem Dungeon.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>SpawnPlacer(RPGPlugin plugin, Random random)</code>: Initialisiert den Placer mit der Plugin-Instanz (für Zugriff auf Manager) und einem Zufallszahlengenerator für die Positionierung.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public void spawnRoomMobs(Room room, DungeonSettings settings, org.bukkit.World world)</code>
            <p>
                Hauptmethode zum Befüllen eines Raumes mit Mobs. 
                <strong>Logik:</strong>
                <ul>
                    <li>Prüft, ob Mobs in den Einstellungen aktiviert sind.</li>
                    <li>Überspringt Start-, Ausgangs- und reine Schatzräume (<code>LOOT</code>).</li>
                    <li>Bestimmt eine zufällige Anzahl an Mobs basierend auf <code>mobsMin</code> und <code>mobsMax</code>.</li>
                    <li>Unterscheidet beim Spawnen zwischen Raumtypen:
                        <ul>
                            <li><strong>BOSS:</strong> Versucht einen speziellen "boss_zombie" über den <code>MobManager</code> zu laden. Falls nicht vorhanden, wird ein Standard-Zombie gespawnt.</li>
                            <li><strong>ELITE:</strong> Spawnt standardmäßig einen <code>HUSK</code>.</li>
                            <li><strong>Standard:</strong> Spawnt standardmäßig einen <code>ZOMBIE</code>.</li>
                        </ul>
                    </li>
                </ul>
            </p>
        </li>
        <li>
            <code>private Location randomPoint(Room room, org.bukkit.World world)</code>
            <p>
                Berechnet eine zufällige <code>Location</code> innerhalb der Grenzen (BoundingBox) eines Raumes. Die Position wird leicht eingerückt, um Kollisionen mit Wänden zu vermeiden, und auf der Y-Ebene des Bodens platziert.
            </p>
            <p><strong>Parameter:</strong> <code>room</code> (Der Zielraum), <code>world</code> (Die Bukkit-Welt).</p>
            <p><strong>Rückgabewert:</strong> Eine <code>Location</code> im Zentrum eines zufälligen Blocks im Raum.</p>
        </li>
        <li>
            <code>private int nextBetween(int min, int max)</code>
            <p>
                Hilfsmethode zur Generierung einer Zufallszahl innerhalb eines inklusiven Bereichs.
            </p>
            <p><strong>Parameter:</strong> <code>min</code> (Untergrenze), <code>max</code> (Obergrenze).</p>
            <p><strong>Rückgabewert:</strong> Ein zufälliger Ganzzahlwert.</p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Zugriff auf den <code>MobManager</code> und <code>CustomMobListener</code>.</li>
        <li><code>Room</code> / <code>RoomType</code>: Bestimmung der Raumgrenzen und der Art des Raumes.</li>
        <li><code>DungeonSettings</code>: Konfiguration der Spawn-Raten und Aktivierung von Bossen/Mobs.</li>
        <li><code>Bukkit API</code>: Verwendung von <code>Location</code>, <code>World</code> und <code>EntityType</code>.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Direction.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Direction.java</h2>
    <p>
        Diese Datei definiert das Enum <code>Direction</code>, welches die sechs kardinalen Richtungen im dreidimensionalen Raum repräsentiert. 
        Es wird primär im Kontext des <strong>Wave Function Collapse (WFC)</strong> Algorithmus für die Generierung von Dungeons verwendet, 
        um Nachbarschaftsbeziehungen zwischen verschiedenen Mustern oder Räumen zu definieren.
    </p>

    <h3>Enum: Direction</h3>
    <p>Das Enum stellt die folgenden Richtungen zur Verfügung:</p>
    <ul>
        <li><code>UP</code>: Oben (positive Y-Achse)</li>
        <li><code>DOWN</code>: Unten (negative Y-Achse)</li>
        <li><code>NORTH</code>: Norden (negative Z-Achse)</li>
        <li><code>SOUTH</code>: Süden (positive Z-Achse)</li>
        <li><code>EAST</code>: Osten (positive X-Achse)</li>
        <li><code>WEST</code>: Westen (negative X-Achse)</li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong><code>opposite()</code></strong>
            <p>Gibt die entgegengesetzte Richtung der aktuellen Instanz zurück.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> Ein <code>Direction</code>-Objekt, das das logische Gegenstück darstellt (z. B. gibt <code>NORTH.opposite()</code> den Wert <code>SOUTH</code> zurück).</li>
                <li><strong>Implementierung:</strong> Nutzt einen modernen Java <code>switch</code>-Ausdruck zur Bestimmung des Gegenpols.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Pattern.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Pattern.java</h2>
    <p>
        Die Klasse <code>Pattern</code> ist eine fundamentale Komponente des <strong>Wave Function Collapse (WFC)</strong> Algorithmus innerhalb des Dungeon-Generierungssystems. 
        Ein Pattern repräsentiert einen vordefinierten Baustein (einen Satz von Blöcken), der basierend auf seinen "Sockets" (Verbindungsstellen) mit anderen Patterns kombiniert werden kann.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        Ein <code>Pattern</code> speichert Informationen über seine physische Zusammensetzung, seine Wahrscheinlichkeit (Gewichtung) und die Regeln für die Nachbarschaftskompatibilität in verschiedene Richtungen.
    </p>

    <h3>Felder</h3>
    <ul>
        <li><code>id</code> (String): Eine eindeutige Kennung für das Pattern.</li>
        <li><code>blocks</code> (Material[]): Ein Array von Bukkit-Materialien, die den Inhalt des Patterns definieren.</li>
        <li><code>sockets</code> (Map&lt;Direction, String&gt;): Eine Map, die jeder Himmelsrichtung einen Socket-Typ zuweist. Zwei Patterns können nur nebeneinander platziert werden, wenn ihre Sockets an der gemeinsamen Kante zusammenpassen.</li>
        <li><code>weight</code> (double): Die Gewichtung des Patterns, die beeinflusst, wie häufig es im Vergleich zu anderen Patterns bei der Generierung ausgewählt wird.</li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>Pattern(String id, Material[] blocks, double weight)</code>
            <p>Konstruktor zur Initialisierung eines neuen Patterns mit ID, Block-Daten und Gewichtung.</p>
        </li>
        <li>
            <code>id()</code>
            <p>Gibt die eindeutige ID des Patterns zurück. (Rückgabewert: <code>String</code>)</p>
        </li>
        <li>
            <code>blocks()</code>
            <p>Gibt das Array der enthaltenen Materialien zurück. (Rückgabewert: <code>Material[]</code>)</p>
        </li>
        <li>
            <code>weight()</code>
            <p>Gibt die relative Gewichtung für den Auswahlalgorithmus zurück. (Rückgabewert: <code>double</code>)</p>
        </li>
        <li>
            <code>setSocket(Direction direction, String socket)</code>
            <p>Definiert den Socket-Typ für eine spezifische <code>Direction</code>. Dies bestimmt, welche anderen Patterns in dieser Richtung angrenzen dürfen.</p>
        </li>
        <li>
            <code>socket(Direction direction)</code>
            <p>Ruft den Socket-Typ für die angegebene Richtung ab. Standardwert ist <code>"AIR"</code>, falls kein spezifischer Socket gesetzt wurde. (Rückgabewert: <code>String</code>)</p>
        </li>
        <li>
            <code>socketDown()</code>
            <p>Bequemlichkeitsmethode, um den Socket für die Richtung <code>DOWN</code> abzufragen. (Rückgabewert: <code>String</code>)</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/PatternLoader.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/PatternLoader.java</h2>
    <p>
        Die Klasse <code>PatternLoader</code> ist verantwortlich für das Laden und Generieren von Mustern (Patterns), die im Wave Function Collapse (WFC) Algorithmus zur Dungeon-Generierung verwendet werden. Sie definiert die strukturellen Bausteine wie Böden, Wände und Korridore basierend auf konfigurierbaren Themes.
    </p>

    <h3>Klasse: PatternLoader</h3>
    <p>
        Diese Klasse dient als Fabrik für <code>Pattern</code>-Objekte. Sie transformiert Materialdefinitionen aus der Konfiguration in logische Blöcke mit spezifischen "Sockets" (Anschlussstellen), um die Kompatibilität zwischen benachbarten Mustern im WFC-System sicherzustellen.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>PatternLoader(JavaPlugin plugin)</code>: Initialisiert den Loader mit einer Instanz des Plugins, um Zugriff auf die Konfigurationsdateien zu erhalten.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public List&lt;Pattern&gt; loadPatterns(String themeName)</code>
            <p>Erstellt eine Liste vordefinierter Muster für ein bestimmtes Theme (z. B. "crypt").</p>
            <ul>
                <li><strong>Parameter:</strong> <code>themeName</code> - Der Name des zu ladenden Themes.</li>
                <li><strong>Rückgabewert:</strong> Eine Liste von <code>Pattern</code>-Objekten, inklusive Luft, Boden, Wänden und Korridoren.</li>
            </ul>
        </li>
        <li>
            <code>private Material[] fill(Material material)</code>
            <p>Hilfsmethode, die ein Array von 8 Blöcken (ein 2x2x2 Gitter) mit einem einzigen Material füllt.</p>
        </li>
        <li>
            <code>private Material[] floorBlocks(Material floorMaterial)</code>
            <p>Erzeugt ein Block-Gitter, bei dem die untere Ebene (y=0) aus dem Bodenmaterial besteht und die obere Ebene aus Luft.</p>
        </li>
        <li>
            <code>private Material[] wallBlocks(Direction direction, Material wallMaterial)</code>
            <p>Erzeugt ein Block-Gitter für eine Wand in einer bestimmten Himmelsrichtung.</p>
        </li>
        <li>
            <code>private boolean isWallCell(Direction direction, int x, int z)</code>
            <p>Prüft, ob eine spezifische Koordinate innerhalb des 2x2 Gitters basierend auf der Richtung eine Wand sein sollte.</p>
        </li>
        <li>
            <code>private Pattern rotateY(Pattern base, String newId)</code>
            <p>Rotiert ein bestehendes Muster um 90 Grad um die Y-Achse. Dabei werden sowohl die Blockdaten als auch die Sockets für die Himmelsrichtungen angepasst.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>base</code> - Das Ursprungsmuster; <code>newId</code> - Die ID für das neue, rotierte Muster.</li>
                <li><strong>Rückgabewert:</strong> Ein neues, rotiertes <code>Pattern</code>-Objekt.</li>
            </ul>
        </li>
        <li>
            <code>private ThemeMaterials resolveTheme(String themeName)</code>
            <p>Liest die Materialdefinitionen für ein Theme aus der <code>config.yml</code> des Plugins aus.</p>
        </li>
        <li>
            <code>private Material readMaterial(ConfigurationSection section, String path, Material fallback)</code>
            <p>Sicheres Auslesen eines Materials aus der Konfiguration mit Fallback-Option.</p>
        </li>
    </ul>

    <h3>Interner Record: ThemeMaterials</h3>
    <p>
        Ein kompakter Datencontainer, der die Materialien für <code>floor</code>, <code>wall</code> und <code>corridor</code> eines Themes speichert.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/RoomWfcFiller.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/RoomWfcFiller.java</h2>
    <p>
        Die Klasse <code>RoomWfcFiller</code> ist dafür verantwortlich, das Innere eines Dungeon-Raums mithilfe des Wave Function Collapse (WFC) Algorithmus zu füllen. Sie dient als Brücke zwischen der abstrakten Raumplanung und der tatsächlichen Platzierung von Blöcken in der Spielwelt basierend auf vordefinierten Mustern (Patterns).
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Klasse:</strong> <code>RoomWfcFiller</code></li>
        <li><strong>Zweck:</strong> Füllen von Raum-Innenbereichen mit prozedural generierten Blockmustern.</li>
        <li><strong>Abhängigkeiten:</strong> <code>RPGPlugin</code>, <code>WfcGenerator</code>, Bukkit API (World, Location, BoundingBox).</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>fillRoom(World world, Room room, String theme)</code></h4>
    <p>
        Berechnet die Dimensionen des Rauminneren und startet den WFC-Generierungsprozess.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>world</code>: Die Bukkit-Welt, in der der Raum generiert wird.</li>
                <li><code>room</code>: Das <code>Room</code>-Objekt, das die Grenzen (Bounds) definiert.</li>
                <li><code>theme</code>: Ein String, der das zu verwendende Set an Mustern (Theme) bestimmt.</li>
            </ul>
        </li>
        <li><strong>Logik:</strong> 
            Die Methode berechnet den Innenraum (unter Ausschluss der Außenwände), bestimmt die Rastergröße basierend auf einer Zellengröße von 2 Blöcken und ruft den <code>wfcGenerator</code> asynchron auf. Nach erfolgreicher Generierung werden die Muster über einen <code>BukkitRunnable</code> im Haupt-Server-Thread platziert.
        </li>
    </ul>

    <h4><code>placePatterns(World world, Pattern[][][] patterns, int baseX, int baseY, int baseZ, int cellSize)</code></h4>
    <p>
        Iteriert durch das dreidimensionale Array der generierten Muster und initiiert deren Platzierung in der Welt.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>world</code>: Zielwelt.</li>
                <li><code>patterns</code>: Das 3D-Array der vom WFC-Algorithmus ausgewählten Muster.</li>
                <li><code>baseX, baseY, baseZ</code>: Die Startkoordinaten des Innenraums.</li>
                <li><code>cellSize</code>: Die Größe einer einzelnen Zelle (standardmäßig 2).</li>
            </ul>
        </li>
    </ul>

    <h4><code>placePattern(World world, Pattern pattern, int baseX, int baseY, int baseZ)</code></h4>
    <p>
        Platziert die tatsächlichen Blöcke eines einzelnen 2x2x2 Musters in der Welt.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>world</code>: Zielwelt.</li>
                <li><code>pattern</code>: Das <code>Pattern</code>-Objekt, das die Blockdaten enthält.</li>
                <li><code>baseX, baseY, baseZ</code>: Die Weltkoordinaten für den Ursprung dieses spezifischen Musters.</li>
            </ul>
        </li>
        <li><strong>Details:</strong> Die Methode setzt die Blöcke ohne Physik-Updates (<code>applyPhysics = false</code>), um die Performance während der Generierung zu optimieren.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WaveGrid.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WaveGrid.java</h2>
    <p>
        Die Klasse <code>WaveGrid</code> stellt das zentrale Datenmodell für den <strong>Wave Function Collapse (WFC)</strong> Algorithmus dar. 
        Sie verwaltet ein dreidimensionales Gitter, in dem jede Zelle eine Liste von möglichen Mustern (Patterns) enthält, die an dieser Position existieren könnten, 
        sowie den Status, ob die Zelle bereits auf ein einzelnes Muster reduziert (kollabiert) wurde.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Diese Klasse dient als Container für den Zustand des Generierungsprozesses. Zu Beginn enthält jede Zelle alle verfügbaren Muster. 
        Während der Algorithmus fortschreitet, werden die Listen der Möglichkeiten pro Zelle gefiltert, bis idealerweise nur noch ein Muster übrig bleibt.
    </p>

    <h3>Konstruktor</h3>
    <ul>
        <li>
            <code>WaveGrid(int width, int height, int depth, List&lt;Pattern&gt; initial)</code>: 
            Initialisiert ein neues Gitter mit den angegebenen Dimensionen. Jede Zelle im Gitter wird mit einer Kopie der <code>initial</code> Liste (allen verfügbaren Mustern) befüllt.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>possibilities(int x, int y, int z)</code>: 
            Gibt die Liste der aktuell möglichen <code>Pattern</code>-Objekte für die angegebene Koordinate zurück.
            <br><strong>Rückgabewert:</strong> <code>List&lt;Pattern&gt;</code>
        </li>
        <li>
            <code>setPossibilities(int x, int y, int z, List&lt;Pattern&gt; list)</code>: 
            Aktualisiert die Liste der Möglichkeiten für eine spezifische Zelle. Dies wird verwendet, um die Entropie während der Propagation zu verringern.
        </li>
        <li>
            <code>collapsed(int x, int y, int z)</code>: 
            Prüft, ob die Zelle an der angegebenen Position bereits final festgelegt (kollabiert) wurde.
            <br><strong>Rückgabewert:</strong> <code>boolean</code>
        </li>
        <li>
            <code>setCollapsed(int x, int y, int z, boolean value)</code>: 
            Markiert eine Zelle als kollabiert oder hebt diesen Status auf.
        </li>
        <li>
            <code>width()</code>, <code>height()</code>, <code>depth()</code>: 
            Geben die Ausdehnung des Gitters in der jeweiligen Achse (X, Y, Z) zurück.
            <br><strong>Rückgabewert:</strong> <code>int</code>
        </li>
    </ul>

    <h3>Technische Details</h3>
    <p>
        Die Klasse verwendet ein 3D-Array von Listen (<code>List&lt;Pattern&gt;[][][]</code>). Da Java keine generischen Arrays direkt unterstützt, 
        wird die Annotation <code>@SuppressWarnings("unchecked")</code> im Konstruktor verwendet, um die Typumwandlung bei der Array-Initialisierung zu ermöglichen.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WfcGenerator.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WfcGenerator.java</h2>
    <p>
        Die Klasse <code>WfcGenerator</code> implementiert den <strong>Wave Function Collapse (WFC)</strong> Algorithmus zur prozeduralen Generierung von Dungeon-Strukturen. 
        Sie nutzt vordefinierte Muster (Patterns) und deren Nachbarschaftsregeln (Sockets), um ein konsistentes dreidimensionales Gitter zu erzeugen.
    </p>

    <h3>Klasse: WfcGenerator</h3>
    <p>
        Diese Klasse ist das Herzstück der WFC-basierten Generierung. Sie verwaltet den Prozess der Entropie-Minimierung und die Ausbreitung von Einschränkungen (Constraint Propagation).
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>WfcGenerator(JavaPlugin plugin)</code>: Initialisiert den Generator und erstellt eine Instanz des <code>PatternLoader</code>, um die benötigten Muster für die Generierung zu laden.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public CompletableFuture&lt;Pattern[][][]&gt; generate(String themeName, int width, int height, int depth)</code>
            <p>
                Startet den Generierungsprozess asynchron. Versucht bis zu 5 Mal, ein gültiges Gitter zu erzeugen, bevor sie <code>null</code> zurückgibt, falls ein Widerspruch (Contradiction) auftritt.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>themeName</code> (Name des Sets), <code>width</code>, <code>height</code>, <code>depth</code> (Dimensionen des Gitters).</li>
                <li><strong>Rückgabewert:</strong> Ein <code>CompletableFuture</code>, das ein 3D-Array von <code>Pattern</code>-Objekten enthält.</li>
            </ul>
        </li>

        <li>
            <code>private Pattern[][][] runAttempt(int width, int height, int depth, List&lt;Pattern&gt; patterns)</code>
            <p>
                Führt einen einzelnen Generierungsversuch durch. Solange noch nicht alle Zellen kollabiert sind, wird die Zelle mit der niedrigsten Entropie gewählt, ein Muster zugewiesen und die Änderung im Gitter propagiert.
            </p>
        </li>

        <li>
            <code>private int[] findLowestEntropyCell(WaveGrid grid)</code>
            <p>
                Sucht im Gitter nach der Zelle, die die wenigsten verbleibenden Möglichkeiten (niedrigste Entropie) hat, aber noch nicht final festgelegt wurde. Dies minimiert die Wahrscheinlichkeit von Fehlern in späteren Schritten.
            </p>
        </li>

        <li>
            <code>private Pattern pickWeighted(List&lt;Pattern&gt; options)</code>
            <p>
                Wählt aus einer Liste von möglichen Mustern eines basierend auf dessen Gewichtung (Wahrscheinlichkeit) aus.
            </p>
        </li>

        <li>
            <code>private boolean propagate(WaveGrid grid, int startX, int startY, int startZ)</code>
            <p>
                Verbreitet die Einschränkungen einer neu kollabierten Zelle auf ihre Nachbarn. Wenn die Möglichkeiten eines Nachbarn eingeschränkt werden, wird dieser ebenfalls in die Warteschlange zur weiteren Prüfung aufgenommen.
            </p>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>true</code>, wenn die Propagation erfolgreich war; <code>false</code>, wenn ein Widerspruch auftrat (eine Zelle hat keine Möglichkeiten mehr).</li>
            </ul>
        </li>

        <li>
            <code>private boolean compatible(List&lt;Pattern&gt; sourceOptions, Pattern neighbor, Direction direction)</code>
            <p>
                Prüft, ob ein potenzielles Nachbarmuster mit den verbleibenden Möglichkeiten der aktuellen Zelle in einer bestimmten Richtung kompatibel ist. Der Abgleich erfolgt über die <code>socket</code>-Definitionen der Muster.
            </p>
        </li>

        <li>
            <code>private boolean inside(WaveGrid grid, int x, int y, int z)</code>
            <p>Hilfsmethode zur Überprüfung, ob sich die Koordinaten innerhalb der Gittergrenzen befinden.</p>
        </li>

        <li>
            <code>private int offsetX/Y/Z(Direction direction)</code>
            <p>Gibt den Koordinaten-Offset für eine gegebene Himmelsrichtung oder vertikale Richtung zurück.</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/gui/BehaviorTreeEditorGui.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/gui/BehaviorTreeEditorGui.java</h2>

    <p>
        Die Klasse <code>BehaviorTreeEditorGui</code> ist für die Bereitstellung und Anzeige einer grafischen Benutzeroberfläche (GUI) innerhalb von Minecraft verantwortlich, die es Administratoren oder Entwicklern ermöglicht, Verhaltensbäume (Behavior Trees) für NPCs oder Mobs visuell zu konfigurieren.
    </p>

    <h3>Klasse: BehaviorTreeEditorGui</h3>
    <p>
        Diese Klasse fungiert als Controller für das Editor-Inventar. Sie nutzt das Bukkit-API, um ein virtuelles Inventar zu erstellen, das als Menü dient.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>BehaviorTreeEditorGui(RPGPlugin plugin)</code>: Initialisiert die Klasse mit einer Instanz des Haupt-Plugins, um Zugriff auf globale Ressourcen und Manager zu erhalten.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public void open(Player player, String treeName)</code>
            <p>
                Erstellt und öffnet ein Inventar-Menü für den angegebenen Spieler. Das Menü ist auf 27 Slots (3 Reihen) begrenzt und verwendet einen speziellen <code>BehaviorTreeEditorHolder</code>, um Interaktionen im <code>GuiListener</code> identifizieren zu können.
            </p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>player</code>: Das <code>Player</code>-Objekt, dem das Inventar angezeigt werden soll.</li>
                <li><code>treeName</code>: Der Name des Verhaltensbaums, der gerade bearbeitet wird (wird im Titel des Inventars angezeigt).</li>
            </ul>
        </li>
    </ul>

    <h3>Vordefinierte UI-Elemente</h3>
    <p>
        Innerhalb der <code>open</code>-Methode werden verschiedene Items in das Inventar gesetzt, die vordefinierte Verhaltensmuster oder Aktionen repräsentieren:
    </p>
    <ul>
        <li><strong>Notfall-Heilung (Slot 10):</strong> Ein <code>TOTEM_OF_UNDYING</code>, das eine Kombination aus <code>health_below</code>, <code>shield_wall</code> und <code>heal_self</code> Knoten darstellt.</li>
        <li><strong>Fernkampf-Phase (Slot 12):</strong> Eine <code>BLAZE_ROD</code>, die Logik für <code>target_distance_above</code> und <code>cast_skill</code> enthält.</li>
        <li><strong>Nahkampf (Slot 14):</strong> Ein <code>IRON_SWORD</code>, um einen einfachen <code>melee_attack</code> Knoten hinzuzufügen.</li>
        <li><strong>Zurücksetzen (Slot 16):</strong> Eine <code>BARRIER</code>, die dazu dient, den aktuellen Baum zu leeren.</li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Hauptklasse des Plugins.</li>
        <li><code>ItemBuilder</code>: Utility-Klasse zur einfachen Erstellung von Bukkit-Items mit Namen und Beschreibungen (Lore).</li>
        <li><code>Text</code>: Utility zur Verarbeitung von MiniMessage-Formatierungen für farbige Texte.</li>
        <li><code>GuiHolders</code>: Enthält den <code>BehaviorTreeEditorHolder</code> zur Identifizierung des Inventartyps.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiHolders.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiHolders.java</h2>
    <p>
        Die Klasse <code>GuiHolders</code> dient der robusten Identifikation von grafischen Benutzeroberflächen (GUIs) innerhalb des RPG-Plugins. 
        Anstatt sich auf die Titel von Inventaren zu verlassen, die durch Lokalisierung oder Farbcodes fehleranfällig sein können, nutzt dieses System spezifische <code>InventoryHolder</code>-Typen. 
        Jede statische Unterklasse repräsentiert einen bestimmten Menütyp und kann zusätzliche Kontextdaten (wie Seitenzahlen oder IDs) speichern.
    </p>

    <h3>Hauptklasse</h3>
    <ul>
        <li><strong>GuiHolders</strong>: Eine finale Utility-Klasse, die als Container für alle GUI-Holder-Definitionen dient. Der Konstruktor ist privat, da die Klasse nicht instanziiert werden soll.</li>
    </ul>

    <h3>GUI-Holder Komponenten</h3>
    <p>Alle folgenden Klassen implementieren das Interface <code>InventoryHolder</code>. Die Methode <code>getInventory()</code> wirft in allen Fällen eine <code>UnsupportedOperationException</code>, da diese Holder lediglich als Marker-Objekte zur Identifizierung im <code>InventoryClickEvent</code> dienen.</p>

    <h4>Einfache Menü-Marker (Ohne Status)</h4>
    <ul>
        <li><code>PlayerMenuHolder</code>: Hauptmenü für Spieler.</li>
        <li><code>AdminMenuHolder</code>: Allgemeines Administrationsmenü.</li>
        <li><code>DungeonAdminHolder</code>: Verwaltung von Dungeons.</li>
        <li><code>WorldBuildingHolder</code>: Menü für Weltbau-Funktionen.</li>
        <li><code>SkillTreeHolder</code>: Anzeige des Skill-Baums.</li>
        <li><code>BuildingCategoryHolder</code>: Auswahl von Gebäudekategorien.</li>
        <li><code>SchematicMoveHolder</code>: Steuerung zum Verschieben von Schematics.</li>
        <li><code>PermissionsMainHolder</code>: Hauptmenü der Berechtigungsverwaltung.</li>
    </ul>

    <h4>Menü-Marker mit Paginierung (Seitenzahlen)</h4>
    <p>Diese Klassen verfügen über ein Feld <code>page</code> (int) und eine entsprechende Getter-Methode, um durch Listen zu navigieren.</p>
    <ul>
        <li><code>BlockFillHolder</code>, <code>ZoneEditorHolder</code>, <code>NpcEditorHolder</code>, <code>QuestEditorHolder</code>, <code>LootEditorHolder</code>, <code>SkillAdminHolder</code>, <code>ClassAdminHolder</code>, <code>QuestListHolder</code>, <code>QuestLogHolder</code>, <code>SkillListHolder</code>, <code>RoleListHolder</code>, <code>PlayerListHolder</code>, <code>PermissionAuditHolder</code>.</li>
    </ul>

    <h4>Spezialisierte Menü-Marker mit Kontextdaten</h4>
    <ul>
        <li>
            <code>QuestDetailHolder</code>
            <p>Details zu einer Quest. Speichert <code>questId</code> (String), <code>active</code> (boolean) und <code>page</code> (int).</p>
        </li>
        <li>
            <code>BuildingListHolder</code>
            <p>Liste von Gebäuden. Speichert <code>category</code> (String) und <code>page</code> (int).</p>
        </li>
        <li>
            <code>BehaviorTreeEditorHolder</code>
            <p>Editor für KI-Verhaltensbäume. Speichert <code>treeName</code> (String).</p>
        </li>
        <li>
            <code>ShopHolder</code>
            <p>Anzeige eines Shops. Speichert <code>shopId</code> (String).</p>
        </li>
        <li>
            <code>RoleDetailHolder</code>, <code>RoleNodesHolder</code>, <code>RoleParentsHolder</code>
            <p>Verwaltung spezifischer Rollenberechtigungen. Speichern <code>roleKey</code> (String) und teilweise <code>page</code>.</p>
        </li>
        <li>
            <code>PlayerRoleHolder</code>
            <p>Zuweisung von Rollen an Spieler. Speichert die <code>targetId</code> (UUID) des Zielspielers. </p>
        </li>
        <li>
            <code>EnchantingHolder</code>
            <p>Menü für Verzauberungen. Speichert <code>recipeId</code> (String) und <code>page</code> (int).</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiManager.java</h2>

    <p>
        Die Klasse <code>GuiManager</code> ist die zentrale Komponente für die Verwaltung und Anzeige von grafischen Benutzeroberflächen (GUIs) innerhalb des RPG-Plugins. Sie nutzt das Bukkit-Inventar-System, um interaktive Menüs für Spieler und Administratoren zu erstellen.
    </p>

    <h3>Klasse: GuiManager</h3>
    <p><strong>Zweck:</strong> Erstellung, Konfiguration und Öffnung verschiedener Inventar-Menüs (Spieler-Profil, Admin-Tools, Quest-Logs, Shop-Systeme, etc.).</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>GuiManager(...)</code>: Initialisiert den Manager mit allen notwendigen Services (QuestManager, PlayerDataManager, etc.) und NamespacedKeys für die Identifizierung von Items in den GUIs.</li>
    </ul>

    <h4>Öffentliche Methoden (Menü-Steuerung)</h4>
    <ul>
        <li>
            <code>openPlayerMenu(Player player)</code>
            <p>Öffnet das Hauptmenü für Spieler. Zeigt Charakterstatistiken (Level, XP, Klasse, Attribute), Skillpunkte und Links zum Quest-Log oder Fraktionsmenü an.</p>
        </li>
        <li>
            <code>openAdminMenu(Player player)</code>
            <p>Öffnet das Administrations-Dashboard mit Zugriff auf Editoren für Zonen, NPCs, Quests, Loot-Tabellen, Skills und Dungeons.</p>
        </li>
        <li>
            <code>openDungeonAdmin(Player player)</code>
            <p>Verwaltet Dungeon-spezifische Einstellungen wie Jigsaw-Modus, WFC-Raumfüllung und das Speichern/Platzieren von Schematics.</p>
        </li>
        <li>
            <code>openQuestLog(Player player, int page)</code>
            <p>Zeigt dem Spieler seine aktuell aktiven Quests inklusive Fortschrittsbalken und Beschreibungen an.</p>
        </li>
        <li>
            <code>openQuestDetails(Player player, String questId, boolean active, int page)</code>
            <p>Zeigt detaillierte Informationen zu einer spezifischen Quest an und ermöglicht die Annahme der Quest.</p>
        </li>
        <li>
            <code>openShop(Player player, ShopDefinition shop)</code>
            <p>Generiert ein Shop-Inventar basierend auf einer <code>ShopDefinition</code>. Berechnet Preise und zeigt RPG-Items mit Seltenheitsstufen an.</p>
        </li>
        <li>
            <code>openEnchanting(Player player, String selectedRecipeId, int page)</code>
            <p>Öffnet das Verzauberungsmenü, in dem Spieler Items aus ihrer Haupthand mit verfügbaren Rezepten verbessern können.</p>
        </li>
        <li>
            <code>openZoneEditor(Player player, int page)</code>
            <p>Ein paginiertes Menü zur Verwaltung von Welt-Zonen (Level-Bereiche, Schadensmultiplikatoren).</p>
        </li>
        <li>
            <code>openNpcEditor(Player player, int page)</code>
            <p>Ermöglicht das Platzieren und Bearbeiten von NPCs mit verschiedenen Rollen (Händler, Questgeber).</p>
        </li>
        <li>
            <code>openPermissionsMain(Player player)</code>
            <p>Einstiegspunkt für das Berechtigungssystem zur Verwaltung von Rollen, Spieler-Rechten und dem Audit-Log.</p>
        </li>
    </ul>

    <h4>Interne Hilfsmethoden</h4>
    <ul>
        <li><code>questStepLore(Quest quest, QuestProgress progress)</code>: Generiert die Beschreibungszeilen (Lore) für Quest-Schritte basierend auf dem aktuellen Fortschritt des Spielers.</li>
        <li><code>fillMaterials()</code>: Gibt eine sortierte Liste aller verfügbaren Block-Materialien für das Worldbuilding-Tool zurück.</li>
        <li><code>resolveClassName(String classId)</code>: Wandelt eine Klassen-ID in einen lesbaren Anzeigenamen um.</li>
        <li><code>parseRarity(String raw)</code>: Hilfsmethode zum sicheren Parsen von Seltenheitsstufen (Rarity) aus Strings.</li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><strong>Bukkit API:</strong> Zur Manipulation von Inventaren und Items.</li>
        <li><strong>Adventure API (Kyori):</strong> Für die Formatierung von Texten und Komponenten.</li>
        <li><strong>GuiHolders:</strong> Verwendet benutzerdefinierte <code>InventoryHolder</code>, um Klick-Events in den entsprechenden Listenern zuzuordnen.</li>
        <li><strong>ItemBuilder / ItemGenerator:</strong> Utility-Klassen zur schnellen Erstellung komplexer ItemStacks.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/gui/SkillTreeGui.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/gui/SkillTreeGui.java</h2>
    <p>
        Die Klasse <code>SkillTreeGui</code> ist für die Darstellung und Verwaltung der grafischen Benutzeroberfläche (GUI) des Skillbaums verantwortlich. 
        Sie ermöglicht es Spielern, ihre verfügbaren Fähigkeiten einzusehen, deren Voraussetzungen zu prüfen und neue Skills zu erlernen.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Name:</strong> <code>SkillTreeGui</code></li>
        <li><strong>Zweck:</strong> Erstellung und Anzeige eines interaktiven Inventar-Menüs, das die Skill-Struktur des RPG-Systems visualisiert.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>SkillTreeGui(RPGPlugin plugin)</code></h4>
    <p>Der Konstruktor initialisiert die GUI-Klasse mit der Hauptinstanz des Plugins.</p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>plugin</code>: Die Instanz des <code>RPGPlugin</code>, um auf Manager und Datenbanken zuzugreifen.</li>
            </ul>
        </li>
    </ul>

    <h4><code>public void open(Player player)</code></h4>
    <p>
        Öffnet das Skillbaum-Inventar für einen bestimmten Spieler. Diese Methode berechnet das Layout, prüft den Fortschritt des Spielers (gelernte vs. gesperrte Skills) 
        und füllt das Inventar mit entsprechenden Items.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>player</code>: Der Spieler, dem das Menü angezeigt werden soll.</li>
            </ul>
        </li>
        <li><strong>Logik:</strong>
            <ul>
                <li>Erstellt ein Inventar mit 54 Slots (6 Reihen).</li>
                <li>Nutzt den <code>SkillTreeManager</code>, um die Skill-Knoten zu laden.</li>
                <li>Visualisierung: 
                    <ul>
                        <li><code>ENCHANTED_BOOK</code>: Bereits erlernte Skills (Grün).</li>
                        <li><code>BOOK</code>: Freigeschaltete, aber noch nicht gelernte Skills (Gelb).</li>
                        <li><code>BARRIER</code>: Gesperrte Skills, deren Voraussetzungen nicht erfüllt sind (Rot).</li>
                    </ul>
                </li>
                <li>Speichert die Skill-ID in den <code>PersistentDataContainer</code> des Items, um Klicks später verarbeiten zu können.</li>
            </ul>
        </li>
    </ul>

    <h4><code>private Map&lt;String, Integer&gt; layout(SkillTreeManager treeManager)</code></h4>
    <p>
        Berechnet die Position (Slot-Index) jedes Skills innerhalb des Inventars basierend auf der Baumstruktur.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>treeManager</code>: Der Manager, der die hierarchische Struktur der Skills bereitstellt.</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> Eine <code>Map</code>, die Skill-IDs ihren jeweiligen Slot-Nummern im Inventar zuordnet.</li>
        <li><strong>Algorithmus:</strong> Verwendet eine Breitensuche (BFS) mit einer <code>ArrayDeque</code>, um die Ebenen des Baums zu durchlaufen und Zeilen/Spalten zuzuweisen.</li>
    </ul>

    <h4><code>private int depth(SkillTreeManager.SkillNode node)</code></h4>
    <p>
        Hilfsmethode zur Bestimmung der Tiefe eines Knotens im Skillbaum.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>node</code>: Der zu prüfende Skill-Knoten.</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> <code>int</code> - Die Anzahl der Elternknoten bis zur Wurzel (0 für Wurzelknoten).</li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>SkillTreeManager</code>: Liefert die logische Struktur des Baums.</li>
        <li><code>PlayerProfile</code>: Liefert Informationen über die bereits gelernten Skills des Spielers.</li>
        <li><code>ItemBuilder</code>: Hilfsklasse zur komfortablen Erstellung von Bukkit-Items.</li>
        <li><code>Text</code>: Utility zur Verarbeitung von MiniMessage-Formatierungen.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ArenaListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ArenaListener.java</h2>

    <p>
        Die Klasse <code>ArenaListener</code> ist eine Listener-Komponente innerhalb des RPG-Plugins, die speziell für die Handhabung von Ereignissen in Kampf-Arenen zuständig ist. Sie stellt sicher, dass der Tod eines Spielers innerhalb einer Arena kontrolliert abläuft, ohne die üblichen Spielmechaniken (wie Item-Verlust) negativ zu beeinflussen.
    </p>

    <h3>Klasse: ArenaListener</h3>
    <p>
        Implementiert das <code>org.bukkit.event.Listener</code> Interface.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>ArenaListener(RPGPlugin plugin)</code>: 
            Initialisiert den Listener und speichert eine Referenz auf das Haupt-Plugin, um auf den <code>ArenaManager</code> zugreifen zu können.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>onDeath(PlayerDeathEvent event)</code>
            <p>
                Diese Methode wird durch das <code>@EventHandler</code>-Annotation markiert und reagiert auf den Tod eines Spielers.
            </p>
            <strong>Funktionsweise:</strong>
            <ul>
                <li>Setzt <code>setKeepInventory(true)</code>, damit der Spieler seine Gegenstände nach dem Tod behält.</li>
                <li>Löscht alle Drops mit <code>getDrops().clear()</code>, um zu verhindern, dass Items in der Arena liegen bleiben.</li>
                <li>Setzt <code>setKeepLevel(true)</code> und <code>setDroppedExp(0)</code>, damit der Spieler seine Erfahrungspunkte behält und keine XP-Kugeln fallen gelassen werden.</li>
                <li>Ruft <code>plugin.arenaManager().handleDeath(player)</code> auf, um die interne Arena-Logik (z. B. Punktestand, Teleportation oder Rundenende) zu triggern.</li>
            </ul>
            <strong>Parameter:</strong>
            <ul>
                <li><code>PlayerDeathEvent event</code>: Das von Bukkit ausgelöste Event beim Tod eines Spielers.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/BehaviorEditorListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/BehaviorEditorListener.java</h2>
    <p>
        Die Klasse <code>BehaviorEditorListener</code> ist eine Listener-Komponente für das Bukkit-Framework. 
        Ihre Hauptaufgabe besteht darin, Interaktionen innerhalb der grafischen Benutzeroberfläche (GUI) für den 
        Behavior Tree Editor zu verarbeiten. Sie ermöglicht es Administratoren oder Entwicklern, das Verhalten von 
        NPCs oder Mobs dynamisch über ein Inventar-Menü und Chat-Eingaben zu konfigurieren.
    </p>

    <h3>Klassen-Definition</h3>
    <p>
        <code>public class BehaviorEditorListener implements Listener</code>
    </p>
    <ul>
        <li><strong>Zweck:</strong> Abfangen von Inventar-Klicks und Steuerung des Konfigurationsflusses für Verhaltensbäume.</li>
        <li><strong>Abhängigkeiten:</strong> Nutzt den <code>RPGPlugin</code> Kern, den <code>BehaviorTreeManager</code> zur Datenspeicherung und den <code>PromptManager</code> für Benutzereingaben.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4>onClick(InventoryClickEvent event)</h4>
    <p>
        Diese Methode reagiert auf Klicks im Editor-Inventar. Sie validiert zunächst, ob der Klickende ein Spieler ist und ob das geöffnete Inventar zum <code>BehaviorTreeEditorHolder</code> gehört.
    </p>
    <ul>
        <li><strong>Logik:</strong> Basierend auf dem angeklickten Slot werden verschiedene Aktionen ausgeführt:
            <ul>
                <li><code>Slot 10</code>: Startet den Dialog für die Notfall-Heilung.</li>
                <li><code>Slot 12</code>: Startet den Dialog für Fernkampf-Verhalten.</li>
                <li><code>Slot 14</code>: Fügt direkt ein Nahkampf-Template hinzu.</li>
                <li><code>Slot 16</code>: Setzt den gesamten Verhaltensbaum zurück.</li>
            </ul>
        </li>
        <li><strong>Parameter:</strong> <code>InventoryClickEvent event</code> - Das ausgelöste Event.</li>
    </ul>

    <h4>promptEmergency(Player player, String treeName)</h4>
    <p>
        Öffnet eine Eingabeaufforderung im Chat, um eine "Notfall-Heilungs-Sequenz" zu erstellen.
    </p>
    <ul>
        <li><strong>Eingabeformat:</strong> <code>&lt;threshold&gt; &lt;skillId&gt; &lt;healAmount&gt;</code></li>
        <li><strong>Funktionsweise:</strong> Erstellt eine <code>SequenceNode</code>, die prüft, ob das Leben unter einen Schwellenwert fällt, einen Skill auslöst und den Mob heilt.</li>
    </ul>

    <h4>promptRanged(Player player, String treeName)</h4>
    <p>
        Öffnet eine Eingabeaufforderung im Chat, um ein Fernkampf-Verhalten zu definieren.
    </p>
    <ul>
        <li><strong>Eingabeformat:</strong> <code>&lt;distance&gt; &lt;skillId&gt;</code></li>
        <li><strong>Funktionsweise:</strong> Erstellt eine <code>SequenceNode</code>, die prüft, ob das Ziel weit genug entfernt ist, und dann einen entsprechenden Skill (z.B. Pfeilschuss) ausführt.</li>
    </ul>

    <h4>parseDouble(String input, double fallback)</h4>
    <p>
        Eine Hilfsmethode zur sicheren Konvertierung von String-Eingaben in Dezimalzahlen.
    </p>
    <ul>
        <li><strong>Parameter:</strong> 
            <ul>
                <li><code>input</code>: Der zu parsende String.</li>
                <li><code>fallback</code>: Der Standardwert, falls das Parsing fehlschlägt.</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> Die konvertierte <code>double</code> Zahl oder der Fallback-Wert.</li>
    </ul>

    <h3>Verhaltenstypen (Templates)</h3>
    <p>Die Klasse unterstützt die Erstellung folgender Knotenstrukturen im <code>BehaviorTreeManager</code>:</p>
    <ul>
        <li><code>melee_attack</code>: Einfacher Nahkampfangriff.</li>
        <li><code>sequence</code>: Kombinierte Logik (z.B. <code>health_below</code> -> <code>cast_skill</code> -> <code>heal_self</code>).</li>
        <li><code>target_distance_above</code>: Bedingung für Fernkampfangriffe.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/BuildingPlacementListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/BuildingPlacementListener.java</h2>
    <p>
        Die Klasse <code>BuildingPlacementListener</code> ist ein Event-Listener für den Bukkit-Server, der speziell für das Platzieren von Gebäuden innerhalb des RPG-Systems verantwortlich ist. Sie überwacht Spielerinteraktionen und delegiert die Logik für den Bauprozess an den <code>BuildingManager</code>.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Name:</strong> <code>BuildingPlacementListener</code></li>
        <li><strong>Interface:</strong> Implementiert <code>org.bukkit.event.Listener</code></li>
        <li><strong>Zweck:</strong> Abfangen von Rechtsklicks auf Blöcke, um den Platzierungsvorgang von vordefinierten Gebäuden zu starten.</li>
    </ul>

    <h3>Konstruktor</h3>
    <p>
        <code>public BuildingPlacementListener(RPGPlugin plugin)</code>
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>plugin</code> (RPGPlugin): Die Hauptinstanz des Plugins, um Zugriff auf Manager und Dienste (wie Berechtigungen und Gebäudeverwaltung) zu erhalten.</li>
            </ul>
        </li>
    </ul>

    <h3>Methoden</h3>
    
    <h4>onPlace(PlayerInteractEvent event)</h4>
    <p>
        Diese Methode wird aufgerufen, wenn ein Spieler mit der Welt interagiert. Sie prüft die Bedingungen für eine Gebäudeplatzierung.
    </p>
    <ul>
        <li><strong>Annotation:</strong> <code>@EventHandler</code></li>
        <li><strong>Logik:</strong>
            <ul>
                <li>Prüft, ob die Aktion ein Rechtsklick auf einen Block (<code>RIGHT_CLICK_BLOCK</code>) war.</li>
                <li>Validiert, ob der Spieler über die Administrator-Berechtigung (<code>rpg.admin</code>) verfügt.</li>
                <li>Berechnet die Zielposition (ein Block über dem angeklickten Block).</li>
                <li>Ruft <code>plugin.buildingManager().handlePlacement()</code> auf.</li>
                <li>Falls die Platzierung erfolgreich eingeleitet wurde, wird das Event abgebrochen (um Standard-Minecraft-Interaktionen zu verhindern) und dem Spieler eine Bestätigung gesendet.</li>
            </ul>
        </li>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>event</code> (PlayerInteractEvent): Das von Bukkit bereitgestellte Interaktions-Event.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Zugriff auf zentrale Dienste.</li>
        <li><code>BuildingManager</code>: Führt die eigentliche Logik zum Laden und Platzieren von Schematics oder Gebäudestrukturen aus.</li>
        <li><code>PermissionService</code>: Überprüfung der Spielerberechtigungen.</li>
        <li><code>Text</code>: Hilfsklasse zur Formatierung von Chat-Nachrichten (MiniMessage).</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CombatListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CombatListener.java</h2>
    <p>
        Die Klasse <code>CombatListener</code> ist eine zentrale Komponente für die Verarbeitung von Kampfereignissen, Beuteverteilung und Quest-Fortschritten innerhalb des RPG-Systems. Sie implementiert das Bukkit-Interface <code>Listener</code> und reagiert auf verschiedene Spielereignisse wie Schaden, Tod, Blockabbau und Crafting.
    </p>

    <h3>Hauptfunktionen</h3>
    <ul>
        <li><strong>Friendly Fire Schutz:</strong> Verhindert, dass sich Mitglieder derselben Party gegenseitig verletzen.</li>
        <li><strong>Kampf-Log:</strong> Sendet detaillierte Schadensmeldungen an Angreifer und Opfer, sofern diese Funktion für sie aktiviert ist.</li>
        <li><strong>Erfahrungspunkte (XP):</strong> Berechnet und verteilt XP an Spieler oder Party-Mitglieder bei Tötungen, Blockabbau oder Crafting.</li>
        <li><strong>Beutesystem (Loot):</strong> Generiert Beute basierend auf Loot-Tabellen oder zufälligen generischen Drops unter Berücksichtigung des Spielerlevels.</li>
        <li><strong>Quest-Integration:</strong> Aktualisiert den Fortschritt von Quests, wenn bestimmte Entitäten getötet werden.</li>
        <li><strong>Event-Tracking:</strong> Informiert den <code>WorldEventManager</code> über Aktionen wie Kills, Sammeln oder Crafting.</li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>onFriendlyFire(EntityDamageByEntityEvent event)</code>
            <p>Prüft, ob Angreifer und Ziel in derselben Party sind und bricht das Schadensevent gegebenenfalls ab.</p>
        </li>
        <li>
            <code>onCombatLog(EntityDamageByEntityEvent event)</code>
            <p>Sendet Textnachrichten über den verursachten oder erlittenen Schaden an die beteiligten Spieler.</p>
        </li>
        <li>
            <code>onEntityDeath(EntityDeathEvent event)</code>
            <p>Verarbeitet den Tod von Entitäten. Berechnet XP-Verteilung (inkl. XP-Split in Partys), generiert Loot über <code>LootManager</code> oder generische Tabellen und aktualisiert Quest-Fortschritte für alle beteiligten Party-Mitglieder in der Nähe.</p>
        </li>
        <li>
            <code>onBlockBreak(BlockBreakEvent event)</code>
            <p>Gibt dem Spieler XP für das Abbauen von Blöcken und triggert Sammel-Events im <code>WorldEventManager</code>.</p>
        </li>
        <li>
            <code>onCraft(CraftItemEvent event)</code>
            <p>Gibt dem Spieler XP für das Herstellen von Gegenständen und triggert Crafting-Events.</p>
        </li>
        <li>
            <code>resolveAttacker(EntityDamageByEntityEvent event)</code>
            <p>Hilfsmethode, die den verursachenden Spieler ermittelt, auch wenn der Schaden durch ein Projektil (z.B. Pfeil) verursacht wurde.</p>
            <p><strong>Rückgabewert:</strong> Der <code>Player</code>, der den Schaden verursacht hat, oder <code>null</code>.</p>
        </li>
        <li>
            <code>dropGenericLoot(Player killer, EntityDeathEvent event)</code>
            <p>Erzeugt Standard-Beute (Gold und zufällige Ausrüstung), falls keine spezifische Loot-Tabelle für das Monster definiert ist.</p>
        </li>
        <li>
            <code>selectMaterialForLevel(int level)</code>
            <p>Wählt basierend auf dem Level des Spielers einen passenden Material-Pool (Low, Mid, High) für zufällige Drops aus.</p>
        </li>
        <li>
            <code>rollRarity()</code>
            <p>Berechnet die Seltenheit (Rarity) eines Gegenstands basierend auf den definierten Gewichtungen der <code>Rarity</code>-Enum.</p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Hauptinstanz für den Zugriff auf Manager (Party, PlayerData, Loot, Quest, etc.).</li>
        <li><code>PlayerProfile</code>: Speichert und aktualisiert XP, Gold und Attribute des Spielers.</li>
        <li><code>LootTable</code> &amp; <code>LootEntry</code>: Definieren die Wahrscheinlichkeiten und Arten von Gegenständen, die fallen gelassen werden.</li>
        <li><code>WorldEventManager</code>: Verarbeitet globale Statistiken oder Event-Trigger.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CustomMobListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CustomMobListener.java</h2>
    <p>
        Die Klasse <code>CustomMobListener</code> ist eine zentrale Komponente für das Management von benutzerdefinierten RPG-Kreaturen (Mobs). 
        Sie implementiert das Bukkit-<code>Listener</code>-Interface und steuert das Verhalten, die Statusanzeigen (Healthbars), das Loot-System sowie die Skalierung von Attributen innerhalb von Dungeons.
    </p>

    <h3>Hauptklasse: CustomMobListener</h3>
    <p>
        Verwaltet Events und Logiken für benutzerdefinierte Entitäten, einschließlich KI-Verhaltenszyklen und Belohnungssystemen.
    </p>
    <ul>
        <li><strong>Felder:</strong>
            <ul>
                <li><code>mobKey</code>: Ein <code>NamespacedKey</code> zur Identifizierung von Custom Mobs in den persistenten Daten der Entität.</li>
                <li><code>behaviorTasks</code>: Eine Map, die die laufenden KI-Tasks (Behavior Loops) pro Entität speichert.</li>
                <li><code>behaviorContexts</code>: Speichert den Kontext (Ziel, Status) für die Verhaltensbäume der Mobs.</li>
                <li><code>healthBars</code>: Verwaltet die über den Köpfen der Mobs schwebenden <code>TextDisplay</code>-Elemente für die Lebensanzeige.</li>
            </ul>
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>onDamage(EntityDamageByEntityEvent event)</code>
            <p>Passt den ausgehenden Schaden eines Mobs basierend auf seiner <code>MobDefinition</code> und der Dungeon-Skalierung an.</p>
        </li>
        <li>
            <code>onDeath(EntityDeathEvent event)</code>
            <p>
                Wird aufgerufen, wenn ein Custom Mob stirbt. Bereinigt Ressourcen (Healthbars, Tasks), vergibt Erfahrungspunkte (XP) und Gold an den Spieler, 
                triggert Welt-Events und generiert Loot basierend auf Loot-Tabellen oder einem Fallback-System.
            </p>
        </li>
        <li>
            <code>applyDefinition(LivingEntity entity, MobDefinition mob)</code>
            <p>
                Initialisiert eine Entität mit den Werten einer <code>MobDefinition</code>. Setzt Leben, Ausrüstung, persistente IDs und startet den KI-Verhaltenszyklus.
                <strong>Parameter:</strong> <code>entity</code> (Die zu modifizierende Entität), <code>mob</code> (Die Vorlage).
            </p>
        </li>
        <li>
            <code>onMobDamage(EntityDamageEvent event)</code> / <code>onMobHeal(EntityRegainHealthEvent event)</code>
            <p>Aktualisiert die visuelle Healthbar des Mobs, wenn sich dessen Lebenspunkte ändern.</p>
        </li>
        <li>
            <code>startBehaviorLoop(LivingEntity entity, MobDefinition mob)</code>
            <p>
                Startet einen periodischen Scheduler (1 Tick Intervall), der den Verhaltensbaum (Behavior Tree) des Mobs ausführt und Ziele in der Nähe sucht.
            </p>
        </li>
        <li>
            <code>dropFallbackLoot(Player killer, EntityDeathEvent event)</code>
            <p>
                Generiert zufällige Ausrüstung (Schwerter, Rüstung), falls der Mob keine spezifische Loot-Tabelle besitzt. Die Qualität skaliert mit dem Level des Spielers.
            </p>
        </li>
        <li>
            <code>buildHealthText(MobDefinition mob, double health)</code>
            <p>
                Erstellt einen formatierten String mit einem Fortschrittsbalken (ASCII-Art), der den Namen und die aktuellen HP des Mobs darstellt.
                <strong>Rückgabewert:</strong> Ein farbiger String für das <code>TextDisplay</code>.
            </p>
        </li>
    </ul>

    <h3>Hilfsfunktionen</h3>
    <ul>
        <li><code>selectMaterialForLevel(int level)</code>: Wählt passende Item-Materialien (Holz, Eisen, Diamant etc.) basierend auf dem Level aus.</li>
        <li><code>rollRarity()</code>: Berechnet eine zufällige Seltenheit (Rarity) basierend auf deren Gewichtung.</li>
        <li><code>findTarget(LivingEntity entity)</code>: Sucht den nächsten Spieler im Umkreis von 20 Blöcken (400 squared distance).</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/DamageIndicatorListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/DamageIndicatorListener.java</h2>
    <p>
        Die Klasse <code>DamageIndicatorListener</code> ist verantwortlich für die visuelle Darstellung von Schadens- und Heilungswerten direkt in der Spielwelt. 
        Dies geschieht durch das Erzeugen von schwebenden Textanzeigen (<code>TextDisplay</code>), die kurzzeitig über den betroffenen Entitäten erscheinen und nach oben steigen.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Name:</strong> <code>DamageIndicatorListener</code></li>
        <li><strong>Typ:</strong> Listener (Bukkit Event Listener)</li>
        <li><strong>Zweck:</strong> Erzeugung von dynamischen Schadens- und Heilungsindikatoren über Entitäten.</li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>onDamage(EntityDamageEvent event)</code>
            <p>
                Wird ausgelöst, wenn eine Entität Schaden erleidet. Berechnet den finalen Schaden und erzeugt einen roten (physisch) oder türkisen (magisch) Indikator mit dem Text "-[Wert] ❤".
            </p>
        </li>
        <li>
            <code>onRegain(EntityRegainHealthEvent event)</code>
            <p>
                Wird ausgelöst, wenn eine Entität Lebenspunkte regeneriert. Erzeugt einen grünen Indikator mit dem Text "+[Wert] ❤".
            </p>
        </li>
        <li>
            <code>isMagicDamage(EntityDamageEvent.DamageCause cause)</code>
            <p>
                Hilfsmethode zur Bestimmung der Schadensart. Gibt <code>true</code> zurück, wenn die Ursache magischer Natur ist (z. B. Magie, Drachenatem, Wither oder Gift).
            </p>
        </li>
        <li>
            <code>spawnIndicator(Location base, String text, NamedTextColor color)</code>
            <p>
                Kernlogik zum Erstellen der Anzeige.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>base</code>: Der Ursprungsort (Position der Entität).</li>
                        <li><code>text</code>: Der anzuzeigende Text.</li>
                        <li><code>color</code>: Die Farbe des Textes.</li>
                    </ul>
                </li>
                <li><strong>Funktionsweise:</strong> Erstellt ein <code>TextDisplay</code>-Entity, konfiguriert es als Billboard (immer zum Spieler gewandt) und startet einen Scheduler-Task, der die Anzeige langsam nach oben schweben lässt, bevor sie nach 20 Ticks (ca. 1 Sekunde) entfernt wird.</li>
            </ul>
        </li>
        <li>
            <code>offset()</code>
            <p>
                Generiert einen zufälligen Versatzwert, damit mehrere Indikatoren nicht exakt an derselben Stelle erscheinen und sich gegenseitig überlagern.
            </p>
        </li>
    </ul>

    <h3>Technische Details</h3>
    <ul>
        <li><strong>Adventure API:</strong> Nutzt <code>net.kyori.adventure.text.Component</code> für die Textformatierung.</li>
        <li><strong>Entity Display:</strong> Verwendet das moderne <code>TextDisplay</code>-Feature von Minecraft für eine performante und saubere Darstellung ohne Rüstungsständer-Hacks.</li>
        <li><strong>Animation:</strong> Die Aufwärtsbewegung wird über einen <code>runTaskTimer</code> realisiert, der die Position pro Tick um 0.04 Blöcke erhöht.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/GuiListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/GuiListener.java</h2>
    <p>Der <code>GuiListener</code> ist eine zentrale Komponente des RPG-Systems, die für die Verarbeitung aller Interaktionen innerhalb der verschiedenen grafischen Benutzeroberflächen (GUIs) zuständig ist. Er implementiert das Bukkit <code>Listener</code>-Interface und reagiert primär auf Inventar-Klicks.</p>

    <h3>Klasse: GuiListener</h3>
    <p>Diese Klasse verwaltet die Logik für eine Vielzahl von Menüs, darunter Spieler-Menüs, Admin-Editoren, Quest-Logs, Skill-Bäume und Shop-Systeme.</p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>onClick(InventoryClickEvent event)</code>
            <p>Der Haupt-Event-Handler für Klicks in Inventaren. Er identifiziert den Typ des Menüs anhand des <code>InventoryHolder</code> und delegiert die Aktion an die entsprechende Logik (z.B. Öffnen eines Untermenüs, Starten eines Prompts oder Ausführen einer Admin-Aktion).</p>
        </li>
        <li>
            <code>handleShopClick(Player player, Inventory inventory, int slot, ItemStack clicked, GuiHolders.ShopHolder holder, boolean rightClick)</code>
            <p>Verarbeitet Kauf- und Verkaufsvorgänge in Shops. Unterstützt sowohl normale Minecraft-Items als auch spezielle RPG-Items mit Seltenheitsstufen.</p>
        </li>
        <li>
            <code>fillSelection(Player player, Material material)</code>
            <p>Füllt einen mit der "Editor Wand" markierten Bereich (Pos1 bis Pos2) mit einem bestimmten Block-Material.</p>
        </li>
        <li>
            <code>giveWand(Player player)</code>
            <p>Gibt dem Spieler das Editor-Werkzeug (Stick), mit dem Positionen für Zonen oder Schematics markiert werden können.</p>
        </li>
        <li>
            <code>promptSchematicSave(Player player)</code>
            <p>Öffnet einen Eingabedialog zum Speichern des aktuell markierten Bereichs als Schematic-Datei.</p>
        </li>
        <li>
            <code>toggleDungeonSetting(Player player, String path)</code>
            <p>Schaltet Konfigurationseinstellungen für Dungeons (z.B. Jigsaw-Generierung) direkt über das GUI um.</p>
        </li>
    </ul>

    <h3>Unterstützte Menü-Typen (Auszug):</h3>
    <ul>
        <li><strong>PlayerMenu:</strong> Zugriff auf Skills und Quest-Logs für Spieler.</li>
        <li><strong>AdminMenu:</strong> Zentrale Steuerung für Zonen, NPCs, Quests, Loot, Skills und Berechtigungen.</li>
        <li><strong>ZoneEditor:</strong> Erstellen, Bearbeiten und Löschen von RPG-Zonen (Levelbereiche, Multiplikatoren).</li>
        <li><strong>NpcEditor:</strong> Verwaltung von NPCs, deren Rollen (Händler, Questgeber), Dialogen und Standorten.</li>
        <li><strong>QuestEditor:</strong> Definition von Quest-Schritten, Belohnungen und Voraussetzungen.</li>
        <li><strong>SkillAdmin:</strong> Erstellung und Konfiguration von aktiven und passiven Fähigkeiten.</li>
        <li><strong>Permissions:</strong> Verwaltung von Rollen, Vererbung und spezifischen Permission-Nodes für Spieler.</li>
        <li><strong>Enchanting:</strong> Interface für das benutzerdefinierte Verzauberungssystem.</li>
    </ul>

    <h3>Interne Hilfsfunktionen:</h3>
    <p>Die Klasse enthält zahlreiche private Hilfsmethoden (<code>resolve...</code>), um Metadaten aus Items zu extrahieren, die mittels <code>PersistentDataContainer</code> gespeichert wurden. Dies ermöglicht eine zustandslose Identifizierung von Objekten (wie Quest-IDs oder NPC-Keys) innerhalb der GUIs.</p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ItemStatListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ItemStatListener.java</h2>
    <p>
        Die Klasse <code>ItemStatListener</code> ist eine Listener-Komponente für das Bukkit-Framework. 
        Ihre Hauptaufgabe besteht darin, die RPG-Attribute und Set-Boni eines Spielers zu aktualisieren, 
        sobald sich dessen Inventar ändert oder der Spieler den Server betritt.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Name:</strong> <code>ItemStatListener</code></li>
        <li><strong>Interface:</strong> <code>org.bukkit.event.Listener</code></li>
        <li><strong>Zweck:</strong> Überwachung von Spielerereignissen zur dynamischen Neuberechnung von Item-Statistiken.</li>
    </ul>

    <h3>Konstruktor</h3>
    <p>
        <code>public ItemStatListener(RPGPlugin plugin)</code>
    </p>
    <ul>
        <li><strong>Parameter:</strong> <code>RPGPlugin plugin</code> - Die Instanz des Haupt-Plugins, um Zugriff auf die verschiedenen Manager (ItemStatManager, PlayerDataManager, ClassManager) zu erhalten.</li>
    </ul>

    <h3>Event-Handler</h3>
    
    <h4>onInventoryClick</h4>
    <p>
        <code>public void onInventoryClick(InventoryClickEvent event)</code>
    </p>
    <p>
        Wird ausgelöst, wenn ein Spieler in ein Inventar klickt. Da dies oft bedeutet, dass Ausrüstungsgegenstände gewechselt wurden, triggert diese Methode eine asynchrone Aktualisierung der Spielerwerte.
    </p>
    <ul>
        <li><strong>Logik:</strong> 
            <ul>
                <li>Prüft, ob der Akteur ein Spieler ist.</li>
                <li>Führt einen Task im nächsten Server-Tick aus, um sicherzustellen, dass das Item bereits im Slot liegt.</li>
                <li>Ruft <code>updateSetBonus</code> im <code>ItemStatManager</code> auf.</li>
                <li>Wendet die Attribute über das <code>PlayerProfile</code> an, unter Einbeziehung von Item-Stats und Klassen-Definitionen.</li>
            </ul>
        </li>
    </ul>

    <h4>onJoin</h4>
    <p>
        <code>public void onJoin(PlayerJoinEvent event)</code>
    </p>
    <p>
        Wird ausgelöst, wenn ein Spieler dem Server beitritt. Dies stellt sicher, dass die Attribute des Spielers direkt beim Start korrekt berechnet werden.
    </p>
    <ul>
        <li><strong>Logik:</strong> 
            <ul>
                <li>Initialisiert die Set-Boni für den beitretenden Spieler.</li>
                <li>Berechnet die Gesamt-Attribute (Leben, Stärke, etc.) basierend auf der aktuellen Ausrüstung und Klasse neu.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/MobHealthBarListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/MobHealthBarListener.java</h2>
    <p>
        Die Klasse <code>MobHealthBarListener</code> ist verantwortlich für die visuelle Darstellung von Lebensbalken über den Köpfen von Monstern. 
        Sie nutzt das Minecraft <code>TextDisplay</code>-Entity, um dynamische Informationen über die aktuelle und maximale Gesundheit eines Mobs anzuzeigen.
    </p>

    <h3>Klassen-Definition</h3>
    <p>
        <code>public class MobHealthBarListener implements Listener</code>
    </p>
    <ul>
        <li><strong>Zweck:</strong> Überwachung von Gesundheitsänderungen bei Monstern und Verwaltung der zugehörigen Anzeige-Entities.</li>
        <li><strong>Mitglieder:</strong>
            <ul>
                <li><code>healthBars</code>: Eine Map, die die UUID eines Mobs mit seinem aktiven <code>TextDisplay</code> verknüpft.</li>
            </ul>
        </li>
    </ul>

    <h3>Methoden</h3>
    
    <h4>Event-Handler</h4>
    <ul>
        <li>
            <code>onDamage(EntityDamageEvent event)</code>
            <p>Wird ausgelöst, wenn ein Entity Schaden erleidet. Berechnet die verbleibende Gesundheit nach dem Schaden und aktualisiert den Lebensbalken, sofern es sich um ein Monster handelt, das kein "Custom Mob" ist.</p>
        </li>
        <li>
            <code>onRegain(EntityRegainHealthEvent event)</code>
            <p>Wird ausgelöst, wenn ein Entity geheilt wird. Aktualisiert die Anzeige basierend auf der neuen Gesundheitsmenge.</p>
        </li>
        <li>
            <code>onDeath(EntityDeathEvent event)</code>
            <p>Wird beim Tod eines Entities aufgerufen, um das zugehörige <code>TextDisplay</code>-Entity sauber aus der Welt und dem Speicher zu entfernen.</p>
        </li>
    </ul>

    <h4>Interne Logik</h4>
    <ul>
        <li>
            <code>isCustomMob(LivingEntity living)</code>
            <p>Prüft über den <code>PersistentDataContainer</code>, ob es sich um einen speziellen Custom-Mob handelt. Falls ja, wird kein Standard-Lebensbalken angezeigt (da diese oft eigene Logiken besitzen).</p>
        </li>
        <li>
            <code>updateHealthBar(LivingEntity living, double health)</code>
            <p>Sucht nach einem existierenden Lebensbalken. Falls keiner existiert oder dieser ungültig ist, wird <code>attachHealthBar</code> aufgerufen, ansonsten wird nur der Text aktualisiert.</p>
        </li>
        <li>
            <code>attachHealthBar(LivingEntity living, double health)</code>
            <p>Erzeugt ein neues <code>TextDisplay</code>-Entity über dem Mob, konfiguriert die Sichtbarkeit (Billboard, SeeThrough, Shadowed) und setzt es als "Passenger" auf den Mob, damit es sich mit ihm bewegt.</p>
        </li>
        <li>
            <code>removeHealthBar(LivingEntity living)</code>
            <p>Entfernt das Anzeige-Entity sicher aus der Welt und löscht den Eintrag aus der internen Map.</p>
        </li>
        <li>
            <code>buildHealthText(LivingEntity living, double health)</code>
            <p>
                Erstellt den formatierten String für die Anzeige. 
                <strong>Rückgabewert:</strong> Ein String, der den Namen des Mobs, einen farbigen Balken (grün für gefüllt, rot für leer) sowie die numerischen HP-Werte enthält.
                Beispiel: <code>Zombie [||||||||||] 20/20 HP</code>
            </p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcListener.java</h2>
    <p>Die Klasse <code>NpcListener</code> ist eine zentrale Komponente für die Interaktion mit Non-Player Characters (NPCs) in der Spielwelt. Sie verarbeitet Spielerinteraktionen, steuert Dialogsysteme, verwaltet Fraktionsanforderungen und generiert dynamische Händlershops basierend auf der Rolle des NPCs.</p>

    <h3>Hauptklasse: NpcListener</h3>
    <p>Implementiert das <code>Listener</code>-Interface von Bukkit, um auf Spielerereignisse zu reagieren.</p>
    <ul>
        <li><strong>onInteract(PlayerInteractEntityEvent event):</strong> Der Haupteinstiegspunkt für NPC-Interaktionen. Überprüft, ob die angeklickte Entität ein registrierter NPC ist, und löst entsprechende Aktionen wie Dialoge, Quest-Angebote oder das Öffnen von Shops aus.</li>
    </ul>

    <h3>Shop-System und Händlerrollen</h3>
    <p>Die Klasse enthält eine umfangreiche Logik zur Erstellung und Verwaltung von Shops, die auf die spezifische Rolle eines NPCs zugeschnitten sind.</p>
    <ul>
        <li><strong>buildVendorShop(Npc npc, Player player):</strong> Erstellt einen spezialisierten Shop basierend auf der <code>NpcRole</code> (z. B. Waffen-, Rüstungs- oder Rohstoffhändler). Die Preise werden dynamisch anhand des Materials berechnet.</li>
        <li><strong>buildMixedVendorShop(Npc npc, Player player):</strong> Generiert einen Gemischtwarenladen mit zufälligen RPG-Gegenständen. Die Gegenstände erhalten zufällige Seltenheitsgrade (Rarity) und werden an das Level des Spielers angepasst.</li>
        <li><strong>applyFactionDiscount(Npc npc, Player player, ShopDefinition shop):</strong> Berechnet und gewährt Rabatte auf Shop-Preise, basierend auf dem Ruf des Spielers bei der jeweiligen Fraktion des NPCs.</li>
        <li><strong>priceForMaterial(Material material, NpcRole role):</strong> Hilfsmethode zur Berechnung des Basispreises eines Gegenstands unter Berücksichtigung seiner Qualität (z. B. Netherite vs. Holz).</li>
    </ul>

    <h3>Dialog- und Quest-System</h3>
    <p>Verwaltet komplexe Interaktionsbäume und die Vergabe von Aufgaben.</p>
    <ul>
        <li><strong>openDialogue(Player player, Npc npc, String nodeId):</strong> Startet oder führt einen Dialogbaum fort. Berücksichtigt Bedingungen wie Fraktionsruf oder bereits abgeschlossene Quests, um verfügbare Antwortoptionen anzuzeigen.</li>
        <li><strong>openStaticShop(Player player, Npc npc):</strong> Öffnet einen vordefinierten Shop, falls der NPC eine feste <code>shopId</code> besitzt.</li>
    </ul>

    <h3>Material-Listen (Hilfsmethoden)</h3>
    <p>Diese privaten Methoden geben Listen von Materialien zurück, die für die jeweilige Händlerkategorie relevant sind:</p>
    <ul>
        <li><code>weaponMaterials()</code>: Schwerter, Äxte, Bögen, etc.</li>
        <li><code>armorMaterials()</code>: Rüstungsteile aus verschiedenen Materialien.</li>
        <li><code>itemMaterials()</code>: Nahrung, Tränke und Gebrauchsgegenstände.</li>
        <li><code>resourceMaterials()</code>: Erze, Barren und Edelsteine.</li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Zugriff auf Manager-Klassen (NpcManager, FactionManager, QuestManager, etc.).</li>
        <li><code>Npc</code> &amp; <code>NpcRole</code>: Datenmodelle für die NPC-Konfiguration.</li>
        <li><code>PlayerProfile</code>: Speichert spielerspezifische Daten wie Level und Ruf.</li>
        <li><code>Text</code>: Utility zur Formatierung von Chat-Nachrichten (MiniMessage).</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcProtectionListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcProtectionListener.java</h2>

    <p>
        Die Klasse <code>NpcProtectionListener</code> ist eine spezialisierte Listener-Komponente für das Bukkit-Framework. 
        Ihr primärer Zweck ist der Schutz von Nicht-Spieler-Charakteren (NPCs) vor Schaden und feindseligen Interaktionen durch die Spielwelt oder andere Entitäten, ohne auf externe Plugins angewiesen zu sein.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class NpcProtectionListener implements Listener</code>
    </p>
    <p>
        Diese Klasse implementiert das <code>Listener</code>-Interface und registriert Events, die den Status und die Unversehrtheit von NPCs betreffen. Sie nutzt das <code>PersistentDataContainer</code>-System von Bukkit, um NPCs anhand spezifischer Metadaten zu identifizieren.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong><code>NpcProtectionListener(RPGPlugin plugin)</code></strong>
            <p>Konstruktor der Klasse. Erhält eine Instanz des Haupt-Plugins, um Zugriff auf den <code>NpcManager</code> und dessen NamespacedKeys zu erhalten.</p>
        </li>
        <li>
            <strong><code>private boolean isNpc(Entity entity)</code></strong>
            <p>
                Überprüft, ob eine gegebene Entität ein geschützter NPC ist.
                <strong>Parameter:</strong> <code>entity</code> (Die zu prüfende Entität).
                <strong>Rückgabewert:</strong> <code>boolean</code> (Wahr, wenn die Entität den NPC-Key in ihren persistenten Daten besitzt).
            </p>
        </li>
        <li>
            <strong><code>@EventHandler public void onDamage(EntityDamageEvent event)</code></strong>
            <p>
                Verhindert jegliche Art von Schaden an NPCs. Wenn das Ziel des Schadensereignisses als NPC identifiziert wird, wird das Event abgebrochen (cancelled).
            </p>
        </li>
        <li>
            <strong><code>@EventHandler public void onTarget(EntityTargetEvent event)</code></strong>
            <p>
                Verhindert, dass NPCs von anderen Entitäten (z. B. Monstern) als Ziel ausgewählt werden. Dies stellt sicher, dass NPCs nicht in Kämpfe verwickelt werden oder Aggro von Mobs ziehen.
            </p>
        </li>
    </ul>

    <h3>Besondere Hinweise</h3>
    <p>
        Die Klasse verzichtet bewusst auf das Abbrechen von <code>PlayerInteractAtEntityEvent</code>. Dies ermöglicht es Spielern weiterhin, mit NPCs durch Rechtsklick zu interagieren (z. B. um Dialoge zu starten oder Shops zu öffnen), während die physische Unversehrtheit des NPCs gewahrt bleibt.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/PlayerListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/PlayerListener.java</h2>
    <p>
        Die Klasse <code>PlayerListener</code> ist eine zentrale Komponente zur Verwaltung von Spieler-Events innerhalb des RPG-Systems. 
        Sie steuert grundlegende Mechanismen wie das Laden von Profilen beim Betreten des Servers, die Formatierung des Chats, 
        Spezial-Interaktionen mit Editor-Werkzeugen sowie das Verhalten bei Spielertod und Item-Nutzung.
    </p>

    <h3>Klasse: PlayerListener</h3>
    <p><strong>Beschreibung:</strong> Implementiert das <code>Listener</code>-Interface von Bukkit, um auf spielerspezifische Ereignisse zu reagieren.</p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>onJoin(PlayerJoinEvent event)</code>
            <p>Wird aufgerufen, wenn ein Spieler den Server betritt. Der Spieler wird vorübergehend "eingefroren" (freeze), während sein Profil asynchron aus der Datenbank geladen wird. Nach Abschluss des Ladevorgangs werden Attribute angewendet und der Spieler wieder freigegeben.</p>
        </li>
        <li>
            <code>onChat(AsyncPlayerChatEvent event)</code>
            <p>Verarbeitet Chat-Nachrichten. Prüft zuerst, ob der <code>PromptManager</code> eine Eingabe erwartet. Falls nicht, wird die Nachricht formatiert, wobei der RPG-Titel des Spielers (falls vorhanden) vorangestellt wird.</p>
        </li>
        <li>
            <code>onDeath(PlayerDeathEvent event)</code>
            <p>Verhindert den Verlust von Inventar und Erfahrungspunkten beim Tod. Informiert zudem den <code>DungeonManager</code> über das Ableben des Spielers, um Instanz-Logik zu triggern.</p>
        </li>
        <li>
            <code>onWandUse(PlayerInteractEvent event)</code>
            <p>Ermöglicht Administratoren mit der Berechtigung <code>rpg.editor</code> die Nutzung eines "Wands" (Zauberstab, hier ein Stick). Durch Links- oder Rechtsklick auf Blöcke können Positionen (Pos1/Pos2) für Bearbeitungszwecke markiert werden.</p>
        </li>
        <li>
            <code>onUseItem(PlayerInteractEvent event)</code>
            <p>Reagiert auf die Nutzung von Items (Rechtsklick). Es wird geprüft, in welcher Zone sich der Spieler befindet, und das Ereignis an den <code>WorldEventManager</code> zur weiteren Verarbeitung weitergeleitet.</p>
        </li>
        <li>
            <code>freeze(Player player)</code>
            <p><strong>Privat:</strong> Speichert die aktuelle Lauf- und Fluggeschwindigkeit des Spielers und setzt diese auf Null. Macht den Spieler unverwundbar und deaktiviert Kollisionen.</p>
        </li>
        <li>
            <code>unfreeze(Player player)</code>
            <p><strong>Privat:</strong> Stellt die ursprüngliche Geschwindigkeit des Spielers wieder her und reaktiviert Verwundbarkeit sowie Kollisionen.</p>
        </li>
        <li>
            <code>serializeLocation(Location location)</code>
            <p><strong>Privat:</strong> Wandelt ein Bukkit-Location-Objekt in einen speicherbaren String im Format <code>Welt,X,Y,Z</code> um.</p>
        </li>
    </ul>

    <h4>Interne Felder</h4>
    <ul>
        <li><code>walkSpeed</code>: Map zur temporären Speicherung der Laufgeschwindigkeit während des Ladevorgangs.</li>
        <li><code>flySpeed</code>: Map zur temporären Speicherung der Fluggeschwindigkeit während des Ladevorgangs.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ProfessionListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ProfessionListener.java</h2>
    <p>
        Die Klasse <code>ProfessionListener</code> ist eine zentrale Komponente für das Berufe-System des RPG-Plugins. 
        Sie implementiert das Interface <code>Listener</code> von Bukkit und überwacht Spieleraktionen wie das Abbauen von Blöcken 
        und das Herstellen von Gegenständen, um Erfahrungspunkte (XP) zu vergeben und Berufe-Einschränkungen durchzusetzen.
    </p>

    <h3>Klasse: ProfessionListener</h3>
    <p>
        Verwaltet die Interaktionen zwischen Spielern und der Spielwelt in Bezug auf Berufe wie Bergbau (Mining), Kräuterkunde (Herbalism) und Schmiedekunst (Blacksmithing).
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>onBlockBreak(BlockBreakEvent event)</code>
            <p>
                Wird aufgerufen, wenn ein Spieler einen Block abbaut. Diese Methode übernimmt zwei Hauptaufgaben:
            </p>
            <ul>
                <li>
                    <strong>Ressourcen-Knoten (Resource Nodes):</strong> Überprüft, ob der Block ein registrierter Ressourcen-Knoten ist. 
                    Falls ja, wird geprüft, ob der Knoten regeneriert oder ob der Typ korrekt ist. Bei Erfolg wird der Knoten temporär deaktiviert, 
                    die Beute gedroppt und dem Spieler XP im entsprechenden Beruf gutgeschrieben. Nach Ablauf der Respawn-Zeit wird der Block automatisch wiederhergestellt.
                </li>
                <li>
                    <strong>Standard-Abbau:</strong> Falls es kein spezieller Knoten ist, wird geprüft, ob das Material des Blocks in der Konfiguration für 
                    Bergbau oder Kräuterkunde hinterlegt ist, und entsprechend XP vergeben.
                </li>
            </ul>
        </li>
        <li>
            <code>onCraft(CraftItemEvent event)</code>
            <p>
                Wird aufgerufen, wenn ein Spieler einen Gegenstand herstellt.
            </p>
            <ul>
                <li>
                    <strong>Level-Beschränkung:</strong> Prüft, ob der Spieler das erforderliche Level im Beruf "Schmiedekunst" besitzt, um den Gegenstand herzustellen. 
                    Falls nicht, wird das Event abgebrochen.
                </li>
                <li>
                    <strong>XP-Vergabe:</strong> Verleiht dem Spieler XP basierend auf dem hergestellten Gegenstand.
                </li>
                <li>
                    <strong>Gildenhallen-Bonus:</strong> Überprüft, ob sich der Spieler in der Nähe seiner Gildenhalle befindet. 
                    Falls die Gildenhalle über ein Handwerks-Upgrade verfügt, erhält der Spieler zusätzliche Bonus-XP.
                </li>
            </ul>
        </li>
    </ul>

    <h4>Abhängigkeiten</h4>
    <ul>
        <li><code>RPGPlugin</code>: Hauptinstanz des Plugins für den Zugriff auf Manager.</li>
        <li><code>ResourceNodeManager</code>: Verwaltung von speziellen Ressourcen-Knoten in der Welt.</li>
        <li><code>ProfessionManager</code>: Logik für XP-Berechnung und Level-Abfragen.</li>
        <li><code>PlayerDataManager</code>: Zugriff auf das Profil des Spielers.</li>
        <li><code>GuildManager</code>: Überprüfung von Gilden-Boni und Standorten.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/SkillHotbarListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/SkillHotbarListener.java</h2>
    <p>
        Die Klasse <code>SkillHotbarListener</code> ist eine Listener-Komponente für das Bukkit-Framework. 
        Ihre Hauptaufgabe besteht darin, Spielerinteraktionen abzufangen und zu prüfen, ob der Spieler eine Fertigkeit (Skill) über seine Hotbar auslösen möchte.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Name:</strong> <code>SkillHotbarListener</code></li>
        <li><strong>Schnittstellen:</strong> <code>Listener</code></li>
        <li><strong>Zweck:</strong> Überwachung von Rechtsklicks, um an Hotbar-Slots gebundene Skills zu aktivieren.</li>
    </ul>

    <h3>Konstruktor</h3>
    <p>
        <code>public SkillHotbarListener(RPGPlugin plugin)</code>
    </p>
    <ul>
        <li><strong>Parameter:</strong> 
            <ul>
                <li><code>plugin</code> (RPGPlugin): Die Instanz des Haupt-Plugins, um Zugriff auf Manager-Klassen wie den <code>PlayerDataManager</code> und den <code>SkillHotbarManager</code> zu erhalten.</li>
            </ul>
        </li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>onInteract(PlayerInteractEvent event)</code></h4>
    <p>
        Diese Methode wird aufgerufen, wenn ein Spieler eine Interaktion in der Welt ausführt (z. B. Links- oder Rechtsklick).
    </p>
    <ul>
        <li><strong>Annotation:</strong> <code>@EventHandler</code></li>
        <li><strong>Logik:</strong>
            <ul>
                <li>Prüft, ob die Interaktion mit der Haupthand (<code>EquipmentSlot.HAND</code>) durchgeführt wurde.</li>
                <li>Filtert die Aktion so, dass nur Rechtsklicks (auf Luft oder Blöcke) verarbeitet werden.</li>
                <li>Ermittelt den aktuell ausgewählten Hotbar-Slot des Spielers (indexiert von 1 bis 9).</li>
                <li>Ruft das <code>PlayerProfile</code> des Spielers ab.</li>
                <li>Fragt den <code>SkillHotbarManager</code> ab, ob für diesen Slot eine <code>skillId</code> registriert ist.</li>
                <li>Falls eine gültige Skill-ID gefunden wird, wird die Methode <code>plugin.useSkill(player, skillId)</code> aufgerufen, um die Fertigkeit auszuführen.</li>
            </ul>
        </li>
        <li><strong>Parameter:</strong> 
            <ul>
                <li><code>event</code> (PlayerInteractEvent): Das von Bukkit bereitgestellte Event-Objekt.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ZoneListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ZoneListener.java</h2>
    <p>
        Die Klasse <code>ZoneListener</code> ist eine Event-Listener-Komponente für Bukkit/Spigot, die für die Überwachung von Spielerbewegungen in Bezug auf definierte Zonen (Gebiete) verantwortlich ist. Sie steuert Benachrichtigungen beim Betreten/Verlassen von Zonen, wendet Zoneneffekte an und aktualisiert den Fortschritt von Erkundungs-Quests.
    </p>

    <h3>Klassen-Details</h3>
    <ul>
        <li><strong>Name:</strong> <code>ZoneListener</code></li>
        <li><strong>Interface:</strong> Implementiert <code>org.bukkit.event.Listener</code></li>
        <li><strong>Zweck:</strong> Verwaltung von Zonenübergängen und damit verbundenen Spiellogiken.</li>
    </ul>

    <h3>Konstruktor</h3>
    <p>
        <code>public ZoneListener(RPGPlugin plugin)</code><br>
        Initialisiert den Listener mit der Hauptinstanz des Plugins, um Zugriff auf Manager wie den <code>ZoneManager</code> oder <code>PlayerDataManager</code> zu erhalten.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>onMove(PlayerMoveEvent event)</code>
            <p>
                <strong>Beschreibung:</strong> Diese Methode wird bei jeder Bewegung eines Spielers ausgelöst. Sie prüft, ob der Spieler eine Zonengrenze überschritten hat.
            </p>
            <ul>
                <li><strong>Trigger:</strong> <code>PlayerMoveEvent</code></li>
                <li><strong>Logik:</strong> Vergleicht die aktuelle Zone am Zielort (<code>event.getTo()</code>) mit der zuletzt gespeicherten Zone des Spielers. Bei einem Wechsel wird eine Nachricht gesendet und ggf. ein Verlangsamungseffekt (Slow) angewendet, falls die Zone einen <code>slowMultiplier</code> kleiner als 1.0 besitzt.</li>
            </ul>
        </li>
        <li>
            <code>handleExploreQuests(Player player, Zone zone)</code>
            <p>
                <strong>Beschreibung:</strong> Eine private Hilfsmethode, die prüft, ob der Spieler aktive Quests hat, die das Entdecken der aktuellen Zone erfordern.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>player</code>: Der Spieler, der die Zone betreten hat.</li>
                        <li><code>zone</code>: Die betretene Zone.</li>
                    </ul>
                </li>
                <li><strong>Logik:</strong> Iteriert durch alle aktiven Quests des Spielerprofils. Wenn ein Quest-Schritt vom Typ <code>EXPLORE</code> ist und die Ziel-ID mit der Zonen-ID übereinstimmt, wird der Fortschritt erhöht und geprüft, ob die Quest abgeschlossen werden kann.</li>
            </ul>
        </li>
    </ul>

    <h3>Mitglieder / Felder</h3>
    <ul>
        <li><code>plugin</code>: Instanz des <code>RPGPlugin</code> für den Zugriff auf globale Manager.</li>
        <li><code>lastZone</code>: Eine <code>Map</code>, die die <code>UUID</code> des Spielers auf die ID der letzten Zone mappt, in der er sich befand. Dies dient zur Erkennung von Zonenwechseln und verhindert redundante Nachrichten bei Bewegungen innerhalb derselben Zone.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ArenaManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ArenaManager.java</h2>
    <p>Der <code>ArenaManager</code> ist eine zentrale Komponente des RPG-Systems, die für die Verwaltung von PvP-Arenen, die Warteschlange der Spieler und die Berechnung von ELO-Rankings zuständig ist. Er steuert den gesamten Lebenszyklus eines Kampfes, vom Beitritt zur Warteschlange bis hin zur Ergebnisverarbeitung nach einem Tod.</p>

    <h3>Klasse: ArenaManager</h3>
    <p>Diese Klasse verwaltet die Instanzen der Arenen und koordiniert die Matchmaking-Logik.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>ArenaManager(RPGPlugin plugin)</code>: Initialisiert den Manager, lädt die Konfiguration aus der Datei <code>arenas.yml</code> und erstellt Standardwerte, falls die Datei nicht existiert.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>joinQueue(Player player)</code>
            <p>Fügt einen Spieler der PvP-Warteschlange hinzu. Prüft vorher, ob der Spieler bereits in einer Arena oder in der Warteschlange ist. Startet automatisch den Matchmaking-Prozess.</p>
        </li>
        <li>
            <code>removeFromQueue(Player player)</code>
            <p>Entfernt einen Spieler manuell aus der Warteschlange.</p>
        </li>
        <li>
            <code>arenaFor(Player player)</code>
            <p>Gibt ein <code>Optional&lt;Arena&gt;</code> zurück, das die aktuelle Arena des Spielers enthält, falls er sich in einem Kampf befindet.</p>
        </li>
        <li>
            <code>handleDeath(Player loser)</code>
            <p>Verarbeitet den Tod eines Spielers innerhalb einer Arena. Ermittelt den Gewinner und leitet das Ende des Matches ein.</p>
        </li>
        <li>
            <code>topPlayers(int limit)</code>
            <p>Gibt eine Liste der <code>PlayerProfile</code> zurück, sortiert nach deren ELO-Wert absteigend, begrenzt durch das angegebene Limit.</p>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>tryStartMatch()</code>
            <p>Prüft, ob genügend Spieler in der Warteschlange sind (mindestens 2) und ob eine Arena im Status <code>WAITING</code> verfügbar ist. Wenn ja, werden die Spieler teleportiert und der Kampf beginnt.</p>
        </li>
        <li>
            <code>teleportPlayers(Arena arena, Player p1, Player p2)</code>
            <p>Teleportiert beide Kontrahenten an die in der Arena-Konfiguration definierten Startpunkte.</p>
        </li>
        <li>
            <code>endMatch(Arena arena, Player winner, Player loser)</code>
            <p>Beendet den Kampf, berechnet die neuen ELO-Werte mithilfe des <code>EloCalculator</code>, speichert die Spielerprofile und setzt den Arena-Status zurück auf <code>WAITING</code>.</p>
        </li>
        <li>
            <code>other(Arena arena, UUID player)</code>
            <p>Hilfsmethode, um die UUID des Gegners eines Spielers innerhalb einer Arena zu finden.</p>
        </li>
        <li>
            <code>load()</code>
            <p>Lädt die Arena-Definitionen (Koordinaten, Welten, Spawnpunkte) aus der <code>arenas.yml</code>.</p>
        </li>
        <li>
            <code>save()</code>
            <p>Speichert den aktuellen Zustand der Konfiguration physisch auf die Festplatte.</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/AuctionHouseManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/AuctionHouseManager.java</h2>
    <p>Der <code>AuctionHouseManager</code> ist eine zentrale Verwaltungskomponente für das Auktionshaussystem des RPG-Plugins. Er ist verantwortlich für das Laden, Speichern und Verwalten von Auktionsangeboten (<code>AuctionListing</code>) sowie für die Serialisierung von Minecraft-Items in ein persistentes Format.</p>

    <h3>Klasse: AuctionHouseManager</h3>
    <p>Diese Klasse verwaltet die Liste aller aktiven Auktionen und synchronisiert diese mit einer lokalen Konfigurationsdatei (<code>auctions.yml</code>).</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>AuctionHouseManager(JavaPlugin plugin)</code>: Initialisiert den Manager, legt die Datei <code>auctions.yml</code> im Datenordner des Plugins fest und lädt bestehende Auktionen aus der Datei.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>listings()</code>
            <p>Gibt eine Map aller aktuell registrierten Auktionsangebote zurück.</p>
            <strong>Rückgabewert:</strong> <code>Map&lt;String, AuctionListing&gt;</code>
        </li>
        <li>
            <code>getListing(String id)</code>
            <p>Ruft ein spezifisches Auktionsangebot anhand seiner eindeutigen ID ab.</p>
            <strong>Parameter:</strong> <code>id</code> (Die ID der Auktion)
        </li>
        <li>
            <code>addListing(AuctionListing listing)</code>
            <p>Fügt ein neues Auktionsangebot zum System hinzu und speichert es sofort in der Konfigurationsdatei.</p>
            <strong>Parameter:</strong> <code>listing</code> (Das hinzuzufügende AuctionListing-Objekt)
        </li>
        <li>
            <code>removeListing(String id)</code>
            <p>Entfernt ein Auktionsangebot aus dem Speicher und der Konfigurationsdatei.</p>
            <strong>Parameter:</strong> <code>id</code> (Die ID der zu löschenden Auktion)
        </li>
        <li>
            <code>saveListing(AuctionListing listing)</code>
            <p>Überträgt die Daten eines einzelnen Auktionsangebots in die YAML-Konfiguration und führt eine Speicherung auf die Festplatte durch.</p>
        </li>
        <li>
            <code>serializeItem(ItemStack item)</code>
            <p>Konvertiert ein <code>ItemStack</code>-Objekt in einen Base64-kodierten String. Dies wird verwendet, um Items in der YAML-Datei zu speichern.</p>
            <strong>Parameter:</strong> <code>item</code> (Das zu serialisierende Item) | <strong>Rückgabewert:</strong> Base64-String oder <code>null</code> bei Fehlern.
        </li>
        <li>
            <code>deserializeItem(String data)</code>
            <p>Rekonstruiert ein <code>ItemStack</code>-Objekt aus einem Base64-kodierten String.</p>
            <strong>Parameter:</strong> <code>data</code> (Der Base64-String) | <strong>Rückgabewert:</strong> <code>ItemStack</code> oder <code>null</code> bei Fehlern.
        </li>
        <li>
            <code>load()</code>
            <p>Private Hilfsmethode, die alle Auktionsdaten aus der <code>auctions.yml</code> liest und die interne Map initialisiert.</p>
        </li>
        <li>
            <code>save()</code>
            <p>Private Hilfsmethode, die den aktuellen Zustand der <code>YamlConfiguration</code> physisch in der Datei auf der Festplatte speichert.</p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>com.example.rpg.model.AuctionListing</code>: Das Datenmodell für eine Auktion.</li>
        <li><code>org.bukkit.configuration.file.YamlConfiguration</code>: Zur Handhabung der Datenspeicherung im YAML-Format.</li>
        <li><code>org.bukkit.util.io.BukkitObjectInputStream/OutputStream</code>: Zur binären Serialisierung von Minecraft-spezifischen Objekten.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/BehaviorTreeManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/BehaviorTreeManager.java</h2>
    <p>
        Der <code>BehaviorTreeManager</code> ist eine zentrale Komponente zur Verwaltung und dynamischen Erstellung von Verhaltensbäumen (Behavior Trees) für NPCs oder Mobs innerhalb des RPG-Systems. Er ermöglicht das Laden von Verhaltenslogiken aus YAML-Konfigurationsdateien und stellt diese dem Plugin zur Verfügung.
    </p>

    <h3>Klasse: BehaviorTreeManager</h3>
    <p>
        Diese Klasse verwaltet den Lebenszyklus von Verhaltensbäumen, einschließlich des Ladens von der Festplatte, des Parsens der Knotenstruktur und der Bereitstellung von Standardverhalten.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>BehaviorTreeManager(JavaPlugin plugin)</code>: Initialisiert den Manager, erstellt den Ordner <code>behaviors</code> im Plugin-Verzeichnis, generiert bei Bedarf eine Beispielkonfiguration (Skeleton King) und lädt alle vorhandenen Verhaltensbäume.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>getTree(String name)</code>: 
            Sucht einen geladenen Verhaltensbaum anhand seines Namens.
            <ul>
                <li><strong>Parameter:</strong> <code>name</code> - Der Name der YAML-Datei (ohne Endung).</li>
                <li><strong>Rückgabewert:</strong> Der entsprechende <code>BehaviorNode</code> oder ein Standard-Verhaltensbaum, falls der Name nicht gefunden wurde.</li>
            </ul>
        </li>
        <li>
            <code>addTemplate(String treeName, Map&lt;String, Object&gt; template)</code>: 
            Fügt einem bestehenden Baum dynamisch eine neue Verhaltensvorlage als Kindknoten hinzu und speichert die Konfiguration.
        </li>
        <li>
            <code>resetTree(String treeName)</code>: 
            Setzt einen Verhaltensbaum auf einen leeren "Selector"-Zustand zurück.
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>loadAll()</code>: 
            Scannt den Verhaltensordner nach <code>.yml</code> Dateien und transformiert diese in ausführbare <code>BehaviorNode</code>-Strukturen.
        </li>
        <li>
            <code>parseNode(ConfigurationSection section, String fallbackId)</code>: 
            Rekursive Methode, die eine Konfigurationssektion liest und den entsprechenden Knotentyp identifiziert.
        </li>
        <li>
            <code>buildNode(String type, String id, ConfigurationSection section)</code>: 
            Eine Factory-Methode (Switch-Expression), die Instanzen spezifischer Knoten wie <code>MeleeAttackNode</code>, <code>CastSkillNode</code>, <code>FleeNode</code>, etc., basierend auf dem Typ-String erstellt.
        </li>
        <li>
            <code>buildComposite(CompositeNode node, ConfigurationSection section)</code>: 
            Verarbeitet zusammengesetzte Knoten (Selector/Sequence) und fügt ihnen ihre konfigurierten Kindknoten hinzu.
        </li>
        <li>
            <code>defaultTree()</code>: 
            Erstellt einen hartcodierten Standard-Verhaltensbaum (Verfolgen und Nahkampf), falls keine Konfiguration vorliegt.
        </li>
        <li>
            <code>seedSkeletonKing()</code>: 
            Erzeugt eine initiale Beispiel-YAML-Datei für einen Boss-Gegner ("Skeleton King"), um die Syntax der Verhaltensbäume zu demonstrieren.
        </li>
    </ul>

    <h4>Unterstützte Knotentypen in der Konfiguration</h4>
    <ul>
        <li><code>selector</code>: Führt Kinder aus, bis eines Erfolg hat.</li>
        <li><code>sequence</code>: Führt Kinder nacheinander aus, solange sie Erfolg haben.</li>
        <li><code>inverter</code>: Kehrt das Ergebnis des Kindknotens um.</li>
        <li><code>cooldown</code>: Verhindert die Ausführung des Kindknotens für eine bestimmte Zeit.</li>
        <li><code>melee_attack</code>: Führt einen Nahkampfangriff aus.</li>
        <li><code>cast_skill</code>: Aktiviert eine spezifische Fähigkeit (Parameter: <code>skill</code>).</li>
        <li><code>flee</code>: Lässt die Entität fliehen.</li>
        <li><code>heal_self</code>: Heilt die Entität (Parameter: <code>amount</code>).</li>
        <li><code>walk_to_target</code>: Bewegt die Entität zum Ziel.</li>
        <li><code>health_below</code>: Bedingungsknoten (Prüft <code>threshold</code>).</li>
        <li><code>target_distance_above</code>: Bedingungsknoten (Prüft <code>distance</code>).</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/BuildingManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/BuildingManager.java</h2>
    <p>Der <code>BuildingManager</code> ist eine zentrale Komponente zur Verwaltung und Platzierung von Gebäuden und Schematics innerhalb der Spielwelt. Er ermöglicht das Laden von Bauplänen (Sponge Schematics), die Handhabung von mehrstöckigen Gebäuden, die Verwaltung von Möbeln innerhalb dieser Gebäude sowie Funktionen zum Rückgängigmachen (Undo) und Verschieben von Platzierungen.</p>

    <h3>Hauptklasse: BuildingManager</h3>
    <p>Diese Klasse verwaltet die Konfiguration von Gebäuden, den Cache für Schematics und die aktiven Platzierungssitzungen der Spieler.</p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public BuildingManager(RPGPlugin plugin)</code>
            <p>Initialisiert den Manager, lädt die <code>buildings.yml</code> Konfiguration und stellt sicher, dass der Schematics-Ordner existiert.</p>
        </li>
        <li>
            <code>public void beginPlacement(Player player, String buildingId, Transform.Rotation rotation)</code>
            <p>Startet den Platzierungsmodus für ein vordefiniertes Gebäude aus der Konfiguration.</p>
        </li>
        <li>
            <code>public void beginSingleSchematicPlacement(Player player, String schematicName, Transform.Rotation rotation)</code>
            <p>Startet den Platzierungsmodus für eine einzelne Schematic-Datei.</p>
        </li>
        <li>
            <code>public void saveSelectionAsSchematic(Player player, String relativePath, Location pos1, Location pos2)</code>
            <p>Speichert einen ausgewählten Bereich in der Welt als neue Schematic-Datei ab.</p>
        </li>
        <li>
            <code>public boolean handlePlacement(Player player, Location target)</code>
            <p>Verarbeitet den Klick eines Spielers in der Welt, um das ausgewählte Gebäude oder die Schematic an der Zielposition zu platzieren.</p>
        </li>
        <li>
            <code>public void undoLast(Player player)</code>
            <p>Macht die letzte Gebäudeplatzierung des Spielers rückgängig, indem der vorherige Zustand der Blöcke aus dem Undo-Buffer wiederhergestellt wird.</p>
        </li>
        <li>
            <code>public void moveLastPlacement(Player player, int dx, int dy, int dz)</code>
            <p>Verschiebt das zuletzt platzierte Objekt um die angegebenen Koordinaten-Differenzen. Dies geschieht durch ein internes Undo und eine anschließende Neuplatzierung.</p>
        </li>
        <li>
            <code>public Map&lt;BuildingCategory, List&lt;BuildingDefinition&gt;&gt; byCategory()</code>
            <p>Gibt alle geladenen Gebäudedefinitionen gruppiert nach ihren Kategorien zurück.</p>
        </li>
    </ul>

    <h3>Interne Hilfsklassen (Records)</h3>
    <ul>
        <li><code>PlacementSession</code>: Speichert temporär die Daten einer laufenden Platzierung (welches Gebäude, welche Rotation).</li>
        <li><code>PlacementRecord</code>: Hält Informationen über eine abgeschlossene Platzierung fest, um Verschiebungen zu ermöglichen.</li>
        <li><code>PlacementPart</code>: Repräsentiert einen Teil eines Gebäudes (z.B. Basis, Stockwerk oder Möbelstück) inklusive seiner Transformation.</li>
        <li><code>Bounds</code>: Hilfsstruktur zur Berechnung der räumlichen Ausdehnung einer Platzierung.</li>
    </ul>

    <h3>Wichtige interne Funktionen</h3>
    <ul>
        <li><code>loadSchematicAsync(String name)</code>: Lädt Schematics asynchron und nutzt einen <code>ConcurrentHashMap</code> Cache, um die Performance zu optimieren.</li>
        <li><code>prepareArea(...)</code>: Bereitet den Zielbereich vor der Platzierung vor. Dies beinhaltet das Laden von Chunks, das Entfernen von Entities (außer Spielern) und das Leeren von Blöcken (Luft), sofern es sich nicht um unterstützten Untergrund handelt.</li>
        <li><code>pasteBuilding(...)</code>: Die Kernlogik für komplexe Gebäude. Sie berechnet die Anzahl der Stockwerke (basierend auf Zufallswerten in der Definition), platziert Keller, Erdgeschoss, Obergeschosse und Möbelstücke unter Berücksichtigung der Rotation.</li>
        <li><code>clearBlocks(...)</code>: Entfernt vorhandene Blöcke im Zielbereich und speichert deren alten Zustand im <code>UndoBuffer</code>.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ClassManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ClassManager.java</h2>
    <p>Der <code>ClassManager</code> ist eine zentrale Verwaltungskomponente für die verschiedenen Charakterklassen im RPG-System. Er ist verantwortlich für das Laden, Speichern und Bereitstellen von Klassendefinitionen sowie für die Berechnung klassenspezifischer Attributsboni.</p>

    <h3>Klasse: ClassManager</h3>
    <p>Diese Klasse verwaltet die Persistenz von Charakterklassen über eine YAML-Konfigurationsdatei (<code>classes.yml</code>).</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>ClassManager(JavaPlugin plugin)</code>: Initialisiert den Manager, erstellt bei Bedarf die Standardkonfiguration und lädt die vorhandenen Klassendaten aus der Datei.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>getClass(String id)</code>
            <p>Ruft eine spezifische Klassendefinition anhand ihrer ID ab.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>id</code> - Die eindeutige Kennung der Klasse.</li>
                <li><strong>Rückgabewert:</strong> Das entsprechende <code>ClassDefinition</code>-Objekt oder <code>null</code>.</li>
            </ul>
        </li>
        <li>
            <code>classes()</code>
            <p>Gibt eine Map aller registrierten Klassen zurück.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> Eine <code>Map&lt;String, ClassDefinition&gt;</code>.</li>
            </ul>
        </li>
        <li>
            <code>saveClass(ClassDefinition definition)</code>
            <p>Speichert eine einzelne Klassendefinition in der Konfigurationsdatei.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>definition</code> - Das zu speichernde Objekt.</li>
            </ul>
        </li>
        <li>
            <code>saveAll()</code>
            <p>Bereinigt die aktuelle Konfiguration und schreibt alle im Speicher befindlichen Klassen erneut in die Datei.</p>
        </li>
        <li>
            <code>classBonuses(String classId)</code>
            <p>Berechnet die Attributsboni (Stats), die ein Spieler basierend auf seiner gewählten Klasse erhält.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>classId</code> - Die ID der Klasse (z. B. "warrior", "ranger", "mage").</li>
                <li><strong>Rückgabewert:</strong> Eine Map mit <code>RPGStat</code>-Typen und deren jeweiligen Bonuswerten.</li>
            </ul>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li><code>load()</code>: Liest die Klassendaten aus der <code>classes.yml</code> und füllt den internen Cache.</li>
        <li><code>seedDefaults()</code>: Erstellt Standardklassen (Krieger, Ranger, Magier), falls noch keine Konfigurationsdatei existiert.</li>
        <li><code>save()</code>: Führt den eigentlichen Schreibvorgang auf die Festplatte durch und fängt mögliche <code>IOException</code>-Fehler ab.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/CraftingOrderManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/CraftingOrderManager.java</h2>
    <p>
        Der <code>CraftingOrderManager</code> ist eine zentrale Verwaltungskomponente für Handwerksaufträge (Crafting Orders) innerhalb des RPG-Systems. 
        Er ist für das Laden, Speichern und Verwalten von Aufträgen zuständig, die Spieler erstellen können, um Materialien gegen Gold von anderen Spielern oder NPCs fertigen zu lassen.
    </p>

    <h3>Klasse: CraftingOrderManager</h3>
    <p>
        Diese Klasse fungiert als Schnittstelle zwischen dem In-Memory-Speicher der Aufträge und der persistenten Speicherung in einer YAML-Datei.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>CraftingOrderManager(RPGPlugin plugin)</code>: Initialisiert den Manager, legt die Datei <code>crafting_orders.yml</code> im Datenordner des Plugins fest und lädt bestehende Aufträge.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>orders()</code>
            <p>Gibt eine Map aller aktuell geladenen Handwerksaufträge zurück.</p>
            <p><strong>Rückgabewert:</strong> <code>Map&lt;String, CraftingOrder&gt;</code></p>
        </li>
        <li>
            <code>getOrder(String id)</code>
            <p>Sucht einen spezifischen Auftrag anhand seiner eindeutigen ID.</p>
            <p><strong>Parameter:</strong> <code>id</code> - Die ID des gesuchten Auftrags.</p>
            <p><strong>Rückgabewert:</strong> Das <code>CraftingOrder</code>-Objekt oder <code>null</code>, falls nicht gefunden.</p>
        </li>
        <li>
            <code>saveOrder(CraftingOrder order)</code>
            <p>Speichert einen neuen oder aktualisierten Auftrag in der Konfiguration und schreibt diese auf die Festplatte.</p>
            <p><strong>Parameter:</strong> <code>order</code> - Das zu speichernde <code>CraftingOrder</code>-Objekt.</p>
        </li>
        <li>
            <code>removeOrder(String id)</code>
            <p>Entfernt einen Auftrag sowohl aus dem Speicher als auch aus der Konfigurationsdatei.</p>
            <p><strong>Parameter:</strong> <code>id</code> - Die ID des zu löschenden Auftrags.</p>
        </li>
        <li>
            <code>load()</code>
            <p>Private Hilfsmethode, die die <code>crafting_orders.yml</code> ausliest und die <code>orders</code>-Map mit <code>CraftingOrder</code>-Instanzen füllt. Verarbeitet dabei UUIDs für Auftraggeber sowie Material- und Belohnungsinformationen.</p>
        </li>
        <li>
            <code>save()</code>
            <p>Private Hilfsmethode, die den aktuellen Stand der <code>YamlConfiguration</code> physisch in die Datei schreibt. Behandelt <code>IOException</code>-Fehler und gibt Warnungen im Log aus.</p>
        </li>
    </ul>

    <h3>Datenstruktur</h3>
    <p>
        Die Daten werden in der Datei <code>crafting_orders.yml</code> mit folgendem Schema gespeichert:
    </p>
    <ul>
        <li><code>requester</code>: Die UUID des Spielers, der den Auftrag erstellt hat.</li>
        <li><code>material</code>: Der Name des zu fertigenden Materials.</li>
        <li><code>amount</code>: Die gewünschte Anzahl der Gegenstände.</li>
        <li><code>rewardGold</code>: Die Goldbelohnung für den Handwerker.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/DungeonManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/DungeonManager.java</h2>
    <p>Der <code>DungeonManager</code> ist eine zentrale Komponente des RPG-Systems, die für die Verwaltung, Erstellung und den Lebenszyklus von Dungeon-Instanzen verantwortlich ist. Er steuert den Zugriff über Fraktionsvoraussetzungen, verwaltet Warteschlangen (Matchmaking) und regelt die Belohnungen nach Abschluss eines Dungeons.</p>

    <h3>Klasse: DungeonManager</h3>
    <p>Diese Klasse fungiert als Schnittstelle zwischen den Spielern und dem Dungeon-Generierungssystem.</p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public DungeonManager(RPGPlugin plugin)</code>
            <p>Initialisiert den Manager, lädt die Konfiguration für Ein- und Ausgänge und instanziiert den <code>DungeonGenerator</code>.</p>
        </li>
        <li>
            <code>public void enterDungeon(Player player)</code>
            <p>Speichert den aktuellen Standort des Spielers und teleportiert ihn zum globalen Dungeon-Eingang.</p>
        </li>
        <li>
            <code>public void leaveDungeon(Player player)</code>
            <p>Teleportiert den Spieler aus einem Dungeon zurück zu seinem ursprünglichen Standort oder zum definierten Ausgangspunkt.</p>
        </li>
        <li>
            <code>public void generateDungeon(Player player, String theme, List&lt;Player&gt; party)</code>
            <p>Startet die Generierung eines neuen Dungeons basierend auf einem Thema (z. B. "wfc" für Wave Function Collapse). Berechnet die Skalierung basierend auf dem Level der Gruppe und teleportiert alle Mitglieder in die neue Instanz. Instanzen werden automatisch nach 15 Minuten geschlossen.</p>
        </li>
        <li>
            <code>public void closeDungeon(DungeonInstance instance)</code>
            <p>Entlädt und löscht die Welt einer Dungeon-Instanz und entfernt alle Referenzen darauf aus dem Speicher.</p>
        </li>
        <li>
            <code>public void joinQueue(Player player, String theme)</code>
            <p>Fügt einen Spieler der Warteschlange für ein bestimmtes Dungeon-Thema hinzu. Prüft vorher, ob der Spieler die nötigen Fraktionsvoraussetzungen erfüllt und nicht bereits in einer Warteschlange ist.</p>
        </li>
        <li>
            <code>public void leaveQueue(Player player)</code>
            <p>Entfernt einen Spieler aus seiner aktuellen Warteschlange.</p>
        </li>
        <li>
            <code>public void markDeath(Player player)</code>
            <p>Markiert innerhalb einer Instanz, dass ein Tod aufgetreten ist, was den "No-Death"-Bonus für die Gruppe deaktiviert.</p>
        </li>
        <li>
            <code>public void completeDungeon(DungeonInstance instance)</code>
            <p>Verarbeitet den erfolgreichen Abschluss eines Dungeons. Berechnet XP und Gold basierend auf der Skalierung der Instanz und vergibt Boni, falls kein Spieler gestorben ist.</p>
        </li>
        <li>
            <code>public boolean hasFactionAccess(Player player, String theme)</code>
            <p>Prüft in der Konfiguration, ob für ein Thema ein bestimmter Fraktionsruf erforderlich ist und ob der Spieler diesen Rang besitzt.</p>
        </li>
        <li>
            <code>private void tryMatch(String theme)</code>
            <p>Versucht, eine Gruppe aus der Warteschlange zusammenzustellen. Das System sucht nach einer klassischen Rollenverteilung: 1 Tank, 1 Heiler und 2 DPS-Spieler.</p>
        </li>
        <li>
            <code>private double computeScale(List&lt;Player&gt; party)</code>
            <p>Berechnet einen Skalierungsfaktor für die Schwierigkeit und Belohnungen basierend auf dem Durchschnittslevel der Gruppe (ca. +5% Stärke pro Level über 1).</p>
        </li>
        <li>
            <code>public void shutdown()</code>
            <p>Bereinigt beim Ausschalten des Servers alle aktiven Dungeon-Instanzen und löscht deren temporäre Welten.</p>
        </li>
    </ul>

    <h4>Wichtige Felder</h4>
    <ul>
        <li><code>activeInstances</code>: Ordnet Spieler-UUIDs ihren aktuell zugewiesenen Dungeon-Instanzen zu.</li>
        <li><code>queueByTheme</code>: Verwaltet die Wartelisten für die verschiedenen Dungeon-Typen.</li>
        <li><code>returnLocations</code>: Speichert, woher die Spieler kamen, um sie nach dem Dungeon korrekt zurückzuteleportieren.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/EnchantManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/EnchantManager.java</h2>
    <p>Der <code>EnchantManager</code> ist eine zentrale Komponente des RPG-Systems, die für die Verwaltung und Anwendung von Verzauberungen auf Gegenstände zuständig ist. Er lädt Verzauberungsrezepte aus einer Konfigurationsdatei, prüft die Voraussetzungen für Spieler und wendet Status-Upgrades oder Affixe auf Items an.</p>

    <h3>Klassen</h3>
    <ul>
        <li>
            <code>EnchantManager</code>: Die Hauptklasse zur Verwaltung des Verzauberungssystems. Sie nutzt die Bukkit <code>PersistentDataContainer</code> API, um Verzauberungsdaten direkt auf den Items zu speichern.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public EnchantManager(RPGPlugin plugin)</code>
            <p>Konstruktor, der den Manager initialisiert, die <code>enchantments.yml</code> lädt und die notwendigen <code>NamespacedKey</code>-Objekte für die Item-Metadaten erstellt.</p>
        </li>
        <li>
            <code>public Map&lt;String, EnchantmentRecipe&gt; recipes()</code>
            <p>Gibt eine Map aller geladenen Verzauberungsrezepte zurück.</p>
        </li>
        <li>
            <code>public List&lt;EnchantmentRecipe&gt; availableRecipes(Player player, ItemStack target)</code>
            <p>Ermittelt alle Rezepte, die ein Spieler für ein bestimmtes Item aktuell nutzen kann. Prüft dabei das Mindestlevel des Spielers und ob der Ziel-Slot des Items (z.B. Rüstung, Hand) zum Rezept passt.</p>
        </li>
        <li>
            <code>public boolean applyRecipe(Player player, String recipeId)</code>
            <p>Versucht, eine Verzauberung auf ein Item anzuwenden. Diese Methode führt umfangreiche Validierungen durch:</p>
            <ul>
                <li>Existenz des Rezepts.</li>
                <li>Gültigkeit des Ziel-Items (muss ein RPG-Item sein).</li>
                <li>Level-Anforderungen des Spielers.</li>
                <li>Kosten in Gold und Materialien.</li>
            </ul>
            <p>Bei Erfolg werden die Kosten abgezogen, die Item-Metadaten aktualisiert (Stats oder Affixe), die Lore des Items neu generiert und etwaige Spezialeffekte (<code>SkillEffectConfig</code>) ausgelöst.</p>
        </li>
        <li>
            <code>private void load()</code>
            <p>Liest die Verzauberungsdefinitionen aus der <code>enchantments.yml</code> und transformiert sie in <code>EnchantmentRecipe</code>-Objekte.</p>
        </li>
        <li>
            <code>private int applyStatUpgrade(ItemMeta meta, EnchantmentRecipe recipe)</code>
            <p>Erhöht einen spezifischen RPG-Statuswert (z.B. Stärke) auf dem Item dauerhaft um 1 Punkt.</p>
        </li>
        <li>
            <code>private AffixResult applyAffix(ItemMeta meta, EnchantmentRecipe recipe)</code>
            <p>Fügt einem Item ein spezielles Affix (Namenszusatz mit Bonus) hinzu. Verhindert Duplikate und berechnet die damit verbundenen Bonus-Stats.</p>
        </li>
        <li>
            <code>private void applyBaseStatBonus(ItemMeta meta, RPGStat stat, int amount)</code>
            <p>Interne Hilfsmethode, die die rohen Attributwerte in der <code>PersistentDataContainer</code> des Items anpasst (z.B. Erhöhung der Lebenspunkte bei <code>CONSTITUTION</code> oder der Krit-Chance bei <code>DEXTERITY</code>).</p>
        </li>
    </ul>

    <h3>Hilfsstrukturen</h3>
    <ul>
        <li><code>AffixResult</code> (Record): Ein interner Datentyp, der das Ergebnis einer Affix-Anwendung speichert (ob es hinzugefügt wurde, Name des Affix, welcher Stat-Bonus gewährt wurde).</li>
        <li><code>affixStatBonuses</code>: Eine vordefinierte Map, die Affix-Namen (wie "Praezision") bestimmten <code>RPGStat</code>-Werten zuordnet.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/FactionManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/FactionManager.java</h2>
    <p>Der <code>FactionManager</code> ist eine zentrale Verwaltungskomponente für das Fraktionssystem des RPG-Plugins. Er ist verantwortlich für das Laden, Speichern und Verwalten von Fraktionen sowie deren Rängen und Reputationsstufen über eine YAML-Konfigurationsdatei.</p>

    <h3>Klasse: FactionManager</h3>
    <p>Diese Klasse verwaltet die Persistenz von Fraktionsdaten und bietet Methoden zum Abrufen von Fraktionsinformationen basierend auf Spieler-Reputation.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>FactionManager(JavaPlugin plugin)</code>: Initialisiert den Manager, erstellt bei Bedarf eine Standard-Konfigurationsdatei (<code>factions.yml</code>) und lädt die vorhandenen Fraktionen in den Speicher.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>getFaction(String id)</code>: 
            Gibt ein <code>Faction</code>-Objekt basierend auf der ID zurück.
            <br><strong>Rückgabewert:</strong> Die gefundene Fraktion oder <code>null</code>.
        </li>
        <li>
            <code>factions()</code>: 
            Gibt eine Map aller registrierten Fraktionen zurück.
            <br><strong>Rückgabewert:</strong> <code>Map&lt;String, Faction&gt;</code>.
        </li>
        <li>
            <code>getRank(String factionId, int rep)</code>: 
            Ermittelt den passenden Fraktionsrang für einen bestimmten Reputationswert innerhalb einer Fraktion.
            <br><strong>Parameter:</strong> <code>factionId</code> (ID der Fraktion), <code>rep</code> (Reputationspunkte).
            <br><strong>Rückgabewert:</strong> Das <code>FactionRank</code>-Objekt, das dem Reputationswert entspricht.
        </li>
        <li>
            <code>saveFaction(Faction faction)</code>: 
            Speichert eine einzelne Fraktion und ihre Ränge in der Konfigurationsdatei.
        </li>
        <li>
            <code>saveAll()</code>: 
            Bereinigt die aktuelle Konfiguration und speichert alle im Speicher befindlichen Fraktionen erneut ab.
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li><code>load()</code>: Liest alle Fraktionsdaten aus der <code>factions.yml</code> ein und transformiert sie in Java-Objekte.</li>
        <li><code>seedDefaults()</code>: Erstellt eine Standardfraktion ("Abenteurergilde") mit den Rängen <em>Neutral</em>, <em>Freundlich</em> und <em>Ehrfürchtig</em>, falls keine Datei existiert.</li>
        <li><code>serializeRanks(Faction faction)</code>: Konvertiert die Ränge einer Fraktion in eine Liste von Maps für die YAML-Speicherung.</li>
        <li><code>loadRanks(ConfigurationSection section)</code>: Extrahiert die Rang-Informationen aus einer Konfigurationssektion.</li>
        <li><code>save()</code>: Schreibt die <code>YamlConfiguration</code> physisch auf die Festplatte.</li>
        <li><code>mapString / mapInt / mapDouble / mapBool</code>: Hilfsmethoden zum sicheren Auslesen von Werten aus Maps mit Fallback-Werten bei Fehlern oder fehlenden Daten.</li>
    </ul>

    <h3>Datenstruktur in der Konfiguration</h3>
    <p>Die Daten werden in der <code>factions.yml</code> wie folgt strukturiert:</p>
    <pre><code>
fraktions_id:
  name: "Anzeigename"
  ranks:
    - id: "rang_id"
      name: "Rang Name"
      minRep: 0
      shopDiscount: 0.1
      dungeonAccess: true
    </code></pre>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/GuildManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/GuildManager.java</h2>
    <p>Der <code>GuildManager</code> ist eine zentrale Verwaltungskomponente für das Gildensystem des RPG-Plugins. Er ist verantwortlich für das Erstellen, Auflösen und Verwalten von Gilden, die Handhabung von Mitgliedschaften, Rollen, Gildenbanken sowie die Persistenz der Gildedaten in einer YAML-Datei.</p>

    <h3>Klasse: GuildManager</h3>
    <p>Diese Klasse verwaltet den Lebenszyklus von Gilden und deren Interaktionen mit Spielern.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>GuildManager(RPGPlugin plugin)</code>: Initialisiert den Manager, lädt die <code>guilds.yml</code> und stellt die gespeicherten Gilden-Daten wieder her.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>guildById(String id)</code>: 
            Sucht eine Gilde anhand ihrer ID.
            <br><strong>Rückgabewert:</strong> Ein <code>Optional&lt;Guild&gt;</code>.
        </li>
        <li>
            <code>guildFor(UUID member)</code>: 
            Ermittelt die Gilde, in der ein bestimmter Spieler Mitglied ist.
            <br><strong>Rückgabewert:</strong> Ein <code>Optional&lt;Guild&gt;</code>.
        </li>
        <li>
            <code>hallLocation(Guild guild)</code>: 
            Erstellt ein Bukkit-<code>Location</code>-Objekt für das Gildenhaus, falls die Koordinaten und die Welt in der Gilde definiert sind.
            <br><strong>Rückgabewert:</strong> <code>Location</code> oder <code>null</code>.
        </li>
        <li>
            <code>isMember(UUID member)</code>: 
            Prüft, ob ein Spieler Mitglied in irgendeiner Gilde ist.
            <br><strong>Rückgabewert:</strong> <code>boolean</code>.
        </li>
        <li>
            <code>createGuild(String id, String name, Player leader)</code>: 
            Erstellt eine neue Gilde mit der angegebenen ID und dem Namen. Der Ersteller wird automatisch als Anführer (Leader) gesetzt.
        </li>
        <li>
            <code>disbandGuild(Guild guild)</code>: 
            Löscht eine Gilde vollständig, entfernt alle Mitglieder aus der Gilde und aktualisiert deren Spielerprofile.
        </li>
        <li>
            <code>invite(UUID target, String guildId)</code>: 
            Speichert eine ausstehende Einladung für einen Spieler in eine bestimmte Gilde.
        </li>
        <li>
            <code>acceptInvite(UUID playerId)</code>: 
            Verarbeitet die Annahme einer Einladung. Fügt den Spieler der Gilde hinzu und aktualisiert sein Profil.
            <br><strong>Rückgabewert:</strong> Ein <code>Optional&lt;Guild&gt;</code> der beigetretenen Gilde.
        </li>
        <li>
            <code>leaveGuild(UUID member)</code>: 
            Entfernt einen Spieler aus seiner aktuellen Gilde. Falls der Anführer die Gilde verlässt, wird die Gilde aufgelöst.
        </li>
        <li>
            <code>setRole(Guild guild, UUID member, GuildMemberRole role)</code>: 
            Aktualisiert die Rolle eines Mitglieds innerhalb einer Gilde.
        </li>
        <li>
            <code>deposit(Guild guild, int amount)</code>: 
            Zahlt einen Goldbetrag in die Gildenbank ein.
        </li>
        <li>
            <code>withdraw(Guild guild, int amount)</code>: 
            Versucht, einen Goldbetrag von der Gildenbank abzuheben.
            <br><strong>Rückgabewert:</strong> <code>true</code>, wenn genug Gold vorhanden war, sonst <code>false</code>.
        </li>
        <li>
            <code>saveAll()</code>: 
            Speichert alle aktuell geladenen Gilden und deren Daten in die Konfigurationsdatei.
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li><code>load()</code>: Liest alle Gilden, Mitglieder, Rollen, Gildenhaus-Upgrades und Gilden-Quests aus der YAML-Konfiguration ein.</li>
        <li><code>saveGuild(Guild guild)</code>: Serialisiert eine einzelne Gilde in die Konfigurationssektion und stößt den Speichervorgang an.</li>
        <li><code>save()</code>: Schreibt den aktuellen Stand der <code>YamlConfiguration</code> physisch auf die Festplatte.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ItemStatManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ItemStatManager.java</h2>
    <p>Der <code>ItemStatManager</code> ist eine zentrale Komponente zur Verwaltung von RPG-Attributen auf Gegenständen (ItemStacks). Er nutzt den <code>PersistentDataContainer</code> von Bukkit, um statistische Werte wie Stärke, kritische Trefferchance und Lebenspunkte direkt in den Metadaten der Items zu speichern und auszulesen. Zudem verwaltet er Set-Boni und Affixe.</p>

    <h3>Klasse: ItemStatManager</h3>
    <p>Diese Klasse stellt Methoden bereit, um Items mit zufälligen Werten zu generieren, die Lore (Beschreibung) zu aktualisieren und die Gesamtboni eines Spielers basierend auf seiner Ausrüstung zu berechnen.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>ItemStatManager(JavaPlugin plugin)</code>: Initialisiert die <code>NamespacedKey</code>-Objekte, die für den Zugriff auf die persistenten Daten der Items benötigt werden.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>void applyAffixes(ItemStack item)</code>
            <p>Verleiht einem Gegenstand zufällige RPG-Attribute (Stärke, Krit-Chance, Leben) sowie eine Set-Zugehörigkeit. Der Name des Items wird durch zufällige Präfixe und Suffixe (z.B. "Brennendes Schwert der Stärke") angepasst.</p>
        </li>
        <li>
            <code>void updateLore(ItemMeta meta)</code>
            <p>Aktualisiert die Beschreibung (Lore) eines Items basierend auf den im <code>PersistentDataContainer</code> gespeicherten Werten. Zeigt Attribute, Set-Informationen und Verzauberungs-Affixe an.</p>
        </li>
        <li>
            <code>void updateSetBonus(Player player)</code>
            <p>Prüft die Rüstung eines Spielers auf Set-IDs. Wenn mindestens 4 Teile desselben Sets getragen werden, erhält der Spieler einen entsprechenden Trankeffekt (z.B. Feuerschutz für das "Ember"-Set).</p>
        </li>
        <li>
            <code>Map&lt;RPGStat, Integer&gt; collectStatBonuses(Player player)</code>
            <p>Berechnet die Summe aller RPG-Attribute über die gesamte Ausrüstung des Spielers (Haupthand, Nebenhand und Rüstung).</p>
            <ul>
                <li><strong>Rückgabewert:</strong> Eine Map, die jedem <code>RPGStat</code> den summierten Bonuswert zuordnet.</li>
            </ul>
        </li>
        <li>
            <code>NamespacedKey enchantStatKey(RPGStat stat)</code>
            <p>Gibt den spezifischen Schlüssel für ein bestimmtes RPG-Attribut zurück, das durch Verzauberungen hinzugefügt wurde.</p>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li><code>void addStat(Map&lt;RPGStat, Integer&gt; totals, RPGStat stat, int amount)</code>: Hilfsmethode zum sicheren Addieren von Werten in eine Statistik-Map.</li>
        <li><code>String randomFrom(List&lt;String&gt; values)</code>: Wählt ein zufälliges Element aus einer Liste von Strings.</li>
        <li><code>String prettyName(String material)</code>: Formatiert Materialnamen in eine lesbare Form (kleingeschrieben, Unterstriche durch Leerzeichen ersetzt).</li>
    </ul>

    <h4>Definierte Set-Boni</h4>
    <p>Folgende Sets sind aktuell im Code fest hinterlegt:</p>
    <ul>
        <li><code>ember</code>: Verleiht <code>FIRE_RESISTANCE</code> (Feuerresistenz).</li>
        <li><code>guardian</code>: Verleiht <code>DAMAGE_RESISTANCE</code> (Resistenz).</li>
        <li><code>swift</code>: Verleiht <code>SPEED</code> (Schnelligkeit).</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/LootManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/LootManager.java</h2>
    <p>
        Der <code>LootManager</code> ist eine zentrale Komponente des RPG-Systems, die für die Verwaltung, das Laden und das Speichern von Beutetabellen (Loot Tables) verantwortlich ist. 
        Er ermöglicht es, Belohnungen für verschiedene Entitäten (z. B. Mobs) über eine Konfigurationsdatei (<code>loot.yml</code>) zu definieren und zur Laufzeit abzurufen.
    </p>

    <h3>Klasse: LootManager</h3>
    <p>
        Diese Klasse verwaltet die Persistenz von Loot-Daten unter Verwendung der Bukkit-YAML-Konfiguration.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>LootManager(JavaPlugin plugin)</code>: Initialisiert den Manager, lädt die <code>loot.yml</code> aus dem Datenordner des Plugins und erstellt Standardwerte, falls die Datei noch nicht existiert.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public Map&lt;String, LootTable&gt; tables()</code>
            <p>Gibt eine Map aller aktuell geladenen Loot-Tabellen zurück, wobei die ID der Tabelle als Schlüssel dient.</p>
        </li>
        <li>
            <code>public LootTable getTable(String id)</code>
            <p>Sucht eine spezifische Loot-Tabelle anhand ihrer eindeutigen ID.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>id</code> - Die ID der gesuchten Tabelle.</li>
                <li><strong>Rückgabewert:</strong> Die <code>LootTable</code> oder <code>null</code>, falls nicht gefunden.</li>
            </ul>
        </li>
        <li>
            <code>public LootTable getTableFor(String key)</code>
            <p>Sucht eine Loot-Tabelle basierend auf dem Attribut <code>appliesTo</code> (z. B. ein Mob-Typ wie "ZOMBIE").</p>
            <ul>
                <li><strong>Parameter:</strong> <code>key</code> - Der Bezeichner der Entität, für die Loot gesucht wird.</li>
                <li><strong>Rückgabewert:</strong> Die erste passende <code>LootTable</code> oder <code>null</code>.</li>
            </ul>
        </li>
        <li>
            <code>public void saveTable(LootTable table)</code>
            <p>Konvertiert ein <code>LootTable</code>-Objekt in eine YAML-Sektion und speichert die enthaltenen <code>LootEntry</code>-Daten (Material, Chance, Mengen, Seltenheit).</p>
        </li>
        <li>
            <code>public void saveAll()</code>
            <p>Bereinigt die aktuelle Konfiguration und schreibt alle im Speicher befindlichen Tabellen erneut in die Datei.</p>
        </li>
        <li>
            <code>private void load()</code>
            <p>Liest die <code>loot.yml</code> ein, iteriert durch alle Sektionen und transformiert die YAML-Daten in <code>LootTable</code>- und <code>LootEntry</code>-Objekte. Enthält Fallback-Werte für fehlende Datenfelder.</p>
        </li>
        <li>
            <code>private void seedDefaults()</code>
            <p>Erstellt eine initiale Beispiel-Loot-Tabelle für Zombies ("forest_mobs"), um eine korrekte Dateistruktur bei der ersten Ausführung zu gewährleisten.</p>
        </li>
        <li>
            <code>private void save()</code>
            <p>Führt den eigentlichen Schreibvorgang der <code>YamlConfiguration</code> auf die Festplatte aus und fängt mögliche <code>IOException</code>-Fehler ab.</p>
        </li>
    </ul>

    <h3>Datenstruktur in der Konfiguration</h3>
    <p>
        Die Daten werden in folgendem Format gespeichert:
    </p>
    <pre><code>
ID_DER_TABELLE:
  appliesTo: "ENTITY_TYPE"
  entries:
    - material: "MATERIAL_NAME"
      chance: 0.5
      minAmount: 1
      maxAmount: 3
      rarity: "COMMON"
    </code></pre>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/MobManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/MobManager.java</h2>
    <p>
        Der <code>MobManager</code> ist eine zentrale Verwaltungskomponente für benutzerdefinierte Mob-Definitionen innerhalb des RPG-Plugins. 
        Er ist verantwortlich für das Laden, Speichern und Bereitstellen von <code>MobDefinition</code>-Objekten, die aus einer YAML-Konfigurationsdatei (<code>mobs.yml</code>) stammen.
    </p>

    <h3>Klasse: MobManager</h3>
    <p>
        Diese Klasse verwaltet die Lebenszyklen von Mob-Konfigurationen und stellt sicher, dass Standardwerte vorhanden sind, falls keine Konfigurationsdatei existiert.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>MobManager(JavaPlugin plugin)</code>: Initialisiert den Manager, lädt die <code>mobs.yml</code> aus dem Datenordner des Plugins und erstellt Standard-Mobs (Seeding), falls die Datei noch nicht existiert.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>getMob(String id)</code>
            <p>Sucht eine Mob-Definition anhand ihrer eindeutigen ID.</p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>id</code>: Die ID des gesuchten Mobs.</li>
            </ul>
            <strong>Rückgabewert:</strong> Das entsprechende <code>MobDefinition</code>-Objekt oder <code>null</code>, falls nicht gefunden.
        </li>

        <li>
            <code>mobs()</code>
            <p>Gibt eine Map aller aktuell geladenen Mob-Definitionen zurück.</p>
            <strong>Rückgabewert:</strong> Eine <code>Map&lt;String, MobDefinition&gt;</code>.
        </li>

        <li>
            <code>saveMob(MobDefinition mob)</code>
            <p>Speichert eine einzelne Mob-Definition in der Konfigurationsdatei. Dabei werden Attribute wie Name, Typ, Gesundheit, Schaden, Ausrüstung, Skills, XP und Beutetabellen persistiert.</p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>mob</code>: Das zu speichernde <code>MobDefinition</code>-Objekt.</li>
            </ul>
        </li>

        <li>
            <code>saveAll()</code>
            <p>Bereinigt die aktuelle Konfigurationsdatei und schreibt alle im Speicher befindlichen Mob-Definitionen erneut hinein.</p>
        </li>

        <li>
            <code>load()</code>
            <p>Privat. Lädt alle Mob-Definitionen aus der <code>mobs.yml</code> in den internen Speicher. Verwendet Standardwerte für fehlende Felder (z.B. Typ "ZOMBIE", Gesundheit 40).</p>
        </li>

        <li>
            <code>seedDefaults()</code>
            <p>Privat. Erstellt vordefinierte Beispiel-Mobs wie den "Seuchenbringer" (Boss-Zombie) und den "Skelettkönig", um eine initiale Konfiguration bereitzustellen.</p>
        </li>

        <li>
            <code>save()</code>
            <p>Privat. Schreibt die aktuelle <code>YamlConfiguration</code> physisch auf die Festplatte und fängt mögliche <code>IOException</code>-Fehler ab.</p>
        </li>
    </ul>

    <h3>Verwaltete Attribute pro Mob</h3>
    <p>Der Manager verarbeitet folgende Datenfelder innerhalb der <code>mobs.yml</code>:</p>
    <ul>
        <li><code>name</code>: Anzeigename des Mobs (unterstützt Farbcodes).</li>
        <li><code>type</code>: Der Bukkit-Entity-Typ (z.B. ZOMBIE, SKELETON).</li>
        <li><code>health</code>: Maximale Lebenspunkte.</li>
        <li><code>damage</code>: Basisschaden des Mobs.</li>
        <li><code>mainHand</code> / <code>helmet</code>: Ausrüstungsgegenstände.</li>
        <li><code>skills</code>: Eine Liste von Skill-IDs, die der Mob nutzen kann.</li>
        <li><code>skillIntervalSeconds</code>: Zeitabstand zwischen Skill-Aktivierungen.</li>
        <li><code>xp</code>: Erfahrungspunkte, die bei Tod vergeben werden.</li>
        <li><code>lootTable</code>: Verweis auf eine Beutetabelle.</li>
        <li><code>behaviorTree</code>: Verweis auf eine KI-Verhaltensstruktur.</li>
        <li><code>boss</code>: Boolean-Flag zur Kennzeichnung als Boss-Gegner.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/NpcManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/NpcManager.java</h2>
    <p>Der <code>NpcManager</code> ist eine zentrale Verwaltungskomponente für Nicht-Spieler-Charaktere (NPCs) innerhalb des RPG-Plugins. Er ist verantwortlich für das Laden, Speichern, Erstellen und Spawnen von NPCs in der Spielwelt sowie für die Handhabung ihrer Dialogstrukturen.</p>

    <h3>Klasse: NpcManager</h3>
    <p>Diese Klasse verwaltet die Lebenszyklen von NPCs und nutzt YAML-Konfigurationen zur Persistenz.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>NpcManager(JavaPlugin plugin)</code>: Initialisiert den Manager, lädt die <code>npcs.yml</code> aus dem Datenordner des Plugins und erstellt den <code>NamespacedKey</code> für die Identifizierung von NPC-Entities.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>npcKey()</code>: Gibt den <code>NamespacedKey</code> zurück, der verwendet wird, um die NPC-ID in den persistenten Daten der Bukkit-Entity zu speichern.
            <br><strong>Rückgabewert:</strong> <code>NamespacedKey</code>
        </li>
        <li>
            <code>npcs()</code>: Gibt eine Map aller aktuell geladenen NPCs zurück.
            <br><strong>Rückgabewert:</strong> <code>Map&lt;String, Npc&gt;</code>
        </li>
        <li>
            <code>getNpc(String id)</code>: Ruft ein spezifisches NPC-Objekt anhand seiner ID ab.
            <br><strong>Parameter:</strong> <code>id</code> - Die eindeutige Kennung des NPCs.
        </li>
        <li>
            <code>spawnAll()</code>: Iteriert durch alle registrierten NPCs und spawnt sie in ihren jeweiligen Welten.
        </li>
        <li>
            <code>spawnNpc(Npc npc)</code>: Erzeugt eine physische Entity (Villager) in der Welt für den angegebenen NPC.
            <ul>
                <li>Setzt den Namen und macht ihn sichtbar.</li>
                <li>Deaktiviert die KI (AI) und macht den NPC unverwundbar sowie lautlos.</li>
                <li>Speichert die NPC-ID im <code>PersistentDataContainer</code> der Entity.</li>
            </ul>
            <br><strong>Parameter:</strong> <code>npc</code> - Das zu spawnende NPC-Modell.
        </li>
        <li>
            <code>saveNpc(Npc npc)</code>: Überführt die Daten eines einzelnen NPCs (Position, Rolle, Dialoge, Fraktionsvoraussetzungen) in die Konfigurationsstruktur.
            <br><strong>Parameter:</strong> <code>npc</code> - Der zu speichernde NPC.
        </li>
        <li>
            <code>saveAll()</code>: Bereinigt die aktuelle Konfigurationsdatei und speichert alle geladenen NPCs erneut ab.
        </li>
        <li>
            <code>load()</code>: Lädt alle NPC-Definitionen aus der <code>npcs.yml</code>. Rekonstruiert dabei die Positionen, Rollen (z.B. QUESTGIVER) und verknüpfte IDs für Shops oder Fraktionen.
        </li>
        <li>
            <code>serializeDialogue(Npc npc)</code>: Wandelt die komplexen Dialogknoten und Antwortoptionen eines NPCs in eine Map-Struktur um, die von der YAML-Konfiguration gespeichert werden kann.
            <br><strong>Rückgabewert:</strong> Eine Liste von Maps mit Dialogdaten.
        </li>
        <li>
            <code>loadDialogue(ConfigurationSection section, Npc npc)</code>: Rekonstruiert die Dialogbäume aus der Konfigurationsdatei, inklusive Bedingungen wie benötigter Ruf, Fraktionszugehörigkeit oder Quest-Status.
        </li>
    </ul>

    <h4>Hilfsmethoden (Privat)</h4>
    <ul>
        <li><code>mapString</code>, <code>mapInt</code>, <code>mapBool</code>: Hilfsfunktionen zum sicheren Auslesen von Werten aus generischen Maps mit Fallback-Werten.</li>
        <li><code>valueOrNull(Object raw)</code>: Konvertiert ein Objekt in einen String oder gibt <code>null</code> zurück, falls der Wert leer ist.</li>
        <li><code>save()</code>: Schreibt den aktuellen Stand der <code>YamlConfiguration</code> physisch auf die Festplatte.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PartyManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PartyManager.java</h2>
    <p>
        Der <code>PartyManager</code> ist eine zentrale Verwaltungskomponente für das Gruppen-System (Party-System) innerhalb des RPG-Plugins. 
        Er ist dafür verantwortlich, die Zuordnung von Spielern zu ihren jeweiligen Gruppen zu speichern, neue Gruppen zu erstellen und die Mitgliederstruktur zu verwalten.
    </p>

    <h3>Klasse: PartyManager</h3>
    <p>
        Diese Klasse verwaltet die Laufzeitdaten aller aktiven Gruppen mithilfe einer Map, die Spieler-UUIDs direkt ihren Gruppeninstanzen zuordnet.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public Party createParty(UUID leader)</code>
            <p>
                Erstellt eine neue Gruppe mit dem angegebenen Spieler als Anführer.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>leader</code> (UUID) - Die UUID des Spielers, der die Gruppe gründet.</li>
                <li><strong>Rückgabewert:</strong> <code>Party</code> - Die neu erstellte Gruppeninstanz.</li>
            </ul>
        </li>
        <li>
            <code>public Optional&lt;Party&gt; getParty(UUID member)</code>
            <p>
                Sucht nach der Gruppe, in der ein bestimmter Spieler Mitglied ist.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>member</code> (UUID) - Die UUID des zu suchenden Spielers.</li>
                <li><strong>Rückgabewert:</strong> <code>Optional&lt;Party&gt;</code> - Ein Optional, das die Gruppe enthält, sofern der Spieler Teil einer Gruppe ist.</li>
            </ul>
        </li>
        <li>
            <code>public void addMember(Party party, UUID member)</code>
            <p>
                Fügt einen Spieler einer bestehenden Gruppe hinzu und registriert diese Zuordnung im Manager.
            </p>
            <ul>
                <li><strong>Parameter:</strong> 
                    <ul>
                        <li><code>party</code> (Party) - Die Zielgruppe.</li>
                        <li><code>member</code> (UUID) - Die UUID des Spielers, der beitreten soll.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code>public void removeMember(UUID member)</code>
            <p>
                Entfernt einen Spieler aus seiner aktuellen Gruppe. Diese Methode enthält eine spezifische Logik für verschiedene Szenarien:
            </p>
            <ul>
                <li>Wenn der Spieler der <strong>Anführer</strong> ist, wird die gesamte Gruppe aufgelöst und alle Mitglieder werden aus der internen Verwaltung entfernt.</li>
                <li>Wenn die Gruppe nach dem Verlassen <strong>leer</strong> ist, wird sie vollständig gelöscht.</li>
                <li>Ansonsten wird lediglich die Verknüpfung für den einzelnen Spieler aufgehoben.</li>
                <li><strong>Parameter:</strong> <code>member</code> (UUID) - Die UUID des Spielers, der die Gruppe verlassen soll oder entfernt wird.</li>
            </ul>
        </li>
    </ul>

    <h4>Interne Struktur</h4>
    <p>
        Die Klasse verwendet eine <code>Map&lt;UUID, Party&gt; partiesByMember</code>, um einen schnellen Zugriff auf die Gruppeninformationen eines Spielers zu ermöglichen, ohne alle Gruppen iterativ durchsuchen zu müssen.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PlayerDataManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PlayerDataManager.java</h2>
    <p>
        Der <code>PlayerDataManager</code> ist eine zentrale Verwaltungskomponente für Spielerprofile innerhalb des RPG-Systems. 
        Er fungiert als Brücke zwischen der Datenbank (via <code>PlayerDao</code>) und dem aktiven Spielgeschehen, indem er Profile im Arbeitsspeicher vorhält (Caching) und asynchrone Lade- sowie Speichervorgänge koordiniert.
    </p>

    <h3>Klasse: PlayerDataManager</h3>
    <p>Diese Klasse verwaltet die Laufzeitdaten der Spieler und stellt sicher, dass Profilinformationen konsistent geladen und gespeichert werden.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>PlayerDataManager(JavaPlugin plugin, PlayerDao playerDao)</code>: Initialisiert den Manager mit der Plugin-Instanz und dem Datenzugriffsobjekt (DAO).</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>getProfile(UUID uuid)</code>
            <p>Ruft das Profil eines Spielers anhand seiner UUID ab. Falls das Profil noch nicht im Cache existiert, wird ein neues, leeres <code>PlayerProfile</code>-Objekt erstellt und zurückgegeben.</p>
            <strong>Rückgabewert:</strong> <code>PlayerProfile</code>
        </li>
        <li>
            <code>getProfile(Player player)</code>
            <p>Überladene Hilfsmethode, die das Profil basierend auf einem Bukkit-<code>Player</code>-Objekt abruft.</p>
            <strong>Parameter:</strong> <code>player</code> - Das Bukkit Player-Objekt.
        </li>
        <li>
            <code>profiles()</code>
            <p>Gibt die interne Map aller aktuell geladenen Profile zurück.</p>
            <strong>Rückgabewert:</strong> <code>Map&lt;UUID, PlayerProfile&gt;</code>
        </li>
        <li>
            <code>loadProfileAsync(UUID uuid)</code>
            <p>Lädt ein Spielerprofil asynchron aus der Datenbank. Bei einem Fehler wird eine Warnung im Log ausgegeben. Falls kein Profil in der Datenbank existiert, wird ein neues Profil initialisiert.</p>
            <strong>Rückgabewert:</strong> <code>CompletableFuture&lt;PlayerProfile&gt;</code>
        </li>
        <li>
            <code>saveProfile(PlayerProfile profile)</code>
            <p>Speichert das angegebene Profil asynchron in der Datenbank. Fehler während des Speichervorgangs werden protokolliert.</p>
        </li>
        <li>
            <code>saveAll()</code>
            <p>Iteriert über alle aktuell im Cache befindlichen Profile und stößt für jedes einzelne den Speichervorgang an. Diese Methode wird typischerweise beim Herunterfahren des Servers oder bei regelmäßigen Backups verwendet.</p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>PlayerDao</code>: Schnittstelle für den Datenbankzugriff.</li>
        <li><code>PlayerProfile</code>: Datenmodell, das die RPG-spezifischen Informationen eines Spielers enthält.</li>
        <li><code>JavaPlugin</code>: Wird für das Logging von Fehlern benötigt.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ProfessionManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ProfessionManager.java</h2>
    <p>
        Der <code>ProfessionManager</code> ist eine zentrale Komponente zur Verwaltung des Berufssystems innerhalb des RPG-Plugins. 
        Er ist verantwortlich für das Laden der Berufsdefinitionen aus einer Konfigurationsdatei (<code>professions.yml</code>), 
        die Berechnung von Erfahrungspunkten (XP), das Level-Up-System sowie die Vergabe von Belohnungen beim Erreichen bestimmter Stufen.
    </p>

    <h3>Klasse: ProfessionManager</h3>
    <p>Verwaltet die Logik für Berufe wie Bergbau, Kräuterkunde oder Schmiedekunst.</p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>public ProfessionManager(JavaPlugin plugin)</code>
            <p>Initialisiert den Manager, lädt die Konfiguration und erstellt Standardwerte (Seed), falls die Datei noch nicht existiert.</p>
        </li>
        <li>
            <code>public int getLevel(PlayerProfile profile, String profession)</code>
            <p>Gibt das aktuelle Level eines Spielers in einem bestimmten Beruf zurück. Standardwert ist 1.</p>
        </li>
        <li>
            <code>public void setLevel(PlayerProfile profile, String profession, int level)</code>
            <p>Setzt das Level eines Spielers für einen Beruf manuell fest (Minimum 1).</p>
        </li>
        <li>
            <code>public int addXp(PlayerProfile profile, String profession, int xp, Player player)</code>
            <p>
                Fügt einem Spieler XP in einem Beruf hinzu. Berechnet automatisch Level-Ups basierend auf einem Schwellenwert (Level * 100). 
                Löst bei einem Level-Aufstieg Belohnungen aus.
            </p>
            <p><strong>Rückgabewert:</strong> Das neue Level des Spielers.</p>
        </li>
        <li>
            <code>public int xpForMaterial(String profession, String material)</code>
            <p>Gibt an, wie viele XP das Interagieren mit einem bestimmten Material (z.B. COAL_ORE) für den jeweiligen Beruf gewährt.</p>
        </li>
        <li>
            <code>public int requiredLevelForCraft(String profession, String resultMaterial)</code>
            <p>Gibt das benötigte Mindestlevel zurück, um einen bestimmten Gegenstand in diesem Beruf herzustellen.</p>
        </li>
        <li>
            <code>private void fireLevelRewards(String profession, int level, Player player)</code>
            <p>Führt Konsolenbefehle aus, die als Belohnung für das Erreichen eines Levels in der Konfiguration hinterlegt sind, und sendet eine Nachricht an den Spieler.</p>
        </li>
    </ul>

    <h3>Innere Klasse: ProfessionDefinition</h3>
    <p>Repräsentiert die statischen Daten eines Berufs, wie sie in der Konfiguration definiert sind.</p>
    <ul>
        <li><code>id</code>: Eindeutiger technischer Name des Berufs.</li>
        <li><code>displayName</code>: Der Name des Berufs, wie er im Spiel angezeigt wird.</li>
        <li><code>xpSources</code>: Eine Map, die Materialien (Strings) den entsprechenden XP-Werten zuordnet.</li>
        <li><code>craftRequirements</code>: Eine Map, die herstellbare Gegenstände den benötigten Mindestleveln zuordnet.</li>
        <li><code>levelRewards</code>: Eine Map, die Level-Meilensteine einer Liste von Befehlen zuordnet, die ausgeführt werden sollen.</li>
    </ul>

    <h3>Standard-Berufe (Defaults):</h3>
    <p>Wenn keine Konfiguration vorhanden ist, werden folgende Berufe automatisch angelegt:</p>
    <ul>
        <li><strong>Bergbau (Mining):</strong> XP durch Kohle, Eisen und Diamanten. Belohnung auf Level 5: Eine Eisen-Spitzhacke.</li>
        <li><strong>Kräuterkunde (Herbalism):</strong> XP durch Weizen, Karotten und Netherwarzen. Belohnung auf Level 5: Ein goldener Apfel.</li>
        <li><strong>Schmiedekunst (Blacksmithing):</strong> XP durch das Herstellen von Schwertern. Benötigt Level 3 für Eisenschwerter und Level 6 für Diamantschwerter.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PvpSeasonManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PvpSeasonManager.java</h2>
    <p>Der <code>PvpSeasonManager</code> ist eine zentrale Komponente zur Verwaltung von PvP-Saisons innerhalb des RPG-Systems. Er kümmert sich um den Lebenszyklus einer Saison, einschließlich Start, Überprüfung des Enddatums, Zurücksetzen von Spieler-Ratings (Elo) und der Verteilung von Belohnungen an die besten Spieler.</p>

    <h3>Klasse: PvpSeasonManager</h3>
    <p>Diese Klasse verwaltet die Persistenz der aktuellen Saison in einer YAML-Datei und steuert die Logik für saisonale Übergänge.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>PvpSeasonManager(RPGPlugin plugin)</code>: Initialisiert den Manager, lädt die Konfigurationsdatei <code>pvp_season.yml</code> und stellt den Zustand der aktuellen Saison aus der Datei wieder her.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>currentSeason()</code>: 
            <br><strong>Rückgabewert:</strong> Das aktuelle <code>PvpSeason</code>-Objekt oder <code>null</code>, wenn keine Saison aktiv ist.
        </li>
        <li>
            <code>startSeason(String id, String name, long endTimestamp)</code>: 
            <br>Startet eine neue PvP-Saison.
            <br><strong>Parameter:</strong>
            <ul>
                <li><code>id</code>: Eindeutige Kennung der Saison.</li>
                <li><code>name</code>: Anzeigename der Saison.</li>
                <li><code>endTimestamp</code>: Zeitpunkt (Unix-Timestamp), an dem die Saison enden soll.</li>
            </ul>
            <br><strong>Details:</strong> Setzt alle Spieler-Elo-Werte auf 1000 zurück, speichert den neuen Zustand und sendet eine serverweite Nachricht.
        </li>
        <li>
            <code>endSeason()</code>: 
            <br>Beendet die aktuelle Saison manuell. Löst die Belohnungsverteilung aus, löscht die Saisondaten und informiert den Server.
        </li>
        <li>
            <code>checkSeasonEnd()</code>: 
            <br>Überprüft, ob die aktuelle Saison basierend auf dem Zeitstempel abgelaufen ist. Wenn ja, wird <code>endSeason()</code> aufgerufen.
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>resetRatings()</code>: 
            <br>Setzt das Elo-Rating aller geladenen Spielerprofile auf den Standardwert von 1000 zurück.
        </li>
        <li>
            <code>awardRewards()</code>: 
            <br>Ermittelt die Top 3 Spieler basierend auf ihrem Elo-Rating und verteilt spezifische Titel und kosmetische Belohnungen (Champion, Gladiator, Contender).
        </li>
        <li>
            <code>award(PlayerProfile profile, String title, String cosmeticId)</code>: 
            <br>Weist einem einzelnen Spieler einen Titel und ein kosmetisches Item zu und sendet eine Benachrichtigung, falls der Spieler online ist.
        </li>
        <li>
            <code>load()</code>: 
            <br>Liest die Saisondaten aus der <code>pvp_season.yml</code> ein.
        </li>
        <li>
            <code>save()</code>: 
            <br>Speichert den aktuellen Zustand der Saison (oder löscht die Einträge, falls keine Saison aktiv ist) in die YAML-Datei.
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/QuestManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/QuestManager.java</h2>
    <p>
        Der <code>QuestManager</code> ist eine zentrale Verwaltungskomponente für das Quest-System des RPG-Plugins. 
        Er ist verantwortlich für das Laden, Speichern und Bereitstellen von Quest-Definitionen aus einer YAML-Konfigurationsdatei (<code>quests.yml</code>).
    </p>

    <h3>Klasse: QuestManager</h3>
    <p>
        Diese Klasse verwaltet eine Sammlung von Quests und synchronisiert diese mit dem Dateisystem.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>QuestManager(JavaPlugin plugin)</code>: Initialisiert den Manager, legt die <code>quests.yml</code> an, falls diese nicht existiert (mit Standardwerten), und lädt die vorhandenen Quests in den Speicher.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>getQuest(String id)</code>
            <p>Sucht eine Quest anhand ihrer eindeutigen ID.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>id</code> - Die ID der gesuchten Quest.</li>
                <li><strong>Rückgabewert:</strong> Das <code>Quest</code>-Objekt oder <code>null</code>, falls nicht gefunden.</li>
            </ul>
        </li>
        <li>
            <code>quests()</code>
            <p>Gibt eine Map aller aktuell geladenen Quests zurück.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>Map&lt;String, Quest&gt;</code></li>
            </ul>
        </li>
        <li>
            <code>saveQuest(Quest quest)</code>
            <p>Speichert eine einzelne Quest-Instanz in die Konfigurationsdatei. Dabei werden Name, Beschreibung, Wiederholbarkeit, Mindestlevel, erforderliche Events, Quest-Schritte und Belohnungen serialisiert.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>quest</code> - Das zu speichernde Quest-Objekt.</li>
            </ul>
        </li>
        <li>
            <code>saveAll()</code>
            <p>Bereinigt die aktuelle Konfigurationsdatei und schreibt alle im Speicher befindlichen Quests erneut hinein.</p>
        </li>
        <li>
            <code>reload()</code>
            <p>Lädt die <code>quests.yml</code> Datei vom Datenträger neu ein, um manuelle Änderungen an der Datei im laufenden Betrieb zu übernehmen.</p>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>load()</code>
            <p>Interne Logik zum Parsen der YAML-Struktur. Sie wandelt die Konfigurationsabschnitte in <code>Quest</code>, <code>QuestStep</code> und <code>QuestReward</code> Objekte um.</p>
        </li>
        <li>
            <code>seedDefaults()</code>
            <p>Erstellt eine Beispiel-Quest ("Wolfsplage"), falls noch keine Quest-Datei existiert, um dem Administrator eine Vorlage zu bieten.</p>
        </li>
        <li>
            <code>save()</code>
            <p>Führt den eigentlichen Schreibvorgang der <code>YamlConfiguration</code> auf die Festplatte aus und fängt mögliche I/O-Fehler ab.</p>
        </li>
    </ul>

    <h3>Datenstruktur in der Konfiguration</h3>
    <p>
        Die Quests werden in folgendem Format gespeichert:
    </p>
    <ul>
        <li><code>name</code>: Anzeigename der Quest.</li>
        <li><code>description</code>: Beschreibungstext.</li>
        <li><code>repeatable</code>: Boolean, ob die Quest mehrfach abgeschlossen werden kann.</li>
        <li><code>minLevel</code>: Erforderliches Mindestlevel des Spielers.</li>
        <li><code>steps</code>: Eine Liste von Aufgaben (Typ, Ziel-ID, Anzahl).</li>
        <li><code>reward</code>: Belohnungen wie Erfahrungspunkte (XP), Skillpunkte und Fraktionsruf.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ResourceNodeManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ResourceNodeManager.java</h2>
    <p>
        Der <code>ResourceNodeManager</code> ist eine zentrale Verwaltungskomponente für Ressourcen-Knoten (Resource Nodes) innerhalb des RPG-Systems. 
        Er ist verantwortlich für das Laden, Speichern und Verwalten von abbaubaren Objekten in der Spielwelt, wie zum Beispiel Erzvorkommen oder Kräuter, 
        die mit bestimmten Berufen (Professions) verknüpft sind.
    </p>

    <h3>Klasse: ResourceNodeManager</h3>
    <p>
        Diese Klasse verwaltet eine Sammlung von <code>ResourceNode</code>-Objekten und synchronisiert diese mit einer YAML-Konfigurationsdatei.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>ResourceNodeManager(RPGPlugin plugin)</code>: Initialisiert den Manager, legt die Datei <code>resource_nodes.yml</code> im Datenordner des Plugins fest und lädt die vorhandenen Knoten.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>nodes()</code>
            <p>Gibt eine Map aller registrierten Ressourcen-Knoten zurück, wobei die ID des Knotens als Schlüssel dient.</p>
            <strong>Rückgabewert:</strong> <code>Map&lt;String, ResourceNode&gt;</code>
        </li>
        <li>
            <code>nodeAt(Location location)</code>
            <p>Sucht nach einem Ressourcen-Knoten an einer spezifischen Position in der Welt.</p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>location</code>: Die <code>Location</code> (Position), die überprüft werden soll.</li>
            </ul>
            <strong>Rückgabewert:</strong> Das <code>ResourceNode</code>-Objekt an dieser Position oder <code>null</code>, falls kein Knoten gefunden wurde.
        </li>
        <li>
            <code>createNode(Player player, String profession, Material material, int respawnSeconds, int xp)</code>
            <p>Erstellt einen neuen Ressourcen-Knoten an der aktuellen Position des Spielers und speichert diesen in der Konfiguration.</p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>player</code>: Der Spieler, dessen aktuelle Block-Position als Standort für den Knoten dient.</li>
                <li><code>profession</code>: Der Beruf, der zum Abbau dieses Knotens erforderlich ist (z. B. "mining").</li>
                <li><code>material</code>: Das Bukkit-<code>Material</code>, aus dem der Knoten besteht.</li>
                <li><code>respawnSeconds</code>: Die Zeit in Sekunden, bis der Knoten nach dem Abbau regeneriert.</li>
                <li><code>xp</code>: Die Erfahrungspunkte, die ein Spieler beim Abbau erhält.</li>
            </ul>
        </li>
        <li>
            <code>saveNode(ResourceNode node)</code>
            <p>Überträgt die Daten eines einzelnen Knotens in die YAML-Konfiguration und schreibt diese in die Datei.</p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>node</code>: Das zu speichernde <code>ResourceNode</code>-Objekt.</li>
            </ul>
        </li>
        <li>
            <code>saveAll()</code>
            <p>Bereinigt die aktuelle Konfigurationsdatei und speichert alle im Speicher befindlichen Knoten erneut ab.</p>
        </li>
        <li>
            <code>load()</code> (privat)
            <p>Liest alle Knoten-Definitionen aus der <code>resource_nodes.yml</code> ein und instanziiert die entsprechenden <code>ResourceNode</code>-Objekte.</p>
        </li>
        <li>
            <code>save()</code> (privat)
            <p>Schreibt den aktuellen Stand der <code>YamlConfiguration</code> physisch auf die Festplatte. Behandelt <code>IOException</code>-Fehler durch eine Warnung im Log.</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ShopManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ShopManager.java</h2>
    <p>
        Die Klasse <code>ShopManager</code> ist für die Verwaltung, Speicherung und das Laden von Shop-Definitionen innerhalb des RPG-Plugins verantwortlich. 
        Sie nutzt eine YAML-Datei (<code>shops.yml</code>), um Shop-Daten persistent zu speichern, und stellt Methoden bereit, um auf diese Daten zuzugreifen oder sie zur Laufzeit zu modifizieren.
    </p>

    <h3>Klasse: ShopManager</h3>
    <p>Zentrale Verwaltungseinheit für alle In-Game-Shops.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>ShopManager(JavaPlugin plugin)</code>: Initialisiert den Manager, lädt die Konfigurationsdatei und erstellt Standardwerte (Seed), falls die Datei noch nicht existiert.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>getShop(String id)</code>
            <p>Sucht einen Shop anhand seiner eindeutigen ID.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>id</code> - Die ID des Shops.</li>
                <li><strong>Rückgabewert:</strong> <code>ShopDefinition</code> - Das gefundene Shop-Objekt oder <code>null</code>.</li>
            </ul>
        </li>
        <li>
            <code>shops()</code>
            <p>Gibt eine Map aller registrierten Shops zurück.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>Map&lt;String, ShopDefinition&gt;</code></li>
            </ul>
        </li>
        <li>
            <code>registerShop(ShopDefinition shop)</code>
            <p>Registriert ein neues Shop-Objekt im Speicher des Managers.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>shop</code> - Die zu registrierende <code>ShopDefinition</code>.</li>
            </ul>
        </li>
        <li>
            <code>saveShop(ShopDefinition shop)</code>
            <p>Konvertiert eine einzelne Shop-Definition in ein YAML-Format und speichert sie in der Konfiguration.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>shop</code> - Der zu speichernde Shop.</li>
            </ul>
        </li>
        <li>
            <code>saveAll()</code>
            <p>Bereinigt die aktuelle Konfigurationsdatei und schreibt alle im Speicher befindlichen Shops erneut hinein.</p>
        </li>
        <li>
            <code>load()</code>
            <p>Lädt alle Shop-Daten aus der <code>shops.yml</code>. Dabei werden Attribute wie Titel, Material, Preise, Seltenheit (Rarity) und Mindestlevel für jedes Item verarbeitet.</p>
        </li>
        <li>
            <code>seedDefaults()</code>
            <p>Erstellt eine initiale Beispiel-Konfiguration (z. B. einen "Dorfschmied" mit Eisenschwert und Heiltrank), wenn keine Datei vorhanden ist.</p>
        </li>
        <li>
            <code>save()</code>
            <p>Schreibt den aktuellen Stand der <code>YamlConfiguration</code> physisch auf die Festplatte.</p>
        </li>
    </ul>

    <h3>Datenstruktur in der Konfiguration</h3>
    <p>Ein Shop-Eintrag in der YAML-Datei umfasst folgende Felder pro Item:</p>
    <ul>
        <li><code>slot</code>: Die Position im Inventar-GUI.</li>
        <li><code>material</code>: Der Minecraft-Materialname.</li>
        <li><code>name</code>: Der Anzeigename (unterstützt Farbcodes).</li>
        <li><code>buyPrice</code> / <code>sellPrice</code>: Die Preise für Kauf und Verkauf.</li>
        <li><code>rpgItem</code>: Boolean, ob es sich um ein spezielles RPG-Item handelt.</li>
        <li><code>rarity</code>: Die Seltenheitsstufe des Items.</li>
        <li><code>minLevel</code>: Das benötigte Mindestlevel des Spielers.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillHotbarManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillHotbarManager.java</h2>
    <p>
        Der <code>SkillHotbarManager</code> ist eine zentrale Komponente zur Verwaltung der Skill-Zuweisungen (Bindings) für Spieler. 
        Er ermöglicht es, spezifische Fähigkeiten (Skills) an bestimmte Slots in der Hotbar eines Spielers zu binden und diese Konfigurationen dauerhaft zu speichern.
    </p>

    <h3>Klasse: SkillHotbarManager</h3>
    <p>
        Diese Klasse fungiert als Schnittstelle zwischen den Spielerprofilen und der Persistenzschicht, um die Skill-Belegungen zu verwalten.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>SkillHotbarManager(PlayerDataManager playerDataManager)</code>: 
            Initialisiert den Manager mit einer Instanz des <code>PlayerDataManager</code>, um Änderungen an den Spielerprofilen speichern zu können.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public void bindSkill(PlayerProfile profile, int slot, String skillId)</code>
            <p>
                Verknüpft eine Skill-ID mit einem spezifischen Slot im Profil des Spielers. Nach der Zuweisung wird das Profil automatisch über den <code>PlayerDataManager</code> gespeichert.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>profile</code>: Das <code>PlayerProfile</code> des betroffenen Spielers.</li>
                        <li><code>slot</code>: Die Index-Nummer des Hotbar-Slots (Integer).</li>
                        <li><code>skillId</code>: Die eindeutige Identifikationszeichenfolge des zuzuweisenden Skills.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code>public String getBinding(PlayerProfile profile, int slot)</code>
            <p>
                Ruft die aktuell zugewiesene Skill-ID für einen bestimmten Slot aus dem Spielerprofil ab.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>profile</code>: Das <code>PlayerProfile</code>, das abgefragt werden soll.</li>
                        <li><code>slot</code>: Der abzufragende Hotbar-Slot.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Ein <code>String</code>, der die Skill-ID enthält, oder <code>null</code>, falls der Slot nicht belegt ist.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillManager.java</h2>
    <p>
        Die Klasse <code>SkillManager</code> ist für die Verwaltung, das Laden und das Speichern aller Fähigkeiten (Skills) innerhalb des RPG-Plugins verantwortlich. 
        Sie fungiert als zentrale Schnittstelle zwischen der Konfigurationsdatei <code>skills.yml</code> und der Laufzeitumgebung des Servers.
    </p>

    <h3>Klasse: SkillManager</h3>
    <p>Verwaltet die Definitionen von Fähigkeiten, deren Kosten, Abklingzeiten und Effekte.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>SkillManager(JavaPlugin plugin)</code>: Initialisiert den Manager, lädt die <code>skills.yml</code> und erstellt Standardwerte (Seeds), falls die Datei noch nicht existiert.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>getSkill(String id)</code>: 
            Gibt ein <code>Skill</code>-Objekt basierend auf seiner eindeutigen ID zurück.
            <br><strong>Rückgabewert:</strong> Das gefundene <code>Skill</code>-Objekt oder <code>null</code>.
        </li>
        <li>
            <code>skills()</code>: 
            Gibt eine Map aller registrierten Fähigkeiten zurück.
            <br><strong>Rückgabewert:</strong> <code>Map&lt;String, Skill&gt;</code>
        </li>
        <li>
            <code>saveSkill(Skill skill)</code>: 
            Speichert eine einzelne Fähigkeit in der Konfiguration. Serialisiert dabei Attribute wie Name, Typ, Kategorie, Cooldown, Manakosten und Effekte.
        </li>
        <li>
            <code>saveAll()</code>: 
            Bereinigt die aktuelle Konfiguration und speichert alle im Speicher befindlichen Fähigkeiten erneut in die Datei.
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>load()</code>: 
            Liest alle Fähigkeiten aus der YAML-Konfiguration ein und konvertiert sie in <code>Skill</code>-Objekte. Unterstützt auch die Zuweisung von erforderlichen Fähigkeiten (Parent-Skills) für Skill-Bäume.
        </li>
        <li>
            <code>seedDefaults()</code>: 
            Erstellt eine umfangreiche Liste von Standard-Fähigkeiten für verschiedene Kategorien (Heilung, Magie, Angriff, Verteidigung, Berufe), um einen sofortigen Spielbetrieb zu ermöglichen.
        </li>
        <li>
            <code>serializeEffects(List&lt;SkillEffectConfig&gt; effects)</code>: 
            Konvertiert eine Liste von Effekt-Konfigurationen in ein Format (Map-Liste), das von Bukkit's YAML-API gespeichert werden kann.
        </li>
        <li>
            <code>loadEffects(ConfigurationSection section)</code>: 
            Extrahiert Effekt-Konfigurationen aus einem YAML-Abschnitt. Unterstützt sowohl das aktuelle Listenformat als auch ein "Legacy"-Format für Abwärtskompatibilität.
        </li>
        <li>
            <code>mapLegacyEffect(String legacy)</code>: 
            Mapping-Funktion, die alte String-basierte Effektbezeichnungen (z.B. <code>"fireball"</code>) in das neue, strukturierte <code>SkillEffectConfig</code>-System überführt.
        </li>
        <li>
            <code>save()</code>: 
            Schreibt den aktuellen Stand der <code>YamlConfiguration</code> physisch auf die Festplatte.
        </li>
    </ul>

    <h3>Standardmäßig definierte Fähigkeiten (Auszug)</h3>
    <ul>
        <li><strong>Heilung:</strong> Heilpuls, Große Heilung, Segen.</li>
        <li><strong>Magie:</strong> Flammenstoß, Frostbolzen, Arkane Explosion.</li>
        <li><strong>Angriff:</strong> Machtstoß, Wirbelwind, Hinrichtung.</li>
        <li><strong>Verteidigung:</strong> Schildwall, Bollwerk, Abwehrhaltung.</li>
        <li><strong>Berufe:</strong> Bergbau-Fokus, Handwerkskunst, Alchemie-Meister.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillSynergyManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillSynergyManager.java</h2>
    <p>
        Der <code>SkillSynergyManager</code> ist eine zentrale Komponente des RPG-Systems, die für die Erkennung und Ausführung von Skill-Synergien verantwortlich ist. Synergien treten auf, wenn bestimmte Fähigkeiten (Skills) innerhalb eines definierten Zeitfensters und in einem bestimmten Umkreis von Spielern derselben Gruppe (Party), Gilde oder Umgebung eingesetzt werden.
    </p>

    <h3>Klasse: SkillSynergyManager</h3>
    <p>Diese Klasse verwaltet das Laden der Synergie-Konfigurationen aus einer YAML-Datei und überwacht die Skill-Nutzung der Spieler, um Synergie-Effekte auszulösen.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>SkillSynergyManager(RPGPlugin plugin)</code>: Initialisiert den Manager, lädt die Konfigurationsdatei <code>skill_synergies.yml</code> und erstellt Standardwerte (Seeding), falls die Datei noch nicht existiert.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>onSkillUsed(Player player, String skillId)</code>
            <p>Wird aufgerufen, wenn ein Spieler eine Fähigkeit einsetzt. Speichert den Zeitpunkt der Nutzung im <code>PlayerProfile</code> und prüft alle registrierten Synergien.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>player</code> (Der auslösende Spieler), <code>skillId</code> (Die ID des eingesetzten Skills).</li>
                <li><strong>Effekt:</strong> Wendet bei Erfolg die konfigurierten <code>SkillEffectConfig</code>-Effekte auf den Spieler an und sendet eine Benachrichtigung.</li>
            </ul>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>hasRequiredSkills(Player player, SkillSynergy synergy)</code>
            <p>Prüft, ob alle für eine Synergie erforderlichen Skills innerhalb des Zeitfensters (<code>windowSeconds</code>) von Spielern im relevanten Bereich (Scope) eingesetzt wurden.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> - True, wenn alle Bedingungen erfüllt sind.</li>
            </ul>
        </li>
        <li>
            <code>resolveScope(Player player, SkillSynergy synergy)</code>
            <p>Ermittelt die Liste der Spieler, die für eine Synergie in Frage kommen, basierend auf dem definierten Wirkungsbereich.</p>
            <ul>
                <li><strong>Scopes:</strong> <code>PARTY</code> (Gruppenmitglieder), <code>GUILD</code> (Gildenmitglieder) oder Umkreis (alle nahen Spieler).</li>
                <li><strong>Rückgabewert:</strong> <code>List&lt;Player&gt;</code> - Liste der Spieler innerhalb des Radius.</li>
            </ul>
        </li>
        <li>
            <code>load()</code>
            <p>Liest die Synergie-Definitionen aus der Konfigurationsdatei ein und transformiert sie in <code>SkillSynergy</code>-Objekte inklusive ihrer Effekte und Parameter.</p>
        </li>
        <li>
            <code>seedDefaults()</code>
            <p>Erstellt eine Beispiel-Synergie namens "Steam Burst", die ausgelöst wird, wenn "frost_bolt" und "ember_shot" kombiniert werden.</p>
        </li>
        <li>
            <code>save()</code>
            <p>Speichert die aktuelle Konfiguration physisch in der <code>skill_synergies.yml</code> Datei.</p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Hauptinstanz für den Zugriff auf andere Manager (Party, Guild, PlayerData).</li>
        <li><code>SkillSynergy</code>: Datenmodell für eine Synergie-Definition.</li>
        <li><code>PlayerProfile</code>: Speichert die Historie der zuletzt genutzten Skills pro Spieler.</li>
        <li><code>SkillEffectRegistry</code>: Wird verwendet, um die Synergie-Effekte (z.B. Schaden) tatsächlich anzuwenden.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillTreeManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillTreeManager.java</h2>
    <p>
        Der <code>SkillTreeManager</code> ist eine zentrale Komponente zur Verwaltung und Strukturierung von Fähigkeiten in einer hierarchischen Baumstruktur (Skill-Tree). Er verarbeitet die Abhängigkeiten zwischen verschiedenen Skills und ermöglicht die Navigation durch die Talentbäume.
    </p>

    <h3>Klasse: SkillTreeManager</h3>
    <p>
        Diese Klasse verwaltet die Knoten des Skill-Baums und bietet Methoden zum Neuaufbau der Struktur basierend auf den verfügbaren Skills.
    </p>
    <ul>
        <li>
            <strong>Konstruktor: <code>SkillTreeManager(SkillManager skillManager)</code></strong>
            <p>Initialisiert den Manager mit einem <code>SkillManager</code> und führt initial die Methode <code>rebuild()</code> aus.</p>
        </li>
        <li>
            <strong>Methode: <code>void rebuild()</code></strong>
            <p>
                Baut die gesamte Baumstruktur neu auf. Zuerst werden alle Skills aus dem <code>SkillManager</code> in <code>SkillNode</code>-Objekte transformiert. 
                Anschließend werden die Eltern-Kind-Beziehungen anhand der in den Skills definierten Voraussetzungen (<code>requiredSkill</code>) verknüpft.
            </p>
        </li>
        <li>
            <strong>Methode: <code>List&lt;SkillNode&gt; roots()</code></strong>
            <p>
                Gibt eine Liste aller Wurzelknoten (Skills ohne Voraussetzungen) zurück. Die Liste ist alphabetisch nach der Skill-ID sortiert.
            </p>
            <p><strong>Rückgabewert:</strong> Eine Liste von <code>SkillNode</code>-Objekten, die den Anfang eines Skill-Zweigs bilden.</p>
        </li>
        <li>
            <strong>Methode: <code>Map&lt;String, SkillNode&gt; nodes()</code></strong>
            <p>Gibt eine Map aller registrierten Knoten zurück, wobei die Skill-ID als Schlüssel dient.</p>
        </li>
    </ul>

    <h3>Innere Klasse: SkillNode</h3>
    <p>
        Repräsentiert einen einzelnen Knoten innerhalb des Skill-Baums. Ein Knoten kapselt ein <code>Skill</code>-Objekt und speichert Referenzen auf seinen Elternknoten sowie seine Kinder.
    </p>
    <ul>
        <li>
            <strong><code>skill()</code></strong>: Gibt das zugehörige <code>Skill</code>-Modell zurück.
        </li>
        <li>
            <strong><code>parent()</code></strong>: Gibt den übergeordneten <code>SkillNode</code> zurück (die Voraussetzung für diesen Skill).
        </li>
        <li>
            <strong><code>setParent(SkillNode parent)</code></strong>: Setzt den Elternknoten für diesen Skill.
        </li>
        <li>
            <strong><code>children()</code></strong>: Gibt eine Liste von <code>SkillNode</code>-Objekten zurück, die diesen Skill als Voraussetzung haben.
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SpawnerManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SpawnerManager.java</h2>
    <p>
        Der <code>SpawnerManager</code> ist eine zentrale Komponente des RPG-Systems, die für die Verwaltung und das automatische Erscheinen (Spawning) von Monstern (Mobs) in definierten Zonen verantwortlich ist. Er liest Konfigurationen aus einer YAML-Datei, überwacht die Spielerpräsenz in Zonen und steuert die Mob-Dichte basierend auf festgelegten Intervallen und Wahrscheinlichkeiten.
    </p>

    <h3>Klasse: SpawnerManager</h3>
    <p>
        Diese Klasse verwaltet den Lebenszyklus von Spawnern, einschließlich Laden, Speichern und der Ausführung der Spawning-Logik über einen Scheduler-Task.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public SpawnerManager(RPGPlugin plugin)</code>
            <p>Konstruktor der Klasse. Initialisiert die Konfigurationsdatei <code>spawners.yml</code>, lädt vorhandene Spawner-Daten und startet den Hintergrund-Task für das Mob-Spawning.</p>
        </li>
        <li>
            <code>public Spawner getSpawner(String id)</code>
            <p>Gibt ein <code>Spawner</code>-Objekt basierend auf seiner eindeutigen ID zurück.</p>
        </li>
        <li>
            <code>public void saveSpawner(Spawner spawner)</code>
            <p>Speichert die Konfiguration eines einzelnen Spawners in der YAML-Konfiguration. Parameter: <code>spawner</code> (Das zu speichernde Spawner-Objekt).</p>
        </li>
        <li>
            <code>public void saveAll()</code>
            <p>Überschreibt die gesamte Konfigurationsdatei mit den aktuell im Speicher befindlichen Spawner-Daten.</p>
        </li>
        <li>
            <code>private void load()</code>
            <p>Lädt alle Spawner-Definitionen aus der <code>spawners.yml</code> in den internen Speicher.</p>
        </li>
        <li>
            <code>private void startTask()</code>
            <p>Startet einen asynchronen Bukkit-Task, der alle 40 Ticks (ca. 2 Sekunden) prüft, ob neue Mobs gespawnt werden müssen. Die Logik berücksichtigt das Intervall des Spawners, die maximale Mob-Anzahl in der Zone und ob Spieler in der Zone anwesend sind.</p>
        </li>
        <li>
            <code>private boolean hasPlayersInZone(Zone zone)</code>
            <p>Prüft, ob sich aktuell mindestens ein Spieler innerhalb der Grenzen der angegebenen Zone befindet.</p>
        </li>
        <li>
            <code>private int countMobsInZone(Zone zone)</code>
            <p>Zählt die Anzahl der lebenden Entitäten in einer Zone, die über die <code>PersistentDataContainer</code>-API als "Custom Mobs" markiert sind.</p>
        </li>
        <li>
            <code>private MobDefinition pickMob(Spawner spawner)</code>
            <p>Wählt zufällig eine <code>MobDefinition</code> aus der Liste des Spawners aus, basierend auf den konfigurierten Gewichtungen (Wahrscheinlichkeiten).</p>
        </li>
        <li>
            <code>private void spawnMobInZone(Zone zone, MobDefinition mob)</code>
            <p>Erzeugt eine neue Instanz eines Mobs an einer zufälligen Position innerhalb der Zone. Die Methode sucht automatisch den höchsten soliden Block für die Y-Koordinate und wendet die Mob-Definition über den <code>CustomMobListener</code> an.</p>
        </li>
        <li>
            <code>private int randomBetween(int min, int max)</code>
            <p>Hilfsmethode zur Generierung einer Zufallszahl zwischen zwei Werten (inklusiv).</p>
        </li>
    </ul>

    <h3>Datenstruktur: Spawner</h3>
    <p>
        Obwohl die Klasse <code>Spawner</code> extern definiert ist (<code>com.example.rpg.model.Spawner</code>), nutzt der Manager folgende Attribute:
    </p>
    <ul>
        <li><code>id</code>: Eindeutiger Identifikator des Spawners.</li>
        <li><code>zoneId</code>: Die ID der Zone, in der Mobs erscheinen sollen.</li>
        <li><code>maxMobs</code>: Die maximale Anzahl an Mobs, die dieser Spawner gleichzeitig in der Zone halten darf.</li>
        <li><code>spawnInterval</code>: Zeitabstand in Ticks zwischen den Spawn-Versuchen.</li>
        <li><code>mobs</code>: Eine Map von Mob-IDs und deren Gewichtung für die Zufallsauswahl.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/TradeManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/TradeManager.java</h2>
    <p>
        Der <code>TradeManager</code> ist eine zentrale Verwaltungskomponente für Handelsanfragen zwischen Spielern innerhalb des RPG-Systems. 
        Er dient dazu, aktive Handelsvorgänge zu registrieren, abzurufen und nach Abschluss oder Abbruch wieder zu bereinigen.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        Die Klasse nutzt eine interne Map, um Spieler-UUIDs mit den entsprechenden <code>TradeRequest</code>-Objekten zu verknüpfen. 
        Dabei wird sichergestellt, dass beide beteiligten Parteien (Anfragender und Ziel) auf dasselbe Handelsobjekt zugreifen können.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public void requestTrade(UUID requester, UUID target)</code>
            <p>
                Initiiert eine neue Handelsanfrage zwischen zwei Spielern.
            </p>
            <ul>
                <li><strong>Parameter:</strong> 
                    <ul>
                        <li><code>requester</code>: Die UUID des Spielers, der den Handel startet.</li>
                        <li><code>target</code>: Die UUID des Spielers, der zum Handel eingeladen wird.</li>
                    </ul>
                </li>
                <li><strong>Funktionsweise:</strong> Erstellt ein neues <code>TradeRequest</code>-Objekt und speichert es für beide UUIDs in der internen Map.</li>
            </ul>
        </li>
        <li>
            <code>public TradeRequest getRequest(UUID player)</code>
            <p>
                Ruft die aktuelle Handelsanfrage für einen bestimmten Spieler ab.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>player</code>: Die UUID des Spielers.</li>
                <li><strong>Rückgabewert:</strong> Das zugehörige <code>TradeRequest</code>-Objekt oder <code>null</code>, falls kein Handel aktiv ist.</li>
            </ul>
        </li>
        <li>
            <code>public void clear(UUID player)</code>
            <p>
                Entfernt eine Handelsanfrage aus dem System. Diese Methode wird aufgerufen, wenn ein Handel abgeschlossen wurde, abgelehnt wurde oder ein Spieler die Verbindung trennt.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>player</code>: Die UUID eines der am Handel beteiligten Spieler.</li>
                <li><strong>Funktionsweise:</strong> Identifiziert die Anfrage über die Spieler-UUID und entfernt die Einträge für beide beteiligten Parteien (Anfragender und Ziel) aus der Map.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>com.example.rpg.model.TradeRequest</code>: Datenmodell, das die Details der Handelsbeziehung hält.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/VoiceChatManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/VoiceChatManager.java</h2>
    <p>
        Der <code>VoiceChatManager</code> ist für die Integration und Verwaltung von Sprachkanälen innerhalb des RPG-Systems verantwortlich. 
        Er dient als Brücke zur "Simple Voice Chat"-API (von Max Henkel) und ermöglicht es Spielern, automatisch kanalbasierten Sprachgruppen 
        beizutreten, die auf ihrer aktuellen Party oder Gilde basieren.
    </p>

    <h3>Klasse: VoiceChatManager</h3>
    <p>
        Diese Klasse nutzt Reflection, um optional mit der Voice-Chat-API zu interagieren, sofern diese auf dem Server installiert ist.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>VoiceChatManager(RPGPlugin plugin)</code>: Initialisiert den Manager und versucht, die Verbindung zur Voice-Chat-API herzustellen.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>joinParty(Player player)</code>
            <p>Versetzt den Spieler in einen Sprachkanal, der spezifisch für seine aktuelle Party erstellt wurde. Der Kanalname basiert auf der UUID des Party-Leiters.</p>
        </li>
        <li>
            <code>joinGuild(Player player)</code>
            <p>Versetzt den Spieler in den Sprachkanal seiner Gilde. Erfordert, dass der Spieler Mitglied einer Gilde ist.</p>
        </li>
        <li>
            <code>leave(Player player)</code>
            <p>Entfernt den Spieler aus seinem aktuellen Sprachkanal und setzt ihn zurück in den Standard-Status (Lobby).</p>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>tryInitApi()</code>
            <p>Versucht mittels Reflection die <code>VoicechatServerApi</code> zu laden. Wenn die Klasse nicht gefunden wird, bleibt die Voice-Unterstützung deaktiviert, ohne den Start des Plugins zu verhindern.</p>
        </li>
        <li>
            <code>joinChannel(Player player, String channel, String label)</code>
            <p>Interne Logik zum Speichern des Kanalstatus und zum Senden von Benachrichtigungen an den Spieler.</p>
        </li>
        <li>
            <code>setGroup(Player player, String groupId, String label)</code>
            <p>
                Interagiert direkt mit der Voice-Chat-API. Erstellt eine Gruppe basierend auf einer generierten UUID aus dem <code>groupId</code>-String und weist den Spieler dieser Gruppe zu.
                Gibt <code>true</code> zurück, wenn die API-Operation erfolgreich war.
            </p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Hauptinstanz für den Zugriff auf Party- und Spielerdaten.</li>
        <li><code>Simple Voice Chat API</code>: Externe Schnittstelle für die Sprachübertragung (optional).</li>
        <li><code>Text Utility</code>: Zur Formatierung von Chat-Nachrichten mittels MiniMessage.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/WorldEventManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/WorldEventManager.java</h2>
    <p>Der <code>WorldEventManager</code> ist eine zentrale Komponente zur Verwaltung von dynamischen Welt-Events innerhalb des RPG-Systems. Er ist verantwortlich für das Laden, Speichern, Starten und Überwachen von Events, die global oder in bestimmten Zonen stattfinden können. Die Klasse verarbeitet Spielerinteraktionen wie Kämpfe, Erkundungen und Handwerk, um den Fortschritt dieser Events voranzutreiben.</p>

    <h3>Klasse: WorldEventManager</h3>
    <p>Verwaltet den Lebenszyklus von <code>WorldEvent</code>-Objekten und persistiert deren Status in einer YAML-Konfiguration.</p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>public WorldEventManager(RPGPlugin plugin)</code>
            <p>Initialisiert den Manager, lädt die <code>events.yml</code> und stellt die Verbindung zum Haupt-Plugin her.</p>
        </li>
        <li>
            <code>public void startEvent(String id)</code>
            <p>Aktiviert ein Event anhand seiner ID, setzt den bisherigen Fortschritt und die Teilnehmerliste zurück und sendet eine Rundnachricht an den Server.</p>
        </li>
        <li>
            <code>public void stopEvent(String id)</code>
            <p>Deaktiviert ein laufendes Event manuell.</p>
        </li>
        <li>
            <code>public void handleKill(Player player, String mobType, String zoneId)</code>
            <p>Verarbeitet das Töten eines Mobs. Prüft, ob aktive Events in der Zone existieren, die diesen Mob-Typ als Ziel (KILL oder DEFEND) haben, und aktualisiert den Fortschritt.</p>
        </li>
        <li>
            <code>public void handleExplore(Player player, String zoneId)</code>
            <p>Wird aufgerufen, wenn ein Spieler eine Zone betritt. Aktualisiert Fortschritte für EXPLORE- oder ESCORT-Ziele in aktiven Events.</p>
        </li>
        <li>
            <code>public void handleCraft(Player player, String material, String zoneId)</code>
            <p>Registriert handwerkliche Aktivitäten (CRAFT) für aktive Events in der entsprechenden Zone.</p>
        </li>
        <li>
            <code>public void handleCollect(Player player, String material, String zoneId)</code>
            <p>Registriert das Sammeln von Gegenständen (COLLECT) für aktive Events.</p>
        </li>
        <li>
            <code>public void handleUseItem(Player player, String material, String zoneId)</code>
            <p>Registriert die Nutzung von Gegenständen (USE_ITEM) für aktive Events.</p>
        </li>
        <li>
            <code>private void completeEvent(WorldEvent event)</code>
            <p>Schließt ein Event ab, verteilt Belohnungen (XP, Gold, Fraktionsruf) an alle Teilnehmer und schaltet potenziell neue Quests frei.</p>
        </li>
        <li>
            <code>public void saveEvent(WorldEvent event)</code>
            <p>Speichert den aktuellen Zustand eines einzelnen Events (Name, Zone, Belohnungen, Schritte und Fortschritt) in die Konfigurationsdatei.</p>
        </li>
        <li>
            <code>private void load()</code>
            <p>Lädt alle Event-Definitionen und den Status abgeschlossener Events aus der <code>events.yml</code>.</p>
        </li>
    </ul>

    <h4>Wichtige Felder:</h4>
    <ul>
        <li><code>events</code>: Eine Map, die Event-IDs auf ihre jeweiligen <code>WorldEvent</code>-Objekte abbildet.</li>
        <li><code>completed</code>: Speichert, welche Events bereits erfolgreich abgeschlossen wurden.</li>
        <li><code>config</code>: Die <code>YamlConfiguration</code> zur Persistierung der Daten.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ZoneManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ZoneManager.java</h2>
    <p>Der <code>ZoneManager</code> ist eine zentrale Verwaltungskomponente für Gebietsdefinitionen (Zones) innerhalb des RPG-Plugins. Er ist verantwortlich für das Laden, Speichern und Abfragen von Zonen-Daten aus einer YAML-Konfigurationsdatei (<code>zones.yml</code>).</p>

    <h3>Klasse: ZoneManager</h3>
    <p>Diese Klasse verwaltet eine Sammlung von <code>Zone</code>-Objekten und bietet Methoden zur räumlichen Abfrage von Standorten innerhalb der Spielwelt.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>ZoneManager(JavaPlugin plugin)</code>: Initialisiert den Manager, erstellt die Referenz zur <code>zones.yml</code> im Datenordner des Plugins und lädt die vorhandenen Zonen in den Speicher.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public Map&lt;String, Zone&gt; zones()</code>
            <p>Gibt eine Map aller aktuell geladenen Zonen zurück, wobei die ID der Zone als Schlüssel dient.</p>
            <p><strong>Rückgabewert:</strong> Eine Map von Zonen-IDs zu <code>Zone</code>-Objekten.</p>
        </li>
        <li>
            <code>public Zone getZone(String id)</code>
            <p>Sucht eine spezifische Zone anhand ihrer eindeutigen ID.</p>
            <p><strong>Parameter:</strong> <code>id</code> - Die ID der gesuchten Zone.</p>
            <p><strong>Rückgabewert:</strong> Das <code>Zone</code>-Objekt oder <code>null</code>, falls keine Zone mit dieser ID existiert.</p>
        </li>
        <li>
            <code>public Zone getZoneAt(Location location)</code>
            <p>Ermittelt, in welcher Zone sich ein bestimmter Standort in der Welt befindet.</p>
            <p><strong>Parameter:</strong> <code>location</code> - Der zu prüfende Bukkit-Standort.</p>
            <p><strong>Rückgabewert:</strong> Die erste Zone, die den Standort umschließt, oder <code>null</code>, wenn der Standort in keiner definierten Zone liegt.</p>
        </li>
        <li>
            <code>public void saveZone(Zone zone)</code>
            <p>Speichert oder aktualisiert eine einzelne Zone in der Konfigurationsdatei. Dabei werden Attribute wie Name, Welt, Level-Bereich, Multiplikatoren und Koordinaten (x1, y1, z1 bis x2, y2, z2) serialisiert.</p>
            <p><strong>Parameter:</strong> <code>zone</code> - Das zu speichernde Zonen-Objekt.</p>
        </li>
        <li>
            <code>public void saveAll()</code>
            <p>Bereinigt die aktuelle Konfiguration und speichert alle im Speicher befindlichen Zonen erneut in die Datei.</p>
        </li>
        <li>
            <code>private void load()</code>
            <p>Interne Methode zum Einlesen der Zonen-Daten aus der <code>zones.yml</code>. Sie füllt die interne Map mit <code>Zone</code>-Instanzen und setzt Standardwerte für fehlende Felder (z.B. Level 1-60, Multiplikator 1.0).</p>
        </li>
        <li>
            <code>private void save()</code>
            <p>Schreibt den aktuellen Stand der <code>YamlConfiguration</code> physisch auf die Festplatte. Fehler beim Schreibvorgang werden im Plugin-Log protokolliert.</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/Arena.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/Arena.java</h2>
    <p>
        Die Klasse <code>Arena</code> ist ein Datenmodell, das eine Kampfarena innerhalb des RPG-Systems repräsentiert. 
        Sie speichert Informationen über die räumlichen Grenzen der Arena, die Startpunkte für zwei Spieler sowie den aktuellen Status und die Teilnehmer eines Duells.
    </p>

    <h3>Klasse: Arena</h3>
    <p>
        Diese Klasse dient als Container für alle relevanten Daten einer Arena-Instanz. Sie wird primär vom <code>ArenaManager</code> verwaltet.
    </p>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>Arena(String id)</code>: Erstellt eine neue Arena-Instanz mit einer eindeutigen Identifikationsnummer.
        </li>
    </ul>

    <h4>Eigenschaften (Felder)</h4>
    <ul>
        <li><code>id</code>: Eindeutiger Bezeichner der Arena (String).</li>
        <li><code>world</code>: Der Name der Welt, in der sich die Arena befindet.</li>
        <li><code>x1, y1, z1</code>: Die Koordinaten der ersten Ecke des Arena-Bereichs.</li>
        <li><code>x2, y2, z2</code>: Die Koordinaten der gegenüberliegenden Ecke des Arena-Bereichs.</li>
        <li><code>spawn1x, spawn1y, spawn1z</code>: Die Koordinaten des Startpunkts für den ersten Spieler.</li>
        <li><code>spawn2x, spawn2y, spawn2z</code>: Die Koordinaten des Startpunkts für den zweiten Spieler.</li>
        <li><code>status</code>: Der aktuelle Zustand der Arena (Standard: <code>ArenaStatus.WAITING</code>).</li>
        <li><code>playerOne</code>: Die UUID des ersten Teilnehmers.</li>
        <li><code>playerTwo</code>: Die UUID des zweiten Teilnehmers.</li>
    </ul>

    <h4>Wichtige Methoden</h4>
    <ul>
        <li>
            <code>id()</code>: Gibt die ID der Arena zurück.
            <br><strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>status()</code> / <code>setStatus(ArenaStatus status)</code>: Getter und Setter für den aktuellen Status der Arena (z. B. wartend, kämpfend).
        </li>
        <li>
            <code>playerOne()</code> / <code>setPlayerOne(UUID playerOne)</code>: Verwaltet die Identität des ersten Spielers in der Arena.
        </li>
        <li>
            <code>playerTwo()</code> / <code>setPlayerTwo(UUID playerTwo)</code>: Verwaltet die Identität des zweiten Spielers in der Arena.
        </li>
        <li>
            <code>setWorld(String world)</code>: Legt fest, in welcher Spielwelt die Arena-Koordinaten gültig sind.
        </li>
        <li>
            <code>setX1, setY1, setZ1 / setX2, setY2, setZ2</code>: Methoden zur Definition der räumlichen Ausdehnung der Arena.
        </li>
        <li>
            <code>setSpawn1x, setSpawn1y, setSpawn1z / setSpawn2x, setSpawn2y, setSpawn2z</code>: Methoden zur Festlegung der exakten Teleport-Punkte für die Duellanten.
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/ArenaStatus.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/ArenaStatus.java</h2>

    <p>
        Die Datei <code>ArenaStatus.java</code> definiert eine Enumeration (<code>enum</code>), die den aktuellen Lebenszyklus-Zustand einer Arena innerhalb des RPG-Systems repräsentiert. Diese Zustände werden primär vom <code>ArenaManager</code> verwendet, um den Spielablauf zu steuern.
    </p>

    <h3>ArenaStatus (Enum)</h3>
    <p>
        Dieses Enum dient zur Kennzeichnung, in welcher Phase sich eine spezifische Arena-Instanz befindet.
    </p>

    <h4>Aufzählungswerte:</h4>
    <ul>
        <li>
            <code>WAITING</code>: Die Arena befindet sich im Wartezustand. Dies bedeutet in der Regel, dass auf weitere Spieler gewartet wird oder ein Start-Countdown läuft.
        </li>
        <li>
            <code>FIGHTING</code>: Der Kampf ist aktiv. In diesem Zustand findet das eigentliche Spielgeschehen statt, und Interaktionen wie Schaden oder Zielerreichung werden verarbeitet.
        </li>
        <li>
            <code>ENDING</code>: Die Kampfphase ist abgeschlossen. Dieser Zustand wird für die Nachbereitung genutzt, wie zum Beispiel das Verteilen von Belohnungen, das Anzeigen von Statistiken oder das Zurücksetzen der Arena-Umgebung.
        </li>
    </ul>

    <h4>Verwendung:</h4>
    <p>
        Die Zustände ermöglichen es anderen Systemen (wie dem <code>ArenaListener</code>), Entscheidungen basierend auf dem aktuellen Status zu treffen (z. B. den Beitritt zu verhindern, wenn der Status bereits auf <code>FIGHTING</code> steht).
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/AuctionListing.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/AuctionListing.java</h2>
    <p>
        Die Klasse <code>AuctionListing</code> ist ein Datenmodell innerhalb des RPG-Plugins, das ein einzelnes Angebot im Auktionshaus repräsentiert. 
        Sie dient als Container für Informationen über den Verkäufer, den Gegenstand und den festgelegten Preis.
    </p>

    <h3>Klasse: AuctionListing</h3>
    <p>
        Diese Klasse speichert die Metadaten einer aktiven Auktion. Sie wird primär vom <code>AuctionHouseManager</code> verwendet, 
        um Transaktionen zwischen Spielern zu verwalten.
    </p>

    <h4>Attribute</h4>
    <ul>
        <li><code>id</code> (String): Eine eindeutige Kennung für das Auktionsangebot.</li>
        <li><code>seller</code> (UUID): Die Unique ID des Spielers, der den Gegenstand zum Verkauf anbietet.</li>
        <li><code>itemData</code> (String): Eine serialisierte Repräsentation des Gegenstands (z. B. Base64-kodierte NBT-Daten).</li>
        <li><code>price</code> (int): Der geforderte Kaufpreis in der Spielwährung.</li>
    </ul>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>AuctionListing(String id)</code>: Erstellt ein neues Auktionsangebot mit der angegebenen ID.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>id()</code>: Gibt die eindeutige ID des Angebots zurück.
            <br><strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>seller()</code>: Gibt die UUID des Verkäufers zurück.
            <br><strong>Rückgabewert:</strong> <code>UUID</code>
        </li>
        <li>
            <code>setSeller(UUID seller)</code>: Legt den Verkäufer für dieses Angebot fest.
            <br><strong>Parameter:</strong> <code>UUID seller</code>
        </li>
        <li>
            <code>itemData()</code>: Gibt die serialisierten Daten des angebotenen Gegenstands zurück.
            <br><strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>setItemData(String itemData)</code>: Speichert die serialisierten Gegenstandsdaten.
            <br><strong>Parameter:</strong> <code>String itemData</code>
        </li>
        <li>
            <code>price()</code>: Gibt den aktuellen Preis des Angebots zurück.
            <br><strong>Rückgabewert:</strong> <code>int</code>
        </li>
        <li>
            <code>setPrice(int price)</code>: Legt den Verkaufspreis für den Gegenstand fest.
            <br><strong>Parameter:</strong> <code>int price</code>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/BuildingCategory.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/BuildingCategory.java</h2>
    <p>
        Die Datei <code>BuildingCategory.java</code> definiert ein Enum, das die verschiedenen Kategorien von Gebäuden innerhalb des RPG-Systems festlegt. Diese Kategorien dienen zur Klassifizierung von Bauwerken, beispielsweise für das Baumanagement oder die Anzeige in Benutzeroberflächen.
    </p>

    <h3>Enum: BuildingCategory</h3>
    <p>Das Enum enthält vordefinierte Gebäudetypen mit zugehörigen Anzeigenamen.</p>

    <h4>Aufzählungswerte:</h4>
    <ul>
        <li><code>RESIDENTIAL</code>: Repräsentiert Wohngebäude.</li>
        <li><code>SHOP</code>: Repräsentiert Geschäfte und Handelsgebäude.</li>
        <li><code>PUBLIC</code>: Repräsentiert öffentliche Einrichtungen.</li>
        <li><code>CRAFTING</code>: Repräsentiert Gebäude für die Herstellung (Handwerk).</li>
    </ul>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>displayName()</code>: 
            Gibt den lesbaren, deutschsprachigen Namen der Kategorie zurück (z. B. "Wohngebäude").
            <br><strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>fromString(String raw)</code>: 
            Eine statische Hilfsmethode, die versucht, einen String in eine entsprechende <code>BuildingCategory</code> umzuwandeln. 
            Dabei wird die Eingabe normalisiert (Großschreibung, Entfernen von Leerzeichen).
            <ul>
                <li><strong>Parameter:</strong> <code>raw</code> (String) - Der zu prüfende Text.</li>
                <li><strong>Rückgabewert:</strong> Die gefundene <code>BuildingCategory</code>. Falls kein Treffer erzielt wird oder der Eingabewert <code>null</code> ist, wird standardmäßig <code>RESIDENTIAL</code> zurückgegeben.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/BuildingDefinition.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/BuildingDefinition.java</h2>
    <p>
        Die Klasse <code>BuildingDefinition</code> ist ein Datenmodell, das die Struktur und die Eigenschaften eines Gebäudes innerhalb des RPG-Systems definiert. 
        Sie dient als Vorlage für die Generierung von Gebäuden, basierend auf Schematics (Bauplänen), und unterstützt Konzepte wie variable Stockwerke, Kellergeschosse und Inneneinrichtung.
    </p>

    <h3>Klasse: BuildingDefinition</h3>
    <p>
        Diese Klasse speichert Konfigurationsdaten für Gebäude, einschließlich der Pfade zu den Schematic-Dateien und räumlicher Offsets.
    </p>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>BuildingDefinition(String id)</code>: Erstellt eine neue Gebäudedefinition mit einer eindeutigen ID. Standardmäßig wird der Name auf die ID gesetzt.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li><code>id()</code>: Gibt die eindeutige Kennung des Gebäudes zurück.</li>
        <li><code>name()</code> / <code>setName(String name)</code>: Getter und Setter für den Anzeigenamen des Gebäudes.</li>
        <li><code>category()</code> / <code>setCategory(BuildingCategory category)</code>: Definiert den Gebäudetyp (z. B. Wohngebäude), basierend auf dem Enum <code>BuildingCategory</code>.</li>
        <li><code>schematic()</code> / <code>setSchematic(String schematic)</code>: Der Pfad oder Name der Haupt-Schematic-Datei für das Gebäude.</li>
        <li><code>floorSchematic()</code> / <code>setFloorSchematic(String floorSchematic)</code>: Die Schematic-Datei, die für zusätzliche Stockwerke verwendet wird.</li>
        <li><code>minFloors()</code> / <code>maxFloors()</code>: Definiert den Bereich der möglichen Stockwerkanzahl für die prozedurale Generierung.</li>
        <li><code>floorHeight()</code>: Gibt die Höhe eines einzelnen Stockwerks in Blöcken an.</li>
        <li><code>basementSchematic()</code> / <code>basementDepth()</code>: Konfiguration für ein optionales Kellergeschoss und dessen Tiefe.</li>
        <li><code>includeAir()</code>: Bestimmt, ob Luftblöcke aus der Schematic beim Platzieren mitkopiert werden sollen (wichtig für Innenräume).</li>
        <li><code>offsetX()</code>, <code>offsetY()</code>, <code>offsetZ()</code>: Gibt die Verschiebungskoordinaten relativ zum Platzierungspunkt zurück.</li>
        <li><code>setOffset(int x, int y, int z)</code>: Setzt die räumlichen Offsets für die korrekte Ausrichtung des Gebäudes in der Welt.</li>
        <li><code>furniture()</code>: Gibt eine unveränderliche Liste (<code>UnmodifiableList</code>) der zugehörigen <code>FurnitureDefinition</code>-Objekte zurück.</li>
        <li><code>addFurniture(FurnitureDefinition furnitureDefinition)</code>: Fügt der Gebäudedefinition ein neues Einrichtungsobjekt hinzu.</li>
    </ul>

    <h4>Eigenschaften (Felder)</h4>
    <ul>
        <li><code>id</code>: Eindeutiger String-Bezeichner.</li>
        <li><code>category</code>: Standardmäßig auf <code>BuildingCategory.RESIDENTIAL</code> gesetzt.</li>
        <li><code>minFloors</code> / <code>maxFloors</code>: Standardwert ist 1.</li>
        <li><code>floorHeight</code>: Standardwert ist 5 Blöcke.</li>
        <li><code>furniture</code>: Eine Liste von Definitionen für Möbel oder Dekorationen, die innerhalb des Gebäudes platziert werden.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/ClassDefinition.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/ClassDefinition.java</h2>

    <p>Die Klasse <code>ClassDefinition</code> ist ein Datenmodell innerhalb des RPG-Plugins, das die grundlegenden Eigenschaften einer Charakterklasse (z. B. Krieger, Magier) definiert. Sie dient als Vorlage für die Initialisierung von Spielercharakteren und legt fest, welche Fähigkeiten eine Klasse von Beginn an besitzt.</p>

    <h3>Klassenübersicht</h3>
    <p><strong>Name:</strong> <code>ClassDefinition</code></p>
    <p><strong>Paket:</strong> <code>com.example.rpg.model</code></p>
    <p><strong>Beschreibung:</strong> Repräsentiert eine Rollenspiel-Klassendefinition mit einer eindeutigen ID, einem Anzeigenamen und einer Liste von Start-Skills.</p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>public ClassDefinition(String id)</code>: Erzeugt eine neue Klassendefinition mit der angegebenen technischen ID.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public String id()</code>
            <p>Gibt die eindeutige technische Identifikation (ID) der Klasse zurück.</p>
            <p><strong>Rückgabewert:</strong> Die ID als <code>String</code>.</p>
        </li>
        <li>
            <code>public String name()</code>
            <p>Gibt den lesbaren Anzeigenamen der Klasse zurück.</p>
            <p><strong>Rückgabewert:</strong> Der Name als <code>String</code>.</p>
        </li>
        <li>
            <code>public void setName(String name)</code>
            <p>Legt den Anzeigenamen der Klasse fest.</p>
            <p><strong>Parameter:</strong> <code>name</code> - Der neue Anzeigename.</p>
        </li>
        <li>
            <code>public List&lt;String&gt; startSkills()</code>
            <p>Gibt eine Liste der Skill-IDs zurück, die ein Spieler automatisch erhält, wenn er diese Klasse wählt.</p>
            <p><strong>Rückgabewert:</strong> Eine <code>List</code> von <code>String</code>-Objekten (Skill-IDs).</p>
        </li>
        <li>
            <code>public void setStartSkills(List&lt;String&gt; startSkills)</code>
            <p>Definiert die Liste der Start-Fähigkeiten für diese Klasse.</p>
            <p><strong>Parameter:</strong> <code>startSkills</code> - Eine Liste von Skill-IDs.</p>
        </li>
    </ul>

    <h3>Eigenschaften (Felder)</h3>
    <ul>
        <li><code>id</code>: Eindeutiger Bezeichner (final).</li>
        <li><code>name</code>: Der Name der Klasse für die Benutzeroberfläche.</li>
        <li><code>startSkills</code>: Eine Liste von Strings, die auf die initialen Fähigkeiten verweisen.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/CraftingOrder.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/CraftingOrder.java</h2>

    <p>Die Klasse <code>CraftingOrder</code> ist ein Datenmodell innerhalb des RPG-Plugins, das einen Handwerksauftrag (Crafting Order) repräsentiert. Diese Aufträge ermöglichen es Spielern oder NPCs, spezifische Materialien gegen eine Goldbelohnung anzufordern.</p>

    <h3>Klassenbeschreibung</h3>
    <p>
        Diese Klasse fungiert als POJO (Plain Old Java Object) zur Speicherung von Auftragsdetails. Sie verknüpft einen Auftraggeber mit einer Materialanforderung und einer entsprechenden Belohnung.
    </p>

    <h3>Attribute</h3>
    <ul>
        <li><code>id</code> (String): Eine eindeutige Kennung für den Handwerksauftrag.</li>
        <li><code>requester</code> (UUID): Die Unique ID des Spielers oder NPCs, der den Auftrag erstellt hat.</li>
        <li><code>material</code> (String): Die Bezeichnung oder ID des Materials, das hergestellt oder geliefert werden soll.</li>
        <li><code>amount</code> (int): Die Menge des benötigten Materials.</li>
        <li><code>rewardGold</code> (int): Die Menge an Gold, die als Belohnung für den Abschluss des Auftrags ausgezahlt wird.</li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>CraftingOrder(String id)</code>
            <p>Konstruktor zur Initialisierung eines neuen Auftrags mit einer spezifischen ID.</p>
        </li>
        <li>
            <code>id()</code>
            <p>Gibt die eindeutige ID des Auftrags zurück. (Rückgabewert: <code>String</code>)</p>
        </li>
        <li>
            <code>requester()</code> / <code>setRequester(UUID requester)</code>
            <p>Getter und Setter für die UUID des Auftraggebers.</p>
        </li>
        <li>
            <code>material()</code> / <code>setMaterial(String material)</code>
            <p>Getter und Setter für den Materialnamen oder die Material-ID.</p>
        </li>
        <li>
            <code>amount()</code> / <code>setAmount(int amount)</code>
            <p>Getter und Setter für die Anzahl der benötigten Gegenstände.</p>
        </li>
        <li>
            <code>rewardGold()</code> / <code>setRewardGold(int rewardGold)</code>
            <p>Getter und Setter für die Goldbelohnung, die mit diesem Auftrag verknüpft ist.</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/DialogueNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/DialogueNode.java</h2>

    <p>
        Die Klasse <code>DialogueNode</code> ist ein zentrales Datenmodell innerhalb des RPG-Plugins. Sie repräsentiert einen einzelnen Zustand oder "Knoten" innerhalb eines Dialogbaums zwischen einem Spieler und einem NPC.
    </p>

    <h3>Klasse: DialogueNode</h3>
    <p>
        Diese Klasse speichert den Text, den ein NPC in einem bestimmten Moment sagt, sowie die möglichen Interaktionsoptionen, die dem Spieler zur Verfügung stehen.
    </p>

    <h4>Attribute</h4>
    <ul>
        <li><code>id</code> (String): Eine eindeutige Kennung für diesen Dialogknoten, um ihn innerhalb eines Dialogsystems referenzieren zu können.</li>
        <li><code>text</code> (String): Der eigentliche Textinhalt, der dem Spieler angezeigt wird.</li>
        <li><code>options</code> (List&lt;DialogueOption&gt;): Eine Liste von Antwortmöglichkeiten oder Aktionen, die von diesem Knoten ausgehen.</li>
    </ul>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>DialogueNode(String id)</code>: Erzeugt eine neue Instanz des Dialogknotens mit der angegebenen ID. Die Liste der Optionen wird initial als leere <code>ArrayList</code> erstellt.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>id()</code>: 
            <strong>Rückgabewert:</strong> <code>String</code> – Gibt die eindeutige ID des Knotens zurück.
        </li>
        <li>
            <code>text()</code>: 
            <strong>Rückgabewert:</strong> <code>String</code> – Gibt den aktuell gesetzten Dialogtext zurück.
        </li>
        <li>
            <code>setText(String text)</code>: 
            <strong>Parameter:</strong> <code>String text</code> – Setzt oder aktualisiert den Text, den der NPC in diesem Knoten spricht.
        </li>
        <li>
            <code>options()</code>: 
            <strong>Rückgabewert:</strong> <code>List&lt;DialogueOption&gt;</code> – Gibt die Liste der verfügbaren <code>DialogueOption</code>-Objekte zurück, die an diesen Knoten gebunden sind.
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/DialogueOption.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/DialogueOption.java</h2>
    <p>
        Die Klasse <code>DialogueOption</code> ist ein Datenmodell innerhalb des RPG-Systems, das eine einzelne Antwortmöglichkeit oder Auswahl innerhalb eines Dialogbaums repräsentiert. Sie verknüpft den für den Spieler sichtbaren Text mit Logik-Bedingungen und Folgeereignissen.
    </p>

    <h3>Klasse: DialogueOption</h3>
    <p>
        Diese Klasse dient als Container für Informationen über Dialogentscheidungen, einschließlich Voraussetzungen (wie Fraktionsruf oder Queststatus) und Konsequenzen (wie das Starten einer neuen Quest).
    </p>

    <h4>Eigenschaften (Felder)</h4>
    <ul>
        <li><code>text</code>: Der Text der Dialogoption, der dem Spieler angezeigt wird.</li>
        <li><code>nextId</code>: Die ID des nächsten <code>DialogueNode</code>, der geladen wird, wenn diese Option gewählt wird.</li>
        <li><code>requiredFactionId</code>: Die ID einer Fraktion, die benötigt wird, um diese Option freizuschalten.</li>
        <li><code>minRep</code>: Der minimale Rufwert, den der Spieler bei der angegebenen Fraktion benötigt.</li>
        <li><code>requiredQuestId</code>: Die ID einer Quest, die als Bedingung für diese Option dient.</li>
        <li><code>requireQuestCompleted</code>: Ein Boolean, der angibt, ob die oben genannte Quest abgeschlossen sein muss (true) oder lediglich aktiv sein darf (false).</li>
        <li><code>grantQuestId</code>: Die ID einer Quest, die dem Spieler beim Wählen dieser Option automatisch zugewiesen wird.</li>
    </ul>

    <h4>Methoden</h4>
    <p>Die Klasse implementiert Standard-Getter und Setter für alle oben genannten Felder. Die Getter folgen dabei einer Namenskonvention ohne das Präfix "get" (z.B. <code>text()</code> statt <code>getText()</code>).</p>
    
    <ul>
        <li><code>text()</code> / <code>setText(String text)</code>: Zugriff auf den Anzeigetext.</li>
        <li><code>nextId()</code> / <code>setNextId(String nextId)</code>: Steuerung des Dialogflusses.</li>
        <li><code>requiredFactionId()</code> / <code>setRequiredFactionId(String id)</code>: Verwaltung von Fraktionsvoraussetzungen.</li>
        <li><code>minRep()</code> / <code>setMinRep(int minRep)</code>: Verwaltung der Ruf-Schwelle.</li>
        <li><code>requiredQuestId()</code> / <code>setRequiredQuestId(String id)</code>: Verknüpfung mit Quest-Bedingungen.</li>
        <li><code>requireQuestCompleted()</code> / <code>setRequireQuestCompleted(boolean completed)</code>: Spezifizierung des benötigten Quest-Status.</li>
        <li><code>grantQuestId()</code> / <code>setGrantQuestId(String id)</code>: Vergabe von Quests durch Dialoge.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/EnchantmentRecipe.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/EnchantmentRecipe.java</h2>
    <p>
        Die Klasse <code>EnchantmentRecipe</code> ist ein Datenmodell innerhalb des RPG-Plugins, das die Definition für ein Verzauberungsrezept bereitstellt. 
        Es verknüpft Anforderungen (wie Kosten und Level) mit den resultierenden Effekten und Attributverbesserungen, die auf einen Gegenstand angewendet werden können.
    </p>

    <h3>Klasse: EnchantmentRecipe</h3>
    <p>
        Diese Klasse dient als Container für alle Informationen, die notwendig sind, um eine Verzauberung an einem Ausrüstungsgegenstand durchzuführen.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>EnchantmentRecipe(String id)</code>: Erstellt ein neues Rezept mit einer eindeutigen Identifikationsnummer.</li>
    </ul>

    <h4>Eigenschaften (Felder)</h4>
    <ul>
        <li><code>id</code> (String): Die eindeutige Kennung des Rezepts.</li>
        <li><code>type</code> (EnchantRecipeType): Der Typ der Verzauberung (z. B. Präfix, Suffix oder Basis-Verzauberung).</li>
        <li><code>targetSlot</code> (EnchantTargetSlot): Der Ausrüstungsslot, für den dieses Rezept gültig ist (z. B. Waffe, Helm, Brustplatte).</li>
        <li><code>statToImprove</code> (RPGStat): Das spezifische Attribut (z. B. Stärke, Intelligenz), das durch diese Verzauberung verbessert wird.</li>
        <li><code>minLevel</code> (int): Das erforderliche Mindestlevel des Spielers, um dieses Rezept nutzen zu können.</li>
        <li><code>costGold</code> (int): Die Kosten in Goldwährung.</li>
        <li><code>costMaterial</code> (Material): Ein spezifisches Bukkit-Material (Item), das als Handwerkskomponente benötigt wird.</li>
        <li><code>costAmount</code> (int): Die Menge des benötigten Materials.</li>
        <li><code>affix</code> (String): Der Textzusatz, der dem Namen des Gegenstands hinzugefügt wird (z. B. "des Feuers").</li>
        <li><code>effects</code> (List&lt;SkillEffectConfig&gt;): Eine Liste von speziellen Effekten oder Fähigkeiten, die dem Gegenstand durch die Verzauberung verliehen werden.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li><code>id()</code>: Gibt die ID des Rezepts zurück.</li>
        <li><code>type()</code> / <code>setType(EnchantRecipeType type)</code>: Getter und Setter für den Rezepttyp.</li>
        <li><code>targetSlot()</code> / <code>setTargetSlot(EnchantTargetSlot targetSlot)</code>: Getter und Setter für den Ziel-Slot.</li>
        <li><code>statToImprove()</code> / <code>setStatToImprove(RPGStat statToImprove)</code>: Getter und Setter für das zu verbessernde Attribut.</li>
        <li><code>minLevel()</code> / <code>setMinLevel(int minLevel)</code>: Getter und Setter für die Levelvoraussetzung.</li>
        <li><code>costGold()</code> / <code>setCostGold(int costGold)</code>: Getter und Setter für die Goldkosten.</li>
        <li><code>costMaterial()</code> / <code>setCostMaterial(Material costMaterial)</code>: Getter und Setter für den Materialtyp.</li>
        <li><code>costAmount()</code> / <code>setCostAmount(int costAmount)</code>: Getter und Setter für die Materialmenge.</li>
        <li><code>affix()</code> / <code>setAffix(String affix)</code>: Getter und Setter für den Namenszusatz.</li>
        <li><code>effects()</code>: Gibt die Liste der konfigurierten Skill-Effekte zurück.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/EnchantRecipeType.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/EnchantRecipeType.java</h2>

    <p>
        Die Enumeration <code>EnchantRecipeType</code> definiert die verschiedenen Arten von Verzauberungsrezepten, die innerhalb des RPG-Systems zur Modifikation von Gegenständen verwendet werden können.
    </p>

    <h3>EnchantRecipeType (Enum)</h3>
    <p>
        Dieser Typ wird primär in Verbindung mit der Klasse <code>EnchantmentRecipe</code> genutzt, um zu bestimmen, wie eine Verzauberung auf einen Gegenstand angewendet wird.
    </p>

    <h4>Aufzählungswerte:</h4>
    <ul>
        <li>
            <code>STAT_UPGRADE</code>: Repräsentiert ein Rezept, das bestehende Attribute oder Statistiken eines Gegenstands verbessert (z. B. Erhöhung der Angriffsstärke oder Verteidigung).
        </li>
        <li>
            <code>AFFIX</code>: Repräsentiert ein Rezept, das einem Gegenstand ein neues Affix (Präfix oder Suffix) hinzufügt, welches oft spezielle Effekte oder zusätzliche Eigenschaften verleiht.
        </li>
    </ul>

    <h4>Zusammenhang im System:</h4>
    <p>
        Diese Unterscheidung ermöglicht es dem <code>EnchantManager</code>, unterschiedliche Logiken für die Verarbeitung von Upgrades und das Hinzufügen neuer Eigenschaften anzuwenden. Während ein Stat-Upgrade oft auf bestehenden Werten basiert, generiert ein Affix meist neue Datenfelder auf dem Item-Metadaten-Stack.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/EnchantTargetSlot.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/EnchantTargetSlot.java</h2>

    <p>
        Die Enumeration <code>EnchantTargetSlot</code> definiert die gültigen Ausrüstungsplätze (Slots), auf die Verzauberungen in der RPG-Umgebung angewendet werden können. 
        Sie dient primär der Validierung, ob ein bestimmter Gegenstand (ItemStack) für einen spezifischen Slot geeignet ist.
    </p>

    <h3>Enum-Konstanten</h3>
    <ul>
        <li><code>HAND</code>: Der Haupt-Hand-Slot.</li>
        <li><code>OFF_HAND</code>: Der Neben-Hand-Slot.</li>
        <li><code>ARMOR_HEAD</code>: Der Kopf-Slot (Helme, Köpfe).</li>
        <li><code>ARMOR_CHEST</code>: Der Brust-Slot (Brustplatten).</li>
        <li><code>ARMOR_LEGS</code>: Der Bein-Slot (Beinschienen).</li>
        <li><code>ARMOR_FEET</code>: Der Fuß-Slot (Stiefel).</li>
        <li><code>SHIELD</code>: Spezifisch für Schilde.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>matches(ItemStack item)</code></h4>
    <p>
        Prüft, ob ein übergebener Gegenstand mit dem jeweiligen Slot-Typ kompatibel ist. Diese Methode nutzt die Materialnamen der Bukkit-API, um die Eignung festzustellen.
    </p>
    <ul>
        <li><strong>Parameter:</strong> 
            <ul>
                <li><code>item</code> (ItemStack): Der zu prüfende Gegenstand.</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> 
            <code>boolean</code> - Gibt <code>true</code> zurück, wenn der Gegenstand in den Slot passt, andernfalls <code>false</code>.
        </li>
        <li><strong>Logik:</strong>
            <ul>
                <li>Gibt <code>false</code> zurück, wenn das Item <code>null</code> oder Luft ist.</li>
                <li><code>HAND</code> / <code>OFF_HAND</code>: Akzeptiert generell alle Items (<code>true</code>).</li>
                <li><code>SHIELD</code>: Prüft explizit auf <code>Material.SHIELD</code>.</li>
                <li><code>ARMOR_HEAD</code>: Prüft, ob der Materialname auf "HELMET", "HEAD" oder "SKULL" endet.</li>
                <li><code>ARMOR_CHEST</code>: Prüft auf die Endung "CHESTPLATE".</li>
                <li><code>ARMOR_LEGS</code>: Prüft auf die Endung "LEGGINGS".</li>
                <li><code>ARMOR_FEET</code>: Prüft auf die Endung "BOOTS".</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/Faction.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/Faction.java</h2>
    <p>Die Klasse <code>Faction</code> repräsentiert eine Fraktion innerhalb des RPG-Systems. Sie dient als Datenmodell zur Verwaltung von Fraktionsnamen, Identifikatoren und den zugehörigen Rängen, die ein Spieler basierend auf seinem Ruf (Reputation) erreichen kann.</p>

    <h3>Klasse: Faction</h3>
    <p>Diese Klasse kapselt die Informationen einer Fraktion und bietet Logik zur Ermittlung des passenden Ranges basierend auf einem numerischen Ruf-Wert.</p>

    <h4>Attribute</h4>
    <ul>
        <li><code>id</code> (String): Eindeutige Kennung der Fraktion (final).</li>
        <li><code>name</code> (String): Der Anzeigename der Fraktion.</li>
        <li><code>ranks</code> (List&lt;FactionRank&gt;): Eine Liste der verfügbaren Ränge innerhalb dieser Fraktion.</li>
    </ul>

    <h4>Konstruktoren</h4>
    <ul>
        <li><code>Faction(String id)</code>: Erstellt eine neue Fraktion mit der angegebenen ID.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li><code>id()</code>: Gibt die eindeutige ID der Fraktion zurück.
            <ul>
                <li><strong>Rückgabewert:</strong> <code>String</code></li>
            </ul>
        </li>
        <li><code>name()</code>: Gibt den Namen der Fraktion zurück.
            <ul>
                <li><strong>Rückgabewert:</strong> <code>String</code></li>
            </ul>
        </li>
        <li><code>setName(String name)</code>: Setzt den Namen der Fraktion.</li>
        <li><code>ranks()</code>: Gibt die Liste aller Ränge dieser Fraktion zurück.
            <ul>
                <li><strong>Rückgabewert:</strong> <code>List&lt;FactionRank&gt;</code></li>
            </ul>
        </li>
        <li><code>setRanks(List&lt;FactionRank&gt; ranks)</code>: Weist der Fraktion eine Liste von Rängen zu.</li>
        <li><code>rankForRep(int rep)</code>: Ermittelt den höchsten Rang, den ein Spieler mit dem angegebenen Ruf-Wert (Reputation) erreicht hat.
            <ul>
                <li><strong>Parameter:</strong> <code>rep</code> (int) - Der aktuelle Ruf-Wert des Spielers.</li>
                <li><strong>Logik:</strong> Die Methode iteriert durch alle Ränge und gibt denjenigen zurück, dessen Mindestanforderung (<code>minRep</code>) erfüllt ist und der von allen erfüllten Anforderungen die höchste ist.</li>
                <li><strong>Rückgabewert:</strong> <code>FactionRank</code> - Der zutreffende Rang oder <code>null</code>, falls kein Rang erreicht wurde.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/FactionRank.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/FactionRank.java</h2>
    <p>
        Die Klasse <code>FactionRank</code> repräsentiert einen spezifischen Rang innerhalb einer Fraktion im RPG-System. 
        Sie definiert die Voraussetzungen (wie benötigter Ruf) und die Vorteile (wie Rabatte oder Berechtigungen), 
        die ein Spieler erhält, wenn er diesen Rang erreicht.
    </p>

    <h3>Klasse: FactionRank</h3>
    <p>
        Diese Klasse dient als Datenmodell für die verschiedenen Stufen eines Fraktionssystems.
    </p>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>FactionRank(String id)</code>: Erstellt eine neue Instanz eines Fraktionsrangs mit der angegebenen eindeutigen ID.
        </li>
    </ul>

    <h4>Eigenschaften (Felder)</h4>
    <ul>
        <li><code>id</code> (String): Die eindeutige Kennung des Rangs (final).</li>
        <li><code>name</code> (String): Der Anzeigename des Rangs (z. B. "Rekrut", "Ehrenmitglied").</li>
        <li><code>minRep</code> (int): Die minimale Anzahl an Rufpunkten (Reputation), die erforderlich ist, um diesen Rang zu bekleiden.</li>
        <li><code>shopDiscount</code> (double): Ein prozentualer Rabatt (als Dezimalwert), den Mitglieder dieses Rangs in fraktionszugehörigen Läden erhalten.</li>
        <li><code>dungeonAccess</code> (boolean): Gibt an, ob dieser Rang den Zugriff auf spezifische fraktionsgebundene Dungeons erlaubt.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li><code>id()</code>: Gibt die ID des Rangs zurück. (Rückgabewert: <code>String</code>)</li>
        <li><code>name()</code> / <code>setName(String name)</code>: Getter und Setter für den Anzeigenamen des Rangs.</li>
        <li><code>minRep()</code> / <code>setMinRep(int minRep)</code>: Getter und Setter für die benötigte Mindestreputation.</li>
        <li><code>shopDiscount()</code> / <code>setShopDiscount(double shopDiscount)</code>: Getter und Setter für den Shop-Rabatt.</li>
        <li><code>dungeonAccess()</code> / <code>setDungeonAccess(boolean dungeonAccess)</code>: Getter und Setter für die Dungeon-Zugriffsberechtigung.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/FurnitureDefinition.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/FurnitureDefinition.java</h2>
    <p>Diese Datei definiert das Java-Record <code>FurnitureDefinition</code>. Es handelt sich um eine kompakte Datenstruktur, die zur Definition von Möbelobjekten innerhalb des RPG-Systems verwendet wird, insbesondere im Kontext von Gebäuden oder Dekorationen, die auf Schematics basieren.</p>

    <h3>FurnitureDefinition (Record)</h3>
    <p>
        Das Record <code>FurnitureDefinition</code> kapselt alle notwendigen Informationen, um ein Möbelstück aus einer Schematic-Datei zu laden und korrekt in der Welt zu positionieren. Da es als <code>record</code> implementiert ist, generiert Java automatisch die entsprechenden Konstruktoren, Getter sowie <code>equals</code>, <code>hashCode</code> und <code>toString</code> Methoden.
    </p>

    <h4>Komponenten (Felder):</h4>
    <ul>
        <li>
            <code>schematic</code> (String): 
            Der Name oder der Dateipfad der Schematic-Datei, die das dreidimensionale Modell des Möbelstücks enthält.
        </li>
        <li>
            <code>offsetX</code> (int): 
            Der Versatz auf der X-Achse relativ zum Referenzpunkt der Platzierung.
        </li>
        <li>
            <code>offsetY</code> (int): 
            Der Versatz auf der Y-Achse (Höhenachse) relativ zum Referenzpunkt der Platzierung.
        </li>
        <li>
            <code>offsetZ</code> (int): 
            Der Versatz auf der Z-Achse relativ zum Referenzpunkt der Platzierung.
        </li>
        <li>
            <code>rotation</code> (int): 
            Der Rotationswert (üblicherweise in 90-Grad-Schritten oder Grad angegeben), der beim Platzieren des Objekts angewendet werden soll.
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/Guild.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/Guild.java</h2>
    <p>
        Die Klasse <code>Guild</code> repräsentiert eine Gilde innerhalb des RPG-Systems. Sie dient als Datenmodell für die Verwaltung von Gildenmitgliedern, Finanzen, Quests und dem Gildenhaus (Guild Hall) inklusive dessen Upgrades.
    </p>

    <h3>Klassenübersicht</h3>
    <p><strong>Name:</strong> <code>Guild</code></p>
    <p><strong>Paket:</strong> <code>com.example.rpg.model</code></p>
    <p><strong>Beschreibung:</strong> Ein zentrales Modell zur Speicherung aller relevanten Informationen einer Spielervereinigung.</p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>Guild(String id)</code>: Erstellt eine neue Gilden-Instanz mit einer eindeutigen Identifikationsnummer.
        </li>
    </ul>

    <h3>Methoden und Eigenschaften</h3>
    <ul>
        <li>
            <code>id()</code>: Gibt die eindeutige ID der Gilde zurück.
        </li>
        <li>
            <code>name()</code> / <code>setName(String name)</code>: Getter und Setter für den Anzeigenamen der Gilde.
        </li>
        <li>
            <code>leader()</code> / <code>setLeader(UUID leader)</code>: Verwaltet die <code>UUID</code> des Gildenleiters.
        </li>
        <li>
            <code>bankGold()</code> / <code>setBankGold(int bankGold)</code>: Verwaltet das Goldvermögen der Gilde. Der Setter stellt sicher, dass der Betrag nicht unter 0 sinkt.
        </li>
        <li>
            <code>members()</code>: Gibt eine <code>Map</code> zurück, die Spieler-UUIDs ihren jeweiligen Rollen (<code>GuildMemberRole</code>) innerhalb der Gilde zuordnet.
        </li>
        <li>
            <code>quests()</code>: Gibt eine <code>Map</code> der aktiven oder verfügbaren Gilden-Quests zurück.
        </li>
        <li>
            <code>setHall(String world, double x, double y, double z)</code>: Legt den Standort des Gildenhauses fest (Weltname und Koordinaten).
        </li>
        <li>
            <code>hallWorld()</code>, <code>hallX()</code>, <code>hallY()</code>, <code>hallZ()</code>: Getter für die Standortdaten des Gildenhauses.
        </li>
        <li>
            <code>hallUpgrades()</code>: Gibt eine <code>Map</code> zurück, die installierte Upgrades des Gildenhauses und deren jeweilige Stufe speichert.
        </li>
    </ul>

    <h3>Datenstrukturen</h3>
    <ul>
        <li><code>Map&lt;UUID, GuildMemberRole&gt; members</code>: Speicherung der Mitgliederstruktur.</li>
        <li><code>Map&lt;String, GuildQuest&gt; quests</code>: Verwaltung gildenbezogener Aufgaben.</li>
        <li><code>Map&lt;String, Integer&gt; hallUpgrades</code>: Tracking von Fortschritt und Ausbauten des Gildenstützpunktes.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildMemberRole.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildMemberRole.java</h2>

    <p>
        Die Datei <code>GuildMemberRole.java</code> definiert eine Enumeration (Aufzählungstyp), die die verschiedenen hierarchischen Rollen innerhalb eines Gilden-Systems im RPG-Plugin festlegt. Diese Rollen dienen zur Steuerung von Berechtigungen und Verantwortlichkeiten innerhalb einer Spielergilde.
    </p>

    <h3>Klasse: GuildMemberRole</h3>
    <p><strong>Typ:</strong> <code>enum</code></p>
    <p><strong>Zweck:</strong> Definition der Rangordnung und Rollentypen für Gildenmitglieder.</p>

    <h4>Verfügbare Rollen (Enum-Werte):</h4>
    <ul>
        <li>
            <code>LEADER</code>: 
            Repräsentiert den Gildenleiter. Dies ist in der Regel die höchste Instanz mit vollen administrativen Rechten über die Gilde, wie das Auflösen der Gilde oder das Ernennen von Offizieren.
        </li>
        <li>
            <code>OFFICER</code>: 
            Repräsentiert einen Offizier. Diese Rolle verfügt über erweiterte Rechte, um die Gildenleitung zu unterstützen, wie beispielsweise das Einladen oder Entfernen von einfachen Mitgliedern.
        </li>
        <li>
            <code>MEMBER</code>: 
            Repräsentiert ein reguläres Gildenmitglied. Dies ist der Standardrang für Spieler, die einer Gilde beitreten, mit Zugriff auf grundlegende Gildenfunktionen.
        </li>
    </ul>

    <h3>Zusammenhang im System</h3>
    <p>
        Diese Enumeration wird primär von der Klasse <code>Guild</code> und dem <code>GuildManager</code> verwendet, um den Status eines Spielers innerhalb der Gildenstruktur zu validieren und entsprechende Aktionen (z. B. über den <code>GuildCommand</code>) zu autorisieren.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildQuest.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildQuest.java</h2>
    <p>
        Die Klasse <code>GuildQuest</code> ist ein Datenmodell innerhalb des RPG-Plugins, das eine spezifische Quest für eine Gilde repräsentiert. 
        Sie dient dazu, den Fortschritt, die Ziele und den Status von gemeinschaftlichen Aufgaben zu verwalten.
    </p>

    <h3>Klasse: GuildQuest</h3>
    <p><strong>Beschreibung:</strong> Verwaltet die Zustandsdaten einer Gilden-Quest, einschließlich Identifikation, Fortschrittsanzeige und Abschlussstatus.</p>

    <h4>Felder / Eigenschaften</h4>
    <ul>
        <li><code>id</code> (String): Eindeutiger Identifikator der Quest (final).</li>
        <li><code>name</code> (String): Der Anzeigename der Quest.</li>
        <li><code>description</code> (String): Eine detaillierte Beschreibung der Quest-Aufgabe.</li>
        <li><code>goal</code> (int): Der Zielwert, der erreicht werden muss, um die Quest abzuschließen.</li>
        <li><code>progress</code> (int): Der aktuelle Fortschrittswert der Gilde.</li>
        <li><code>completed</code> (boolean): Gibt an, ob die Quest erfolgreich abgeschlossen wurde.</li>
    </ul>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>GuildQuest(String id)</code>: Erstellt eine neue Instanz einer Gilden-Quest mit der angegebenen ID.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li><code>id()</code>: Gibt die ID der Quest zurück.</li>
        <li><code>name()</code> / <code>setName(String name)</code>: Getter und Setter für den Quest-Namen.</li>
        <li><code>description()</code> / <code>setDescription(String description)</code>: Getter und Setter für die Quest-Beschreibung.</li>
        <li>
            <code>goal()</code> / <code>setGoal(int goal)</code>: 
            Verwaltet das Quest-Ziel. Der Setter stellt sicher, dass das Ziel mindestens den Wert 1 hat.
        </li>
        <li>
            <code>progress()</code> / <code>setProgress(int progress)</code>: 
            Verwaltet den aktuellen Fortschritt. Der Setter stellt sicher, dass der Fortschritt nicht unter 0 sinkt.
        </li>
        <li><code>completed()</code> / <code>setCompleted(boolean completed)</code>: Getter und Setter für den Abschlussstatus der Quest.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootEntry.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootEntry.java</h2>
    <p>Die Klasse <code>LootEntry</code> ist ein Datenmodell innerhalb des RPG-Plugins, das einen einzelnen Eintrag in einer Beutetabelle (Loot Table) definiert. Sie legt fest, welcher Gegenstand mit welcher Wahrscheinlichkeit und in welcher Menge fallen gelassen werden kann.</p>

    <h3>Klasse: LootEntry</h3>
    <p><strong>Beschreibung:</strong> Repräsentiert die Definition eines Beute-Gegenstands, einschließlich seiner Drop-Chancen und Mengenbeschränkungen.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>LootEntry(String material, double chance, int minAmount, int maxAmount, Rarity rarity)</code>: Initialisiert einen neuen Beute-Eintrag mit den angegebenen Werten für Material, Chance, Mindest- und Höchstmenge sowie Seltenheit.</li>
    </ul>

    <h4>Felder / Eigenschaften</h4>
    <ul>
        <li><code>material</code> (String): Der Bezeichner des Materials oder Gegenstands (z. B. Minecraft-Materialname).</li>
        <li><code>chance</code> (double): Die Wahrscheinlichkeit, mit der dieser Gegenstand generiert wird.</li>
        <li><code>minAmount</code> (int): Die minimale Anzahl an Gegenständen, die bei einem Drop erzeugt werden.</li>
        <li><code>maxAmount</code> (int): Die maximale Anzahl an Gegenständen, die bei einem Drop erzeugt werden.</li>
        <li><code>rarity</code> (Rarity): Der Seltenheitsgrad des Gegenstands (verweist auf das <code>Rarity</code>-Modell).</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li><code>material()</code> / <code>setMaterial(String material)</code>: Getter und Setter für den Materialnamen.</li>
        <li><code>chance()</code> / <code>setChance(double chance)</code>: Getter und Setter für die Drop-Wahrscheinlichkeit.</li>
        <li><code>minAmount()</code> / <code>setMinAmount(int minAmount)</code>: Getter und Setter für die Mindestmenge.</li>
        <li><code>maxAmount()</code> / <code>setMaxAmount(int maxAmount)</code>: Getter und Setter für die Maximalmenge.</li>
        <li><code>rarity()</code> / <code>setRarity(Rarity rarity)</code>: Getter und Setter für die Seltenheit des Eintrags.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootTable.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootTable.java</h2>
    <p>
        Die Klasse <code>LootTable</code> stellt eine Beutetabelle (Loot Table) innerhalb des RPG-Systems dar. 
        Sie dient als Container für verschiedene Beuteeinträge und definiert, auf welche Entitäten oder Ereignisse diese Tabelle angewendet wird.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        Diese Klasse ist ein einfaches Datenmodell (POJO), das die Struktur einer Beutetabelle definiert, wie sie oft in <code>loot.yml</code> Konfigurationsdateien verwendet wird.
    </p>

    <h3>Attribute</h3>
    <ul>
        <li><code>id</code> (String): Die eindeutige Kennung der Beutetabelle.</li>
        <li><code>appliesTo</code> (String): Definiert den Anwendungsbereich, z. B. eine spezifische Mob-ID oder ein Ereignis.</li>
        <li><code>entries</code> (List&lt;LootEntry&gt;): Eine Liste von <code>LootEntry</code>-Objekten, die die tatsächlichen Gegenstände und deren Drop-Chancen enthalten.</li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>LootTable(String id)</code>
            <p>Konstruktor zur Erstellung einer neuen Beutetabelle mit einer spezifischen ID.</p>
        </li>
        <li>
            <code>id()</code>
            <p>Gibt die eindeutige ID der Beutetabelle zurück.</p>
            <strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>appliesTo()</code>
            <p>Gibt zurück, worauf diese Beutetabelle angewendet wird.</p>
            <strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>setAppliesTo(String appliesTo)</code>
            <p>Legt fest, für welche Entität oder welches Ereignis diese Tabelle gilt.</p>
        </li>
        <li>
            <code>entries()</code>
            <p>Gibt die Liste aller in dieser Tabelle enthaltenen Beuteeinträge zurück.</p>
            <strong>Rückgabewert:</strong> <code>List&lt;LootEntry&gt;</code>
        </li>
        <li>
            <code>setEntries(List&lt;LootEntry&gt; entries)</code>
            <p>Überschreibt die aktuelle Liste der Beuteeinträge.</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/MobDefinition.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/MobDefinition.java</h2>

    <p>Die Klasse <code>MobDefinition</code> dient als Datenmodell zur Definition von Nicht-Spieler-Charakteren (Mobs) innerhalb des RPG-Systems. Sie kapselt alle grundlegenden Attribute, Ausrüstungsgegenstände, Verhaltensweisen und Belohnungen, die einen spezifischen Mob-Typ charakterisieren.</p>

    <h3>Klasse: MobDefinition</h3>
    <p>Diese Klasse fungiert primär als POJO (Plain Old Java Object) für die Konfiguration von Mobs, die üblicherweise aus YAML-Dateien geladen werden.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>MobDefinition(String id)</code>: Erstellt eine neue Mob-Definition mit einer eindeutigen Identifikationsnummer (ID).</li>
    </ul>

    <h4>Eigenschaften (Felder)</h4>
    <ul>
        <li><code>id</code> (String): Die eindeutige Kennung des Mobs.</li>
        <li><code>name</code> (String): Der Anzeigename des Mobs im Spiel.</li>
        <li><code>type</code> (String): Der Basistyp des Entities (z. B. ZOMBIE, SKELETON).</li>
        <li><code>health</code> (double): Die maximalen Lebenspunkte des Mobs.</li>
        <li><code>damage</code> (double): Der Basisschaden, den der Mob verursacht.</li>
        <li><code>mainHand</code> (String): Der Gegenstand, den der Mob in der Haupthand hält.</li>
        <li><code>helmet</code> (String): Die Kopfbedeckung/Rüstung des Mobs.</li>
        <li><code>skills</code> (List&lt;String&gt;): Eine Liste von Spezialfähigkeiten, über die der Mob verfügt.</li>
        <li><code>skillIntervalSeconds</code> (int): Die Zeitspanne in Sekunden zwischen dem Einsatz von Fähigkeiten.</li>
        <li><code>xp</code> (int): Die Menge an Erfahrungspunkten, die ein Spieler beim Besiegen erhält.</li>
        <li><code>lootTable</code> (String): Verweis auf die Beutetabelle, die beim Tod des Mobs verwendet wird.</li>
        <li><code>behaviorTree</code> (String): Der Pfad oder Name des Verhaltensbaums (Behavior Tree), der die KI-Logik steuert.</li>
        <li><code>boss</code> (boolean): Flag, das angibt, ob es sich um einen Boss-Gegner handelt (beeinflusst oft die Anzeige oder spezielle Mechaniken).</li>
    </ul>

    <h4>Wichtige Methoden</h4>
    <ul>
        <li><code>id()</code>: Gibt die ID des Mobs zurück.</li>
        <li><code>name()</code> / <code>setName(String)</code>: Getter und Setter für den Anzeigenamen.</li>
        <li><code>health()</code> / <code>setHealth(double)</code>: Getter und Setter für die Lebenspunkte.</li>
        <li><code>skills()</code> / <code>setSkills(List&lt;String&gt;)</code>: Verwaltung der zugewiesenen Fähigkeiten.</li>
        <li><code>behaviorTree()</code> / <code>setBehaviorTree(String)</code>: Zugriff auf die KI-Konfiguration.</li>
        <li><code>boss()</code> / <code>setBoss(boolean)</code>: Abfrage und Festlegung des Boss-Status.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/Npc.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/Npc.java</h2>
    <p>Die Klasse <code>Npc</code> stellt ein Datenmodell für Nicht-Spieler-Charaktere (NPCs) innerhalb des RPG-Systems dar. Sie speichert Informationen über die Identität, Position, Rolle und Interaktionsmöglichkeiten eines NPCs, wie Dialoge, Quests und Shops.</p>

    <h3>Klasse: Npc</h3>
    <p>Diese Klasse dient als Container für alle relevanten Daten eines NPCs in der Spielwelt.</p>

    <h4>Felder / Eigenschaften</h4>
    <ul>
        <li><code>id</code> (String): Die eindeutige interne Kennung des NPCs.</li>
        <li><code>uuid</code> (UUID): Die Unique Identifier der Entität in der Spielwelt.</li>
        <li><code>name</code> (String): Der Anzeigename des NPCs.</li>
        <li><code>role</code> (NpcRole): Die funktionale Rolle des NPCs (z. B. Händler, Questgeber).</li>
        <li><code>world</code>, <code>x</code>, <code>y</code>, <code>z</code>, <code>yaw</code>, <code>pitch</code>: Standortdaten für die Platzierung in der Welt.</li>
        <li><code>dialog</code> (List&lt;String&gt;): Eine Liste von einfachen Dialogzeilen.</li>
        <li><code>questLink</code> (String): Verknüpfung zu einer Quest-ID.</li>
        <li><code>shopId</code> (String): Verknüpfung zu einer Shop-Definition.</li>
        <li><code>factionId</code> (String): Zugehörigkeit zu einer Fraktion.</li>
        <li><code>requiredRankId</code> (String): Erforderlicher Rang innerhalb einer Fraktion, um mit dem NPC zu interagieren.</li>
        <li><code>dialogueNodes</code> (Map): Ein komplexeres System für verzweigte Dialogbäume.</li>
    </ul>

    <h4>Wichtige Methoden</h4>
    <ul>
        <li>
            <code>Npc(String id)</code>
            <p>Konstruktor zur Erstellung eines neuen NPCs mit einer festen ID.</p>
        </li>
        <li>
            <code>setLocation(Location location)</code>
            <p>Aktualisiert die Positionsdaten des NPCs basierend auf einem Bukkit <code>Location</code>-Objekt.</p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>location</code>: Das Ziel-Location-Objekt.</li>
            </ul>
        </li>
        <li>
            <code>toLocation(org.bukkit.World world)</code>
            <p>Konvertiert die gespeicherten Koordinaten zurück in ein Bukkit <code>Location</code>-Objekt für eine spezifische Welt.</p>
            <strong>Rückgabewert:</strong> Ein <code>Location</code>-Objekt.
        </li>
        <li>
            <code>setRawLocation(String world, double x, double y, double z, float yaw, float pitch)</code>
            <p>Ermöglicht das manuelle Setzen der Standortdaten ohne Bukkit-Objekt (nützlich für Serialisierung/Laden aus Dateien).</p>
        </li>
        <li>
            <code>dialogueNodes()</code>
            <p>Gibt die Map der <code>DialogueNode</code>-Objekte zurück, die für komplexe Gesprächsverläufe genutzt werden.</p>
            <strong>Rückgabewert:</strong> <code>java.util.Map&lt;String, DialogueNode&gt;</code>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/NpcRole.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/NpcRole.java</h2>
    <p>Die Datei <code>NpcRole.java</code> definiert eine Enumeration, die die verschiedenen funktionalen Rollen festlegt, die ein Nicht-Spieler-Charakter (NPC) innerhalb des RPG-Systems einnehmen kann. Diese Rollen bestimmen, welche Interaktionsmöglichkeiten dem Spieler zur Verfügung stehen, wenn er mit einem NPC interagiert.</p>

    <h3>NpcRole (Enum)</h3>
    <p>Diese Enumeration wird verwendet, um NPCs zu kategorisieren und das entsprechende Verhalten (z. B. Öffnen eines Shop-Inventars oder eines Quest-Dialogs) in den Managern und Listenern des Plugins zu steuern.</p>

    <h4>Verfügbare Rollen:</h4>
    <ul>
        <li><code>QUESTGIVER</code>: Kennzeichnet einen NPC als Questgeber. Er ist für das Starten und Abschließen von Aufgaben zuständig.</li>
        <li><code>VENDOR</code>: Ein allgemeiner Händler, der Waren anbietet.</li>
        <li><code>WEAPON_VENDOR</code>: Ein spezialisierter Händler, der primär Waffen verkauft.</li>
        <li><code>ARMOR_VENDOR</code>: Ein spezialisierter Händler für Rüstungen und Schutzausrüstung.</li>
        <li><code>ITEM_VENDOR</code>: Ein Händler für allgemeine Verbrauchsgegenstände und Items.</li>
        <li><code>RESOURCE_VENDOR</code>: Ein Händler, der Rohstoffe und Handwerksmaterialien verkauft oder ankauft.</li>
        <li><code>TRAINER</code>: Ein NPC, bei dem Spieler ihre Fähigkeiten (Skills) verbessern oder neue Techniken erlernen können.</li>
        <li><code>TELEPORTER</code>: Ermöglicht dem Spieler das Reisen zwischen verschiedenen vordefinierten Orten oder Zonen.</li>
        <li><code>BANKER</code>: Bietet Zugriff auf das Banksystem zur sicheren Lagerung von Gegenständen und Währungen.</li>
        <li><code>FACTION_AGENT</code>: Ein Vertreter einer Fraktion, der für fraktionsspezifische Belange, wie Ruf-Belohnungen oder Informationen, zuständig ist.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/Party.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/Party.java</h2>
    <p>
        Die Klasse <code>Party</code> repräsentiert eine Gruppe von Spielern innerhalb des RPG-Systems. 
        Sie dient als Datenmodell zur Verwaltung von Gruppenstrukturen, bestehend aus einem Anführer und mehreren Mitgliedern.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Die Klasse verwendet <code>UUID</code>-Objekte zur eindeutigen Identifizierung der Spieler, was eine Kompatibilität mit der Minecraft-Spielerdatenbank gewährleistet.
    </p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code><strong>Party(UUID leader)</strong></code>: Erstellt eine neue Party. 
            Der übergebene Spieler wird automatisch als Anführer festgelegt und der Mitgliederliste hinzugefügt.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code><strong>leader()</strong></code>: 
            Gibt die <code>UUID</code> des Party-Anführers zurück.
            <br><em>Rückgabewert:</em> <code>UUID</code> des Anführers.
        </li>
        <li>
            <code><strong>members()</strong></code>: 
            Gibt ein Set aller aktuellen Mitglieder der Party zurück.
            <br><em>Rückgabewert:</em> <code>Set&lt;UUID&gt;</code> der Mitglieder.
        </li>
        <li>
            <code><strong>addMember(UUID uuid)</strong></code>: 
            Fügt einen neuen Spieler der Party hinzu.
            <br><em>Parameter:</em> <code>uuid</code> - Die eindeutige ID des hinzuzufügenden Spielers.
        </li>
        <li>
            <code><strong>removeMember(UUID uuid)</strong></code>: 
            Entfernt einen Spieler aus der Party.
            <br><em>Parameter:</em> <code>uuid</code> - Die eindeutige ID des zu entfernenden Spielers.
        </li>
    </ul>

    <h3>Technische Details</h3>
    <ul>
        <li><strong>Datenstruktur:</strong> Die Mitglieder werden in einem <code>HashSet</code> gespeichert, um Duplikate zu vermeiden und effiziente Zugriffszeiten beim Hinzufügen oder Entfernen zu gewährleisten.</li>
        <li><strong>Immutabilität:</strong> Das Feld <code>leader</code> ist als <code>final</code> deklariert, was bedeutet, dass der Anführer einer Party nach der Erstellung nicht mehr geändert werden kann (ein Wechsel der Anführerschaft würde somit ein neues Party-Objekt oder eine Erweiterung der Logik erfordern).</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/PlayerProfile.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/PlayerProfile.java</h2>

    <p>Die Klasse <code>PlayerProfile</code> ist das zentrale Datenmodell für Spieler innerhalb des RPG-Systems. Sie speichert alle relevanten Informationen über den Fortschritt, die Attribute, Quests, Fähigkeiten und sozialen Bindungen eines Spielers.</p>

    <h3>Klasse: PlayerProfile</h3>
    <p>Diese Klasse verwaltet den Zustand eines Spielers, einschließlich Leveling-Logik, Attributsberechnungen und persistenter Daten wie Gold und Gilden-Zugehörigkeit.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>PlayerProfile(UUID uuid)</code>: Erstellt ein neues Profil für die angegebene UUID und initialisiert alle Basis-Attribute (RPGStats) mit einem Standardwert von 5.</li>
    </ul>

    <h4>Wichtige Methoden</h4>
    <ul>
        <li>
            <code>void addXp(int amount)</code>
            <p>Fügt dem Spieler Erfahrungspunkte hinzu. Beinhaltet die Level-Up-Logik: Wenn die benötigten XP erreicht werden, steigt das Level des Spielers und er erhält zusätzliche Fertigkeitspunkte (SkillPoints).</p>
        </li>
        <li>
            <code>int xpNeeded()</code>
            <p>Berechnet die für das nächste Level benötigten Erfahrungspunkte basierend auf einer linearen Formel: <code>100 + (level - 1) * 50</code>.</p>
        </li>
        <li>
            <code>void applyAttributes(Player player, ItemStatManager itemStatManager, ClassManager classManager)</code>
            <p>Berechnet die Gesamt-Attribute des Spielers und wendet diese direkt auf die Minecraft-Attribute des <code>Player</code>-Objekts an (z. B. Angriffsschaden, maximale Gesundheit, Angriffsgeschwindigkeit und Bewegungsgeschwindigkeit). Zudem wird das maximale Mana basierend auf Intelligenz aktualisiert.</p>
        </li>
        <li>
            <code>Map&lt;RPGStat, Integer&gt; totalStats(Player player, ItemStatManager itemStatManager, ClassManager classManager)</code>
            <p>Aggregiert die Basis-Attribute des Spielers mit den Boni aus der aktuellen Ausrüstung (via <code>ItemStatManager</code>) und den Klassen-Boni (via <code>ClassManager</code>).</p>
        </li>
        <li>
            <code>void setHome(String world, double x, double y, double z)</code>
            <p>Speichert die Koordinaten und die Welt für den Heimatpunkt (Home) des Spielers.</p>
        </li>
        <li>
            <code>void setLastSkill(String skillId, long time)</code>
            <p>Speichert die ID und den Zeitpunkt der zuletzt verwendeten Fähigkeit, nützlich für die Validierung von Combos oder Cooldowns.</p>
        </li>
    </ul>

    <h4>Datenfelder / Eigenschaften</h4>
    <ul>
        <li><code>uuid</code>: Die eindeutige Kennung des Spielers.</li>
        <li><code>level / xp / skillPoints</code>: Informationen zum Charakterfortschritt.</li>
        <li><code>mana / maxMana</code>: Ressourcen für die Verwendung von Fähigkeiten.</li>
        <li><code>stats</code>: Eine Map der Basis-Attribute (STRENGTH, DEXTERITY, etc.).</li>
        <li><code>learnedSkills</code>: Liste der freigeschalteten Fähigkeiten.</li>
        <li><code>activeQuests / completedQuests</code>: Tracking des Quest-Fortschritts.</li>
        <li><code>skillCooldowns</code>: Persistente Speicherung von Abklingzeiten (skillId zu Zeitstempel).</li>
        <li><code>gold</code>: Die Währung des Spielers (kann nicht unter 0 fallen).</li>
        <li><code>elo</code>: Das Matchmaking-Rating für PvP-Aktivitäten.</li>
        <li><code>dungeonRole</code>: Die bevorzugte Rolle in Dungeons (Standard: "DPS").</li>
        <li><code>professions</code>: Fortschritt in verschiedenen Berufen.</li>
        <li><code>housingUpgrades</code>: Erworbene Verbesserungen für das Housing-System.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/Profession.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/Profession.java</h2>
    <p>
        Diese Datei definiert die Enumeration <code>Profession</code>, welche die grundlegenden Kategorien von Berufen innerhalb des RPG-Systems festlegt. 
        Sie dient zur Klassifizierung von Tätigkeiten und Fähigkeiten, die ein Spielercharakter erlernen oder ausüben kann.
    </p>

    <h3>Profession (Enum)</h3>
    <p>
        Die <code>Profession</code>-Enum wird verwendet, um zwischen verschiedenen Arten von handwerklichen oder ressourcenbezogenen Spezialisierungen zu unterscheiden.
    </p>

    <h4>Aufzählungswerte:</h4>
    <ul>
        <li>
            <code>GATHERING</code>: Repräsentiert Sammelberufe. Dies umfasst Tätigkeiten wie Bergbau, Kräuterkunde oder das Sammeln von Rohstoffen in der Spielwelt.
        </li>
        <li>
            <code>CRAFTING</code>: Repräsentiert Verarbeitungsberufe. Dies umfasst die Herstellung von Gegenständen, Ausrüstung oder Verbrauchsgütern aus gesammelten Rohstoffen (z. B. Schmieden, Alchemie).
        </li>
    </ul>

    <h3>Verwendung im System</h3>
    <p>
        Diese Enumeration wird voraussichtlich vom <code>ProfessionManager</code> und dem <code>ProfessionListener</code> genutzt, um Fortschritte, Level-Aufstiege oder die Berechtigung zur Interaktion mit bestimmten Ressourcenknoten (ResourceNodes) zu steuern.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/PvpSeason.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/PvpSeason.java</h2>
    <p>
        Die Klasse <code>PvpSeason</code> repräsentiert eine PvP-Saison (Player versus Player) innerhalb des RPG-Systems. 
        Sie dient als Datenmodell zur Verwaltung von zeitlich begrenzten Wettbewerbszeiträumen, in denen Spieler gegeneinander antreten können.
    </p>

    <h3>Klasse: PvpSeason</h3>
    <p><strong>Beschreibung:</strong> Ein Modell, das die Identität, den Namen und die Laufzeit einer PvP-Saison speichert.</p>

    <h4>Attribute</h4>
    <ul>
        <li><code>id</code> (String): Eine eindeutige, unveränderliche Kennung für die Saison.</li>
        <li><code>name</code> (String): Der Anzeigename der Saison.</li>
        <li><code>endTimestamp</code> (long): Der Zeitpunkt des Saisonendes als Unix-Zeitstempel in Millisekunden.</li>
    </ul>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>PvpSeason(String id)</code>: Erstellt eine neue Instanz mit der angegebenen ID.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>id()</code>: 
            <br><strong>Rückgabewert:</strong> <code>String</code> - Die eindeutige ID der Saison.
        </li>
        <li>
            <code>name()</code>: 
            <br><strong>Rückgabewert:</strong> <code>String</code> - Der Name der Saison.
        </li>
        <li>
            <code>setName(String name)</code>: 
            <br>Setzt oder ändert den Namen der Saison.
        </li>
        <li>
            <code>endTimestamp()</code>: 
            <br><strong>Rückgabewert:</strong> <code>long</code> - Der Endzeitpunkt in Millisekunden.
        </li>
        <li>
            <code>setEndTimestamp(long endTimestamp)</code>: 
            <br>Legt fest, wann die Saison enden soll.
        </li>
        <li>
            <code>isActive()</code>: 
            <br>Prüft, ob die Saison aktuell läuft.
            <br><strong>Logik:</strong> Eine Saison gilt als aktiv, wenn der <code>endTimestamp</code> auf 0 gesetzt ist (unbegrenzt) oder wenn die aktuelle Systemzeit vor dem Endzeitpunkt liegt.
            <br><strong>Rückgabewert:</strong> <code>boolean</code> - <code>true</code>, wenn die Saison aktiv ist, andernfalls <code>false</code>.
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/Quest.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/Quest.java</h2>
    <p>
        Die Klasse <code>Quest</code> ist ein zentrales Datenmodell innerhalb des RPG-Plugins. Sie definiert die Struktur einer Quest, einschließlich ihrer Anforderungen, der einzelnen Aufgaben (Steps) und der Belohnungen.
    </p>

    <h3>Klasse: Quest</h3>
    <p>
        Diese Klasse dient als Container für alle Informationen, die eine Quest im Spiel beschreiben. Sie verknüpft logische Abläufe (Quest-Schritte) mit Metadaten wie Level-Anforderungen und Wiederholbarkeit.
    </p>

    <h4>Attribute</h4>
    <ul>
        <li><code>id</code> (String): Eindeutige Kennung der Quest (final).</li>
        <li><code>name</code> (String): Der Anzeigename der Quest.</li>
        <li><code>description</code> (String): Eine detaillierte Beschreibung des Quest-Inhalts.</li>
        <li><code>repeatable</code> (boolean): Gibt an, ob die Quest vom Spieler mehrfach abgeschlossen werden kann.</li>
        <li><code>minLevel</code> (int): Das erforderliche Mindestlevel des Spielers, um die Quest zu starten.</li>
        <li><code>requiredEvent</code> (String): Ein optionales Weltereignis oder eine Bedingung, die erfüllt sein muss.</li>
        <li><code>steps</code> (List&lt;QuestStep&gt;): Eine Liste der einzelnen Aufgaben oder Phasen, aus denen die Quest besteht.</li>
        <li><code>reward</code> (QuestReward): Das Objekt, das die Belohnungen für den erfolgreichen Abschluss definiert.</li>
    </ul>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>Quest(String id)</code>: Erstellt eine neue Quest-Instanz mit der angegebenen ID. Die ID kann nach der Initialisierung nicht mehr geändert werden.
        </li>
    </ul>

    <h4>Wichtige Methoden</h4>
    <ul>
        <li><code>id()</code>: Gibt die eindeutige ID der Quest zurück.</li>
        <li><code>name()</code> / <code>setName(String name)</code>: Getter und Setter für den Quest-Namen.</li>
        <li><code>description()</code> / <code>setDescription(String description)</code>: Getter und Setter für die Quest-Beschreibung.</li>
        <li><code>repeatable()</code> / <code>setRepeatable(boolean repeatable)</code>: Steuert die Wiederholbarkeit der Quest.</li>
        <li><code>minLevel()</code> / <code>setMinLevel(int minLevel)</code>: Verwaltet die Level-Voraussetzung.</li>
        <li><code>steps()</code> / <code>setSteps(List&lt;QuestStep&gt; steps)</code>: Zugriff auf die Liste der Quest-Schritte (Aufgaben).</li>
        <li><code>reward()</code> / <code>setReward(QuestReward reward)</code>: Zugriff auf die Belohnungskonfiguration der Quest.</li>
    </ul>

    <h3>Zusammenhänge</h3>
    <p>
        Die Klasse arbeitet eng mit <code>QuestStep</code> (für die Definition der Aufgaben) und <code>QuestReward</code> (für die Belohnungslogik) zusammen. Sie wird primär vom <code>QuestManager</code> verwaltet und in <code>QuestProgress</code> referenziert, um den aktuellen Stand eines Spielers zu speichern.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestProgress.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestProgress.java</h2>
    <p>
        Die Klasse <code>QuestProgress</code> dient zur Verwaltung und Speicherung des aktuellen Fortschritts eines Spielers innerhalb einer spezifischen Quest. 
        Sie verfolgt den Status einzelner Quest-Schritte und speichert, ob die gesamte Quest bereits abgeschlossen wurde.
    </p>

    <h3>Klasse: QuestProgress</h3>
    <p>
        Diese Klasse bildet das Datenmodell für den Fortschrittszustand einer Quest ab.
    </p>

    <h4>Felder</h4>
    <ul>
        <li><code>questId</code> (String): Die eindeutige Kennung der Quest.</li>
        <li><code>stepProgress</code> (Map&lt;Integer, Integer&gt;): Eine Map, die den Index eines Quest-Schritts auf den aktuellen numerischen Fortschrittswert (z. B. Anzahl getöteter Mobs) abbildet.</li>
        <li><code>completed</code> (boolean): Gibt an, ob die Quest erfolgreich beendet wurde.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>questId()</code>
            <p>Gibt die ID der zugehörigen Quest zurück.</p>
            <strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>stepProgress()</code>
            <p>Gibt die Map mit den Fortschrittsdaten aller Schritte zurück.</p>
            <strong>Rückgabewert:</strong> <code>Map&lt;Integer, Integer&gt;</code>
        </li>
        <li>
            <code>incrementStep(int index, int amount)</code>
            <p>Erhöht den Fortschritt eines bestimmten Schritts um den angegebenen Wert.</p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>index</code>: Der Index des Quest-Schritts.</li>
                <li><code>amount</code>: Der Wert, um den der Fortschritt erhöht werden soll.</li>
            </ul>
        </li>
        <li>
            <code>incrementStepClamped(int index, int amount, int required)</code>
            <p>
                Erhöht den Fortschritt, stellt jedoch sicher, dass der Wert nicht über die erforderliche Menge hinausgeht. 
                <em>Code-Kommentar:</em> Damit bleibt der Fortschritt stabil und Auswertungen werden deterministisch.
            </p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>index</code>: Der Index des Quest-Schritts.</li>
                <li><code>amount</code>: Der zu addierende Wert.</li>
                <li><code>required</code>: Die maximale Grenze (Zielwert) für diesen Schritt.</li>
            </ul>
        </li>
        <li>
            <code>getStepProgress(int index)</code>
            <p>Ruft den aktuellen Fortschrittswert für einen spezifischen Schritt ab.</p>
            <strong>Rückgabewert:</strong> <code>int</code> (Standardwert 0, falls kein Fortschritt existiert).
        </li>
        <li>
            <code>completed()</code>
            <p>Prüft, ob die Quest als abgeschlossen markiert ist.</p>
            <strong>Rückgabewert:</strong> <code>boolean</code>
        </li>
        <li>
            <code>setCompleted(boolean completed)</code>
            <p>Setzt den Abschlussstatus der Quest.</p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>completed</code>: Der neue Status (true für abgeschlossen).</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestReward.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestReward.java</h2>

    <p>
        Die Klasse <code>QuestReward</code> ist ein Datenmodell innerhalb des RPG-Systems, das die Belohnungen definiert, die ein Spieler nach dem erfolgreichen Abschluss einer Quest erhält. Sie kapselt verschiedene Arten von Belohnungen wie Erfahrungspunkte, Fertigkeitspunkte und Fraktionsruf.
    </p>

    <h3>Klasse: QuestReward</h3>
    <p>
        Diese Klasse dient als Container für Belohnungsdaten. Sie ermöglicht es, verschiedene Belohnungsmetriken zentral zu verwalten und an Quest-Objekte zu binden.
    </p>

    <h4>Felder (Attribute)</h4>
    <ul>
        <li><code>xp</code> (int): Die Anzahl der Erfahrungspunkte, die dem Spieler gutgeschrieben werden.</li>
        <li><code>skillPoints</code> (int): Die Anzahl der Fertigkeitspunkte (Skill Points), die der Spieler zur Verbesserung seiner Fähigkeiten erhält.</li>
        <li><code>factionRep</code> (Map&lt;String, Integer&gt;): Eine Map, die Fraktionsnamen (als String) mit den entsprechenden Ruf-Änderungen (als Integer) verknüpft.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>xp()</code>: 
            <p>Gibt die Anzahl der Erfahrungspunkte zurück.</p>
            <strong>Rückgabewert:</strong> <code>int</code> - Die XP-Belohnung.
        </li>
        <li>
            <code>setXp(int xp)</code>: 
            <p>Legt die Anzahl der Erfahrungspunkte fest.</p>
            <strong>Parameter:</strong> <code>xp</code> - Der neue XP-Wert.
        </li>
        <li>
            <code>skillPoints()</code>: 
            <p>Gibt die Anzahl der Fertigkeitspunkte zurück.</p>
            <strong>Rückgabewert:</strong> <code>int</code> - Die Skill-Punkt-Belohnung.
        </li>
        <li>
            <code>setSkillPoints(int skillPoints)</code>: 
            <p>Legt die Anzahl der Fertigkeitspunkte fest.</p>
            <strong>Parameter:</strong> <code>skillPoints</code> - Der neue Wert für die Fertigkeitspunkte.
        </li>
        <li>
            <code>factionRep()</code>: 
            <p>Gibt die Map der Fraktionsruf-Belohnungen zurück.</p>
            <strong>Rückgabewert:</strong> <code>Map&lt;String, Integer&gt;</code> - Eine Übersicht der Ruf-Änderungen pro Fraktion.
        </li>
        <li>
            <code>setFactionRep(Map&lt;String, Integer&gt; factionRep)</code>: 
            <p>Setzt die gesamte Map für den Fraktionsruf.</p>
            <strong>Parameter:</strong> <code>factionRep</code> - Eine Map mit Fraktionsnamen und den zugehörigen Ruf-Werten.
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStep.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStep.java</h2>

    <p>Die Klasse <code>QuestStep</code> repräsentiert einen einzelnen Teilschritt innerhalb eines Quests im RPG-System. Sie definiert die spezifische Aufgabe, die ein Spieler erfüllen muss, um im Quest fortzufahren.</p>

    <h3>Klasse: QuestStep</h3>
    <p>Diese Klasse dient als Datenmodell für die Definition von Quest-Zielen, wie zum Beispiel das Besiegen von Monstern oder das Sammeln von Gegenständen.</p>

    <h4>Attribute</h4>
    <ul>
        <li><code>type</code> (QuestStepType): Der Typ des Quest-Schritts (z. B. KILL, COLLECT, TALK).</li>
        <li><code>target</code> (String): Das Ziel des Schritts. Dies kann eine Mob-ID, eine Item-ID oder der Name eines NPCs sein.</li>
        <li><code>amount</code> (int): Die benötigte Anzahl oder Menge, um diesen Schritt abzuschließen.</li>
    </ul>

    <h4>Konstruktor</h4>
    <p><code>public QuestStep(QuestStepType type, String target, int amount)</code></p>
    <ul>
        <li><strong>type:</strong> Die Art der Aufgabe.</li>
        <li><strong>target:</strong> Die Kennung des Ziels.</li>
        <li><strong>amount:</strong> Die Zielmenge.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public QuestStepType type()</code>
            <p>Gibt den Typ des Quest-Schritts zurück.</p>
        </li>
        <li>
            <code>public void setType(QuestStepType type)</code>
            <p>Aktualisiert den Typ des Quest-Schritts.</p>
        </li>
        <li>
            <code>public String target()</code>
            <p>Gibt das Ziel (ID oder Name) dieses Schritts zurück.</p>
        </li>
        <li>
            <code>public void setTarget(String target)</code>
            <p>Setzt ein neues Ziel für diesen Schritt.</p>
        </li>
        <li>
            <code>public int amount()</code>
            <p>Gibt die erforderliche Menge zurück.</p>
        </li>
        <li>
            <code>public void setAmount(int amount)</code>
            <p>Legt die erforderliche Menge für den Abschluss des Schritts fest.</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStepType.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStepType.java</h2>

    <p>
        Die Datei <code>QuestStepType.java</code> definiert eine Enumeration (<code>enum</code>), welche die verschiedenen Arten von Aufgabenstellungen oder Zielen innerhalb eines Quest-Systems festlegt. Diese Typen bestimmen die Logik, die angewendet werden muss, um den Fortschritt eines Spielers in einem bestimmten Quest-Schritt (<code>QuestStep</code>) zu validieren.
    </p>

    <h3>QuestStepType (Enum)</h3>
    <p>
        Diese Enumeration dient als Identifikator für die Mechanik eines Quest-Ziels. Sie wird voraussichtlich im <code>QuestManager</code> oder in der <code>QuestProgress</code>-Logik verwendet, um Ereignisse (wie das Töten eines Monsters oder das Sammeln eines Items) dem richtigen Quest-Schritt zuzuordnen.
    </p>

    <h4>Verfügbare Werte:</h4>
    <ul>
        <li><code>KILL</code>: Erfordert das Besiegen einer bestimmten Anzahl von Kreaturen oder NPCs.</li>
        <li><code>COLLECT</code>: Erfordert das Sammeln oder Beschaffen einer bestimmten Menge an Gegenständen.</li>
        <li><code>TALK</code>: Erfordert die Interaktion bzw. das Gespräch mit einem spezifischen NPC.</li>
        <li><code>EXPLORE</code>: Erfordert das Erreichen oder Entdecken eines bestimmten Ortes oder einer Zone in der Spielwelt.</li>
        <li><code>CRAFT</code>: Erfordert die Herstellung eines spezifischen Gegenstandes über das Crafting-System.</li>
        <li><code>USE_ITEM</code>: Erfordert die Verwendung eines bestimmten Items an einem bestimmten Ort oder unter bestimmten Bedingungen.</li>
        <li><code>DEFEND</code>: Erfordert das Verteidigen eines Objekts oder einer Position über einen festgelegten Zeitraum.</li>
        <li><code>ESCORT</code>: Erfordert das Begleiten und Schützen eines NPCs oder Objekts von einem Startpunkt zu einem Zielpunkt.</li>
    </ul>

    <h3>Zusammenhang im System</h3>
    <p>
        Dieser Typ ist eng mit der Klasse <code>QuestStep</code> verknüpft. Während <code>QuestStep</code> die Daten (wie Ziel-ID und Menge) hält, definiert <code>QuestStepType</code> die Art der Aktivität. In der <code>quests.yml</code> Konfigurationsdatei wird dieser Enum-Name verwendet, um die Quest-Logik für Designer definierbar zu machen.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/Rarity.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/Rarity.java</h2>
    <p>
        Die Datei definiert das Enum <code>Rarity</code>, welches die Seltenheitsstufen für Gegenstände oder Entitäten innerhalb des RPG-Systems festlegt. 
        Jede Stufe ist mit einer spezifischen Farbe für die Anzeige (via Adventure API) und einem Gewichtungswert für Wahrscheinlichkeitsberechnungen verknüpft.
    </p>

    <h3>Enum: Rarity</h3>
    <p>Repräsentiert die verfügbaren Seltenheitsgrade im Spiel.</p>

    <h4>Konstanten</h4>
    <ul>
        <li><code>COMMON</code>: Gewöhnlich (Farbe: Weiß, Gewichtung: 1.0)</li>
        <li><code>UNCOMMON</code>: Ungewöhnlich (Farbe: Grün, Gewichtung: 0.6)</li>
        <li><code>RARE</code>: Selten (Farbe: Blau, Gewichtung: 0.35)</li>
        <li><code>EPIC</code>: Episch (Farbe: Dunkellila, Gewichtung: 0.15)</li>
        <li><code>LEGENDARY</code>: Legendär (Farbe: Gold, Gewichtung: 0.05)</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>color()</code>: 
            <p>Gibt die <code>NamedTextColor</code> zurück, die dieser Seltenheitsstufe zugeordnet ist. Wird primär für die Formatierung von Item-Namen und Tooltips verwendet.</p>
            <strong>Rückgabewert:</strong> <code>NamedTextColor</code>
        </li>
        <li>
            <code>weight()</code>: 
            <p>Gibt den Gewichtungswert (Wahrscheinlichkeit) der Seltenheitsstufe zurück. Dieser Wert wird typischerweise von Loot-Systemen oder Generatoren verwendet, um die Drop-Chancen zu berechnen.</p>
            <strong>Rückgabewert:</strong> <code>double</code>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/ResourceNode.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/ResourceNode.java</h2>
    <p>
        Die Klasse <code>ResourceNode</code> repräsentiert eine abbaubare Ressourcenquelle (z. B. Erz, Holz oder Kräuter) innerhalb der Spielwelt des RPG-Plugins. 
        Sie speichert Informationen über den Standort, den Typ der Ressource, die benötigte Profession sowie die Respawn-Logik.
    </p>

    <h3>Klasse: ResourceNode</h3>
    <p><strong>Beschreibung:</strong> Ein Datenmodell, das eine spezifische Instanz eines Ressourcen-Knotens in der Welt definiert.</p>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>ResourceNode(String id)</code>: Erstellt eine neue Instanz mit einer eindeutigen Identifikationsnummer.
        </li>
    </ul>

    <h4>Eigenschaften (Felder)</h4>
    <ul>
        <li><code>id</code> (String): Die eindeutige ID des Knotens.</li>
        <li><code>world</code> (String): Der Name der Welt, in der sich der Knoten befindet.</li>
        <li><code>x, y, z</code> (int): Die Koordinaten des Knotens in der Spielwelt.</li>
        <li><code>material</code> (String): Der Materialtyp (z. B. "IRON_ORE"), der visuell dargestellt wird.</li>
        <li><code>profession</code> (String): Die Berufsbezeichnung (Profession), die zum Abbau erforderlich ist.</li>
        <li><code>respawnSeconds</code> (int): Die Zeitspanne in Sekunden, nach der die Ressource nach dem Abbau regeneriert wird.</li>
        <li><code>xp</code> (int): Die Menge an Erfahrungspunkten, die ein Spieler beim Abbau erhält.</li>
        <li><code>nextAvailableAt</code> (long): Ein Zeitstempel (Unix-Zeit), der angibt, wann der Knoten nach einem Abbau wieder verfügbar ist.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <strong>Getter-Methoden:</strong> Bieten Zugriff auf alle oben genannten Felder (z. B. <code>id()</code>, <code>world()</code>, <code>xp()</code>).
        </li>
        <li>
            <strong>Setter-Methoden:</strong> Ermöglichen das Aktualisieren der Knotendaten (z. B. <code>setWorld(String world)</code>, <code>setXp(int xp)</code>, <code>setNextAvailableAt(long time)</code>).
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/RPGStat.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/RPGStat.java</h2>
    <p>
        Die Datei <code>RPGStat.java</code> definiert eine Enumeration (<code>enum</code>), die die grundlegenden Charakterattribute (Stats) innerhalb des RPG-Systems repräsentiert. Diese Attribute dienen als Basis für Berechnungen von Schaden, Verteidigung, kritischen Treffern und anderen Spielmechaniken.
    </p>

    <h3>Klasse: RPGStat (Enum)</h3>
    <p>
        Dieser Aufzählungstyp listet die verfügbaren primären Statistiken auf, die einem Spieler oder einem NPC zugewiesen werden können.
    </p>

    <h4>Aufzählungswerte:</h4>
    <ul>
        <li>
            <code>STRENGTH</code> (Stärke): 
            Repräsentiert in der Regel die physische Kraft, die den Nahkampfschaden und die Tragfähigkeit beeinflusst.
        </li>
        <li>
            <code>DEXTERITY</code> (Geschicklichkeit): 
            Steht für Präzision und Schnelligkeit, beeinflusst oft Fernkampfschaden, Ausweichchance oder Angriffsgeschwindigkeit.
        </li>
        <li>
            <code>CONSTITUTION</code> (Konstitution): 
            Bestimmt die physische Widerstandsfähigkeit, erhöht die maximalen Lebenspunkte und die Regenerationsrate.
        </li>
        <li>
            <code>INTELLIGENCE</code> (Intelligenz): 
            Maßstab für geistige Kapazität, beeinflusst magischen Schaden, Manavorrat oder die Effektivität von Zaubersprüchen.
        </li>
        <li>
            <code>LUCK</code> (Glück): 
            Ein variabler Faktor, der die Chance auf kritische Treffer, bessere Beute (Loot) oder den Erfolg bei bestimmten Zufallsereignissen erhöht.
        </li>
    </ul>

    <h3>Verwendung im System</h3>
    <p>
        Diese Enumeration wird von anderen Komponenten wie dem <code>ItemStatManager</code> und dem <code>PlayerProfile</code> verwendet, um Boni auf Ausrüstungsgegenständen zu definieren oder die Charakterentwicklung zu speichern.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopDefinition.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopDefinition.java</h2>
    <p>
        Die Klasse <code>ShopDefinition</code> dient als Datenmodell für die Definition eines In-Game-Shops innerhalb des RPG-Systems. 
        Sie kapselt die grundlegenden Informationen, die benötigt werden, um ein Shop-Inventar (GUI) für Spieler darzustellen, 
        einschließlich einer eindeutigen Kennung, eines Anzeigetitels und der darin enthaltenen Gegenstände.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Diese Klasse ist ein POJO (Plain Old Java Object), das hauptsächlich zur Speicherung und zum Abruf von Shop-Konfigurationen verwendet wird, 
        die typischerweise aus YAML-Dateien oder einer Datenbank geladen werden.
    </p>

    <h3>Attribute</h3>
    <ul>
        <li><code>id</code> (String): Eine eindeutige, finale Kennung für den Shop.</li>
        <li><code>title</code> (String): Der Anzeigename des Shops, der normalerweise im Kopfzeilenbereich des Inventar-GUIs erscheint.</li>
        <li><code>items</code> (Map&lt;Integer, ShopItem&gt;): Eine Zuordnung von Slot-Indizes (Integer) zu den jeweiligen <code>ShopItem</code>-Objekten.</li>
    </ul>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>ShopDefinition(String id)</code>: 
            Initialisiert eine neue Shop-Definition mit der angegebenen ID. Die ID kann nach der Instanziierung nicht mehr geändert werden.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>id()</code>: 
            Gibt die eindeutige Kennung des Shops zurück.
            <br><strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>title()</code>: 
            Gibt den aktuellen Titel des Shops zurück.
            <br><strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>setTitle(String title)</code>: 
            Legt den Titel fest, der im Shop-Interface angezeigt werden soll.
            <br><strong>Parameter:</strong> <code>title</code> - Der neue Anzeigename.
        </li>
        <li>
            <code>items()</code>: 
            Gibt die Map der im Shop verfügbaren Gegenstände zurück. Der Schlüssel repräsentiert die Position im Inventar.
            <br><strong>Rückgabewert:</strong> <code>Map&lt;Integer, ShopItem&gt;</code>
        </li>
        <li>
            <code>setItems(Map&lt;Integer, ShopItem&gt; items)</code>: 
            Ersetzt die gesamte Liste der Shop-Gegenstände durch eine neue Map.
            <br><strong>Parameter:</strong> <code>items</code> - Eine Map mit Slot-IDs und den dazugehörigen <code>ShopItem</code>-Definitionen.
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopItem.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopItem.java</h2>
    <p>
        Die Klasse <code>ShopItem</code> ist ein Datenmodell (POJO), das ein einzelnes Item innerhalb eines In-Game-Shops repräsentiert. 
        Sie speichert Informationen über die Darstellung des Items, dessen Preise sowie spezifische RPG-Anforderungen.
    </p>

    <h3>Klasse: ShopItem</h3>
    <p>
        Diese Klasse dient als Container für alle Attribute, die ein Verkaufs- oder Ankaufsobjekt in einem Shop definieren.
    </p>

    <h4>Felder / Attribute</h4>
    <ul>
        <li><code>slot</code> (int): Die Position des Items im Inventar-Grid des Shops.</li>
        <li><code>material</code> (String): Der technische Name des Materials (z. B. Minecraft-Material-ID).</li>
        <li><code>name</code> (String): Der Anzeigename des Items im Shop.</li>
        <li><code>buyPrice</code> (int): Der Preis, den ein Spieler zahlen muss, um das Item zu kaufen.</li>
        <li><code>sellPrice</code> (int): Der Betrag, den ein Spieler erhält, wenn er das Item an den Shop verkauft.</li>
        <li><code>rpgItem</code> (boolean): Gibt an, ob es sich um ein spezielles RPG-Item mit erweiterten Stats handelt.</li>
        <li><code>rarity</code> (String): Die Seltenheitsstufe des Items (z. B. COMMON, RARE, EPIC).</li>
        <li><code>minLevel</code> (int): Die Mindeststufe, die ein Spieler erreicht haben muss, um dieses Item zu erwerben oder zu nutzen.</li>
    </ul>

    <h4>Methoden</h4>
    <p>Die Klasse implementiert Standard-Getter und Setter für alle oben genannten Attribute. Die Getter folgen dabei einer kompakten Namenskonvention (z. B. <code>slot()</code> statt <code>getSlot()</code>).</p>
    
    <ul>
        <li><code>slot()</code> / <code>setSlot(int slot)</code>: Zugriff auf den Inventarslot.</li>
        <li><code>material()</code> / <code>setMaterial(String material)</code>: Zugriff auf den Materialtyp.</li>
        <li><code>name()</code> / <code>setName(String name)</code>: Zugriff auf den Anzeigenamen.</li>
        <li><code>buyPrice()</code> / <code>setBuyPrice(int buyPrice)</code>: Zugriff auf den Kaufpreis.</li>
        <li><code>sellPrice()</code> / <code>setSellPrice(int sellPrice)</code>: Zugriff auf den Verkaufspreis.</li>
        <li><code>rpgItem()</code> / <code>setRpgItem(boolean rpgItem)</code>: Statusabfrage, ob es ein RPG-spezifisches Item ist.</li>
        <li><code>rarity()</code> / <code>setRarity(String rarity)</code>: Zugriff auf die Seltenheit.</li>
        <li><code>minLevel()</code> / <code>setMinLevel(int minLevel)</code>: Zugriff auf die Levelbeschränkung.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/Skill.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/Skill.java</h2>
    <p>Die Klasse <code>Skill</code> ist ein zentrales Datenmodell innerhalb des RPG-Plugins. Sie definiert die Eigenschaften und Verhaltensweisen einer Fertigkeit (Skill), die von Charakteren oder Mobs eingesetzt werden kann. Sie dient als Container für Metadaten wie Kosten, Abklingzeiten und die damit verbundenen Effekte.</p>

    <h3>Klasse: Skill</h3>
    <p>Repräsentiert eine einzelne Fertigkeit im Spielsystem.</p>

    <h4>Konstruktoren</h4>
    <ul>
        <li><code>Skill(String id)</code>: Erzeugt eine neue Skill-Instanz mit einer eindeutigen Identifikationsnummer.</li>
    </ul>

    <h4>Eigenschaften (Felder)</h4>
    <ul>
        <li><code>id</code> (String): Die eindeutige Kennung des Skills (final).</li>
        <li><code>name</code> (String): Der Anzeigename der Fertigkeit.</li>
        <li><code>type</code> (SkillType): Die Art des Skills (z. B. Aktiv, Passiv).</li>
        <li><code>category</code> (SkillCategory): Die Kategorie, der dieser Skill zugeordnet ist (z. B. Magie, Nahkampf).</li>
        <li><code>cooldown</code> (int): Die Abklingzeit in Ticks oder Sekunden, bevor der Skill erneut verwendet werden kann.</li>
        <li><code>manaCost</code> (int): Die Menge an Mana, die für die Aktivierung benötigt wird.</li>
        <li><code>requiredSkill</code> (String): Die ID einer Voraussetzung, die erfüllt sein muss, um diesen Skill zu erlernen.</li>
        <li><code>effects</code> (List&lt;SkillEffectConfig&gt;): Eine Liste von Konfigurationen für Effekte, die beim Auslösen des Skills angewendet werden.</li>
    </ul>

    <h4>Wichtige Methoden</h4>
    <ul>
        <li><code>id()</code>: Gibt die ID des Skills zurück.</li>
        <li><code>name()</code> / <code>setName(String name)</code>: Getter und Setter für den Namen.</li>
        <li><code>type()</code> / <code>setType(SkillType type)</code>: Getter und Setter für den Skill-Typ.</li>
        <li><code>category()</code> / <code>setCategory(SkillCategory category)</code>: Getter und Setter für die Kategorie.</li>
        <li><code>cooldown()</code> / <code>setCooldown(int cooldown)</code>: Getter und Setter für die Abklingzeit.</li>
        <li><code>manaCost()</code> / <code>setManaCost(int manaCost)</code>: Getter und Setter für die Manakosten.</li>
        <li><code>effects()</code> / <code>setEffects(List&lt;SkillEffectConfig&gt; effects)</code>: Zugriff auf die Liste der konfigurierten Effekte.</li>
        <li><code>requiredSkill()</code> / <code>setRequiredSkill(String requiredSkill)</code>: Getter und Setter für die Skill-Voraussetzung.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillCategory.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillCategory.java</h2>

    <p>
        Die Datei <code>SkillCategory.java</code> definiert ein Enum, das zur Kategorisierung von Fähigkeiten (Skills) innerhalb des RPG-Systems dient. 
        Diese Kategorien werden verwendet, um Skills im Skill-Baum zu organisieren, Synergieeffekte zu berechnen oder Filter in der Benutzeroberfläche anzuwenden.
    </p>

    <h3>SkillCategory (Enum)</h3>
    <p>
        Dieses Enum listet die grundlegenden Typen von Fähigkeiten auf, die ein Charakter erlernen kann.
    </p>

    <h4>Enum-Werte:</h4>
    <ul>
        <li>
            <code>HEALING</code>: Repräsentiert Fähigkeiten, die auf die Wiederherstellung von Lebenspunkten oder die Heilung von Statuseffekten spezialisiert sind.
        </li>
        <li>
            <code>MAGIC</code>: Umfasst magische Zaubersprüche und Fähigkeiten, die in der Regel Mana verbrauchen oder arkane Effekte nutzen.
        </li>
        <li>
            <code>ATTACK</code>: Bezieht sich auf offensive Fähigkeiten, die darauf ausgelegt sind, Gegnern direkten Schaden zuzufügen.
        </li>
        <li>
            <code>DEFENSE</code>: Bezeichnet defensive Fähigkeiten, wie Schilde, Schadensreduktion oder Schutzmechanismen.
        </li>
        <li>
            <code>PROFESSION</code>: Kategorisiert Fähigkeiten, die mit Berufen (z. B. Bergbau, Schmieden, Alchemie) verknüpft sind und meist außerhalb des direkten Kampfes Anwendung finden.
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillSynergy.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillSynergy.java</h2>

    <p>
        Die Klasse <code>SkillSynergy</code> ist ein Datenmodell innerhalb des RPG-Plugins, das die Logik für Synergieeffekte zwischen verschiedenen Fähigkeiten (Skills) definiert. 
        Eine Synergie beschreibt einen speziellen Bonus oder Effekt, der ausgelöst wird, wenn eine bestimmte Kombination von Fähigkeiten innerhalb eines definierten Zeitfensters und Wirkungsbereichs eingesetzt wird.
    </p>

    <h3>Klasse: SkillSynergy</h3>
    <p><strong>Paket:</strong> <code>com.example.rpg.model</code></p>
    <p><strong>Beschreibung:</strong> Repräsentiert eine Synergie-Definition, die mehrere Skills miteinander verknüpft.</p>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>public SkillSynergy(String id)</code>: Erstellt eine neue Synergie-Instanz mit der angegebenen eindeutigen ID.
        </li>
    </ul>

    <h4>Methoden &amp; Eigenschaften</h4>
    <ul>
        <li>
            <code>id()</code>: 
            <br><strong>Rückgabewert:</strong> <code>String</code> - Die eindeutige Kennung der Synergie.
        </li>
        <li>
            <code>skills()</code> / <code>setSkills(List&lt;String&gt; skills)</code>: 
            <br>Verwaltet die Liste der Skill-IDs, die für die Aktivierung dieser Synergie erforderlich sind.
        </li>
        <li>
            <code>scope()</code> / <code>setScope(String scope)</code>: 
            <br>Definiert den Geltungsbereich der Synergie (z. B. "SELF", "PARTY" oder "AREA").
        </li>
        <li>
            <code>radius()</code> / <code>setRadius(double radius)</code>: 
            <br>Gibt den Wirkungsradius an, in dem die Synergie-Bedingungen geprüft werden oder Effekte wirken.
        </li>
        <li>
            <code>windowSeconds()</code> / <code>setWindowSeconds(int windowSeconds)</code>: 
            <br>Bestimmt das Zeitfenster in Sekunden, innerhalb dessen die erforderlichen Skills gewirkt werden müssen, um die Synergie auszulösen.
        </li>
        <li>
            <code>effects()</code>: 
            <br><strong>Rückgabewert:</strong> <code>List&lt;SkillEffectConfig&gt;</code> - Eine Liste von Konfigurationen für Effekte, die bei erfolgreicher Synergie-Aktivierung ausgeführt werden.
        </li>
    </ul>

    <h4>Zugehörige Felder</h4>
    <ul>
        <li><code>id</code>: Eindeutiger Identifikator.</li>
        <li><code>skills</code>: Eine Liste von Strings, die auf die IDs der beteiligten Skills verweisen.</li>
        <li><code>scope</code>: Der Wirkungsbereich der Synergie.</li>
        <li><code>radius</code>: Numerischer Wert für die Reichweite.</li>
        <li><code>windowSeconds</code>: Zeitliche Toleranz für die Skill-Abfolge.</li>
        <li><code>effects</code>: Liste der resultierenden <code>SkillEffectConfig</code>-Objekte.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillType.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillType.java</h2>

    <p>
        Die Datei <code>SkillType.java</code> definiert eine Enumeration (Aufzählungstyp), die zur Kategorisierung von Fähigkeiten (Skills) innerhalb des RPG-Systems dient. 
        Sie legt fest, wie eine Fähigkeit ausgelöst wird oder im Spiel wirkt.
    </p>

    <h3>SkillType (Enum)</h3>
    <p>
        Diese Enumeration wird verwendet, um zwischen aktiv zu wirkenden Fähigkeiten und permanent wirkenden Effekten zu unterscheiden.
    </p>

    <h4>Aufzählungswerte:</h4>
    <ul>
        <li>
            <code>ACTIVE</code>: Repräsentiert aktive Fähigkeiten. Diese müssen vom Spieler oder NPC gezielt ausgelöst werden (z. B. durch einen Tastendruck oder ein Kommando) und verbrauchen in der Regel Ressourcen wie Mana oder lösen einen Cooldown aus.
        </li>
        <li>
            <code>PASSIVE</code>: Repräsentiert passive Fähigkeiten. Diese sind dauerhaft aktiv, sobald sie erlernt oder ausgerüstet wurden, und bieten permanente Boni oder automatische Effekte, ohne dass eine manuelle Aktivierung erforderlich ist.
        </li>
    </ul>

    <h3>Zusammenhang im System</h3>
    <p>
        Dieser Typ wird primär in der Klasse <code>Skill</code> verwendet, um die Logik der Skill-Verarbeitung zu steuern. Während <code>ACTIVE</code> Skills oft mit dem <code>CastSkillNode</code> im Behavior-Tree oder dem <code>SkillHotbarManager</code> verknüpft sind, werden <code>PASSIVE</code> Skills meist direkt bei der Berechnung von Attributen oder Statuswerten berücksichtigt.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/Spawner.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/Spawner.java</h2>
    <p>
        Die Klasse <code>Spawner</code> ist ein Datenmodell innerhalb des RPG-Plugins, das die Konfiguration für einen automatischen Mob-Generator (Spawner) definiert. Sie legt fest, welche Arten von Kreaturen in welchen Abständen und in welcher Menge innerhalb einer bestimmten Zone erscheinen sollen.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Diese Klasse dient primär als Container für Konfigurationsdaten, die üblicherweise aus der Datei <code>spawners.yml</code> geladen werden.
    </p>

    <h3>Eigenschaften (Felder)</h3>
    <ul>
        <li><code>id</code> (String): Die eindeutige Kennung des Spawners.</li>
        <li><code>zoneId</code> (String): Die ID der Zone (<code>Zone</code>), in der dieser Spawner aktiv ist.</li>
        <li><code>maxMobs</code> (int): Die maximale Anzahl an Kreaturen, die dieser Spawner gleichzeitig in der Welt halten darf.</li>
        <li><code>spawnInterval</code> (int): Das Zeitintervall (üblicherweise in Sekunden oder Ticks), in dem neue Kreaturen generiert werden.</li>
        <li><code>mobs</code> (Map&lt;String, Double&gt;): Eine Liste von Mob-IDs und deren jeweilige Wahrscheinlichkeit (Gewichtung) für das Erscheinen.</li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>Spawner(String id)</code>
            <p>Konstruktor zur Erstellung eines neuen Spawners mit einer festen ID.</p>
        </li>
        <li>
            <code>id()</code>
            <p>Gibt die eindeutige ID des Spawners zurück.</p>
        </li>
        <li>
            <code>zoneId()</code> / <code>setZoneId(String zoneId)</code>
            <p>Getter und Setter für die Zuweisung des Spawners zu einer bestimmten Region.</p>
        </li>
        <li>
            <code>maxMobs()</code> / <code>setMaxMobs(int maxMobs)</code>
            <p>Getter und Setter für das Limit der gleichzeitig existierenden Mobs dieses Spawners.</p>
        </li>
        <li>
            <code>spawnInterval()</code> / <code>setSpawnInterval(int spawnInterval)</code>
            <p>Getter und Setter für die Zeitspanne zwischen den Spawn-Vorgängen.</p>
        </li>
        <li>
            <code>mobs()</code> / <code>setMobs(Map&lt;String, Double&gt; mobs)</code>
            <p>Getter und Setter für die Map der zu spawnenden Mobs. Die Map verknüpft Mob-Definitionen mit deren relativen Spawn-Chancen.</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/TradeRequest.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/TradeRequest.java</h2>
    <p>
        Die Klasse <code>TradeRequest</code> ist ein Datenmodell innerhalb des RPG-Plugins, das eine Handelsanfrage zwischen zwei Spielern repräsentiert. 
        Sie dient als Container für den Status des Handelsprozesses, einschließlich der beteiligten Parteien, der angebotenen Goldmengen und des Bereitschaftsstatus beider Teilnehmer.
    </p>

    <h3>Klasse: TradeRequest</h3>
    <p><strong>Paket:</strong> <code>com.example.rpg.model</code></p>
    <p><strong>Beschreibung:</strong> Verwaltet die Details einer aktiven Handelsinteraktion.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>TradeRequest(UUID requester, UUID target)</code>: 
            Initialisiert eine neue Handelsanfrage mit der eindeutigen ID (UUID) des Anfragenden und des Zielspielers.
        </li>
    </ul>

    <h4>Eigenschaften (Felder)</h4>
    <ul>
        <li><code>requester</code> (UUID): Die ID des Spielers, der den Handel initiiert hat.</li>
        <li><code>target</code> (UUID): Die ID des Spielers, mit dem gehandelt werden soll.</li>
        <li><code>goldOffer</code> (int): Die Menge an Gold, die der Anfragende anbietet.</li>
        <li><code>goldRequest</code> (int): Die Menge an Gold, die der Anfragende vom Zielspieler fordert.</li>
        <li><code>requesterReady</code> (boolean): Gibt an, ob der Anfragende den Handel bestätigt hat.</li>
        <li><code>targetReady</code> (boolean): Gibt an, ob der Zielspieler den Handel bestätigt hat.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li><code>requester()</code>: Gibt die UUID des Anfragenden zurück.</li>
        <li><code>target()</code>: Gibt die UUID des Zielspielers zurück.</li>
        <li><code>goldOffer()</code> / <code>setGoldOffer(int)</code>: Getter und Setter für das Goldangebot des Anfragenden.</li>
        <li><code>goldRequest()</code> / <code>setGoldRequest(int)</code>: Getter und Setter für die Goldforderung an den Zielspieler.</li>
        <li><code>requesterReady()</code> / <code>setRequesterReady(boolean)</code>: Getter und Setter für den Bereitschaftsstatus des Anfragenden.</li>
        <li><code>targetReady()</code> / <code>setTargetReady(boolean)</code>: Getter und Setter für den Bereitschaftsstatus des Zielspielers.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/WorldEvent.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/WorldEvent.java</h2>
    <p>
        Die Klasse <code>WorldEvent</code> repräsentiert ein dynamisches Ereignis in der Spielwelt. 
        Diese Events sind ortsgebunden (Zonen), können mehrere Phasen oder Schritte umfassen und belohnen teilnehmende Spieler mit Erfahrungspunkten, Gold und Fraktionsruf.
    </p>

    <h3>Klasse: WorldEvent</h3>
    <p>
        Dies ist das zentrale Datenmodell für Welt-Ereignisse innerhalb des RPG-Systems. Es speichert den aktuellen Status, die Anforderungen und die Belohnungsstrukturen eines Events.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>WorldEvent(String id)</code>: Erstellt eine neue Instanz eines Welt-Events mit einer eindeutigen Identifikationsnummer.</li>
    </ul>

    <h4>Eigenschaften &amp; Felder</h4>
    <ul>
        <li><code>id</code> (String): Die eindeutige Kennung des Events.</li>
        <li><code>name</code> (String): Der Anzeigename des Ereignisses.</li>
        <li><code>zoneId</code> (String): Die ID der Zone, in der dieses Event stattfindet.</li>
        <li><code>active</code> (boolean): Gibt an, ob das Event momentan aktiv ist und von Spielern absolviert werden kann.</li>
        <li><code>steps</code> (List&lt;QuestStep&gt;): Eine Liste von Schritten oder Phasen, die während des Events abgeschlossen werden müssen.</li>
        <li><code>progress</code> (Map&lt;Integer, Integer&gt;): Speichert den aktuellen Fortschritt der einzelnen Schritte (Schritt-Index zu Fortschrittswert).</li>
        <li><code>rewardXp</code> (int): Die Menge an Erfahrungspunkten, die bei Abschluss gewährt wird.</li>
        <li><code>rewardGold</code> (int): Die Menge an Gold, die als Belohnung ausgezahlt wird.</li>
        <li><code>rewardFactionRep</code> (Map&lt;String, Integer&gt;): Eine Zuordnung von Fraktions-IDs zu Rufpunkten, die Spieler durch das Event erhalten.</li>
        <li><code>unlockQuests</code> (List&lt;String&gt;): Eine Liste von Quest-IDs, die nach erfolgreichem Abschluss dieses Events freigeschaltet werden.</li>
        <li><code>participants</code> (Set&lt;UUID&gt;): Eine Menge der Unique IDs aller Spieler, die aktuell am Event teilnehmen oder dazu beigetragen haben.</li>
    </ul>

    <h4>Wichtige Methoden</h4>
    <ul>
        <li><code>id()</code>, <code>name()</code>, <code>zoneId()</code>: Getter-Methoden für die Basisdaten des Events.</li>
        <li><code>active()</code> / <code>setActive(boolean)</code>: Steuert den Aktivitätsstatus des Events in der Welt.</li>
        <li><code>steps()</code>: Gibt die Liste der definierten <code>QuestStep</code>-Objekte zurück.</li>
        <li><code>progress()</code>: Ermöglicht den Zugriff auf die Fortschrittsdaten der Event-Phasen.</li>
        <li><code>participants()</code>: Gibt die Menge der teilnehmenden Spieler zurück, um Belohnungen korrekt zu verteilen.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/model/Zone.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/model/Zone.java</h2>

    <p>Die Klasse <code>Zone</code> repräsentiert einen definierten räumlichen Bereich innerhalb der Spielwelt eines RPG-Systems. Sie dient dazu, Regionen mit spezifischen Eigenschaften wie Level-Beschränkungen, Bewegungsmodifikatoren oder Schadensmultiplikatoren zu versehen und zu validieren, ob sich ein Spieler innerhalb dieser Grenzen befindet.</p>

    <h3>Klassenübersicht</h3>
    <p><strong>Name:</strong> <code>Zone</code></p>
    <p><strong>Paket:</strong> <code>com.example.rpg.model</code></p>
    <p><strong>Beschreibung:</strong> Ein Datenmodell für Gebietsdefinitionen, das sowohl die geografischen Grenzen (Bounding Box) als auch spielmechanische Metadaten speichert.</p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>Zone(String id)</code>: Erstellt eine neue Zone mit einer eindeutigen Identifikationsnummer.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong>Getter &amp; Setter:</strong>
            <ul>
                <li><code>id()</code>: Gibt die eindeutige ID der Zone zurück.</li>
                <li><code>name()</code> / <code>setName(String name)</code>: Verwaltet den Anzeigenamen der Zone.</li>
                <li><code>world()</code> / <code>setWorld(String world)</code>: Verwaltet den Namen der Welt (Bukkit World), in der sich die Zone befindet.</li>
                <li><code>minLevel()</code> / <code>setMinLevel(int level)</code>: Definiert das empfohlene Mindestlevel für dieses Gebiet.</li>
                <li><code>maxLevel()</code> / <code>setMaxLevel(int level)</code>: Definiert das empfohlene Maximallevel für dieses Gebiet.</li>
                <li><code>slowMultiplier()</code> / <code>setSlowMultiplier(double mult)</code>: Bestimmt den Verlangsamungseffekt innerhalb der Zone (Standard: 1.0).</li>
                <li><code>damageMultiplier()</code> / <code>setDamageMultiplier(double mult)</code>: Bestimmt den Schadensmodifikator innerhalb der Zone (Standard: 1.0).</li>
            </ul>
        </li>
        <li>
            <strong>Geografische Definition:</strong>
            <ul>
                <li><code>setBounds(Location pos1, Location pos2)</code>: Berechnet die minimalen und maximalen Eckpunkte der Zone basierend auf zwei gegebenen <code>Location</code>-Objekten.</li>
                <li><code>setCoordinates(int x1, int y1, int z1, int x2, int y2, int z2)</code>: Setzt die Koordinaten der Zone direkt über Ganzzahlen.</li>
                <li><code>x1(), y1(), z1(), x2(), y2(), z2()</code>: Zugriffsmethoden auf die berechneten Grenzkoordinaten.</li>
            </ul>
        </li>
        <li>
            <strong>Logik:</strong>
            <ul>
                <li>
                    <code>contains(Location location)</code>: Überprüft, ob sich eine gegebene Position innerhalb der Zone befindet.
                    <ul>
                        <li><strong>Parameter:</strong> <code>location</code> - Die zu prüfende Bukkit-Position.</li>
                        <li><strong>Rückgabewert:</strong> <code>boolean</code> - Wahr, wenn die Welt übereinstimmt und die Koordinaten innerhalb der Grenzen liegen.</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>

    <h3>Eigenschaften (Felder)</h3>
    <ul>
        <li><code>id</code>: Eindeutiger Bezeichner (final).</li>
        <li><code>name</code>: Anzeigename der Zone.</li>
        <li><code>world</code>: Name der Zielwelt.</li>
        <li><code>minLevel</code> / <code>maxLevel</code>: Level-Bereich der Zone.</li>
        <li><code>slowMultiplier</code>: Multiplikator für die Bewegungsgeschwindigkeit.</li>
        <li><code>damageMultiplier</code>: Multiplikator für ausgehenden/eingehenden Schaden.</li>
        <li><code>x1, y1, z1</code>: Die minimalen Koordinaten der Bounding Box.</li>
        <li><code>x2, y2, z2</code>: Die maximalen Koordinaten der Bounding Box.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionAuditLog.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionAuditLog.java</h2>
    <p>
        Die Klasse <code>PermissionAuditLog</code> ist für die Protokollierung und Abfrage von sicherheitsrelevanten Ereignissen und Berechtigungsänderungen innerhalb des RPG-Systems zuständig. Sie nutzt eine PostgreSQL-Datenbank zur persistenten Speicherung der Audit-Einträge im JSONB-Format.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Diese Klasse dient als Schnittstelle zwischen der Anwendungslogik und der Datenbanktabelle <code>rpg_audit_log</code>. Sie ermöglicht es, Änderungen nachzuvollziehen (Wer hat was wann geändert) und bietet eine Historienfunktion.
    </p>

    <h3>Konstruktor</h3>
    <ul>
        <li>
            <code>PermissionAuditLog(DatabaseService database)</code>: Initialisiert den Logger mit dem bereitgestellten Datenbankdienst.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong>log(UUID actorUuid, String actorName, String action, String target, Object before, Object after)</strong>
            <p>Erstellt einen neuen Eintrag im Audit-Log.</p>
            <ul>
                <li><code>actorUuid</code>: Die UUID des Spielers oder Administrators, der die Aktion ausführt.</li>
                <li><code>actorName</code>: Der Anzeigename des Akteurs.</li>
                <li><code>action</code>: Eine Beschreibung der durchgeführten Aktion (z.B. "ROLE_ASSIGN").</li>
                <li><code>target</code>: Das Ziel der Aktion (z.B. die UUID des betroffenen Spielers).</li>
                <li><code>before</code>: Der Zustand vor der Änderung (wird automatisch in JSON konvertiert).</li>
                <li><code>after</code>: Der Zustand nach der Änderung (wird automatisch in JSON konvertiert).</li>
            </ul>
        </li>
        <li>
            <strong>recent(int limit)</strong>
            <p>Ruft die neuesten Einträge aus dem Audit-Log ab.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>limit</code> - Die maximale Anzahl der zurückzugebenden Einträge.</li>
                <li><strong>Rückgabewert:</strong> Eine <code>List&lt;String&gt;</code>, die formatierte Log-Einträge (Zeitstempel, Akteur, Aktion, Ziel) enthält.</li>
            </ul>
        </li>
    </ul>

    <h3>Technische Details</h3>
    <ul>
        <li><strong>Datenbank:</strong> Verwendet SQL-Statements mit <code>jsonb</code>-Casting für die Felder <code>before</code> und <code>after</code>, was eine flexible Speicherung von Objektdaten ermöglicht.</li>
        <li><strong>Serialisierung:</strong> Nutzt die <code>Gson</code>-Bibliothek, um Java-Objekte in JSON-Strings für die Datenbank zu transformieren.</li>
        <li><strong>Fehlerbehandlung:</strong> Wirft eine <code>IllegalStateException</code>, falls Datenbankoperationen fehlschlagen.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionDecision.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionDecision.java</h2>
    <p>Diese Datei definiert eine zentrale Enumeration für das Berechtigungssystem des RPG-Plugins. Sie dient dazu, das Ergebnis einer Berechtigungsprüfung eindeutig zu klassifizieren.</p>

    <h3>PermissionDecision (Enum)</h3>
    <p>
        Das Enum <code>PermissionDecision</code> wird verwendet, um den Status einer Berechtigung für einen Spieler oder eine Gruppe darzustellen. Im Gegensatz zu einem einfachen booleschen Wert (wahr/falsch) erlaubt dieses Enum eine differenziertere Logik, insbesondere im Hinblick auf Vererbungshierarchien.
    </p>

    <h4>Mögliche Werte:</h4>
    <ul>
        <li>
            <code>ALLOW</code>: Die Berechtigung wird explizit gewährt. Der Benutzer darf die entsprechende Aktion ausführen.
        </li>
        <li>
            <code>DENY</code>: Die Berechtigung wird explizit verweigert. Der Benutzer darf die entsprechende Aktion nicht ausführen, selbst wenn eine übergeordnete Gruppe dies erlauben würde (Override-Prinzip).
        </li>
        <li>
            <code>INHERIT</code>: Es wurde keine explizite Entscheidung auf dieser Ebene getroffen. Das System soll die Berechtigung von einer übergeordneten Rolle, Gruppe oder Standardeinstellung übernehmen.
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionExplanation.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionExplanation.java</h2>

    <p>
        Die Klasse <code>PermissionExplanation</code> dient als Datencontainer, um das Ergebnis einer Berechtigungsprüfung detailliert zu begründen. 
        Sie speichert nicht nur, ob eine Aktion erlaubt ist, sondern auch, welche Rolle und welcher Berechtigungsknoten ausschlaggebend für die Entscheidung waren.
    </p>

    <h3>Klasse: PermissionExplanation</h3>
    <p>
        Diese Klasse wird primär vom <code>PermissionResolver</code> verwendet, um Transparenz über den Entscheidungsweg des Berechtigungssystems zu schaffen (Audit-Trail).
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>PermissionExplanation(boolean allowed, String winningRole, String winningNode, PermissionDecision winningDecision, List&lt;String&gt; trace)</code>: 
            Initialisiert eine neue Erklärung. Falls die <code>trace</code>-Liste null ist, wird eine leere Liste erstellt.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>allowed()</code>: 
            Gibt zurück, ob der Zugriff gewährt wurde (<code>true</code>) oder nicht (<code>false</code>).
            <br><strong>Rückgabewert:</strong> <code>boolean</code>
        </li>
        <li>
            <code>winningRole()</code>: 
            Gibt den Namen der Rolle zurück, die die finale Entscheidung herbeigeführt hat.
            <br><strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>winningNode()</code>: 
            Gibt den spezifischen Berechtigungsknoten (z. B. <code>rpg.admin.build</code>) zurück, der für das Ergebnis verantwortlich war.
            <br><strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>winningDecision()</code>: 
            Gibt den Typ der Entscheidung zurück (siehe <code>PermissionDecision</code>), z. B. ob die Berechtigung explizit erlaubt oder verweigert wurde.
            <br><strong>Rückgabewert:</strong> <code>PermissionDecision</code>
        </li>
        <li>
            <code>trace()</code>: 
            Gibt eine Liste von Zeichenfolgen zurück, die den Prüfpfad beschreiben (z. B. welche Rollen in welcher Reihenfolge geprüft wurden).
            <br><strong>Rückgabewert:</strong> <code>List&lt;String&gt;</code>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionListener.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionListener.java</h2>
    <p>
        Die Klasse <code>PermissionListener</code> ist eine Event-Listener-Komponente für das Bukkit-Framework. 
        Ihre Hauptaufgabe besteht darin, die Berechtigungsverwaltung (Permissions) mit dem Lebenszyklus eines Spielers auf dem Server zu synchronisieren. 
        Sie stellt sicher, dass Berechtigungen beim Betreten des Servers zugewiesen und beim Verlassen sauber entfernt werden.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class PermissionListener implements Listener</code>
    </p>
    <p>
        Diese Klasse implementiert das <code>Listener</code>-Interface von Bukkit, um auf Server-Events reagieren zu können. 
        Sie hält eine Referenz auf das Haupt-Plugin (<code>RPGPlugin</code>), um auf den <code>PermissionService</code> zuzugreifen.
    </p>

    <h3>Konstruktor</h3>
    <ul>
        <li>
            <code>PermissionListener(RPGPlugin plugin)</code>: Initialisiert den Listener und verknüpft ihn mit der Instanz des RPG-Plugins.
        </li>
    </ul>

    <h3>Methoden (Event-Handler)</h3>
    
    <h4>onJoin</h4>
    <p>
        <code>@EventHandler public void onJoin(PlayerJoinEvent event)</code>
    </p>
    <ul>
        <li><strong>Zweck:</strong> Wird aufgerufen, wenn ein Spieler dem Server beitritt.</li>
        <li><strong>Funktion:</strong> Ruft <code>applyAttachments(Player)</code> im <code>PermissionService</code> auf. Dies bewirkt, dass dem Spieler seine spezifischen Rollen und Berechtigungen über "Permission Attachments" zugewiesen werden.</li>
        <li><strong>Parameter:</strong> <code>PlayerJoinEvent event</code> - Das Bukkit-Event für den Serverbeitritt.</li>
    </ul>

    <h4>onQuit</h4>
    <p>
        <code>@EventHandler public void onQuit(PlayerQuitEvent event)</code>
    </p>
    <ul>
        <li><strong>Zweck:</strong> Wird aufgerufen, wenn ein Spieler den Server verlässt.</li>
        <li><strong>Funktion:</strong> Ruft <code>removeAttachment(UUID)</code> im <code>PermissionService</code> auf. Dies dient der Speicherbereinigung, indem die für den Spieler erstellten Berechtigungs-Objekte aus dem Speicher entfernt werden.</li>
        <li><strong>Parameter:</strong> <code>PlayerQuitEvent event</code> - Das Bukkit-Event für das Verlassen des Servers.</li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Zugriff auf zentrale Dienste.</li>
        <li><code>PermissionService</code>: Logik zur Zuweisung und Entfernung von Berechtigungen.</li>
        <li><code>org.bukkit.event.Listener</code>: Basis-Interface für Event-Handling in Minecraft-Servern.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionRepository.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionRepository.java</h2>
    <p>
        Das Interface <code>PermissionRepository</code> definiert die Standard-Schnittstelle für den Datenzugriff auf Rollen- und Berechtigungsinformationen innerhalb des RPG-Systems. Es dient als Abstraktionsschicht, um verschiedene Speicherlösungen (wie z. B. PostgreSQL oder YAML) austauschbar zu machen.
    </p>

    <h3>Interface: PermissionRepository</h3>
    <p>
        Dieses Interface stellt Methoden bereit, um Rollenkonfigurationen und die Zuweisung von Rollen zu Spielern zu verwalten.
    </p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>List&lt;Role&gt; loadAllRoles()</code>
            <p>Lädt alle im System definierten Rollen aus dem persistenten Speicher.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> Eine Liste aller verfügbaren <code>Role</code>-Objekte.</li>
            </ul>
        </li>
        <li>
            <code>void saveRole(Role role)</code>
            <p>Speichert eine neue Rolle oder aktualisiert eine bestehende Rolle in der Datenbank.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>role</code> - Das zu speichernde Rollen-Objekt.</li>
            </ul>
        </li>
        <li>
            <code>void deleteRole(String roleKey)</code>
            <p>Entfernt eine Rolle dauerhaft aus dem System basierend auf ihrem eindeutigen Schlüssel.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>roleKey</code> - Der Identifikationsschlüssel der zu löschenden Rolle.</li>
            </ul>
        </li>
        <li>
            <code>Optional&lt;PlayerRoles&gt; loadPlayerRoles(UUID playerId)</code>
            <p>Sucht nach den Rollenzuweisungen eines spezifischen Spielers anhand seiner UUID.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>playerId</code> - Die eindeutige ID des Spielers.</li>
                <li><strong>Rückgabewert:</strong> Ein <code>Optional</code>, das die <code>PlayerRoles</code> enthält, sofern vorhanden.</li>
            </ul>
        </li>
        <li>
            <code>void savePlayerRoles(PlayerRoles playerRoles)</code>
            <p>Speichert oder aktualisiert die Verknüpfung zwischen einem Spieler und seinen zugewiesenen Rollen.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>playerRoles</code> - Das Objekt, das die Spieler-ID und die zugehörigen Rollen enthält.</li>
            </ul>
        </li>
        <li>
            <code>List&lt;PlayerRoles&gt; listPlayerRoles()</code>
            <p>Ruft eine vollständige Liste aller Spieler ab, denen Rollen zugewiesen wurden.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> Eine Liste von <code>PlayerRoles</code>-Einträgen für alle bekannten Spieler.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionResolver.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionResolver.java</h2>
    <p>
        Die Klasse <code>PermissionResolver</code> ist eine zentrale Komponente des Berechtigungssystems. Ihre Hauptaufgabe besteht darin, zu prüfen, ob ein Spieler Zugriff auf eine bestimmte Berechtigung (Permission Node) hat. Dabei berücksichtigt sie die primären und zusätzlichen Rollen eines Spielers sowie die Vererbungshierarchien zwischen den Rollen.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        <code>public class PermissionResolver</code>
    </p>
    <p>
        Diese Klasse implementiert die Logik zur Auflösung von Berechtigungen basierend auf einer Map von verfügbaren Rollen und einer Standardentscheidung (Default Decision).
    </p>

    <h3>Konstruktor</h3>
    <ul>
        <li>
            <code>PermissionResolver(Map&lt;String, Role&gt; roles, PermissionDecision defaultDecision)</code>: 
            Initialisiert den Resolver mit dem Rollen-Repository und legt fest, wie verfahren wird, wenn keine explizite Berechtigung gefunden wird.
        </li>
    </ul>

    <h3>Öffentliche Methoden</h3>
    <ul>
        <li>
            <code>public PermissionExplanation explain(PlayerRoles playerRoles, String node)</code>
            <p>
                Analysiert die Berechtigung für einen Spieler und liefert eine detaillierte Erklärung (Trace) zurück.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>playerRoles</code> (Die Rollen des Spielers), <code>node</code> (Der zu prüfende Berechtigungsknoten).</li>
                <li><strong>Rückgabewert:</strong> Ein <code>PermissionExplanation</code>-Objekt, das die Entscheidung, die gewinnende Rolle und den Pfad der Entscheidungsfindung enthält.</li>
            </ul>
        </li>
        <li>
            <code>public boolean resolve(PlayerRoles playerRoles, String node)</code>
            <p>
                Eine vereinfachte Methode, die lediglich ein <code>boolean</code> zurückgibt, ob der Zugriff erlaubt ist oder nicht.
            </p>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>true</code>, wenn die Berechtigung gewährt wurde, ansonsten <code>false</code>.</li>
            </ul>
        </li>
    </ul>

    <h3>Private Hilfsmethoden und Logik</h3>
    <ul>
        <li>
            <code>collectRoleKeys(PlayerRoles playerRoles)</code>: 
            Sammelt alle Rollen-IDs des Spielers, einschließlich aller durch Vererbung (Parents) erreichbaren Rollen, mittels einer Breitensuche (BFS).
        </li>
        <li>
            <code>resolveForRoles(Set&lt;String&gt; roleKeys, String node, List&lt;String&gt; trace)</code>: 
            Durchläuft alle gesammelten Rollen und prüft deren Berechtigungsknoten gegen den Zielknoten. 
            <strong>Priorisierung:</strong> Ein explizites <code>DENY</code> bricht die Suche sofort ab und hat Vorrang. <code>ALLOW</code> wird vermerkt, kann aber durch ein späteres <code>DENY</code> überschrieben werden.
        </li>
        <li>
            <code>matches(String rule, String node)</code>: 
            Prüft, ob eine Regel auf einen Knoten passt. Unterstützt exakte Übereinstimmungen (Case-Insensitive) sowie Wildcards am Ende (z. B. <code>rpg.admin.*</code>).
        </li>
        <li>
            <code>finalizeDecision(...)</code>: 
            Konstruiert das finale <code>PermissionExplanation</code>-Objekt.
        </li>
    </ul>

    <h3>Interne Datenstrukturen</h3>
    <ul>
        <li>
            <code>private record DecisionResult</code>: 
            Ein interner Datensatz zum temporären Speichern des Ergebnisses der Rollenprüfung (Entscheidung, verantwortliche Rolle und der passende Knoten).
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionService.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PermissionService.java</h2>
    <p>Der <code>PermissionService</code> ist die zentrale Komponente zur Verwaltung und Prüfung von Berechtigungen innerhalb des RPG-Plugins. Er implementiert ein rollenbasiertes Berechtigungssystem (RBAC) mit Unterstützung für Vererbung, Caching und Audit-Logging.</p>

    <h3>Klasse: PermissionService</h3>
    <p>Diese Klasse verwaltet die Zuweisung von Rollen an Spieler, die Definition von Berechtigungsknoten innerhalb von Rollen und die Auflösung komplexer Vererbungshierarchien.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>PermissionService(JavaPlugin plugin, DatabaseService database, boolean enabled, String defaultRole, PermissionDecision defaultDecision, boolean opBypass, boolean auditEnabled, long cacheTtlSeconds)</code>: Initialisiert den Service mit Konfigurationswerten, Datenbankanbindung und Cache-Einstellungen.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>void reload()</code>
            <p>Lädt alle Rollen aus dem Repository neu und leert die aktuellen Caches. Falls keine Rollen vorhanden sind, werden Standardrollen (Spieler, Moderator, Admin) erstellt.</p>
        </li>
        <li>
            <code>boolean has(Player player, String node)</code>
            <p>Prüft, ob ein Spieler über eine bestimmte Berechtigung verfügt. Berücksichtigt dabei den OP-Status (falls konfiguriert) und das Plugin-eigene Berechtigungssystem.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>player</code> - Der zu prüfende Spieler; <code>node</code> - Der Berechtigungsknoten (z.B. "rpg.admin.use").</li>
                <li><strong>Rückgabewert:</strong> <code>true</code>, wenn der Zugriff erlaubt ist.</li>
            </ul>
        </li>
        <li>
            <code>PermissionExplanation explain(Player player, String node)</code>
            <p>Liefert eine detaillierte Erklärung, warum eine Berechtigung gewährt oder verweigert wurde (nützlich für Debugging).</p>
        </li>
        <li>
            <code>void applyAttachments(Player player)</code>
            <p>Synchronisiert die internen Rollen-Berechtigungen mit dem Standard-Berechtigungssystem von Bukkit (PermissionAttachments), damit auch andere Plugins die Berechtigungen korrekt erkennen.</p>
        </li>
        <li>
            <code>void createRole(Player actor, String key, String displayName)</code>
            <p>Erstellt eine neue Rolle und speichert sie in der Datenbank.</p>
        </li>
        <li>
            <code>void setRoleNode(Player actor, String roleKey, String node, PermissionDecision decision)</code>
            <p>Setzt oder entfernt einen Berechtigungsknoten für eine spezifische Rolle.</p>
            <ul>
                <li><strong>Entscheidungen:</strong> <code>ALLOW</code>, <code>DENY</code> oder <code>INHERIT</code>.</li>
            </ul>
        </li>
        <li>
            <code>boolean addParent(Player actor, String roleKey, String parentKey)</code>
            <p>Fügt einer Rolle eine Elternrolle zur Vererbung hinzu. Verhindert automatisch zirkuläre Abhängigkeiten.</p>
        </li>
        <li>
            <code>void assignPrimary(Player actor, UUID playerId, String roleKey)</code>
            <p>Weist einem Spieler eine primäre Rolle zu.</p>
        </li>
        <li>
            <code>PlayerRoles getPlayerRoles(UUID playerId)</code>
            <p>Ruft die Rolleninformationen eines Spielers ab oder erstellt ein Standardprofil, falls noch keines existiert.</p>
        </li>
    </ul>

    <h4>Private Hilfskomponenten</h4>
    <ul>
        <li><code>CacheEntry</code>: Ein <code>record</code> zur Speicherung von aufgelösten Berechtigungen im Speicher mit einer Time-to-Live (TTL).</li>
        <li><code>resolve(UUID playerId, String node)</code>: Interne Logik zur Berechtigungsprüfung unter Einbeziehung des Caches.</li>
        <li><code>createsCycle(String roleKey, String parentKey)</code>: Algorithmus zur Erkennung von Endlosschleifen in der Rollenvererbung.</li>
        <li><code>audit(...)</code>: Protokolliert Änderungen an Rollen oder Zuweisungen im Audit-Log, sofern aktiviert.</li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>PermissionRepository</code>: Schnittstelle zur dauerhaften Speicherung (implementiert via <code>PostgresPermissionRepository</code>).</li>
        <li><code>PermissionResolver</code>: Logik-Komponente zur Auflösung der Vererbungshierarchie.</li>
        <li><code>PermissionAuditLog</code>: System zur Protokollierung von administrativen Eingriffen.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PlayerRoles.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PlayerRoles.java</h2>

    <p>Die Klasse <code>PlayerRoles</code> dient als Datenmodell zur Verwaltung der Rollenzuweisungen eines spezifischen Spielers innerhalb des Berechtigungssystems. Sie verknüpft eine eindeutige Spieler-ID (UUID) mit einer Hauptrolle und einer Menge von zusätzlichen Rollen.</p>

    <h3>Klasse: PlayerRoles</h3>
    <p><strong>Beschreibung:</strong> Repräsentiert die Rollenstruktur eines Spielers im RPG-System.</p>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>public PlayerRoles(UUID playerId)</code>: Erstellt ein neues Rollenobjekt für die angegebene Spieler-ID.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <strong><code>playerId()</code></strong>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>UUID</code></li>
                <li><strong>Beschreibung:</strong> Gibt die eindeutige Identifikationsnummer des Spielers zurück.</li>
            </ul>
        </li>
        <li>
            <strong><code>primaryRole()</code></strong>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>String</code></li>
                <li><strong>Beschreibung:</strong> Gibt den Namen der primären Rolle des Spielers zurück (z. B. "Admin" oder "Spieler").</li>
            </ul>
        </li>
        <li>
            <strong><code>setPrimaryRole(String primaryRole)</code></strong>
            <ul>
                <li><strong>Parameter:</strong> <code>primaryRole</code> (String) - Der Name der neuen Hauptrolle.</li>
                <li><strong>Beschreibung:</strong> Legt die primäre Rolle für den Spieler fest.</li>
            </ul>
        </li>
        <li>
            <strong><code>extraRoles()</code></strong>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>Set&lt;String&gt;</code></li>
                <li><strong>Beschreibung:</strong> Gibt eine Menge (Set) aller zusätzlichen Rollen zurück, die dem Spieler zugewiesen wurden. Dies ermöglicht eine granulare Berechtigungssteuerung über die Hauptrolle hinaus.</li>
            </ul>
        </li>
    </ul>

    <h4>Felder</h4>
    <ul>
        <li><code>playerId</code>: Die UUID des Spielers (final).</li>
        <li><code>primaryRole</code>: Die Hauptrolle des Spielers.</li>
        <li><code>extraRoles</code>: Ein <code>HashSet</code>, das zusätzliche Rollenbezeichnungen speichert.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PostgresPermissionRepository.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/PostgresPermissionRepository.java</h2>
    <p>
        Die Klasse <code>PostgresPermissionRepository</code> ist eine konkrete Implementierung des <code>PermissionRepository</code>-Interfaces. 
        Sie dient der persistenten Speicherung und Verwaltung von Rollen und Berechtigungen in einer PostgreSQL-Datenbank. 
        Dabei werden komplexe Datenstrukturen wie Sets und Maps als JSONB-Objekte in der Datenbank abgelegt.
    </p>

    <h3>Klasse: PostgresPermissionRepository</h3>
    <p>
        Diese Klasse stellt die Verbindung zwischen der Anwendungslogik für Berechtigungen und der relationalen Datenbank her.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>PostgresPermissionRepository(DatabaseService database)</code>: Initialisiert das Repository mit einem <code>DatabaseService</code>, um Datenbankverbindungen zu beziehen.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>loadAllRoles()</code>
            <p>Lädt alle definierten Rollen aus der Tabelle <code>rpg_roles</code>. Verarbeitet JSON-Daten für Elternrollen (Parents) und Berechtigungsknoten (Nodes).</p>
            <strong>Rückgabewert:</strong> <code>List&lt;Role&gt;</code> - Eine Liste aller verfügbaren Rollenobjekte.
        </li>
        <li>
            <code>saveRole(Role role)</code>
            <p>Speichert eine Rolle in der Datenbank. Verwendet ein "Upsert"-Verfahren (INSERT ON CONFLICT), um bestehende Rollen zu aktualisieren oder neue anzulegen.</p>
            <strong>Parameter:</strong> <code>Role role</code> - Das zu speichernde Rollenobjekt.
        </li>
        <li>
            <code>deleteRole(String roleKey)</code>
            <p>Löscht eine spezifische Rolle basierend auf ihrem eindeutigen Schlüssel aus der Datenbank.</p>
            <strong>Parameter:</strong> <code>String roleKey</code> - Der Identifikationsschlüssel der Rolle.
        </li>
        <li>
            <code>loadPlayerRoles(UUID playerId)</code>
            <p>Ruft die zugewiesenen Rollen eines spezifischen Spielers aus der Tabelle <code>rpg_player_roles</code> ab.</p>
            <strong>Parameter:</strong> <code>UUID playerId</code> - Die eindeutige ID des Spielers.
            <strong>Rückgabewert:</strong> <code>Optional&lt;PlayerRoles&gt;</code> - Ein Optional, das die Rollendaten des Spielers enthält, sofern vorhanden.
        </li>
        <li>
            <code>savePlayerRoles(PlayerRoles playerRoles)</code>
            <p>Speichert oder aktualisiert die Rollenzuweisungen eines Spielers (primäre Rolle und zusätzliche Rollen).</p>
            <strong>Parameter:</strong> <code>PlayerRoles playerRoles</code> - Das Objekt mit den Spieler-Rollen-Verknüpfungen.
        </li>
        <li>
            <code>listPlayerRoles()</code>
            <p>Listet alle in der Datenbank vorhandenen Spieler-Rollen-Zuweisungen auf.</p>
            <strong>Rückgabewert:</strong> <code>List&lt;PlayerRoles&gt;</code> - Eine Liste aller gespeicherten Spieler-Rollen-Profile.
        </li>
    </ul>

    <h3>Technische Details</h3>
    <ul>
        <li><strong>Datenbank-Mapping:</strong> Die Felder <code>parents</code> und <code>nodes</code> (in Rollen) sowie <code>extra_roles</code> (bei Spielern) werden mittels <strong>Gson</strong> in JSON-Strings serialisiert und als <code>jsonb</code>-Typ in PostgreSQL gespeichert.</li>
        <li><strong>Fehlerbehandlung:</strong> SQL-Ausnahmen werden abgefangen und als <code>IllegalStateException</code> mit einer beschreibenden Fehlermeldung weitergegeben.</li>
        <li><strong>Abhängigkeiten:</strong> Nutzt <code>com.example.rpg.db.DatabaseService</code> für das Connection-Pooling.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/Role.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/permissions/Role.java</h2>
    <p>
        Die Klasse <code>Role</code> repräsentiert eine Berechtigungsrolle innerhalb des RPG-Systems. 
        Sie dient als Container für Berechtigungsknoten und unterstützt Vererbungshierarchien durch die Definition von Elternrollen.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Diese Klasse ist ein zentraler Bestandteil des Berechtigungssystems (Permissions), um Spielern oder Gruppen spezifische Rechte zuzuweisen.
    </p>

    <h3>Konstruktor</h3>
    <ul>
        <li>
            <code>Role(String key, String displayName)</code>: 
            Initialisiert eine neue Rolle mit einem eindeutigen Identifikationsschlüssel und einem Anzeigenamen.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>key()</code>: 
            Gibt den eindeutigen technischen Schlüssel (ID) der Rolle zurück.
            <br><strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>displayName()</code>: 
            Gibt den lesbaren Namen der Rolle zurück, der in der Benutzeroberfläche angezeigt werden kann.
            <br><strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>setDisplayName(String displayName)</code>: 
            Aktualisiert den Anzeigenamen der Rolle.
            <br><strong>Parameter:</strong> <code>displayName</code> (Der neue Name)
        </li>
        <li>
            <code>parents()</code>: 
            Gibt eine Menge (Set) von Schlüsseln anderer Rollen zurück, von denen diese Rolle Berechtigungen erbt.
            <br><strong>Rückgabewert:</strong> <code>Set&lt;String&gt;</code>
        </li>
        <li>
            <code>nodes()</code>: 
            Gibt eine Map der Berechtigungsknoten zurück. Jeder Knoten ist mit einer <code>PermissionDecision</code> verknüpft, die bestimmt, ob die Berechtigung erlaubt oder verweigert wird.
            <br><strong>Rückgabewert:</strong> <code>Map&lt;String, PermissionDecision&gt;</code>
        </li>
    </ul>

    <h3>Eigenschaften (Felder)</h3>
    <ul>
        <li><code>key</code>: Ein finaler String, der die Rolle eindeutig identifiziert.</li>
        <li><code>displayName</code>: Der Name der Rolle für die Anzeige.</li>
        <li><code>parents</code>: Ein <code>HashSet</code>, das die IDs der übergeordneten Rollen speichert.</li>
        <li><code>nodes</code>: Eine <code>HashMap</code>, die Berechtigungs-Strings auf ihre jeweiligen Entscheidungszustände (<code>PermissionDecision</code>) mappt.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/RPGPlugin.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/RPGPlugin.java</h2>
    <p>Die Klasse <code>RPGPlugin</code> ist die zentrale Hauptklasse des RPG-Plugins für Minecraft (Bukkit/Spigot). Sie fungiert als Kernstück des Systems, initialisiert alle Manager-Dienste, registriert Event-Listener und verwaltet die Lebenszyklen der verschiedenen Spielmechaniken wie Quests, Skills, Dungeons und Gilden.</p>

    <h3>Hauptkomponenten</h3>
    <ul>
        <li><strong>Manager-Initialisierung:</strong> In der <code>onEnable()</code>-Methode werden über 30 spezialisierte Manager (z. B. <code>QuestManager</code>, <code>SkillManager</code>, <code>DungeonManager</code>) instanziiert, die die Logik für die jeweiligen Teilbereiche kapseln.</li>
        <li><strong>Datenbank-Anbindung:</strong> Nutzt einen <code>DatabaseService</code> zur persistenten Speicherung von Spielerprofilen, Gilden und Berechtigungen.</li>
        <li><strong>NamespacedKeys:</strong> Definiert eine Vielzahl von Schlüsseln für die Speicherung von Metadaten auf Items und Entitäten (z. B. <code>questKey</code>, <code>skillKey</code>, <code>permRoleKey</code>).</li>
    </ul>

    <h3>Wichtige Methoden</h3>
    <ul>
        <li>
            <code>onEnable()</code>: 
            <p>Initialisiert das Plugin, lädt Konfigurationen, startet Datenbankverbindungen, registriert alle Befehle (Commands) und Listener und startet diverse Hintergrund-Tasks (HUD, Mana-Regeneration, Season-Checks).</p>
        </li>
        <li>
            <code>onDisable()</code>: 
            <p>Sorgt für ein sicheres Herunterfahren des Plugins, indem alle flüchtigen Daten der Manager (Spielerprofile, Quests, Gilden, Auktionshaus-Listings) persistent gespeichert werden.</p>
        </li>
        <li>
            <code>useSkill(Player player, String skillId)</code>: 
            <p>Verarbeitet die Aktivierung eines Skills durch einen Spieler. Prüft Voraussetzungen wie Cooldown, Manakosten und ob der Skill gelernt wurde. Wendet bei Erfolg die konfigurierten Effekte an.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>player</code> (Der ausführende Spieler), <code>skillId</code> (ID des Skills).</li>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> (True, wenn der Skill erfolgreich ausgeführt wurde).</li>
            </ul>
        </li>
        <li>
            <code>useMobSkill(LivingEntity caster, Player target, String skillId)</code>: 
            <p>Ermöglicht es benutzerdefinierten Mobs, Skills gegen Spieler einzusetzen. Unterstützt Effekte wie Schaden, Projektile, Tränke, Partikel und Sounds.</p>
        </li>
        <li>
            <code>broadcastLoot(Player player, ItemStack item)</code>: 
            <p>Sendet eine formatierte Nachricht an den gesamten Server, wenn ein Spieler ein wertvolles Item gelootet hat (sofern in der Config aktiviert).</p>
        </li>
        <li>
            <code>completeQuestIfReady(Player player, Quest quest, QuestProgress progress)</code>: 
            <p>Überprüft, ob alle Schritte einer Quest erfüllt sind. Falls ja, markiert sie die Quest als abgeschlossen und verteilt Belohnungen (XP, Skillpunkte, Fraktionsruf).</p>
        </li>
    </ul>

    <h3>Hintergrund-Tasks</h3>
    <ul>
        <li><strong>HUD Task:</strong> Aktualisiert alle 10 Ticks die Actionbar der Spieler mit Informationen zu Leben, Mana und Gold sowie den Cooldown-Fortschritt des gehaltenen Skills.</li>
        <li><strong>Mana Regen Task:</strong> Regeneriert alle 2 Sekunden (40 Ticks) 5 Manapunkte für alle Online-Spieler.</li>
        <li><strong>Guild Hall Buff Task:</strong> Gewährt Spielern Regeneration und Resistenz, wenn sie sich in der Nähe ihrer Gilden-Halle aufhalten (abhängig vom Upgrade-Level).</li>
        <li><strong>Debug Task:</strong> Zeigt Spielern im Debug-Modus technische Informationen wie die aktuelle Zone und die Anzahl aktiver Quests an.</li>
    </ul>

    <h3>Getter-Methoden</h3>
    <p>Die Klasse bietet eine umfangreiche API von Getter-Methoden (z. B. <code>playerDataManager()</code>, <code>dungeonManager()</code>, <code>permissionService()</code>), um anderen Teilen des Plugins Zugriff auf die zentralen Instanzen der Logik-Komponenten zu ermöglichen.</p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/BlockEntityApplier.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/BlockEntityApplier.java</h2>
    <p>
        Die Klasse <code>BlockEntityApplier</code> ist dafür verantwortlich, NBT-Daten (Named Binary Tag) auf Block-Entitäten (Block Entities) in der Spielwelt anzuwenden. Dies wird primär beim Einfügen von Schematics (Bauplänen) verwendet, um spezifische Daten wie Schildtexte, Spawner-Typen oder Containernamen korrekt zu übertragen und zu transformieren.
    </p>

    <h3>Klasse: BlockEntityApplier</h3>
    <p>Verarbeitet die Metadaten von Blöcken während des Platzierungsvorgangs.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>BlockEntityApplier(Logger logger)</code>: Initialisiert den Applier mit einem Logger für die Fehlerprotokollierung.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>public void apply(World world, Location origin, NbtCompound nbt, Transform transform, int width, int length)</code>
            <p>Wendet NBT-Daten auf einen Block an einer bestimmten Position an.</p>
            <ul>
                <li><strong>world:</strong> Die Zielwelt, in der sich der Block befindet.</li>
                <li><strong>origin:</strong> Der Basispunkt (Ursprung) der Schematic-Platzierung.</li>
                <li><strong>nbt:</strong> Das <code>NbtCompound</code>, das die Daten der Block-Entität enthält.</li>
                <li><strong>transform:</strong> Das Transformationsobjekt zur Berechnung von Rotation und Spiegelung.</li>
                <li><strong>width / length:</strong> Die Dimensionen der Schematic zur korrekten Positionsberechnung.</li>
            </ul>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>applySign(Sign sign, NbtCompound nbt)</code>
            <p>Extrahiert Textdaten aus dem NBT (unterstützt sowohl das alte Format als auch das neuere <code>front_text</code> Format) und schreibt sie auf ein Schild.</p>
        </li>
        <li>
            <code>applySpawner(CreatureSpawner spawner, NbtCompound nbt)</code>
            <p>Liest die Entity-ID aus den Spawner-Daten aus und setzt den Typ des Kreaturen-Spawners (z. B. ZOMBIE, SKELETON).</p>
        </li>
        <li>
            <code>applyContainerName(BlockState container, NbtCompound nbt)</code>
            <p>Setzt den benutzerdefinierten Namen (CustomName) für Container wie Truhen (Chest) oder Fässer (Barrel).</p>
        </li>
        <li>
            <code>readPos(NbtCompound nbt)</code>
            <p>Liest die relative Position der Entität aus dem NBT-Tag aus, wobei sowohl Integer-Arrays als auch Double-Listen unterstützt werden.</p>
            <p><strong>Rückgabewert:</strong> Ein <code>int[]</code> mit [x, y, z] Koordinaten oder <code>null</code>.</p>
        </li>
        <li>
            <code>parseSignText(String raw)</code>
            <p>Bereinigt und parst JSON-formatierte Textstrings, um den reinen Text für Schilder oder Namen zu extrahieren.</p>
        </li>
        <li>
            <code>stripNamespace(String id)</code>
            <p>Entfernt den Minecraft-Namespace (z. B. <code>minecraft:</code>) von einer ID, um sie mit der Bukkit-API kompatibel zu machen.</p>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/BlockPalette.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/BlockPalette.java</h2>

    <p>
        Die Klasse <code>BlockPalette</code> dient als Mapping-Struktur innerhalb des Schematic-Systems. Sie verwaltet die Zuordnung zwischen numerischen IDs (wie sie oft in binären Formaten wie NBT vorkommen) und den entsprechenden Blockzustands-Strings (BlockStates) von Minecraft.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Diese Klasse ist unveränderlich (immutable) konzipiert, da sie eine Kopie der übergebenen Map speichert. Dies stellt sicher, dass die Palette nach der Initialisierung konsistent bleibt.
    </p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code><strong>BlockPalette(Map&lt;Integer, String&gt; idToState)</strong></code>: 
            Erstellt eine neue Instanz der Palette. 
            <ul>
                <li><strong>Parameter:</strong> <code>idToState</code> - Eine Map, die Ganzzahl-IDs mit ihren jeweiligen BlockState-Strings verknüpft.</li>
                <li><strong>Besonderheit:</strong> Verwendet <code>Map.copyOf()</code>, um eine nicht modifizierbare Kopie der Daten zu erstellen.</li>
            </ul>
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code><strong>getState(int id)</strong></code>
            <p>Gibt den Blockzustand zurück, der der angegebenen ID zugeordnet ist.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>id</code> - Die numerische ID des Blocks aus der Palette.</li>
                <li><strong>Rückgabewert:</strong> Ein <code>String</code>, der den Minecraft-Blockzustand repräsentiert (z. B. <code>"minecraft:stone"</code>), oder <code>null</code>, falls die ID nicht existiert.</li>
            </ul>
        </li>
        <li>
            <code><strong>size()</strong></code>
            <p>Gibt die Anzahl der in dieser Palette registrierten Blocktypen zurück.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>int</code> - Die Gesamtanzahl der Einträge in der Palette.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/EntitySpawner.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/EntitySpawner.java</h2>
    <p>
        Die Klasse <code>EntitySpawner</code> ist verantwortlich für das Erzeugen und Konfigurieren von Minecraft-Entities, die in einer Schematic-Datei gespeichert sind. Sie verarbeitet NBT-Daten, berechnet die korrekte Position unter Berücksichtigung von Transformationen (Rotation/Spiegelung) und wendet spezifische Eigenschaften auf die gespawnten Entities an.
    </p>

    <h3>Klasse: EntitySpawner</h3>
    <p>
        Diese Klasse stellt die Logik bereit, um Entities aus NBT-Strukturen in die Spielwelt zu übertragen.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>EntitySpawner(Logger logger)</code>: Initialisiert den Spawner mit einem Logger für Fehlermeldungen und Warnungen bei unbekannten Entity-Typen.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public void spawn(World world, Location origin, NbtCompound nbt, Transform transform, int width, int length)</code>
            <p>
                Hauptmethode zum Erzeugen einer Entity. Sie extrahiert die ID aus dem NBT, bestimmt den <code>EntityType</code>, berechnet die transformierte Position und führt das Spawning in der Welt aus.
            </p>
            <ul>
                <li><strong>world</strong>: Die Zielwelt.</li>
                <li><strong>origin</strong>: Der Basispunkt (Nullpunkt) der Schematic-Platzierung.</li>
                <li><strong>nbt</strong>: Die NBT-Daten der Entity.</li>
                <li><strong>transform</strong>: Das angewendete Transformations-Objekt.</li>
                <li><strong>width/length</strong>: Die Dimensionen der Schematic zur korrekten Positionsberechnung.</li>
            </ul>
        </li>
        <li>
            <code>private Location resolvePosition(...)</code>
            <p>
                Berechnet die absolute Welt-Position der Entity. Dabei werden die relativen Koordinaten aus der NBT-Liste "Pos" extrahiert und durch das <code>Transform</code>-Objekt angepasst.
            </p>
        </li>
        <li>
            <code>private void applyArmorStand(ArmorStand armorStand, NbtCompound nbt)</code>
            <p>
                Wendet spezifische NBT-Tags auf einen Rüstungsständer an, wie z.B. <code>Small</code>, <code>Invisible</code>, <code>ShowArms</code> und <code>CustomName</code>.
            </p>
        </li>
        <li>
            <code>private void applyItemFrame(ItemFrame itemFrame, NbtCompound nbt)</code>
            <p>
                Konfiguriert einen Rahmen (Item Frame), indem das im NBT definierte Item (Material und Anzahl) in den Rahmen gesetzt wird.
            </p>
        </li>
        <li>
            <code>private String stripNamespace(String id)</code>
            <p>
                Hilfsmethode, die den Minecraft-Namespace (z.B. "minecraft:") von einer ID entfernt, um die Kompatibilität mit Bukkit-Methoden zu gewährleisten.
            </p>
        </li>
    </ul>

    <h3>Unterstützte Entity-Spezialisierungen</h3>
    <ul>
        <li><strong>ArmorStand</strong>: Unterstützung für Größe, Sichtbarkeit, Arme und Namen.</li>
        <li><strong>ItemFrame</strong>: Unterstützung für das enthaltene Item.</li>
        <li><strong>Allgemeine Entities</strong>: Alle anderen Typen werden als Standard-Entity ohne zusätzliche NBT-Datenanpassung gespawnt.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtByte.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtByte.java</h2>
    <p>
        Die Datei <code>NbtByte.java</code> definiert einen spezifischen Datentyp innerhalb des NBT-Systems (Named Binary Tag), das für die Handhabung von Minecraft-Schematics verwendet wird. 
        Sie ist als Java-Record implementiert, was eine kompakte und unveränderliche Datenstruktur gewährleistet.
    </p>

    <h3>Klasse: NbtByte</h3>
    <p>
        Ein Record, der einen einzelnen <code>byte</code>-Wert repräsentiert und das Interface <code>NbtTag</code> implementiert.
    </p>

    <h4>Komponenten &amp; Parameter</h4>
    <ul>
        <li><code>byte value</code>: Der eigentliche numerische Wert (8-Bit Ganzzahl), den dieser NBT-Tag speichert.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>typeId()</code>: 
            Gibt den Identifikator für den NBT-Typ zurück.
            <ul>
                <li><strong>Rückgabewert:</strong> <code>byte</code> – Entspricht der Konstante <code>NbtType.BYTE</code>.</li>
            </ul>
        </li>
    </ul>

    <h4>Zusammenhang im Projekt</h4>
    <p>
        Diese Klasse ist Teil des NBT-Frameworks im <code>schematic</code>-Paket. Sie dient dazu, binäre Datenstrukturen abzubilden, die für das Speichern und Laden von Welt-Fragmenten (Schematics) notwendig sind. Durch die Implementierung von <code>NbtTag</code> kann sie polymorph in Listen (<code>NbtList</code>) oder Compounds (<code>NbtCompound</code>) verwendet werden.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtByteArray.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtByteArray.java</h2>

    <p>
        Die Datei <code>NbtByteArray.java</code> definiert einen spezifischen Datentyp innerhalb der NBT-Struktur (Named Binary Tag), 
        die für die Handhabung von Minecraft-Schematics und anderen binären Datenformaten im RPG-Plugin verwendet wird.
    </p>

    <h3>Klasse: NbtByteArray</h3>
    <p>
        <strong>Typ:</strong> Java Record<br>
        <strong>Implementiert:</strong> <code>NbtTag</code>
    </p>
    <p>
        Ein Java Record, der ein Array von Bytes (<code>byte[]</code>) kapselt. Records bieten eine kompakte Syntax für Klassen, 
        die hauptsächlich als Datenträger dienen, und generieren automatisch Konstruktoren, Zugriffsmethoden sowie <code>equals</code>, 
        <code>hashCode</code> und <code>toString</code>.
    </p>

    <h4>Parameter (Record Components)</h4>
    <ul>
        <li><code>byte[] value</code>: Das eigentliche Byte-Array, das die Daten dieses NBT-Tags enthält.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>typeId()</code>: 
            Gibt die eindeutige Identifikationsnummer für diesen NBT-Typ zurück.
            <ul>
                <li><strong>Rückgabewert:</strong> <code>NbtType.BYTE_ARRAY</code> (entspricht dem Standard-NBT-Typ 7).</li>
            </ul>
        </li>
    </ul>

    <h3>Kontext innerhalb des Projekts</h3>
    <p>
        Dieses Record ist Teil des NBT-Systems im Paket <code>com.example.rpg.schematic.nbt</code>. Es wird zusammen mit anderen 
        NBT-Tags (wie <code>NbtInt</code>, <code>NbtCompound</code>, etc.) verwendet, um komplexe Datenstrukturen abzubilden, 
        die für das Laden und Speichern von Gebäuden oder Dungeon-Teilen (Schematics) notwendig sind.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtCompound.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtCompound.java</h2>
    <p>
        Die Klasse <code>NbtCompound</code> ist eine Implementierung des <code>NbtTag</code>-Interfaces. Sie fungiert als Container für eine Sammlung von benannten NBT-Tags (Named Binary Tag) und ähnelt in ihrer Funktionsweise einer Map oder einem Dictionary. Sie ist eine zentrale Komponente für die Handhabung komplexer Datenstrukturen innerhalb von Minecraft-Schematics.
    </p>

    <h3>Klassen-Definition</h3>
    <p><strong>Name:</strong> <code>NbtCompound</code></p>
    <p><strong>Interface:</strong> Implementiert <code>NbtTag</code></p>
    <p><strong>Beschreibung:</strong> Speichert eine interne <code>Map&lt;String, NbtTag&gt;</code>, um verschiedene Datentypen unter eindeutigen Schlüsseln zu organisieren.</p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>typeId()</code>: Gibt die ID des NBT-Typs zurück.
            <ul>
                <li><strong>Rückgabewert:</strong> <code>NbtType.COMPOUND</code> (byte).</li>
            </ul>
        </li>
        <li>
            <code>put(String name, NbtTag tag)</code>: Fügt ein neues Tag zum Compound hinzu.
            <ul>
                <li><strong>Parameter:</strong> <code>name</code> (Schlüssel), <code>tag</code> (das zu speichernde NbtTag-Objekt).</li>
            </ul>
        </li>
        <li>
            <code>values()</code>: Liefert alle enthaltenen Tags.
            <ul>
                <li><strong>Rückgabewert:</strong> Eine nicht modifizierbare <code>Map&lt;String, NbtTag&gt;</code>.</li>
            </ul>
        </li>
        <li>
            <code>get(String name)</code>: Ruft ein generisches Tag anhand seines Namens ab.
            <ul>
                <li><strong>Rückgabewert:</strong> Das <code>NbtTag</code> oder <code>null</code>, falls nicht vorhanden.</li>
            </ul>
        </li>
        <li>
            <code>getString(String name, String fallback)</code>: Hilfsmethode zum Abrufen eines Strings.
            <ul>
                <li><strong>Parameter:</strong> Schlüsselname und ein Standardwert (Fallback).</li>
                <li><strong>Rückgabewert:</strong> Der String-Wert oder der Fallback, falls der Typ nicht passt oder der Schlüssel fehlt.</li>
            </ul>
        </li>
        <li>
            <code>getNumber(String name)</code>: Eine interne Hilfsmethode, die versucht, ein Tag als numerischen Wert (Byte, Short, Int, Long, Float, Double) zu interpretieren.
            <ul>
                <li><strong>Rückgabewert:</strong> Ein <code>Number</code>-Objekt oder <code>null</code>.</li>
            </ul>
        </li>
        <li>
            <code>getInt / getLong / getDouble</code>: Spezifische Getter für numerische Primitive.
            <ul>
                <li><strong>Parameter:</strong> Schlüsselname und Fallback-Wert.</li>
                <li><strong>Funktionsweise:</strong> Nutzt <code>getNumber()</code> und konvertiert das Ergebnis in den gewünschten Zieltyp.</li>
            </ul>
        </li>
        <li>
            <code>getCompound(String name)</code>: Ruft ein verschachteltes <code>NbtCompound</code> ab.
            <ul>
                <li><strong>Rückgabewert:</strong> Das <code>NbtCompound</code> oder <code>null</code>.</li>
            </ul>
        </li>
        <li>
            <code>getList(String name)</code>: Ruft eine <code>NbtList</code> ab.
            <ul>
                <li><strong>Rückgabewert:</strong> Die Liste oder <code>null</code>.</li>
            </ul>
        </li>
        <li>
            <code>getByteArray / getIntArray / getLongArray</code>: Spezialisierte Getter für Array-Typen.
            <ul>
                <li><strong>Rückgabewert:</strong> Das entsprechende primitive Array (z.B. <code>byte[]</code>) oder <code>null</code>.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtDouble.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtDouble.java</h2>

    <p>
        Die Datei <code>NbtDouble.java</code> definiert einen spezifischen Datentyp innerhalb des NBT-Systems (Named Binary Tag), das für die Serialisierung von schematischen Daten (Schematics) im RPG-Plugin verwendet wird.
    </p>

    <h3>Klasse: <code>NbtDouble</code></h3>
    <p>
        <code>NbtDouble</code> ist als Java <strong>Record</strong> implementiert. Dies stellt eine kompakte Möglichkeit dar, eine unveränderliche Datenklasse zu definieren, die primär zum Speichern eines einzelnen Gleitkommawerts mit doppelter Genauigkeit (double) dient.
    </p>

    <h4>Struktur und Merkmale:</h4>
    <ul>
        <li><strong>Implementiert:</strong> <code>NbtTag</code></li>
        <li><strong>Zweck:</strong> Repräsentation eines 64-Bit Gleitkommawerts (Double) im NBT-Format.</li>
    </ul>

    <h4>Komponenten (Fields):</h4>
    <ul>
        <li><code>double value</code>: Der tatsächliche numerische Wert, den dieses Tag speichert.</li>
    </ul>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>typeId()</code>: Gibt die Identifikationsnummer des NBT-Typs zurück.
            <ul>
                <li><strong>Rückgabewert:</strong> <code>byte</code> (entspricht der Konstante <code>NbtType.DOUBLE</code>).</li>
            </ul>
        </li>
    </ul>

    <h3>Kontext innerhalb des Projekts</h3>
    <p>
        Diese Klasse ist Teil des NBT-Frameworks des Plugins, welches für das Einlesen und Speichern von Minecraft-ähnlichen Datenstrukturen (wie z.B. Block-Entitäten oder komplexen Metadaten in Schematics) essenziell ist. Sie arbeitet eng mit <code>NbtType</code> und <code>NbtTag</code> zusammen, um eine typsichere Handhabung von Binärdaten zu gewährleisten.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtFloat.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtFloat.java</h2>

    <p>
        Die Datei <code>NbtFloat.java</code> definiert eine spezialisierte Implementierung eines NBT-Tags (Named Binary Tag) zur Speicherung von Gleitkommazahlen mit einfacher Genauigkeit (float). Sie ist Teil des Schematic-Systems, das für das Laden und Speichern von Bauwerken im Spiel verwendet wird.
    </p>

    <h3>Klasse: NbtFloat</h3>
    <p>
        <code>NbtFloat</code> ist als Java <strong>Record</strong> implementiert, was eine kompakte und unveränderliche (immutable) Datenstruktur gewährleistet.
    </p>

    <h4>Zweck</h4>
    <p>
        Repräsentiert einen NBT-Tag vom Typ <code>FLOAT</code>. Dieser Typ wird in Minecraft-Schematics häufig für Koordinaten, Bewegungsvektoren oder andere physikalische Eigenschaften verwendet, die Dezimalstellen erfordern.
    </p>

    <h4>Parameter</h4>
    <ul>
        <li><code>value</code> (float): Der tatsächliche Gleitkommawert, den dieser Tag kapselt.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>typeId()</code>: Gibt die eindeutige Identifikationsnummer für den NBT-Typ zurück.
            <ul>
                <li><strong>Rückgabewert:</strong> <code>byte</code> – Entspricht der Konstante <code>NbtType.FLOAT</code>.</li>
            </ul>
        </li>
    </ul>

    <h4>Schnittstellen</h4>
    <ul>
        <li>Implementiert <code>NbtTag</code>: Stellt sicher, dass die Klasse in Listen oder Compounds des NBT-Systems verwendet werden kann.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtInt.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtInt.java</h2>

    <p>Die Datei <code>NbtInt.java</code> definiert eine spezialisierte Implementierung eines NBT-Tags (Named Binary Tag) für die Speicherung von ganzzahligen Werten (Integers). Sie ist Teil des NBT-Systems innerhalb des Schematic-Moduls des RPG-Plugins.</p>

    <h3>Klasse: NbtInt</h3>
    <p><strong>Typ:</strong> <code>public record</code></p>
    <p><strong>Zweck:</strong> Repräsentiert einen NBT-Tag vom Typ <code>INT</code>. Da es als Java <code>record</code> implementiert ist, bietet es eine kompakte und unveränderliche (immutable) Datenstruktur zur Speicherung eines einzelnen 32-Bit-Ganzzahlwerts.</p>

    <h4>Komponenten &amp; Parameter</h4>
    <ul>
        <li><code>int value</code>: Der tatsächliche numerische Wert, den dieser NBT-Tag kapselt.</li>
    </ul>

    <h4>Implementierte Schnittstellen</h4>
    <ul>
        <li><code>NbtTag</code>: Markiert diese Klasse als Teil des NBT-Systems und erzwingt die Implementierung der Typ-Identifikation.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public byte typeId()</code>
            <ul>
                <li><strong>Beschreibung:</strong> Gibt die eindeutige Identifikationsnummer für den NBT-Typ "Integer" zurück.</li>
                <li><strong>Rückgabewert:</strong> <code>NbtType.INT</code> (entspricht dem Standard-NBT-Protokoll für Ganzzahlen).</li>
            </ul>
        </li>
    </ul>

    <h3>Zusammenhang im Projekt</h3>
    <p>Diese Klasse wird verwendet, wenn Schematics (Baupläne) geladen oder gespeichert werden, um spezifische Blockdaten oder Metadaten zu verarbeiten, die als 32-Bit-Integer vorliegen (z. B. Koordinaten, Zähler oder Zustands-IDs).</p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtIntArray.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtIntArray.java</h2>

    <p>
        Die Datei <code>NbtIntArray.java</code> definiert eine Datenstruktur zur Repräsentation von Integer-Arrays innerhalb des NBT-Formats (Named Binary Tag). 
        Diese Klasse ist ein integraler Bestandteil des Schematic-Systems, das zum Speichern und Laden von Minecraft-Strukturen verwendet wird.
    </p>

    <h3>Klasse: NbtIntArray</h3>
    <p>
        <code>NbtIntArray</code> ist als Java <strong>Record</strong> implementiert. Dies stellt eine kompakte und unveränderliche (immutable) Datenklasse dar, 
        die automatisch Konstruktoren, Getter und Standardmethoden wie <code>equals()</code> und <code>hashCode()</code> bereitstellt.
    </p>

    <h4>Eigenschaften</h4>
    <ul>
        <li>
            <code>value</code> (int[]): Das zugrunde liegende Array von Ganzzahlen (Integers), das die eigentlichen Daten des NBT-Tags enthält.
        </li>
    </ul>

    <h4>Implementierte Schnittstellen</h4>
    <ul>
        <li><code>NbtTag</code>: Markiert diese Klasse als gültiges Element innerhalb einer NBT-Struktur.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>typeId()</code>: 
            <ul>
                <li><strong>Rückgabewert:</strong> <code>byte</code></li>
                <li><strong>Beschreibung:</strong> Gibt die eindeutige Typ-ID für NBT-Int-Arrays zurück, definiert in <code>NbtType.INT_ARRAY</code>. Dies wird zur Identifizierung des Datentyps während der Serialisierung und Deserialisierung benötigt.</li>
            </ul>
        </li>
    </ul>

    <h3>Kontext innerhalb des Projekts</h3>
    <p>
        Im Rahmen des <code>com.example.rpg.schematic</code> Pakets dient diese Klasse dazu, komplexe Datenfelder (wie z.B. Block-Daten oder spezifische Metadaten in Schematics) effizient zu speichern. Da es sich um ein Record handelt, ist die Handhabung besonders speichereffizient und threadsicher.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtList.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtList.java</h2>

    <p>Die Klasse <code>NbtList</code> ist eine Implementierung des <code>NbtTag</code>-Interfaces. Sie repräsentiert eine Liste von NBT-Tags (Named Binary Tag) desselben Typs. Diese Struktur wird häufig in Minecraft-Schematic-Dateien verwendet, um Sammlungen von Daten wie Inventare, Entitäten-Listen oder Koordinaten-Arrays zu speichern.</p>

    <h3>Klassenübersicht</h3>
    <p><strong>Name:</strong> <code>NbtList</code></p>
    <p><strong>Zweck:</strong> Speicherung und Verwaltung einer geordneten Liste von NBT-Tags eines spezifischen Typs.</p>

    <h3>Konstruktor</h3>
    <ul>
        <li>
            <code>NbtList(byte elementType, List&lt;NbtTag&gt; values)</code>: Erstellt eine neue Liste.
            <ul>
                <li><code>elementType</code>: Die ID des NBT-Typs, den alle Elemente in dieser Liste haben müssen.</li>
                <li><code>values</code>: Eine Liste der initialen <code>NbtTag</code>-Objekte.</li>
            </ul>
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>typeId()</code>: Gibt den NBT-Typ-Identifikator für Listen zurück.
            <br><strong>Rückgabewert:</strong> <code>NbtType.LIST</code> (byte).
        </li>
        <li>
            <code>elementType()</code>: Gibt den Typ der in der Liste enthaltenen Elemente zurück.
            <br><strong>Rückgabewert:</strong> <code>byte</code> (Typ-ID).
        </li>
        <li>
            <code>values()</code>: Gibt eine nicht modifizierbare Ansicht der enthaltenen Tags zurück.
            <br><strong>Rückgabewert:</strong> <code>List&lt;NbtTag&gt;</code>.
        </li>
        <li>
            <code>size()</code>: Gibt die Anzahl der Elemente in der Liste zurück.
            <br><strong>Rückgabewert:</strong> <code>int</code>.
        </li>
        <li>
            <code>get(int index)</code>: Ruft ein spezifisches Tag an der angegebenen Position ab.
            <br><strong>Parameter:</strong> <code>index</code> (int).
            <br><strong>Rückgabewert:</strong> <code>NbtTag</code>.
        </li>
        <li>
            <code>compounds()</code>: Filtert die Liste und gibt alle enthaltenen <code>NbtCompound</code>-Objekte zurück.
            <br><strong>Rückgabewert:</strong> <code>List&lt;NbtCompound&gt;</code>.
        </li>
        <li>
            <code>strings()</code>: Extrahiert die Werte aller <code>NbtString</code>-Tags in der Liste.
            <br><strong>Rückgabewert:</strong> <code>List&lt;String&gt;</code>.
        </li>
        <li>
            <code>doubles()</code>: Konvertiert numerische Tags (Double, Float, Int) innerhalb der Liste in eine Liste von Double-Werten. Dies ist nützlich für die Extraktion von Positionsdaten.
            <br><strong>Rückgabewert:</strong> <code>List&lt;Double&gt;</code>.
        </li>
    </ul>

    <h3>Besonderheiten</h3>
    <p>Die Klasse stellt sicher, dass die interne Liste gekapselt bleibt, indem sie über <code>values()</code> eine <code>UnmodifiableList</code> zurückgibt. Zudem bietet sie komfortable Hilfsmethoden (<code>compounds</code>, <code>strings</code>, <code>doubles</code>), um typsichere Listen der enthaltenen Daten zu extrahieren, ohne dass der Aufrufer manuelle Casts durchführen muss.</p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtLong.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtLong.java</h2>

    <p>
        Die Datei <code>NbtLong.java</code> definiert einen spezifischen Datentyp innerhalb des NBT-Systems (Named Binary Tag), das für die Handhabung von Minecraft-Schematics und Metadaten verwendet wird. Es handelt sich um eine moderne Java-Record-Implementierung, die einen 64-Bit-Ganzzahlwert (Long) repräsentiert.
    </p>

    <h3>Klasse: NbtLong</h3>
    <p>
        <strong>Typ:</strong> <code>public record</code><br>
        <strong>Implementiert:</strong> <code>NbtTag</code>
    </p>

    <h4>Beschreibung</h4>
    <p>
        Ein <code>NbtLong</code> dient zur Speicherung von großen Ganzzahlen. Da es als <code>record</code> implementiert ist, bietet es automatisch Unveränderlichkeit (Immutability) sowie Standardmethoden wie <code>equals()</code>, <code>hashCode()</code> und <code>toString()</code>.
    </p>

    <h4>Komponenten (Fields)</h4>
    <ul>
        <li><code>long value</code>: Der eigentliche numerische Wert, der in diesem Tag gespeichert ist.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public byte typeId()</code>
            <ul>
                <li><strong>Zweck:</strong> Gibt die eindeutige Identifikationsnummer für den NBT-Typ "Long" zurück.</li>
                <li><strong>Rückgabewert:</strong> <code>NbtType.LONG</code> (entspricht dem Standard-NBT-Protokoll für Long-Werte).</li>
            </ul>
        </li>
    </ul>

    <h3>Kontext innerhalb des Projekts</h3>
    <p>
        Diese Klasse ist Teil des <code>com.example.rpg.schematic.nbt</code> Pakets und arbeitet mit anderen NBT-Klassen (wie <code>NbtCompound</code> oder <code>NbtInt</code>) zusammen, um komplexe Datenstrukturen abzubilden, die für das Laden und Speichern von Bauwerken (Schematics) im RPG-Plugin notwendig sind.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtLongArray.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtLongArray.java</h2>

    <p>Die Datei <code>NbtLongArray.java</code> definiert eine spezialisierte Datenstruktur innerhalb des NBT-Systems (Named Binary Tag), die zur Speicherung von Arrays aus 64-Bit-Ganzzahlen (Longs) verwendet wird. Dies ist besonders nützlich für die Serialisierung von großen Datenmengen in Minecraft-Schematics.</p>

    <h3>Klasse: NbtLongArray</h3>
    <p><strong>Typ:</strong> <code>public record</code></p>
    <p><strong>Zweck:</strong> Repräsentiert einen NBT-Tag vom Typ "Long Array". Da es als Java <code>record</code> implementiert ist, bietet es eine unveränderliche Speicherung des Long-Arrays sowie automatische Implementierungen von <code>equals()</code>, <code>hashCode()</code> und <code>toString()</code>.</p>

    <h4>Schnittstellen</h4>
    <ul>
        <li><code>NbtTag</code>: Implementiert das Basis-Interface für alle NBT-Tags im System.</li>
    </ul>

    <h4>Komponenten (Fields)</h4>
    <ul>
        <li><code>long[] value</code>: Das zugrunde liegende Array aus Long-Werten, das die eigentlichen Daten des Tags enthält.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>typeId()</code>
            <ul>
                <li><strong>Beschreibung:</strong> Gibt die eindeutige Identifikationsnummer für den NBT-Typ zurück.</li>
                <li><strong>Rückgabewert:</strong> <code>byte</code> - Der Wert von <code>NbtType.LONG_ARRAY</code> (entspricht dem Standard-NBT-Protokoll).</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtShort.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtShort.java</h2>

    <p>Die Datei <code>NbtShort.java</code> definiert eine spezialisierte Implementierung eines NBT-Tags (Named Binary Tag) für die Speicherung von 16-Bit-Ganzzahlen (Shorts). Sie ist Teil des NBT-Systems innerhalb des Schematic-Moduls des RPG-Plugins.</p>

    <h3>Klasse: <code>NbtShort</code></h3>
    <p><strong>Typ:</strong> <code>public record</code></p>
    <p>
        Diese Klasse ist als Java <strong>Record</strong> implementiert, was eine kompakte und unveränderliche (immutable) Datenstruktur gewährleistet. Sie dient zur Repräsentation eines NBT-Tags vom Typ "Short".
    </p>

    <h4>Eigenschaften</h4>
    <ul>
        <li><code>value</code> (short): Der eigentliche numerische Wert, den dieser Tag speichert.</li>
    </ul>

    <h4>Implementierte Schnittstellen</h4>
    <ul>
        <li><code>NbtTag</code>: Markiert diese Klasse als Teil des NBT-Systems und erzwingt die Implementierung der Typ-Identifikation.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>typeId()</code>: 
            <ul>
                <li><strong>Rückgabewert:</strong> <code>byte</code></li>
                <li><strong>Beschreibung:</strong> Gibt die eindeutige Identifikationsnummer für den NBT-Typ "Short" zurück. Hierbei wird auf die Konstante <code>NbtType.SHORT</code> verwiesen.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtString.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtString.java</h2>
    <p>
        Die Datei <code>NbtString.java</code> definiert einen spezifischen Datentyp innerhalb des NBT-Systems (Named Binary Tag). 
        Dieser Typ wird verwendet, um Textdaten in einer hierarchischen Tag-Struktur zu speichern, wie sie beispielsweise in Minecraft-Schematics vorkommt.
    </p>

    <h3>NbtString (Record)</h3>
    <p>
        <code>NbtString</code> ist als Java <strong>Record</strong> implementiert. Dies bietet eine kompakte Möglichkeit, 
        unveränderliche Datenklassen zu deklarieren, die primär als Datenträger dienen.
    </p>

    <h4>Parameter</h4>
    <ul>
        <li><code>value</code> (String): Die tatsächliche Zeichenkette, die von diesem NBT-Tag repräsentiert wird.</li>
    </ul>

    <h4>Schnittstellen</h4>
    <ul>
        <li>Implementiert <code>NbtTag</code>: Damit gliedert sich die Klasse in das allgemeine NBT-System des Projekts ein.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>typeId()</code>
            <ul>
                <li><strong>Zweck:</strong> Identifiziert den NBT-Tag-Typ für Serialisierungs- und Deserialisierungsprozesse.</li>
                <li><strong>Rückgabewert:</strong> Ein <code>byte</code>, der den Wert von <code>NbtType.STRING</code> zurückgibt.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtTag.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtTag.java</h2>

    <p>
        Die Datei <code>NbtTag.java</code> definiert das Basis-Interface für alle NBT (Named Binary Tag) Elemente innerhalb des RPG-Plugins. 
        NBT ist ein strukturiertes Binärformat, das primär in Minecraft zur Speicherung von komplexen Daten wie Block-Entitäten, Items und Spielerstatistiken verwendet wird.
    </p>

    <h3>Interface: <code>NbtTag</code></h3>
    <p>
        Dieses Interface dient als gemeinsamer Nenner für alle spezifischen NBT-Datentypen (wie <code>NbtInt</code>, <code>NbtCompound</code>, <code>NbtList</code>, etc.). 
        Es stellt sicher, dass jeder Tag seinen eigenen Typ-Identifikator identifizieren kann.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code><strong>typeId()</strong></code>
            <ul>
                <li><strong>Beschreibung:</strong> Gibt die eindeutige ID des NBT-Typs zurück. Diese ID entspricht den offiziellen Minecraft NBT-Spezifikationen (z. B. 1 für Byte, 3 für Int, 10 für Compound).</li>
                <li><strong>Rückgabewert:</strong> <code>byte</code> – Der numerische Identifikator des Datentyps.</li>
            </ul>
        </li>
    </ul>

    <h3>Zusammenhang im System</h3>
    <p>
        Innerhalb des Pakets <code>com.example.rpg.schematic.nbt</code> wird dieses Interface von verschiedenen Klassen implementiert, um eine typsichere Handhabung von Schematics (Bauplänen) und deren Metadaten zu ermöglichen. Es bildet die Grundlage für die Serialisierung und Deserialisierung von NBT-Daten durch die <code>NbtIO</code> Klasse.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtType.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/nbt/NbtType.java</h2>
    <p>
        Die Klasse <code>NbtType</code> ist eine Utility-Klasse innerhalb des NBT-Systems (Named Binary Tag) des RPG-Plugins. 
        Sie dient als zentrale Referenz für die Definition der verschiedenen Datentypen, die im NBT-Format verwendet werden, 
        welches standardmäßig von Minecraft für die Speicherung von Welt- und Schemadaten genutzt wird.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        <strong>Name:</strong> <code>NbtType</code><br>
        <strong>Typ:</strong> <code>public final class</code><br>
        <strong>Zweck:</strong> Bereitstellung von konstanten Byte-Identifikatoren für NBT-Tags.
    </p>

    <h3>Konstanten (Statische Felder)</h3>
    <p>Diese Felder definieren die numerischen IDs der verschiedenen NBT-Datentypen gemäß der offiziellen Spezifikation:</p>
    <ul>
        <li><code>END (0)</code>: Markiert das Ende eines <code>COMPOUND</code>-Tags.</li>
        <li><code>BYTE (1)</code>: Ein vorzeichenbehafteter 8-Bit-Ganzzahlwert.</li>
        <li><code>SHORT (2)</code>: Ein vorzeichenbehafteter 16-Bit-Ganzzahlwert.</li>
        <li><code>INT (3)</code>: Ein vorzeichenbehafteter 3-Bit-Ganzzahlwert.</li>
        <li><code>LONG (4)</code>: Ein vorzeichenbehafteter 64-Bit-Ganzzahlwert.</li>
        <li><code>FLOAT (5)</code>: Ein 32-Bit-Gleitkommawert nach IEEE 754.</li>
        <li><code>DOUBLE (6)</code>: Ein 64-Bit-Gleitkommawert nach IEEE 754.</li>
        <li><code>BYTE_ARRAY (7)</code>: Ein Array aus <code>BYTE</code>-Werten.</li>
        <li><code>STRING (8)</code>: Eine UTF-8 kodierte Zeichenkette.</li>
        <li><code>LIST (9)</code>: Eine Liste von namenlosen Tags des gleichen Typs.</li>
        <li><code>COMPOUND (10)</code>: Eine Sammlung von benannten Tags beliebigen Typs.</li>
        <li><code>INT_ARRAY (11)</code>: Ein Array aus <code>INT</code>-Werten.</li>
        <li><code>LONG_ARRAY (12)</code>: Ein Array aus <code>LONG</code>-Werten.</li>
    </ul>

    <h3>Besonderheiten</h3>
    <ul>
        <li>
            <strong>Privater Konstruktor:</strong> Die Klasse verfügt über einen privaten Konstruktor <code>private NbtType()</code>, 
            um zu verhindern, dass Instanzen dieser Utility-Klasse erzeugt werden.
        </li>
        <li>
            <strong>Final:</strong> Die Klasse ist als <code>final</code> deklariert, was bedeutet, dass sie nicht vererbt werden kann.
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/NbtIO.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/NbtIO.java</h2>
    <p>
        Die Klasse <code>NbtIO</code> ist eine Utility-Klasse für den Lese- und Schreibzugriff auf NBT-Daten (Named Binary Tag). 
        Sie dient primär dazu, komplexe Datenstrukturen, wie sie in Minecraft-Schematics vorkommen, effizient zu serialisieren und zu deserialisieren. 
        Die Klasse unterstützt sowohl komprimierte (GZIP) als auch unkomprimierte Datenströme.
    </p>

    <h3>Klasse: NbtIO</h3>
    <p><strong>Typ:</strong> <code>public final class</code></p>
    <p>
        Diese Klasse kann nicht instanziiert werden (privater Konstruktor) und stellt ausschließlich statische Methoden zur Verfügung.
    </p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>public static NbtCompound read(File file) throws IOException</code>
            <p>
                Liest eine NBT-Datei ein und gibt das darin enthaltene <code>NbtCompound</code> (Wurzelelement) zurück. 
                Die Methode erkennt automatisch, ob die Datei GZIP-komprimiert ist.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>file</code> - Die zu lesende Datei.</li>
                <li><strong>Rückgabewert:</strong> Das deserialisierte <code>NbtCompound</code>-Objekt.</li>
                <li><strong>Fehler:</strong> Wirft eine <code>IOException</code>, wenn das Root-Tag kein Compound ist oder ein Lesefehler auftritt.</li>
            </ul>
        </li>
        <li>
            <code>public static void write(File file, NbtCompound root) throws IOException</code>
            <p>
                Schreibt ein <code>NbtCompound</code>-Objekt in eine Datei. Die Ausgabe wird standardmäßig mit GZIP komprimiert.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>file</code> - Die Zieldatei.</li>
                <li><strong>Parameter:</strong> <code>root</code> - Das zu speichernde NBT-Wurzelelement.</li>
            </ul>
        </li>
        <li>
            <code>private static InputStream openInputStream(File file) throws IOException</code>
            <p>
                Hilfsmethode zum Öffnen eines InputStreams. Sie prüft die ersten zwei Bytes (Magic Number <code>0x1f 0x8b</code>), 
                um festzustellen, ob es sich um einen GZIP-Stream handelt, und wickelt den Stream gegebenenfalls in einen <code>GZIPInputStream</code> ein.
            </p>
        </li>
        <li>
            <code>private static NbtTag readTagPayload(DataInputStream data, byte type) throws IOException</code>
            <p>
                Liest den Inhalt (Payload) eines NBT-Tags basierend auf dem übergebenen Typ-Identifikator.
            </p>
        </li>
        <li>
            <code>private static void writeTagPayload(DataOutputStream data, NbtTag tag) throws IOException</code>
            <p>
                Schreibt den Inhalt eines NBT-Tags in den Datenstrom.
            </p>
        </li>
        <li>
            <code>private static NbtCompound readCompound(DataInputStream data) throws IOException</code>
            <p>
                Liest ein vollständiges NBT-Compound ein, indem es iterativ Tags liest, bis ein <code>NbtType.END</code> erreicht wird.
            </p>
        </li>
        <li>
            <code>private static NbtList readList(DataInputStream data) throws IOException</code>
            <p>
                Liest eine Liste von NBT-Tags desselben Typs ein.
            </p>
        </li>
    </ul>

    <h3>Unterstützte Datentypen (NbtType)</h3>
    <p>
        Die Klasse verarbeitet alle gängigen NBT-Typen durch spezifische Hilfsmethoden für Arrays und primitive Typen:
    </p>
    <ul>
        <li><strong>Primitive:</strong> Byte, Short, Int, Long, Float, Double, String.</li>
        <li><strong>Arrays:</strong> Byte-Arrays, Int-Arrays, Long-Arrays.</li>
        <li><strong>Strukturen:</strong> Lists (Listen von Tags) und Compounds (Schlüssel-Wert-Paare).</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/Schematic.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/Schematic.java</h2>

    <p>
        Die Datei definiert den Java-Record <code>Schematic</code>. Ein Record ist eine kompakte Klassen-Deklaration für Datenklassen. 
        In diesem Kontext dient <code>Schematic</code> als zentrales Datenmodell für dreidimensionale Baupläne (Schematics), 
        die innerhalb des RPG-Systems für das Speichern und Laden von Strukturen, wie z. B. Dungeon-Räumen, verwendet werden.
    </p>

    <h3>Record: Schematic</h3>
    <p>
        Repräsentiert eine vollständige Struktur inklusive ihrer Dimensionen, Blockdaten und Metadaten für Entitäten.
    </p>

    <h4>Parameter / Komponenten:</h4>
    <ul>
        <li>
            <code>int width</code>: Die Ausdehnung der Struktur in der Breite (X-Achse).
        </li>
        <li>
            <code>int height</code>: Die Ausdehnung der Struktur in der Höhe (Y-Achse).
        </li>
        <li>
            <code>int length</code>: Die Ausdehnung der Struktur in der Länge (Z-Achse).
        </li>
        <li>
            <code>BlockPalette palette</code>: Ein Objekt vom Typ <code>BlockPalette</code>, das die Zuordnung zwischen numerischen IDs im <code>blocks</code>-Array und den tatsächlichen Blockzuständen (BlockStates) verwaltet.
        </li>
        <li>
            <code>int[] blocks</code>: Ein Array, das die räumlichen Blockdaten enthält. Die Werte sind in der Regel Indizes, die auf die <code>palette</code> verweisen.
        </li>
        <li>
            <code>List&lt;NbtCompound&gt; blockEntities</code>: Eine Liste von NBT-Daten (Named Binary Tag), die zusätzliche Informationen für Block-Entitäten (wie Truheninhalte, Schildtexte oder Ofen-Daten) speichern.
        </li>
        <li>
            <code>List&lt;NbtCompound&gt; entities</code>: Eine Liste von NBT-Daten für eigenständige Entitäten (wie Mobs, NPCs oder hängende Bilder), die Teil des Bauplans sind.
        </li>
    </ul>

    <h4>Besonderheiten:</h4>
    <p>
        Da es sich um einen <code>record</code> handelt, generiert Java automatisch den Konstruktor, die Getter-Methoden (z. B. <code>width()</code>, <code>palette()</code>), sowie <code>equals()</code>, <code>hashCode()</code> und <code>toString()</code>. Dies stellt sicher, dass die Bauplandaten unveränderlich (immutable) und leicht zu handhaben sind.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/SchematicPaster.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/SchematicPaster.java</h2>
    <p>
        Die Klasse <code>SchematicPaster</code> ist für das Einfügen von Schematics (vorgefertigten Bauplänen) in die Minecraft-Welt verantwortlich. 
        Sie unterstützt das schrittweise Platzieren von Blöcken in Batches, um die Serverleistung zu schonen, sowie Transformationen (Rotationen), 
        das Spawnen von Entities und das Anwenden von Block-Metadaten (Block Entities).
    </p>

    <h3>Hauptklasse: SchematicPaster</h3>
    <p>Verwaltet den Prozess des Einfügens von Schematics unter Berücksichtigung von Performance-Optimierungen.</p>
    <ul>
        <li><strong>Konstruktor:</strong> <code>SchematicPaster(JavaPlugin plugin)</code> - Initialisiert den Paster mit der Plugin-Instanz für den Scheduler und Logger.</li>
        <li>
            <strong>Methode: <code>pasteInBatches</code></strong>
            <p>Fügt eine Schematic asynchron in Batches in die Welt ein.</p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>World world</code>: Die Zielwelt.</li>
                        <li><code>Location origin</code>: Der Ursprungspunkt für die Platzierung.</li>
                        <li><code>Schematic schematic</code>: Das zu platzierende Schematic-Objekt.</li>
                        <li><code>PasteOptions options</code>: Konfiguration (Luft einschließen, Transformationen, Undo-Buffer).</li>
                        <li><code>int batchSize</code>: Anzahl der Blöcke, die pro Server-Tick verarbeitet werden.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> <code>CompletableFuture&lt;Void&gt;</code> - Ein Future, das abgeschlossen wird, wenn der Vorgang beendet ist.</li>
            </ul>
        </li>
    </ul>

    <h3>Hilfsstrukturen</h3>
    <ul>
        <li><strong>Record: <code>PasteOptions</code></strong>
            <p>Ein Datencontainer für Optionen beim Einfügen:</p>
            <ul>
                <li><code>includeAir</code>: Ob Luftblöcke mitüberschrieben werden sollen.</li>
                <li><code>transform</code>: Die anzuwendende Transformation (z. B. Rotation).</li>
                <li><code>undoBuffer</code>: Ein optionaler Puffer zum Speichern des vorherigen Zustands für Rückgängig-Funktionen.</li>
            </ul>
        </li>
        <li><strong>Klasse: <code>BlockPlacement</code></strong>
            <p>Interne Hilfsklasse, die die berechneten Koordinaten und Blockdaten für eine einzelne Platzierung speichert.</p>
        </li>
        <li><strong>Klasse: <code>BlockIterator</code></strong>
            <p>Ein Iterator, der die Blöcke der Schematic unter Berücksichtigung der Transformationen durchläuft.</p>
        </li>
    </ul>

    <h3>Interne Logik und Hilfsmethoden</h3>
    <ul>
        <li><strong><code>applyBlockEntities</code>:</strong> Wendet NBT-Daten auf Blöcke an (z. B. Inventarinhalte von Truhen), nachdem die Blöcke platziert wurden.</li>
        <li><strong><code>spawnEntities</code>:</strong> Spawnt in der Schematic gespeicherte Entities (z. B. Rüstungsständer oder Mobs) an den transformierten Positionen.</li>
        <li><strong><code>ensureChunksLoaded</code>:</strong> Stellt sicher, dass alle Chunks im Zielbereich geladen sind, bevor die Platzierung beginnt, um Fehler zu vermeiden.</li>
        <li><strong><code>rotateBlockData</code>:</strong> Passt die Ausrichtung von Blöcken (z. B. Treppen oder Öfen) an die gewählte Rotation der Schematic an.</li>
        <li><strong><code>rotateFace</code> / <code>rotateOnce</code>:</strong> Hilfsmethoden zur Berechnung der neuen Himmelsrichtung (BlockFace) basierend auf der Rotation.</li>
    </ul>

    <h3>Besonderheiten</h3>
    <ul>
        <li><strong>Performance:</strong> Durch die Verwendung von <code>BukkitRunnable</code> und Batches wird verhindert, dass der Server bei großen Schematics einfriert.</li>
        <li><strong>Fehlertoleranz:</strong> Ungültige Blockdaten oder fehlende Paletteneinträge werden geloggt, ohne den gesamten Prozess abzubrechen.</li>
        <li><strong>Transformation:</strong> Die Klasse nutzt ein <code>Transform</code>-System, um Schematics dynamisch zu drehen.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/SchematicSaver.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/SchematicSaver.java</h2>
    <p>Die Klasse <code>SchematicSaver</code> ist für das Exportieren von Welt-Ausschnitten in das Schematic-Format (basierend auf der Sponge-Spezifikation) verantwortlich. Sie ermöglicht es, Blöcke, deren Zustände und spezifische Block-Entitäten (insbesondere Jigsaw-Blöcke für das Dungeon-System) aus der Minecraft-Welt zu lesen und in einer NBT-basierten Datei zu speichern.</p>

    <h3>Klassen-Komponenten</h3>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public void saveSelection(World world, Location pos1, Location pos2, File file) throws IOException</code>
            <p>Hauptmethode zum Speichern eines Bereichs. Sie berechnet die Dimensionen zwischen zwei Punkten, iteriert über alle Blöcke im definierten Quader und erstellt eine Palette der vorkommenden Blockzustände.</p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>world</code>: Die Bukkit-Welt, aus der die Daten gelesen werden.</li>
                        <li><code>pos1</code> / <code>pos2</code>: Die Eckpunkte des zu speichernden Bereichs.</li>
                        <li><code>file</code>: Die Zieldatei, in der die Schematic gespeichert wird.</li>
                    </ul>
                </li>
            </ul>
        </li>

        <li>
            <code>private NbtCompound buildPalette(List&lt;String&gt; palette)</code>
            <p>Erstellt das NBT-Tag für die Palette. Die Palette ordnet jedem eindeutigen Blockzustand (String) eine numerische ID zu, um Speicherplatz in den Blockdaten zu sparen.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> Ein <code>NbtCompound</code>, das die Zuordnung von Blockzuständen zu IDs enthält.</li>
            </ul>
        </li>

        <li>
            <code>private NbtCompound jigsawEntity(int x, int y, int z, Jigsaw jigsaw)</code>
            <p>Konvertiert einen Jigsaw-Block in ein NBT-Format für Block-Entitäten. Dies ist entscheidend für das prozedurale Dungeon-System, da Jigsaw-Blöcke als Verbindungspunkte (Sockets) dienen.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>x, y, z</code> (relative Koordinaten innerhalb der Schematic), <code>jigsaw</code> (der Block-Status).</li>
            </ul>
        </li>

        <li>
            <code>private String readJigsawName(Jigsaw jigsaw)</code>
            <p>Versucht mittels Reflection den Namen eines Jigsaw-Blocks auszulesen. Dies dient der Identifizierung von Sockets in den Dungeon-Templates.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> Der Name des Jigsaw-Blocks oder der Standardwert "socket".</li>
            </ul>
        </li>

        <li>
            <code>private byte[] encodeVarInts(int[] values)</code>
            <p>Implementiert die VarInt-Kodierung für die Blockdaten. Dies ist ein platzsparendes Format für Ganzzahlen, das in Minecraft-Schematics für das <code>BlockData</code>-Feld verwendet wird.</p>
            <ul>
                <li><strong>Parameter:</strong> Ein Array von Paletten-Indizes.</li>
                <li><strong>Rückgabewert:</strong> Ein Byte-Array der kodierten Daten.</li>
            </ul>
        </li>
    </ul>

    <h3>Besonderheiten</h3>
    <ul>
        <li><strong>Versionierung:</strong> Die Schematic wird mit der Version 2 und der aktuellen <code>DataVersion</code> des Servers gespeichert, um Kompatibilität sicherzustellen.</li>
        <li><strong>Jigsaw-Integration:</strong> Im Gegensatz zu einfachen Schematics werden hier gezielt Jigsaw-Blöcke erfasst, was auf eine enge Verzahnung mit dem <code>JigsawRoomPlacer</code> hindeutet.</li>
        <li><strong>NBT-Struktur:</strong> Die Klasse nutzt ein internes NBT-System (<code>com.example.rpg.schematic.nbt</code>), um die hierarchische Datenstruktur vor dem Schreiben via <code>NbtIO</code> aufzubauen.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/SpongeSchemLoader.java">
    <h2>SpongeSchemLoader.java</h2>
    <p>
        Die Klasse <code>SpongeSchemLoader</code> ist für das Einlesen und Dekodieren von Schematic-Dateien im Sponge-Format verantwortlich. 
        Diese Dateien werden verwendet, um komplexe 3D-Strukturen (wie Dungeon-Räume oder Gebäude) effizient zu speichern und in die Spielwelt zu laden.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Die Klasse bietet Methoden zum Parsen von NBT-Daten (Named Binary Tag), zur Extraktion der Block-Palette und zur Dekomprimierung der Block-Daten.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public Schematic load(File file) throws IOException</code>
            <p>
                Die Hauptmethode zum Laden einer Schematic-Datei. Sie liest die NBT-Struktur ein, validiert die Dimensionen (Breite, Höhe, Länge) und extrahiert die Block-Palette sowie die Block-Entitäten.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>File file</code> - Die zu ladende Datei.</li>
                <li><strong>Rückgabewert:</strong> Ein <code>Schematic</code>-Objekt, das alle Daten der Struktur enthält.</li>
                <li><strong>Fehler:</strong> Wirft eine <code>IOException</code>, wenn das Format ungültig oder nicht unterstützt wird.</li>
            </ul>
        </li>

        <li>
            <code>private int[] readBlocks(NbtCompound root, int paletteSize, int totalBlocks) throws IOException</code>
            <p>
                Entscheidet basierend auf dem Datentyp im NBT-Tag (Byte-Array oder Long-Array), welches Dekodierungsverfahren für die Block-Daten angewendet werden muss.
            </p>
            <ul>
                <li><strong>Parameter:</strong> 
                    <code>NbtCompound root</code> (Wurzel-Tag), 
                    <code>int paletteSize</code> (Größe der Palette), 
                    <code>int totalBlocks</code> (Erwartete Anzahl an Blöcken).
                </li>
                <li><strong>Rückgabewert:</strong> Ein Array von Integern, die auf die Paletten-Indizes verweisen.</li>
            </ul>
        </li>

        <li>
            <code>private int[] decodeVarIntArray(byte[] data, int expected) throws IOException</code>
            <p>
                Dekodiert Block-Daten, die als <code>VarInt</code>-kodiertes Byte-Array vorliegen. Dies ist ein platzsparendes Format, bei dem Ganzzahlen mit variabler Länge gespeichert werden.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>byte[] data</code> (Rohdaten), <code>int expected</code> (Anzahl erwarteter Blöcke).</li>
                <li><strong>Rückgabewert:</strong> Dekodiertes Integer-Array.</li>
            </ul>
        </li>

        <li>
            <code>private int[] unpackLongArray(long[] data, int bits, int expected)</code>
            <p>
                Entpackt Block-Daten aus einem Long-Array. Hierbei werden mehrere Block-Indizes bitweise in einen einzelnen 64-Bit-Long-Wert gepackt, um Speicherplatz zu sparen.
            </p>
            <ul>
                <li><strong>Parameter:</strong> 
                    <code>long[] data</code> (Gepackte Daten), 
                    <code>int bits</code> (Bits pro Block), 
                    <code>int expected</code> (Anzahl erwarteter Blöcke).
                </li>
                <li><strong>Rückgabewert:</strong> Entpacktes Integer-Array.</li>
            </ul>
        </li>
    </ul>

    <h3>Besonderheiten</h3>
    <p>
        Die Klasse unterstützt sowohl die moderne Speicherung mittels <code>VarInt</code> als auch die bit-gepackte Speicherung in <code>long</code>-Arrays. Zudem werden <code>BlockEntities</code> (wie Truheninhalte oder Schildtexte) und reguläre <code>Entities</code> (Mobs) beim Ladevorgang berücksichtigt.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/Transform.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/Transform.java</h2>
    <p>
        Die Klasse <code>Transform</code> ist eine Hilfsklasse innerhalb des Schematic-Systems, die für die Handhabung von räumlichen Transformationen zuständig ist. Sie ermöglicht die Rotation und Verschiebung (Offset) von Koordinaten, was insbesondere beim Platzieren von Schematics (vorgefertigten Bauwerken) in der Spielwelt wichtig ist.
    </p>

    <h3>Klasse: Transform</h3>
    <p>
        Diese Klasse kapselt die Logik, um einen Punkt im dreidimensionalen Raum basierend auf einer Rotation und einem Versatz zu transformieren.
    </p>

    <h4>Innere Aufzählung: Rotation</h4>
    <p>Definiert die möglichen Rotationszustände für die Transformation:</p>
    <ul>
        <li><code>NONE</code>: Keine Rotation.</li>
        <li><code>CLOCKWISE_90</code>: Drehung um 90 Grad im Uhrzeigersinn.</li>
        <li><code>CLOCKWISE_180</code>: Drehung um 180 Grad im Uhrzeigersinn.</li>
        <li><code>CLOCKWISE_270</code>: Drehung um 270 Grad im Uhrzeigersinn.</li>
    </ul>

    <h4>Konstruktor</h4>
    <p><code>public Transform(Rotation rotation, int offsetX, int offsetY, int offsetZ)</code></p>
    <ul>
        <li><strong>rotation</strong>: Die anzuwendende <code>Rotation</code>.</li>
        <li><strong>offsetX / offsetY / offsetZ</strong>: Die ganzzahligen Verschiebungswerte in den jeweiligen Achsen.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public Rotation rotation()</code>: Gibt die eingestellte Rotation zurück.
        </li>
        <li>
            <code>public int offsetX()</code> / <code>offsetY()</code> / <code>offsetZ()</code>: Gibt den jeweiligen Versatzwert zurück.
        </li>
        <li>
            <code>public int[] apply(int x, int y, int z, int width, int length)</code>
            <p>
                Berechnet die neuen Koordinaten basierend auf der Rotation und dem Offset.
            </p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>x, y, z</code>: Die ursprünglichen Koordinaten des Punktes.</li>
                <li><code>width</code>: Die Breite des zu transformierenden Objekts (X-Achse).</li>
                <li><code>length</code>: Die Länge des zu transformierenden Objekts (Z-Achse).</li>
            </ul>
            <strong>Rückgabewert:</strong>
            <p>Ein <code>int[]</code> Array mit drei Elementen <code>[neuesX, neuesY, neuesZ]</code>.</p>
        </li>
    </ul>

    <h3>Funktionsweise der Transformation</h3>
    <p>
        Die Methode <code>apply</code> führt zuerst die Rotation um die Y-Achse durch. Dabei werden die Grenzen des Objekts (<code>width</code> und <code>length</code>) berücksichtigt, um sicherzustellen, dass die Koordinaten innerhalb des neuen Begrenzungsrahmens korrekt berechnet werden. Nach der Rotation wird der definierte <code>offsetX</code>, <code>offsetY</code> und <code>offsetZ</code> auf das Ergebnis addiert.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/UndoBuffer.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/schematic/UndoBuffer.java</h2>

    <p>
        Die Klasse <code>UndoBuffer</code> dient als Container für Blockzustände, die vor einer Manipulation der Spielwelt (z. B. durch das Einfügen einer Schematic) gesichert wurden. 
        Sie ermöglicht es, Änderungen zu protokollieren, um sie zu einem späteren Zeitpunkt rückgängig machen zu können.
    </p>

    <h3>Klassen &amp; Records</h3>

    <h4><code>BlockSnapshot</code> (Record)</h4>
    <p>
        Ein kompakter Datentyp, der den Zustand eines einzelnen Blocks zu einem bestimmten Zeitpunkt speichert.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>location</code> (Location): Die exakte Position des Blocks in der Welt.</li>
                <li><code>data</code> (BlockData): Die Bukkit-Blockdaten (Typ, Ausrichtung, Zustand), die an dieser Position existierten.</li>
            </ul>
        </li>
    </ul>

    <h4><code>UndoBuffer</code> (Hauptklasse)</h4>
    <p>
        Verwaltet eine Liste von <code>BlockSnapshot</code>-Objekten.
    </p>

    <h3>Methoden</h3>

    <ul>
        <li>
            <code>public void add(Location location, BlockData data)</code>
            <p>
                Erstellt einen neuen <code>BlockSnapshot</code> aus der angegebenen Position und den Blockdaten und fügt diesen der internen Liste hinzu.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>location</code>: Die <code>Location</code> des zu sichernden Blocks.</li>
                        <li><code>data</code>: Die <code>BlockData</code> des zu sichernden Blocks.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code>public List&lt;BlockSnapshot&gt; snapshots()</code>
            <p>
                Gibt eine unveränderliche Ansicht der aktuell im Puffer gespeicherten Schnappschüsse zurück.
            </p>
            <ul>
                <li><strong>Rückgabewert:</strong> Eine <code>List</code> von <code>BlockSnapshot</code>-Objekten, die nicht direkt modifiziert werden kann.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/AggroEffect.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/AggroEffect.java</h2>

    <p>Die Klasse <code>AggroEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. Ihr Hauptzweck besteht darin, die Aggressivität (Aggro) von Monstern in der Umgebung auf den ausführenden Spieler zu lenken. Dies ist ein klassischer Mechanismus für "Provokation" oder "Taunt"-Fähigkeiten.</p>

    <h3>Klassenbeschreibung</h3>
    <p><strong>Name:</strong> <code>AggroEffect</code></p>
    <p><strong>Interface:</strong> <code>SkillEffect</code></p>
    <p><strong>Zweck:</strong> Erzwingt, dass alle Monster (Mobs) innerhalb eines bestimmten Radius den ausführenden Spieler als ihr aktuelles Ziel (Target) setzen.</p>

    <h3>Methoden</h3>
    
    <h4><code>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code></h4>
    <p>Führt den Effekt der Aggro-Zuweisung aus.</p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>player</code> (Player): Der Spieler, der die Fähigkeit einsetzt und auf den die Monster fixiert werden.</li>
                <li><code>profile</code> (PlayerProfile): Das RPG-Profil des Spielers (wird in dieser Implementierung nicht direkt genutzt).</li>
                <li><code>params</code> (Map): Eine Map mit Konfigurationsparametern für den Effekt.</li>
            </ul>
        </li>
        <li><strong>Logik:</strong>
            <ol>
                <li>Liest den Parameter <code>radius</code> aus den <code>params</code> aus (Standardwert ist 8.0).</li>
                <li>Sucht alle Entitäten im Umkreis des Spielers basierend auf diesem Radius.</li>
                <li>Filtert die Entitäten, sodass nur Instanzen von <code>Mob</code> (Monster/Tiere) verarbeitet werden.</li>
                <li>Setzt für jeden gefundenen Mob das Ziel mit <code>setTarget(player)</code> auf den ausführenden Spieler.</li>
            </ol>
        </li>
    </ul>

    <h4><code>parseDouble(Object raw)</code></h4>
    <p>Eine private Hilfsmethode zur sicheren Konvertierung von Konfigurationswerten.</p>
    <ul>
        <li><strong>Parameter:</strong> <code>raw</code> (Object) - Der zu konvertierende Wert aus der Parameter-Map.</li>
        <li><strong>Rückgabewert:</strong> <code>double</code> - Der konvertierte Zahlenwert oder 8.0 als Fallback bei Fehlern.</li>
    </ul>

    <h3>Konfigurationsparameter</h3>
    <p>In der <code>skills.yml</code> oder über das Skill-System können folgende Parameter für diesen Effekt definiert werden:</p>
    <ul>
        <li><code>radius</code> (Zahl): Der Radius in Blöcken, in dem Mobs provoziert werden. Standard: <code>8</code>.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/DamageEffect.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/DamageEffect.java</h2>

    <p>
        Die Klasse <code>DamageEffect</code> implementiert das Interface <code>SkillEffect</code> und ist für die Berechnung und Anwendung von Schaden verantwortlich, der durch Fertigkeiten (Skills) verursacht wird. Sie unterstützt sowohl Einzelzielschaden als auch Flächenschaden (Area of Effect).
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>DamageEffect</code> verarbeitet Parameter aus einer Konfigurations-Map, um zu bestimmen, wie viel Schaden an welchen Entitäten in der Umgebung des Spielers verursacht werden soll. Dabei werden Spielercharaktere standardmäßig vom Schaden ausgeschlossen.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code>
            <p>
                Führt den Schadenseffekt aus. Die Methode unterscheidet zwei Modi basierend auf dem Parameter <code>radius</code>:
            </p>
            <ul>
                <li><strong>Flächenschaden (AoE):</strong> Wenn <code>radius &gt; 0</code>, werden alle lebenden Entitäten (außer Spieler) im Umkreis gescannt, nach Entfernung sortiert und bis zum Erreichen von <code>maxTargets</code> mit Schaden belegt.</li>
                <li><strong>Einzelzielschaden:</strong> Wenn kein Radius angegeben ist, wird die am nächsten stehende lebende Entität in einem kleinen Standardbereich (3x2x3 Blöcke) gesucht und angegriffen.</li>
            </ul>
        </li>
        <li>
            <code>parseDouble(Object raw)</code>
            <p>Hilfsmethode zur sicheren Konvertierung von Konfigurationswerten in <code>double</code>. Gibt <code>0.0</code> zurück, falls die Konvertierung fehlschlägt.</p>
        </li>
        <li>
            <code>parseInt(Object raw)</code>
            <p>Hilfsmethode zur sicheren Konvertierung von Konfigurationswerten in <code>int</code>. Gibt <code>1</code> zurück, falls die Konvertierung fehlschlägt.</p>
        </li>
    </ul>

    <h3>Konfigurationsparameter (params)</h3>
    <p>Die Methode <code>apply</code> wertet folgende Schlüssel in der Parameter-Map aus:</p>
    <ul>
        <li><code>amount</code> (Standard: 4): Die Menge an Schadenspunkten, die abgezogen werden.</li>
        <li><code>radius</code> (Standard: 0): Der Radius für Flächenschaden. Ein Wert von 0 aktiviert den Einzelzielmodus.</li>
        <li><code>maxTargets</code> (Standard: 1): Die maximale Anzahl an Zielen, die im Flächenschaden-Modus getroffen werden können.</li>
    </ul>

    <h3>Besonderheiten</h3>
    <ul>
        <li><strong>Ziel-Filterung:</strong> Der Effekt filtert Instanzen von <code>Player</code> heraus, um Friendly Fire durch Skills zu verhindern. Es werden nur <code>LivingEntity</code>-Objekte angegriffen.</li>
        <li><strong>Sortierung:</strong> Ziele werden immer nach ihrer quadratischen Distanz (<code>distanceSquared</code>) zum ausführenden Spieler sortiert, um die Performance zu optimieren und die logisch nächsten Ziele zuerst zu treffen.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/HealEffect.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/HealEffect.java</h2>
    <p>
        Die Klasse <code>HealEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. 
        Ihr Hauptzweck ist es, die Lebenspunkte (Health) eines Spielers um einen definierten Wert zu erhöhen, wenn ein entsprechender Skill aktiviert wird.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class HealEffect implements SkillEffect</code>
    </p>
    <p>
        Diese Klasse stellt die Logik für Heilungseffekte bereit. Sie interagiert direkt mit der Bukkit-API, um die aktuellen Attribute des Spielers abzufragen und zu modifizieren.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</strong>
            <ul>
                <li><strong>Beschreibung:</strong> Führt die Heilung am Zielspieler aus. Die Methode berechnet die neue Gesundheit basierend auf dem aktuellen Wert und dem übergebenen Heilbetrag, wobei das maximale Gesundheitslimit des Spielers berücksichtigt wird.</li>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>player</code> (Player): Das Bukkit-Player-Objekt, das geheilt werden soll.</li>
                        <li><code>profile</code> (PlayerProfile): Das RPG-Profil des Spielers (wird in dieser Implementierung aktuell nicht direkt für die Berechnung genutzt).</li>
                        <li><code>params</code> (Map): Eine Map mit Konfigurationsparametern. Erwartet wird der Schlüssel <code>"amount"</code> (Standardwert: 4).</li>
                    </ul>
                </li>
                <li><strong>Logik:</strong> Die neue Gesundheit wird via <code>Math.min(maxHealth, currentHealth + amount)</code> begrenzt, um Overhealing über das Maximum hinaus zu verhindern.</li>
            </ul>
        </li>
        <li>
            <strong>parseDouble(Object raw)</strong>
            <ul>
                <li><strong>Beschreibung:</strong> Eine private Hilfsmethode, die versucht, ein Objekt in einen Double-Wert zu konvertieren.</li>
                <li><strong>Parameter:</strong> <code>raw</code> (Object): Der zu konvertierende Wert.</li>
                <li><strong>Rückgabewert:</strong> <code>double</code>: Der konvertierte Wert oder <code>0.0</code>, falls die Konvertierung fehlschlägt (NumberFormatException).</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>org.bukkit.entity.Player</code>: Zur Manipulation der Spieler-Gesundheit.</li>
        <li><code>org.bukkit.attribute.Attribute</code>: Zur Ermittlung der maximalen Gesundheit (GENERIC_MAX_HEALTH).</li>
        <li><code>com.example.rpg.skill.SkillEffect</code>: Basis-Interface für alle Skill-Effekte.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ParticleEffect.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ParticleEffect.java</h2>
    <p>
        Die Klasse <code>ParticleEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. 
        Ihr Hauptzweck ist die visuelle Darstellung von Fähigkeiten durch das Erzeugen von Partikeleffekten in der Spielwelt an der Position des Spielers.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class ParticleEffect implements SkillEffect</code>
    </p>
    <p>
        Diese Klasse stellt die Logik bereit, um Bukkit-Partikel basierend auf Konfigurationsparametern zu spawnen. Sie wird typischerweise aufgerufen, 
        wenn ein Spieler eine Fähigkeit aktiviert, die eine visuelle Rückmeldung erfordert.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code>
            <p>
                Führt den Effekt aus. Diese Methode extrahiert die Partikel-Konfiguration aus den übergebenen Parametern und spawnt die Partikel in der Welt.
            </p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>player</code>: Das <code>Player</code>-Objekt (Bukkit), bei dem die Partikel erscheinen sollen.</li>
                <li><code>profile</code>: Das RPG-Profil des Spielers (wird in dieser Implementierung für die Logik nicht direkt verwendet).</li>
                <li><code>params</code>: Eine Map mit Konfigurationswerten für den Effekt:
                    <ul>
                        <li><code>type</code> (String): Der Name des Partikel-Typs (z. B. "FLAME", "HEART"). Standardwert: <code>SPELL</code>.</li>
                        <li><code>count</code> (Integer): Die Anzahl der zu erzeugenden Partikel. Standardwert: <code>10</code>.</li>
                        <li><code>speed</code> (Double): Die Bewegungsgeschwindigkeit der Partikel. Standardwert: <code>0.01</code>.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code>parseInt(Object raw)</code> (privat)
            <p>
                Hilfsmethode zur sicheren Konvertierung von Objekten in Ganzzahlen. Gibt bei Fehlern den Standardwert <code>10</code> zurück.
            </p>
        </li>
        <li>
            <code>parseDouble(Object raw)</code> (privat)
            <p>
                Hilfsmethode zur sicheren Konvertierung von Objekten in Gleitkommazahlen. Gibt bei Fehlern den Standardwert <code>0.01</code> zurück.
            </p>
        </li>
    </ul>

    <h3>Logik-Details</h3>
    <p>
        Die Partikel werden standardmäßig 1.0 Blöcke über der aktuellen Position des Spielers (<code>player.getLocation().add(0, 1.0, 0)</code>) gespawnt. 
        Dabei wird ein Streuungsbereich (Offset) von 0.3 in der Breite/Tiefe und 0.6 in der Höhe verwendet, um eine natürliche Verteilung zu erzielen. 
        Falls ein ungültiger Partikel-Typ in den Parametern angegeben wird, fällt das System automatisch auf <code>Particle.SPELL</code> zurück.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/PotionStatusEffect.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/PotionStatusEffect.java</h2>

    <p>Die Klasse <code>PotionStatusEffect</code> implementiert das Interface <code>SkillEffect</code> und ist dafür verantwortlich, Spielern oder Entitäten in der Umgebung Status-Effekte (Trankeffekte) zuzuweisen. Dies wird häufig für Buffs, Debuffs oder Heilungseffekte innerhalb des RPG-Systems verwendet.</p>

    <h3>Klassenübersicht</h3>
    <p><strong>Name:</strong> <code>PotionStatusEffect</code></p>
    <p><strong>Zweck:</strong> Anwendung von Minecraft-Trankeffekten (PotionEffects) basierend auf Konfigurationsparametern.</p>

    <h3>Methoden</h3>

    <h4><code>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code></h4>
    <p>Diese Methode führt die Logik zur Anwendung des Effekts aus. Sie wertet die übergebenen Parameter aus und entscheidet, ob der Effekt nur auf den Zaubernden oder auf Entitäten in einem bestimmten Radius angewendet wird.</p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>player</code> (Player): Der Spieler, der die Fähigkeit auslöst.</li>
                <li><code>profile</code> (PlayerProfile): Das RPG-Profil des Spielers.</li>
                <li><code>params</code> (Map): Eine Map mit Konfigurationswerten für den Effekt.</li>
            </ul>
        </li>
        <li><strong>Unterstützte Parameter in <code>params</code>:</strong>
            <ul>
                <li><code>type</code> (String): Der Name des Trankeffekts (z. B. "SPEED", "INCREASE_DAMAGE"). Standard: "SPEED".</li>
                <li><code>duration</code> (Integer): Die Dauer des Effekts in Ticks (20 Ticks = 1 Sekunde). Standard: 100.</li>
                <li><code>amplifier</code> (Integer): Die Stärke des Effekts (0 ist Stufe I). Standard: 0.</li>
                <li><code>radius</code> (Double): Wenn größer als 0, wird der Effekt auf alle lebenden Entitäten in diesem Umkreis angewendet. Standard: 0.</li>
            </ul>
        </li>
    </ul>

    <h4><code>parseInt(Object raw)</code> (privat)</h4>
    <p>Hilfsmethode zur sicheren Konvertierung von Objekten in Ganzzahlen.</p>
    <ul>
        <li><strong>Rückgabewert:</strong> Der Integer-Wert oder <code>0</code>, falls die Konvertierung fehlschlägt.</li>
    </ul>

    <h4><code>parseDouble(Object raw)</code> (privat)</h4>
    <p>Hilfsmethode zur sicheren Konvertierung von Objekten in Gleitkommazahlen.</p>
    <ul>
        <li><strong>Rückgabewert:</strong> Der Double-Wert oder <code>0.0</code>, falls die Konvertierung fehlschlägt.</li>
    </ul>

    <h3>Besonderheiten</h3>
    <ul>
        <li><strong>Validierung:</strong> Wenn der angegebene <code>type</code> nicht im Bukkit-Enum <code>PotionEffectType</code> gefunden wird, bricht die Methode ohne Fehler ab.</li>
        <li><strong>Zielerfassung:</strong> Falls ein Radius definiert ist, nutzt die Klasse die Stream-API, um alle <code>LivingEntity</code>-Objekte im Umkreis zu filtern und den Effekt auf diese anzuwenden.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ProjectileEffect.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ProjectileEffect.java</h2>

    <p>Die Klasse <code>ProjectileEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. Ihr Hauptzweck ist es, dem Spieler das Abfeuern von Projektilen als Teil eines Skill-Effekts zu ermöglichen.</p>

    <h3>Klassenbeschreibung</h3>
    <p>
        Diese Klasse stellt die Logik bereit, um verschiedene Arten von Projektilen (wie Schneebälle oder Feuerbälle) direkt von der Position des Spielers aus in Blickrichtung zu starten.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</strong>
            <p>Führt den Effekt aus, indem ein Projektil basierend auf den übergebenen Parametern instanziiert und abgeschossen wird.</p>
            
            <strong>Parameter:</strong>
            <ul>
                <li><code>player</code>: Das <code>Player</code>-Objekt von Bukkit, welches das Projektil abschießt.</li>
                <li><code>profile</code>: Das RPG-Profil des Spielers (wird in dieser spezifischen Implementierung aktuell nicht direkt für Berechnungen genutzt).</li>
                <li><code>params</code>: Eine Map mit Konfigurationsparametern für den Effekt.</li>
            </ul>

            <strong>Konfigurationsoptionen in <code>params</code>:</strong>
            <ul>
                <li><code>type</code> (String): Bestimmt den Typ des Projektils. Standardwert ist <code>"SNOWBALL"</code>.
                    <ul>
                        <li><code>"SMALL_FIREBALL"</code>: Schießt einen kleinen Feuerball (SmallFireball).</li>
                        <li><code>"SNOWBALL"</code>: Schießt einen Schneeball (Snowball).</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>

    <h3>Besonderheiten</h3>
    <p>
        Die Methode nutzt ein modernes Java <code>switch</code>-Statement (Pattern Matching / Arrow Syntax), um den Projektiltyp zu bestimmen. Falls ein unbekannter Typ angegeben wird, fällt das System automatisch auf den Standardwert <code>Snowball</code> zurück.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/SoundEffect.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/SoundEffect.java</h2>
    <p>
        Die Klasse <code>SoundEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. 
        Ihr Hauptzweck ist das Abspielen von akustischen Signalen (Sounds) an der Position eines Spielers, wenn eine bestimmte Fähigkeit (Skill) aktiviert wird.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class SoundEffect implements SkillEffect</code>
    </p>
    <p>
        Diese Klasse stellt die Logik bereit, um Bukkit-Sounds basierend auf dynamischen Parametern zu laden und abzuspielen. Sie ist so konzipiert, dass sie über eine Konfigurations-Map gesteuert werden kann.
    </p>

    <h3>Methoden</h3>
    
    <h4><code>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code></h4>
    <p>
        Führt den Effekt aus, indem ein Sound an der aktuellen Position des Spielers in der Welt abgespielt wird.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>player</code> (Player): Das Bukkit-Player-Objekt, an dessen Standort der Sound abgespielt wird.</li>
                <li><code>profile</code> (PlayerProfile): Das RPG-Profil des Spielers (wird in dieser Implementierung nicht direkt genutzt).</li>
                <li><code>params</code> (Map&lt;String, Object&gt;): Eine Map mit Konfigurationsparametern für den Sound.
                    <ul>
                        <li><code>sound</code>: Der Name des Sounds (Standard: <code>ENTITY_PLAYER_LEVELUP</code>).</li>
                        <li><code>volume</code>: Die Lautstärke des Sounds (Standard: <code>1.0</code>).</li>
                        <li><code>pitch</code>: Die Tonhöhe des Sounds (Standard: <code>1.0</code>).</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> <code>void</code></li>
        <li><strong>Besonderheiten:</strong> Falls der angegebene Sound-Name ungültig ist (nicht in der <code>Sound</code>-Enum von Bukkit existiert), wird standardmäßig <code>ENTITY_PLAYER_LEVELUP</code> verwendet.</li>
    </ul>

    <h4><code>parseFloat(Object raw)</code></h4>
    <p>
        Eine private Hilfsmethode, die versucht, ein beliebiges Objekt in einen <code>float</code>-Wert umzuwandeln.
    </p>
    <ul>
        <li><strong>Parameter:</strong> <code>raw</code> (Object): Der zu konvertierende Wert.</li>
        <li><strong>Rückgabewert:</strong> <code>float</code>: Der konvertierte Wert oder <code>1.0f</code>, falls die Konvertierung fehlschlägt (z. B. bei ungültigem Format).</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/VelocityEffect.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/VelocityEffect.java</h2>

    <p>Die Klasse <code>VelocityEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. Ihr Hauptzweck ist es, die Bewegungsgeschwindigkeit (Velocity) eines Spielers zu manipulieren, um Effekte wie Rückstoß, Sprünge oder Sprints zu realisieren.</p>

    <h3>Klassenbeschreibung</h3>
    <p><code>public class VelocityEffect implements SkillEffect</code></p>
    <p>Diese Klasse berechnet einen Richtungsvektor basierend auf der Blickrichtung des Spielers und wendet diesen auf die physikalische Bewegung des Spieler-Entitätscharakters in der Bukkit-Umgebung an.</p>

    <h3>Methoden</h3>

    <h4><code>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code></h4>
    <p>Führt den Effekt aus und verändert die Geschwindigkeit des Spielers basierend auf den übergebenen Parametern.</p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>player</code>: Das <code>Player</code>-Objekt (Bukkit), auf das der Effekt angewendet wird.</li>
                <li><code>profile</code>: Das <code>PlayerProfile</code> des Spielers (enthält RPG-spezifische Daten).</li>
                <li><code>params</code>: Eine Map mit Konfigurationsparametern für den Effekt:
                    <ul>
                        <li><code>forward</code> (Double): Die Stärke des Impulses in Blickrichtung (Standard: 1.2).</li>
                        <li><code>up</code> (Double): Die Stärke des vertikalen Impulses (Standard: 0.3).</li>
                        <li><code>add</code> (Boolean): Wenn <code>true</code>, wird die neue Geschwindigkeit zur aktuellen addiert. Wenn <code>false</code>, wird die Geschwindigkeit überschrieben (Standard: false).</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>

    <h4><code>parseDouble(Object raw)</code></h4>
    <p>Eine private Hilfsmethode, die versucht, ein Objekt sicher in einen Double-Wert zu konvertieren.</p>
    <ul>
        <li><strong>Rückgabewert:</strong> Der konvertierte <code>double</code>-Wert oder <code>0.0</code>, falls die Konvertierung fehlschlägt.</li>
    </ul>

    <h4><code>parseBoolean(Object raw)</code></h4>
    <p>Eine private Hilfsmethode zur Konvertierung eines Objekts in einen booleschen Wert.</p>
    <ul>
        <li><strong>Rückgabewert:</strong> <code>true</code> oder <code>false</code> basierend auf der String-Repräsentation des Objekts.</li>
    </ul>

    <h3>Funktionsweise</h3>
    <p>Der Effekt ermittelt zunächst die Blickrichtung des Spielers mittels <code>player.getLocation().getDirection()</code>. Dieser Vektor wird mit dem <code>forward</code>-Faktor multipliziert. Anschließend wird die Y-Komponente (vertikal) explizit auf den <code>up</code>-Wert gesetzt. Je nach <code>add</code>-Parameter wird dieser resultierende Vektor entweder direkt als neue Velocity gesetzt oder auf die bestehende Velocity des Spielers aufaddiert.</p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/XpEffect.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/XpEffect.java</h2>

    <p>
        Die Klasse <code>XpEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. 
        Ihr primärer Zweck ist es, einem Spieler Erfahrungspunkte (XP) gutzuschreiben, wenn ein entsprechender Skill aktiviert wird.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class XpEffect implements SkillEffect</code>
    </p>
    <p>
        Diese Klasse stellt die Logik bereit, um das <code>PlayerProfile</code> eines Spielers direkt zu modifizieren, indem die Methode <code>addXp</code> aufgerufen wird. 
        Dies ist nützlich für Skills, die Belohnungen gewähren oder passive Erfahrungsboni bieten.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</strong>
            <p>Führt den Effekt aus und fügt dem Spielerprofil XP hinzu.</p>
            <ul>
                <li><code>player</code>: Die Bukkit-Player-Instanz (in dieser Implementierung primär für den Kontext, die Logik erfolgt auf dem Profil).</li>
                <li><code>profile</code>: Das <code>PlayerProfile</code>-Objekt, auf dem die XP gutgeschrieben werden.</li>
                <li><code>params</code>: Eine Map mit Konfigurationsparametern. Erwartet den Schlüssel <code>"amount"</code> (Integer oder String), der die Menge der zu vergebenden XP definiert. Standardwert ist 0.</li>
            </ul>
        </li>
        <li>
            <strong>parseInt(Object raw)</strong>
            <p>Eine private Hilfsmethode, die versucht, ein Objekt sicher in einen Integer umzuwandeln.</p>
            <ul>
                <li><code>raw</code>: Das zu konvertierende Objekt.</li>
                <li><strong>Rückgabewert:</strong> Der extrahierte Integer-Wert oder <code>0</code>, falls die Konvertierung fehlschlägt (z. B. bei ungültigem Format).</li>
            </ul>
        </li>
    </ul>

    <h3>Konfiguration</h3>
    <p>
        In der <code>skills.yml</code> oder anderen Konfigurationsdateien kann dieser Effekt wie folgt definiert werden:
    </p>
    <pre><code>
effect:
  type: XP
  amount: 50
    </code></pre>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffect.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffect.java</h2>
    <p>
        Das Interface <code>SkillEffect</code> definiert die grundlegende Struktur für alle Effekte, die durch Fähigkeiten (Skills) im RPG-System ausgelöst werden können. Es dient als Abstraktionsschicht, um verschiedene Arten von Auswirkungen (wie Schaden, Heilung oder visuelle Effekte) einheitlich zu behandeln.
    </p>

    <h3>Interface: <code>SkillEffect</code></h3>
    <p>
        Dieses Interface stellt sicher, dass jeder Effekt eine Methode zur Ausführung der Logik sowie eine optionale Methode zur Beschreibung des Effekts bereitstellt.
    </p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>void apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code>
            <p>
                Führt die Logik des Effekts aus.
            </p>
            <ul>
                <li><strong>player:</strong> Das <code>Player</code>-Objekt von Bukkit, auf das oder durch das der Effekt gewirkt wird.</li>
                <li><strong>profile:</strong> Das <code>PlayerProfile</code> des Spielers, welches RPG-spezifische Daten enthält.</li>
                <li><strong>params:</strong> Eine Map mit Konfigurationsparametern für den spezifischen Effekt (z. B. Schadenshöhe, Radius, Dauer), die meist aus einer YAML-Konfiguration geladen werden.</li>
            </ul>
        </li>
        <li>
            <code>default List&lt;Component&gt; describe(Map&lt;String, Object&gt; params)</code>
            <p>
                Erzeugt eine textuelle Beschreibung des Effekts basierend auf den übergebenen Parametern. Diese wird standardmäßig als leere Liste implementiert und kann von konkreten Klassen überschrieben werden, um Tooltips oder Log-Nachrichten zu generieren.
            </p>
            <ul>
                <li><strong>params:</strong> Die Konfigurationsparameter des Effekts.</li>
                <li><strong>Rückgabewert:</strong> Eine Liste von <code>Component</code>-Objekten (Adventure API) für die formatierte Textausgabe.</li>
            </ul>
        </li>
    </ul>

    <h3>Zusammenhang im System</h3>
    <p>
        Klassen wie <code>DamageEffect</code>, <code>HealEffect</code> oder <code>ParticleEffect</code> implementieren dieses Interface. Die Registrierung und Instanziierung dieser Effekte erfolgt in der Regel über die <code>SkillEffectRegistry</code> unter Verwendung von <code>SkillEffectConfig</code>.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectConfig.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectConfig.java</h2>
    <p>
        Die Klasse <code>SkillEffectConfig</code> fungiert als Datencontainer für die Konfiguration eines spezifischen Skill-Effekts. 
        Sie verknüpft einen Effekt-Typ mit einer dynamischen Liste von Parametern, die zur Laufzeit interpretiert werden können.
    </p>

    <h3>Klasse: SkillEffectConfig</h3>
    <p><strong>Beschreibung:</strong> Diese Klasse speichert die Definition eines Effekts, einschließlich seines Typs und der zugehörigen Konfigurationswerte (wie Stärke, Dauer oder Radius).</p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>SkillEffectConfig(SkillEffectType type, Map&lt;String, Object&gt; params)</code>: 
            Initialisiert eine neue Konfiguration. Wenn die übergebene Parameter-Map nicht null ist, werden alle Einträge in die interne Map kopiert.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>type()</code>: 
            Gibt den <code>SkillEffectType</code> dieses Effekts zurück.
            <br><strong>Rückgabewert:</strong> Der Typ des Effekts.
        </li>
        <li>
            <code>setType(SkillEffectType type)</code>: 
            Aktualisiert den Typ des Effekts.
            <br><strong>Parameter:</strong> <code>type</code> - Der neue Effekt-Typ.
        </li>
        <li>
            <code>params()</code>: 
            Gibt die Map der Konfigurationsparameter zurück.
            <br><strong>Rückgabewert:</strong> Eine <code>Map&lt;String, Object&gt;</code> mit den Parametern.
        </li>
        <li>
            <code>setParams(Map&lt;String, Object&gt; params)</code>: 
            Ersetzt die aktuelle Parameter-Map durch eine neue.
            <br><strong>Parameter:</strong> <code>params</code> - Die neue Map mit Einstellungen.
        </li>
        <li>
            <code>describe()</code>: 
            Erstellt eine lesbare String-Repräsentation der Konfiguration. 
            Dabei werden der Name des Typs und alle enthaltenen Parameter im Format <code>Key=Value</code> aufgelistet.
            <br><strong>Rückgabewert:</strong> Ein formatierter String (z.B. <code>DAMAGE (amount=10, radius=5)</code>).
        </li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectRegistry.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectRegistry.java</h2>
    <p>
        Die Klasse <code>SkillEffectRegistry</code> fungiert als zentrales Register für alle verfügbaren Skill-Effekte innerhalb des RPG-Systems. 
        Sie ermöglicht die Entkopplung von Effekt-Definitionen (Konfiguration) und deren tatsächlicher Programmlogik, indem sie <code>SkillEffectType</code>-Enums auf konkrete <code>SkillEffect</code>-Implementierungen abbildet.
    </p>

    <h3>Klassen-Details</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.skill</code></li>
        <li><strong>Sichtbarkeit:</strong> <code>public</code></li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>register(SkillEffectType type, SkillEffect effect)</code></h4>
    <p>
        Registriert eine neue Effekt-Logik für einen bestimmten Effekt-Typ. Diese Methode unterstützt das Fluent-Interface-Design, indem sie die Instanz des Registry-Objekts zurückgibt.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>type</code> (SkillEffectType): Der Typ des Effekts (z. B. Schaden, Heilung, Partikel).</li>
                <li><code>effect</code> (SkillEffect): Die Implementierung der Logik, die ausgeführt werden soll.</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> <code>SkillEffectRegistry</code> - Die aktuelle Instanz für verkettete Aufrufe.</li>
    </ul>

    <h4><code>apply(SkillEffectConfig config, org.bukkit.entity.Player player, com.example.rpg.model.PlayerProfile profile)</code></h4>
    <p>
        Sucht den entsprechenden Effekt basierend auf der übergebenen Konfiguration und führt diesen aus. Wenn für den angegebenen Typ kein Effekt registriert ist, bricht die Methode ohne Fehler ab.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>config</code> (SkillEffectConfig): Die Konfiguration des auszuführenden Effekts, welche den Typ und die spezifischen Parameter enthält.</li>
                <li><code>player</code> (Player): Das Bukkit-Player-Objekt, auf das der Effekt angewendet wird oder das den Effekt auslöst.</li>
                <li><code>profile</code> (PlayerProfile): Das RPG-Profil des Spielers für zusätzliche Statuswerte oder Daten.</li>
            </ul>
        </li>
    </ul>

    <h3>Interne Struktur</h3>
    <p>
        Die Klasse verwendet intern eine <code>EnumMap&lt;SkillEffectType, SkillEffect&gt;</code>. Dies ist eine hochperformante Map-Implementierung, die speziell für die Verwendung mit Enums optimiert ist und einen schnellen Zugriff auf die Effekt-Logik zur Laufzeit gewährleistet.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectType.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectType.java</h2>
    <p>
        Diese Datei definiert die Enumeration <code>SkillEffectType</code>. Sie dient als zentrales Register für alle verfügbaren Arten von Effekten, die durch Fähigkeiten (Skills) im RPG-System ausgelöst werden können.
    </p>

    <h3>SkillEffectType (Enum)</h3>
    <p>
        Das Enum <code>SkillEffectType</code> kategorisiert die verschiedenen Wirkungsweisen von Skills. Diese Typen werden in der Regel von der <code>SkillEffectRegistry</code> verwendet, um die entsprechende Logik für einen Effekt zu instanziieren.
    </p>

    <h4>Verfügbare Konstanten:</h4>
    <ul>
        <li><code>HEAL</code>: Repräsentiert Heilungseffekte, die Lebenspunkte regenerieren.</li>
        <li><code>DAMAGE</code>: Repräsentiert Effekte, die Schaden an Entitäten verursachen.</li>
        <li><code>PROJECTILE</code>: Definiert das Abfeuern von Projektilen (z. B. Pfeile oder Feuerbälle).</li>
        <li><code>POTION</code>: Bezieht sich auf Status-Effekte (Potion Effects) wie Vergiftung, Stärke oder Schnelligkeit.</li>
        <li><code>SOUND</code>: Ermöglicht das Abspielen von akustischen Signalen bei Aktivierung eines Skills.</li>
        <li><code>XP</code>: Repräsentiert Effekte, die Erfahrungspunkte vergeben oder modifizieren.</li>
        <li><code>PARTICLE</code>: Dient der visuellen Darstellung durch Partikeleffekte in der Spielwelt.</li>
        <li><code>VELOCITY</code>: Beeinflusst die Bewegungsgeschwindigkeit oder stößt Entitäten in eine bestimmte Richtung (Knockback/Dash).</li>
        <li><code>AGGRO</code>: Modifiziert das Bedrohungslevel (Aggro) von Mobs gegenüber Spielern oder anderen Entitäten.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/util/AuditLog.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/util/AuditLog.java</h2>
    <p>
        Die Klasse <code>AuditLog</code> ist eine Hilfskomponente innerhalb des RPG-Plugins, die für die Protokollierung von administrativen Aktionen oder sicherheitsrelevanten Ereignissen zuständig ist. Sie schreibt Log-Einträge in eine dedizierte Datei namens <code>audit.log</code> im Datenordner des Plugins.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class AuditLog</code>
    </p>
    <p>
        Diese Klasse stellt eine einfache Schnittstelle bereit, um Aktionen von Benutzern (CommandSender) mit einem Zeitstempel dauerhaft zu speichern. Dies dient der Nachverfolgbarkeit von Befehlen und Änderungen am System.
    </p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>public AuditLog(JavaPlugin plugin)</code>: 
            Initialisiert eine neue Instanz des Audit-Loggers. 
            <ul>
                <li><strong>Parameter:</strong> <code>plugin</code> - Die Instanz des JavaPlugins, um auf den Datenordner und den Logger zuzugreifen.</li>
            </ul>
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public void log(CommandSender sender, String action)</code>
            <p>
                Erstellt einen neuen Log-Eintrag in der Datei <code>audit.log</code>. Das Format des Eintrags ist: <code>[Zeitstempel] | [Name des Senders] | [Aktion]</code>.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>sender</code> - Das <code>CommandSender</code>-Objekt (z. B. ein Spieler oder die Konsole), das die Aktion ausgeführt hat.</li>
                <li><strong>Parameter:</strong> <code>action</code> - Eine textuelle Beschreibung der durchgeführten Aktion.</li>
                <li><strong>Besonderheit:</strong> Die Methode verwendet einen <code>FileWriter</code> im Append-Modus (<code>true</code>), um bestehende Logs nicht zu überschreiben. Fehler beim Schreiben werden im Plugin-Logger als Warnung ausgegeben.</li>
            </ul>
        </li>
    </ul>

    <h3>Dateisystem-Interaktion</h3>
    <p>
        Die Log-Datei wird standardmäßig unter folgendem Pfad verwaltet:
        <code>plugins/RPGPlugin/audit.log</code>
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/util/EloCalculator.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/util/EloCalculator.java</h2>

    <p>
        Die Klasse <code>EloCalculator</code> ist eine Utility-Klasse, die zur Berechnung von Elo-Bewertungen (Ratings) in einem kompetitiven Umfeld (z. B. PvP-Systeme innerhalb des RPG-Plugins) dient. Sie implementiert die mathematische Formel des Elo-Systems, um die Punktveränderung nach einem Spiel oder Kampf basierend auf der relativen Stärke der Kontrahenten zu ermitteln.
    </p>

    <h3>Klassen-Details</h3>
    <ul>
        <li><strong>Modifikatoren:</strong> <code>public final</code></li>
        <li><strong>Beschreibung:</strong> Die Klasse ist als <code>final</code> deklariert und besitzt einen privaten Konstruktor, um eine Instanziierung zu verhindern, da sie ausschließlich statische Hilfsmethoden bereitstellt.</li>
    </ul>

    <h3>Methoden</h3>
    
    <div class="method-definition">
        <h4><code>calculateNewRating(int rating, int opponentRating, double score, int kFactor)</code></h4>
        <p>
            Berechnet das neue Elo-Rating eines Spielers basierend auf seinem aktuellen Rating, dem Rating des Gegners, dem Ausgang des Spiels und einem Gewichtungsfaktor (K-Faktor).
        </p>
        
        <h5>Parameter:</h5>
        <ul>
            <li><code>int rating</code>: Das aktuelle Elo-Rating des Spielers.</li>
            <li><code>int opponentRating</code>: Das aktuelle Elo-Rating des Gegners.</li>
            <li><code>double score</code>: Das Ergebnis des Kampfes. Üblicherweise <code>1.0</code> für einen Sieg, <code>0.5</code> für ein Unentschieden und <code>0.0</code> für eine Niederlage.</li>
            <li><code>int kFactor</code>: Der K-Faktor, der bestimmt, wie stark sich das Ergebnis auf das Rating auswirkt (die maximale Punktveränderung).</li>
        </ul>

        <h5>Rückgabewert:</h5>
        <p>
            <code>int</code>: Das neu berechnete Rating, gerundet auf die nächste Ganzzahl.
        </p>

        <h5>Funktionsweise:</h5>
        <ol>
            <li>Berechnung der Gewinnerwartung (<code>expected</code>) mittels der logistischen Funktion: 
                <code>1 / (1 + 10^((GegnerRating - SpielerRating) / 400))</code>.
            </li>
            <li>Anpassung des Ratings: <code>Rating + K-Faktor * (Ergebnis - Erwartung)</code>.</li>
        </ol>
    </div>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemBuilder.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemBuilder.java</h2>

    <p>Die Klasse <code>ItemBuilder</code> ist eine Hilfsklasse im Fluent-Interface-Design, die dazu dient, die Erstellung und Modifikation von <code>ItemStack</code>-Objekten in der Bukkit/Spigot-API zu vereinfachen. Sie kapselt die Komplexität der <code>ItemMeta</code>-Handhabung und ermöglicht eine verkettete Konfiguration von Gegenständen.</p>

    <h3>Klassenübersicht</h3>
    <p><strong>Name:</strong> <code>ItemBuilder</code></p>
    <p><strong>Paket:</strong> <code>com.example.rpg.util</code></p>
    <p><strong>Beschreibung:</strong> Erleichtert das Erstellen von Minecraft-Items mit benutzerdefinierten Namen und Beschreibungen (Lore) unter Verwendung der Adventure-API (Components).</p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code><strong>ItemBuilder(Material material)</strong></code>
            <p>Initialisiert einen neuen ItemBuilder für ein bestimmtes Material.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>material</code> - Das <code>Material</code>, aus dem das Item bestehen soll.</li>
            </ul>
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code><strong>name(Component name)</strong></code>
            <p>Legt den Anzeigenamen des Gegenstands fest.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>name</code> - Ein Adventure <code>Component</code> Objekt für den Namen.</li>
                <li><strong>Rückgabewert:</strong> <code>ItemBuilder</code> (für Method-Chaining).</li>
            </ul>
        </li>
        <li>
            <code><strong>loreLine(Component line)</strong></code>
            <p>Fügt der Beschreibung (Lore) des Gegenstands eine einzelne Zeile hinzu.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>line</code> - Die hinzuzufügende Textzeile als <code>Component</code>.</li>
                <li><strong>Rückgabewert:</strong> <code>ItemBuilder</code> (für Method-Chaining).</li>
            </ul>
        </li>
        <li>
            <code><strong>loreLines(List&lt;Component&gt; lines)</strong></code>
            <p>Fügt der Beschreibung des Gegenstands mehrere Zeilen gleichzeitig hinzu.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>lines</code> - Eine Liste von <code>Component</code> Objekten.</li>
                <li><strong>Rückgabewert:</strong> <code>ItemBuilder</code> (für Method-Chaining).</li>
            </ul>
        </li>
        <li>
            <code><strong>build()</strong></code>
            <p>Schließt die Konfiguration ab, wendet die Metadaten (Name und Lore) auf das Item an und gibt das fertige Objekt zurück.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> Das fertig konfigurierte <code>ItemStack</code> Objekt.</li>
            </ul>
        </li>
    </ul>

    <h3>Beispiel für die Verwendung</h3>
    <pre><code>
ItemStack myItem = new ItemBuilder(Material.DIAMOND_SWORD)
    .name(Component.text("Legendäres Schwert"))
    .loreLine(Component.text("Ein mächtiges Artefakt."))
    .build();
    </code></pre>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemGenerator.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemGenerator.java</h2>
    <p>
        Die Klasse <code>ItemGenerator</code> ist eine Hilfsklasse innerhalb des RPG-Plugins, die für die dynamische Erstellung von Gegenständen (Items) verantwortlich ist. Sie verknüpft Materialien mit Seltenheitsgraden, setzt Metadaten für das RPG-System und integriert Affixe über den <code>ItemStatManager</code>.
    </p>

    <h3>Klasse: ItemGenerator</h3>
    <p>
        Diese Klasse stellt Methoden bereit, um Standard-Bukkit-<code>ItemStack</code>-Objekte in spezialisierte RPG-Gegenstände mit Attributen und persistenten Daten umzuwandeln.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>ItemGenerator(JavaPlugin plugin, ItemStatManager itemStatManager)</code>: 
            Initialisiert den Generator. Erstellt die notwendigen <code>NamespacedKey</code>-Objekte für die Identifizierung von RPG-Items und deren Seltenheit in der <code>PersistentDataContainer</code>-API von Bukkit.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <strong><code>createRpgItem(Material material, Rarity rarity, int minLevel)</code></strong>
            <p>Erzeugt einen neuen RPG-Gegenstand basierend auf den übergebenen Parametern.</p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>material</code> (Material): Der Bukkit-Materialtyp des Items (z. B. DIAMOND_SWORD).</li>
                        <li><code>rarity</code> (Rarity): Der Seltenheitsgrad des Items, welcher Farbe und Name beeinflusst.</li>
                        <li><code>minLevel</code> (int): Die Mindeststufe, die für das Item angezeigt wird.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Ein konfigurierter <code>ItemStack</code>.</li>
                <li><strong>Funktionsweise:</strong> 
                    Setzt den Anzeigenamen und die Lore (Beschreibung) basierend auf der Seltenheit. 
                    Speichert persistente Daten (<code>rpg_item</code> und <code>rpg_rarity</code>) auf dem Item, damit andere Systeme es als RPG-Gegenstand erkennen. 
                    Ruft den <code>itemStatManager</code> auf, um zufällige Affixe (Stats) anzuwenden.
                </li>
            </ul>
        </li>
        <li>
            <strong><code>itemKey()</code></strong>
            <ul>
                <li><strong>Rückgabewert:</strong> Der <code>NamespacedKey</code>, der zur Identifizierung von RPG-Items verwendet wird.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>com.example.rpg.model.Rarity</code>: Definiert die Seltenheitsstufen und zugehörige Farben.</li>
        <li><code>com.example.rpg.manager.ItemStatManager</code>: Wird verwendet, um dem Item spezifische Attribute (Affixe) zuzuweisen.</li>
        <li><code>net.kyori.adventure.text.Component</code>: Zur Erstellung von formatierten Texten für Namen und Beschreibungen.</li>
        <li><code>org.bukkit.persistence.PersistentDataContainer</code>: Zur Speicherung von Metadaten direkt auf dem Item-Stack.</li>
    </ul>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/util/PromptManager.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/util/PromptManager.java</h2>
    <p>
        Der <code>PromptManager</code> ist eine Hilfsklasse, die dazu dient, Benutzereingaben über den Chat abzufangen und zu verarbeiten. 
        Dies ist besonders nützlich für interaktive Abläufe, bei denen ein Spieler auf eine bestimmte Nachricht antworten soll (z. B. Namenseingaben für Gilden, Beträge für Auktionen oder Bestätigungen).
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Die Klasse verwaltet eine interne Map, die Spieler-UUIDs mit entsprechenden Callback-Funktionen (<code>Consumer</code>) verknüpft.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public void prompt(Player player, Component message, Consumer&lt;String&gt; handler)</code>
            <p>
                Registriert eine neue Eingabeaufforderung für einen Spieler.
            </p>
            <ul>
                <li><strong>player:</strong> Der Spieler, von dem eine Eingabe erwartet wird.</li>
                <li><strong>message:</strong> Die Nachricht (als Adventure Component), die dem Spieler im Chat angezeigt wird.</li>
                <li><strong>handler:</strong> Ein <code>Consumer</code>, der ausgeführt wird, sobald der Spieler eine Nachricht im Chat sendet.</li>
            </ul>
        </li>

        <li>
            <code>public boolean handle(Player player, String message)</code>
            <p>
                Versucht, eine eingehende Chat-Nachricht eines Spielers zu verarbeiten, falls für diesen ein aktiver Prompt existiert.
            </p>
            <ul>
                <li><strong>player:</strong> Der Spieler, der die Nachricht gesendet hat.</li>
                <li><strong>message:</strong> Der Inhalt der gesendeten Nachricht.</li>
                <li><strong>Rückgabewert:</strong> Gibt <code>true</code> zurück, wenn ein Handler gefunden und ausgeführt wurde, andernfalls <code>false</code>.</li>
            </ul>
        </li>

        <li>
            <code>public void cancel(Player player)</code>
            <p>
                Entfernt eine ausstehende Eingabeaufforderung für den angegebenen Spieler, ohne den Handler auszuführen. Dies kann genutzt werden, wenn der Vorgang abgebrochen werden soll.
            </p>
            <ul>
                <li><strong>player:</strong> Der Spieler, dessen Prompt gelöscht werden soll.</li>
            </ul>
        </li>
    </ul>

    <h3>Funktionsweise</h3>
    <p>
        Wenn ein Spieler eine Nachricht sendet, prüft das System (üblicherweise über einen Listener), ob der <code>PromptManager</code> einen Eintrag für diesen Spieler hat. 
        Ist dies der Fall, wird die Nachricht nicht als normaler Chat behandelt, sondern an den hinterlegten <code>handler</code> übergeben und der Prompt aus der Liste gelöscht.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/util/Text.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/util/Text.java</h2>
    <p>
        Die Klasse <code>Text</code> ist eine Utility-Klasse innerhalb des RPG-Plugins, die als Wrapper für die Verarbeitung von Textkomponenten dient. Sie vereinfacht die Nutzung der <strong>Kyori Adventure API</strong> und des <strong>MiniMessage</strong>-Formats zur Erstellung von formatierten Chat-Nachrichten in Minecraft.
    </p>

    <h3>Klassen-Details</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.util</code></li>
        <li><strong>Modifikatoren:</strong> <code>public final</code> (Die Klasse kann nicht instanziiert oder erweitert werden)</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>mm(String input)</code></h4>
    <p>
        Diese statische Methode wandelt einen String, der im MiniMessage-Format verfasst ist, in eine Adventure-<code>Component</code> um. MiniMessage erlaubt eine einfache Formatierung von Texten (z. B. Farben, Farbverläufe oder Tooltips) mithilfe von Tags wie <code>&lt;red&gt;</code> oder <code>&lt;gradient&gt;</code>.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>input</code> (String): Der zu deserialisierende Text mit MiniMessage-Tags.</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> 
            <code>Component</code> - Eine formatierte Textkomponente, die direkt an Spieler gesendet oder in GUIs verwendet werden kann.
        </li>
    </ul>

    <h3>Interne Implementierung</h3>
    <p>
        Die Klasse nutzt eine statische Instanz von <code>MiniMessage.miniMessage()</code>, um eine effiziente Wiederverwendung des Deserialisierers zu gewährleisten. Der private Konstruktor verhindert die Erzeugung von Objekten dieser Utility-Klasse.
    </p>
</section>
<section id="plugins/RPGPlugin/src/main/java/com/example/rpg/util/WorldUtils.java">
    <h2>plugins/RPGPlugin/src/main/java/com/example/rpg/util/WorldUtils.java</h2>
    <p>Die Klasse <code>WorldUtils</code> stellt Hilfsmethoden für die Verwaltung von Minecraft-Welten innerhalb des RPG-Plugins bereit. Ihr Hauptfokus liegt auf dem sicheren Entladen und Löschen von Welten, was insbesondere für temporäre Instanzen wie Dungeons von Bedeutung ist.</p>

    <h3>Klassenübersicht</h3>
    <p><strong>Name:</strong> <code>WorldUtils</code></p>
    <p><strong>Paket:</strong> <code>com.example.rpg.util</code></p>
    <p><strong>Beschreibung:</strong> Eine Utility-Klasse zur Handhabung von Welt-Operationen, die über die Standard-API von Bukkit hinausgehen, wie z.B. das rekursive Löschen von Welt-Ordnern vom Dateisystem.</p>

    <h3>Methoden</h3>
    
    <ul>
        <li>
            <h4><code>unloadAndDeleteWorld(World world, Location fallback)</code></h4>
            <p><strong>Zweck:</strong> Entlädt eine Welt sicher aus dem Server-Speicher und löscht anschließend alle zugehörigen Dateien vom Datenträger.</p>
            <p><strong>Funktionsweise:</strong>
                <ul>
                    <li>Teleportiert alle Spieler, die sich aktuell in der Welt befinden, an einen sicheren Ort (entweder die angegebene <code>fallback</code> Location oder den Spawn der Hauptwelt).</li>
                    <li>Sendet eine Benachrichtigung an die betroffenen Spieler ("Der Dungeon löst sich auf...").</li>
                    <li>Entlädt die Welt über die Bukkit-API ohne Speicherung der Änderungen.</li>
                    <li>Ruft die interne Methode <code>deleteDirectory</code> auf, um den Welt-Ordner zu entfernen.</li>
                </ul>
            </p>
            <p><strong>Parameter:</strong></p>
            <ul>
                <li><code>world</code> (World): Die zu löschende Bukkit-Welt.</li>
                <li><code>fallback</code> (Location): Der Zielort, an den Spieler teleportiert werden sollen.</li>
            </ul>
        </li>

        <li>
            <h4><code>deleteDirectory(File directory)</code></h4>
            <p><strong>Zweck:</strong> Eine private Hilfsmethode zum rekursiven Löschen eines Verzeichnisses und dessen Inhalts.</p>
            <p><strong>Funktionsweise:</strong> Nutzt <code>Files.walk</code>, um den Verzeichnisbaum zu durchlaufen, sortiert die Pfade in umgekehrter Reihenfolge (damit Dateien vor ihren Elternverzeichnissen gelöscht werden) und löscht jedes Element.</p>
            <p><strong>Parameter:</strong></p>
            <ul>
                <li><code>directory</code> (File): Das zu löschende Verzeichnis.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>org.bukkit.Bukkit</code>: Zur Interaktion mit dem Server und zum Entladen der Welten.</li>
        <li><code>org.bukkit.World</code> / <code>Location</code>: Repräsentation der Spielwelt und Koordinaten.</li>
        <li><code>java.nio.file.Files</code>: Für Dateioperationen auf Systemebene.</li>
        <li><code>com.example.rpg.util.Text</code>: Zur Formatierung von Chat-Nachrichten mittels MiniMessage.</li>
    </ul>
</section>
<section id="plugins/WorldCreatorPlugin/README.md">
    <h2>plugins/WorldCreatorPlugin/README.md</h2>
    <p>
        Diese Dokumentation beschreibt das <strong>WorldCreatorPlugin</strong>, ein spezialisiertes Bukkit/Spigot-Plugin zur dynamischen Generierung und Verwaltung von Spielwelten innerhalb eines Minecraft-Servers.
    </p>

    <h3>Zweck des Plugins</h3>
    <p>
        Das Plugin ermöglicht es Administratoren und Spielern (je nach Berechtigung), über ein grafisches Ingame-Menü neue Welten mit spezifischen Generatoren zu erstellen. Nach der Erstellung erfolgt eine automatische Teleportation des Spielers in die neue Welt.
    </p>

    <h3>Unterstützte Welttypen</h3>
    <p>
        Das Plugin bietet verschiedene vordefinierte Welt-Templates an, die über das Menü ausgewählt werden können:
    </p>
    <ul>
        <li><strong>Leere Welt (Void):</strong> Eine Welt ohne Blöcke, ideal für kreative Projekte oder technische Setups.</li>
        <li><strong>Wasserwelt:</strong> Eine Welt, die primär aus Ozeanen besteht.</li>
        <li><strong>Sky-Inseln:</strong> Generiert schwebende Inseln in der Luft.</li>
        <li><strong>Dschungel:</strong> Eine Welt mit Fokus auf dichten Dschungel-Biomen.</li>
        <li><strong>Wüste:</strong> Eine Welt mit Fokus auf ariden Wüsten-Biomen.</li>
    </ul>

    <h3>Build-Prozess</h3>
    <p>
        Das Plugin wird mit Apache Maven gebaut. Um die ausführbare JAR-Datei zu erstellen, muss folgender Befehl im Hauptverzeichnis ausgeführt werden:
    </p>
    <pre><code>mvn -f plugins/WorldCreatorPlugin/pom.xml package</code></pre>
    <p>
        Die resultierende Datei befindet sich anschließend im Verzeichnis <code>plugins/WorldCreatorPlugin/target/</code>.
    </p>

    <h3>Befehle und Nutzung</h3>
    <p>
        Die Interaktion mit dem Plugin erfolgt primär über einen zentralen Chat-Befehl:
    </p>
    <ul>
        <li>
            <code>/worlds</code>: Öffnet das grafische Benutzeroberflächen-Menü (GUI), in dem die verschiedenen Welttypen als Symbole dargestellt werden. Ein Klick auf ein Symbol startet den Erstellungsprozess.
        </li>
    </ul>

    <h3>Installation</h3>
    <ol>
        <li>Kopieren Sie die generierte JAR-Datei in das <code>plugins/</code> Verzeichnis Ihres Minecraft-Servers.</li>
        <li>Starten Sie den Server neu oder laden Sie die Plugins neu.</li>
        <li>Stellen Sie sicher, dass die notwendigen Berechtigungen für den Befehl <code>/worlds</code> gesetzt sind.</li>
    </ol>
</section>
<section id="plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/FixedBiomeProvider.java">
    <h2>plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/FixedBiomeProvider.java</h2>

    <p>
        Die Klasse <code>FixedBiomeProvider</code> ist eine spezialisierte Implementierung des <code>BiomeProvider</code> der Bukkit-API. 
        Ihr Hauptzweck besteht darin, eine Welt mit einem einzigen, statischen Biom zu versorgen, unabhängig von den Koordinaten innerhalb der Welt.
    </p>

    <h3>Klasse: FixedBiomeProvider</h3>
    <p>
        Diese Klasse erweitert <code>org.bukkit.generator.BiomeProvider</code> und wird verwendet, um die Biomerzeugung in benutzerdefinierten Welt-Generatoren zu steuern.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>FixedBiomeProvider(Biome biome)</code>: Initialisiert den Provider mit einem spezifischen Biom-Typ.
            <ul>
                <li><strong>Parameter:</strong> <code>biome</code> - Das <code>Biome</code>, das für die gesamte Welt verwendet werden soll.</li>
            </ul>
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>@Override Biome getBiome(WorldInfo worldInfo, int x, int y, int z)</code>
            <p>
                Gibt das Biom für die angegebenen Koordinaten zurück. In dieser Implementierung wird unabhängig von <code>x</code>, <code>y</code> und <code>z</code> immer das im Konstruktor definierte Biom zurückgegeben.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>worldInfo</code> (Metadaten der Welt), <code>x</code>, <code>y</code>, <code>z</code> (Koordinaten).</li>
                <li><strong>Rückgabewert:</strong> Das festgelegte <code>Biome</code>.</li>
            </ul>
        </li>
        <li>
            <code>@Override List&lt;Biome&gt; getBiomes(WorldInfo worldInfo)</code>
            <p>
                Gibt eine Liste aller Biome zurück, die dieser Provider in der angegebenen Welt erzeugen kann.
            </p>
            <ul>
                <li><strong>Rückgabewert:</strong> Eine unveränderliche Liste, die ausschließlich das eine konfigurierte <code>Biome</code> enthält.</li>
            </ul>
        </li>
    </ul>

    <h4>Zusammenhang im Projekt</h4>
    <p>
        Diese Klasse wird wahrscheinlich von Generatoren wie dem <code>VoidChunkGenerator</code> oder <code>WaterChunkGenerator</code> genutzt, um sicherzustellen, dass die Umgebung konsistent bleibt (z.B. eine reine Ozean-Welt oder eine leere Welt mit einem spezifischen Himmel/Klima).
    </p>
</section>
<section id="plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/SkyIslandsChunkGenerator.java">
    <h2>plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/SkyIslandsChunkGenerator.java</h2>

    <p>
        Die Klasse <code>SkyIslandsChunkGenerator</code> ist eine spezialisierte Implementierung des <code>ChunkGenerator</code> von Bukkit. 
        Sie dient dazu, eine Welt zu generieren, die aus schwebenden Inseln besteht, anstatt eines zusammenhängenden Terrains.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public final class SkyIslandsChunkGenerator extends ChunkGenerator</code>
    </p>
    <p>
        Diese Klasse überschreibt die Standard-Logik zur Chunk-Generierung, um eine "Sky Islands"-Umgebung zu erschaffen. 
        Die Inseln werden prozedural und deterministisch basierend auf dem Seed der Welt verteilt.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong>generateChunkData(World world, Random random, int chunkX, int chunkZ, BiomeGrid biome)</strong>
            <p>
                Dies ist die Hauptmethode zur Erzeugung der Blockdaten für einen spezifischen Chunk.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>world</code>: Die Instanz der Welt, für die der Chunk generiert wird.</li>
                        <li><code>random</code>: Eine Zufallsquelle (wird hier zugunsten einer eigenen Seed-Logik ergänzt).</li>
                        <li><code>chunkX</code>: Die X-Koordinate des Chunks.</li>
                        <li><code>chunkZ</code>: Die Z-Koordinate des Chunks.</li>
                        <li><code>biome</code>: Das BiomeGrid zur Festlegung der Biome innerhalb des Chunks.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> <code>ChunkData</code> – Ein Objekt, das die Block-Informationen des generierten Chunks enthält.</li>
                <li><strong>Funktionsweise:</strong>
                    <ul>
                        <li>Es wird eine deterministische Zufallsquelle (<code>seededRandom</code>) erstellt, die auf dem Welt-Seed und den Chunk-Koordinaten basiert.</li>
                        <li>Mit einer Wahrscheinlichkeit von 35 % (<code>0.35</code>) wird innerhalb des Chunks eine Insel generiert.</li>
                        <li>Die Inseln haben ein zufälliges Zentrum (X/Z innerhalb des Chunks, Y zwischen 90 und 120) und einen Radius zwischen 4 und 9 Blöcken.</li>
                        <li>Die Form der Insel wird durch eine Distanzberechnung (Euklidischer Abstand) bestimmt, was zu sphärischen bzw. ellipsoiden Gebilden führt.</li>
                        <li>Die oberste Schicht der Insel wird mit <code>Material.GRASS_BLOCK</code> versehen, während das Innere aus <code>Material.STONE</code> besteht.</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>

    <h3>Besonderheiten</h3>
    <p>
        Die Generierung nutzt eine einfache mathematische Formel für die Inselform. Da die Inseln nur innerhalb eines Chunks berechnet werden und keine Nachbar-Chunks prüfen, sind die Inseln in dieser Implementierung auf die Größe eines Chunks (16x16) begrenzt und können an den Chunk-Grenzen abgeschnitten sein, sofern der Radius das Zentrum zu nah an den Rand rückt.
    </p>
</section>
<section id="plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/VoidChunkGenerator.java">
    <h2>plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/VoidChunkGenerator.java</h2>

    <p>
        Die Klasse <code>VoidChunkGenerator</code> ist eine spezialisierte Implementierung des <code>ChunkGenerator</code> der Bukkit-API. 
        Ihr Hauptzweck besteht darin, eine komplett leere Welt (eine sogenannte "Void-Welt") zu generieren, in der keine Blöcke automatisch erzeugt werden.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public final class VoidChunkGenerator extends ChunkGenerator</code>
    </p>
    <p>
        Diese Klasse überschreibt die Standard-Generierungslogik von Minecraft, um sicherzustellen, dass Chunks ohne jegliche Terrain-Daten erstellt werden. 
        Dies ist besonders nützlich für Server-Lobbys, Skyblock-Welten oder kreative Projekte, bei denen eine leere Leinwand benötigt wird.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong>generateChunkData</strong>
            <p>
                Diese Methode wird vom Server aufgerufen, wenn ein neuer Chunk generiert werden muss.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>World world</code>: Die Welt, für die der Chunk generiert wird.</li>
                        <li><code>Random random</code>: Ein Zufallszahlengenerator für diesen Chunk.</li>
                        <li><code>int chunkX</code>: Die X-Koordinate des Chunks.</li>
                        <li><code>int chunkZ</code>: Die Z-Koordinate des Chunks.</li>
                        <li><code>BiomeGrid biome</code>: Die Biom-Daten für den Chunk.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> <code>ChunkData</code> – Ein Objekt, das die Blockdaten für den Chunk enthält. In dieser Implementierung wird ein leeres <code>ChunkData</code>-Objekt zurückgegeben.</li>
                <li><strong>Beschreibung:</strong> Die Methode ruft <code>createChunkData(world)</code> auf, was ein initialisiertes, aber leeres Datenpaket für den Chunk erzeugt, wodurch keine Blöcke in der Welt platziert werden.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WaterChunkGenerator.java">
    <h2>plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WaterChunkGenerator.java</h2>

    <p>Die Klasse <code>WaterChunkGenerator</code> ist eine spezialisierte Implementierung des <code>ChunkGenerator</code> von Bukkit. Ihr Hauptzweck besteht darin, eine Welt zu generieren, die ausschließlich aus einer flachen Wasserschicht bis zu einer definierten Meereshöhe besteht.</p>

    <h3>Klassenübersicht</h3>
    <p><strong>Name:</strong> <code>WaterChunkGenerator</code></p>
    <p><strong>Typ:</strong> <code>final class</code></p>
    <p><strong>Basisklasse:</strong> <code>ChunkGenerator</code></p>

    <h3>Konstanten</h3>
    <ul>
        <li><code>SEA_LEVEL</code> (int): Definiert die Höhe des Wasserspiegels. In dieser Implementierung ist der Wert fest auf <strong>62</strong> gesetzt.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>generateChunkData(World world, Random random, int chunkX, int chunkZ, BiomeGrid biome)</code></h4>
    <p>Diese Methode überschreibt den Standard-Generierungsprozess für Chunks, um die spezifische Wasserwelt-Struktur zu erzeugen.</p>
    
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>world</code>: Die Welt, für die der Chunk generiert wird.</li>
                <li><code>random</code>: Ein Zufallszahlengenerator (wird in dieser Implementierung nicht aktiv genutzt, da die Welt statisch ist).</li>
                <li><code>chunkX</code>: Die X-Koordinate des Chunks.</li>
                <li><code>chunkZ</code>: Die Z-Koordinate des Chunks.</li>
                <li><code>biome</code>: Das Biom-Gitter für den Chunk.</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> <code>ChunkData</code> – Das Objekt, das die Blockdaten für den generierten Chunk enthält.</li>
        <li><strong>Funktionsweise:</strong>
            <ol>
                <li>Erstellt ein neues <code>ChunkData</code>-Objekt für die angegebene Welt.</li>
                <li>Iteriert über die gesamte Grundfläche des Chunks (16x16 Blöcke).</li>
                <li>Setzt auf der untersten Ebene (Y = 0) einen Block aus <code>Material.BEDROCK</code> (Grundgestein).</li>
                <li>Füllt alle Ebenen von Y = 1 bis einschließlich Y = 62 (<code>SEA_LEVEL</code>) mit <code>Material.WATER</code>.</li>
            </ol>
        </li>
    </ul>
</section>
<section id="plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldCreatorPlugin.java">
    <h2>plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldCreatorPlugin.java</h2>
    <p>
        Die Klasse <code>WorldCreatorPlugin</code> ist die Hauptklasse eines Bukkit-Plugins, das es Spielern ermöglicht, dynamisch neue Welten mit verschiedenen Generierungstypen über eine grafische Benutzeroberfläche (GUI) zu erstellen.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public final class WorldCreatorPlugin extends JavaPlugin implements Listener</code>
    </p>
    <p>
        Diese Klasse fungiert sowohl als Plugin-Einstiegspunkt als auch als Event-Listener. Sie verwaltet die Logik für das Erstellen des Auswahlmenüs, die Verarbeitung von Klicks und die eigentliche Weltgenerierung.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>onEnable()</code>: 
            Initialisiert das Plugin, registriert die Events und konfiguriert die Slot-Belegung für das Auswahlmenü (GUI).
        </li>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>: 
            Verarbeitet den Plugin-Befehl. Wenn ein Spieler den Befehl ausführt, wird das Auswahlmenü (Inventory) geöffnet.
            <ul>
                <li><strong>Parameter:</strong> <code>sender</code> (Der Ausführende), <code>command</code>, <code>label</code>, <code>args</code>.</li>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> (true, wenn der Befehl erfolgreich verarbeitet wurde).</li>
            </ul>
        </li>
        <li>
            <code>onInventoryClick(InventoryClickEvent event)</code>: 
            Ein Event-Handler, der reagiert, wenn ein Spieler auf ein Item im "World Creator"-Menü klickt. Er verhindert die Mitnahme des Items und startet den Prozess der Welterstellung basierend auf dem gewählten Typ.
        </li>
        <li>
            <code>buildMenu()</code>: 
            Erstellt ein <code>Inventory</code>-Objekt mit 27 Slots und platziert die Auswahl-Items an den vordefinierten Positionen.
            <ul>
                <li><strong>Rückgabewert:</strong> <code>Inventory</code> (Das fertige GUI-Menü).</li>
            </ul>
        </li>
        <li>
            <code>createMenuItem(WorldTypeOption option)</code>: 
            Erzeugt ein <code>ItemStack</code> für eine bestimmte Welt-Option. Nutzt <code>PersistentDataContainer</code>, um den Typ der Welt sicher im Item zu speichern.
            <ul>
                <li><strong>Parameter:</strong> <code>option</code> (Die Welt-Konfiguration).</li>
                <li><strong>Rückgabewert:</strong> <code>ItemStack</code> (Das Icon für das Menü).</li>
            </ul>
        </li>
        <li>
            <code>createWorldAndTeleport(Player player, WorldTypeOption option)</code>: 
            Die Kernlogik zur Welterstellung. Generiert einen eindeutigen Namen basierend auf Zeitstempel und Typ, konfiguriert den <code>WorldCreator</code> mit dem entsprechenden Generator oder BiomeProvider und teleportiert den Spieler nach Abschluss der Erstellung in die neue Welt.
            <ul>
                <li><strong>Parameter:</strong> <code>player</code> (Der Zielspieler), <code>option</code> (Der gewählte Welttyp).</li>
            </ul>
        </li>
    </ul>

    <h3>Konstanten und Felder</h3>
    <ul>
        <li><code>MENU_TITLE</code>: Der Titel des GUI-Fensters ("World Creator").</li>
        <li><code>NAME_FORMAT</code>: Zeitstempel-Format (<code>yyyyMMdd-HHmmss</code>) für die Benennung der Welten.</li>
        <li><code>worldTypeKey</code>: Ein <code>NamespacedKey</code> zur Identifizierung von Metadaten auf den Menü-Items.</li>
        <li><code>slotMap</code>: Eine Map, die <code>WorldTypeOption</code>-Werten bestimmte Slots im Inventar zuweist.</li>
    </ul>
</section>
<section id="plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldTypeOption.java">
    <h2>plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldTypeOption.java</h2>
    <p>
        Diese Datei definiert das Enum <code>WorldTypeOption</code>, welches die verschiedenen verfügbaren Welt-Typen für das WorldCreatorPlugin repräsentiert. Es dient primär zur Identifizierung der Generierungs-Modi und zur Darstellung dieser Optionen in einer Benutzeroberfläche (GUI).
    </p>

    <h3>Enum: WorldTypeOption</h3>
    <p>
        Das Enum verknüpft technische Welt-Typen mit lesbaren Namen und grafischen Repräsentationen (Icons) aus der Bukkit-API.
    </p>

    <h4>Aufzählungswerte (Constants)</h4>
    <ul>
        <li><code>VOID</code>: Repräsentiert eine leere Welt. Icon: <code>Material.GLASS</code>.</li>
        <li><code>WATER</code>: Repräsentiert eine Wasserwelt. Icon: <code>Material.WATER_BUCKET</code>.</li>
        <li><code>SKY_ISLANDS</code>: Repräsentiert fliegende Inseln. Icon: <code>Material.ELYTRA</code>.</li>
        <li><code>JUNGLE</code>: Repräsentiert einen Dschungel-Welt-Typ. Icon: <code>Material.JUNGLE_LOG</code>.</li>
        <li><code>DESERT</code>: Repräsentiert einen Wüsten-Welt-Typ. Icon: <code>Material.SAND</code>.</li>
    </ul>

    <h4>Felder (Fields)</h4>
    <ul>
        <li><code>displayName</code> (String): Der Anzeigename des Welt-Typs in deutscher Sprache.</li>
        <li><code>icon</code> (Material): Das Bukkit-Material, das als Icon für diesen Typ verwendet wird.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>getDisplayName()</code>
            <p>Gibt den lesbaren Namen des Welt-Typs zurück.</p>
            <p><strong>Rückgabewert:</strong> <code>String</code> (z.B. "Sky Inseln")</p>
        </li>
        <li>
            <code>getIcon()</code>
            <p>Gibt das zugeordnete Material-Icon zurück.</p>
            <p><strong>Rückgabewert:</strong> <code>Material</code></p>
        </li>
    </ul>
</section>
<section id="Program.cs">
    <h2>Program.cs</h2>
    <p>
        Die Datei <code>Program.cs</code> stellt den Haupteinstiegspunkt (Entry Point) für die C#-Launcher-Anwendung dar. Sie ist verantwortlich für die Initialisierung der Dienste, die Verarbeitung von Befehlszeilenargumenten und den Start der grafischen Benutzeroberfläche (GUI).
    </p>

    <h3>Klasse: Program</h3>
    <p>
        Eine interne statische Klasse, die die Logik für den Anwendungsstart kapselt.
    </p>

    <h4>Methode: Main()</h4>
    <p>
        Dies ist die primäre Methode, die beim Ausführen der Anwendung aufgerufen wird.
    </p>
    <ul>
        <li><strong>Zweck:</strong> Konfiguration der Laufzeitumgebung, Instanziierung der Kerndienste und Steuerung des Programmflusses (CLI-Modus vs. GUI-Modus).</li>
        <li><strong>Attribute:</strong> <code>[STAThread]</code> – Erforderlich für Windows Forms, um sicherzustellen, dass das COM-Threading-Modell für die Anwendung auf "Single-Threaded Apartment" gesetzt ist.</li>
        <li><strong>Funktionsweise:</strong>
            <ul>
                <li>Initialisiert die Anwendungskonfiguration über <code>ApplicationConfiguration.Initialize()</code>.</li>
                <li>Erstellt Instanzen der zentralen Dienste:
                    <ul>
                        <li><code>ConfigService</code>: Verwaltung der <code>launcher-config.json</code>.</li>
                        <li><code>DownloadService</code>: Handhabung von HTTP-Downloads.</li>
                        <li><code>ServerService</code> &amp; <code>LauncherService</code>: Logik für Server-Interaktionen.</li>
                        <li><code>ClientLauncherService</code>: Starten des Spiel-Clients.</li>
                    </ul>
                </li>
                <li><strong>CLI-Logik:</strong> Wenn Argumente übergeben werden (z. B. <code>play [Name]</code>), wird der Client direkt im Headless-Modus gestartet, ohne die GUI zu laden.</li>
                <li><strong>GUI-Logik:</strong> Falls keine spezifischen Befehle erkannt werden, startet <code>Application.Run</code> das Hauptfenster (<code>MainForm</code>) und übergibt alle notwendigen Dienste via Dependency Injection.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>CLauncher.Services</code>: Enthält die Geschäftslogik für Konfiguration, Downloads und Client-Management.</li>
        <li><code>System.Windows.Forms</code>: Basis-Framework für die Benutzeroberfläche.</li>
    </ul>
</section>
<section id="README.md">
  <h2>README.md</h2>
  <p>
    Die <code>README.md</code> dient als zentrale Dokumentation für das <strong>MineLauncherRPG</strong>-Projekt. Sie beschreibt sowohl den technischen Aufbau des C#-Launchers als auch die umfangreichen In-Game-Features des zugehörigen RPG-Plugins.
  </p>

  <h3>C_launcher (C#-Komponente)</h3>
  <p>
    Ein GUI-basierter Launcher für Minecraft-Server (Vanilla, Paper, Bukkit, CraftBukkit) und ein integrierter Client-Launcher für den Offline-Modus.
  </p>
  <ul>
    <li><strong>Voraussetzungen:</strong> Windows, .NET 8 SDK, Java (im PATH oder konfiguriert).</li>
    <li><strong>Funktionen:</strong> Automatischer Download von Server-JARs, RAM-Konfiguration, EULA-Akzeptanz und Client-Start.</li>
    <li><strong>Konfiguration:</strong> Gesteuert über die <code>launcher-config.json</code>, welche Einstellungen für Server-Typ, Version, Java-Pfad und Speicherzuweisung enthält.</li>
  </ul>

  <h3>RPG – Spielerbefehle (Minecraft Plugin)</h3>
  <p>
    Das Plugin bietet ein tiefgreifendes RPG-System. Die Befehle sind unter dem Hauptbefehl <code>/rpg</code> gruppiert:
  </p>
  <ul>
    <li><strong>Charakterentwicklung:</strong> <code>/rpg skilltree</code> (visueller Skillbaum), <code>/rpg class choose</code> (Klassenwahl), <code>/rpg respec</code> (Zurücksetzen von Attributen).</li>
    <li><strong>Wirtschaft & Handel:</strong> <code>/rpg money</code>, <code>/rpg pay</code>, sowie ein Auktionshaussystem (<code>/auction list/sell/buy</code>) und ein direktes Handelssystem (<code>/trade</code>).</li>
    <li><strong>Soziale Systeme:</strong> Umfangreiche Befehle für <strong>Partys</strong> (<code>/party</code>) und <strong>Gilden</strong> (<code>/guild</code>), inklusive Gildenbanken, Gildenquests und Gildenhallen-Upgrades.</li>
    <li><strong>Berufe & Housing:</strong> <code>/rpg profession</code> zur Verwaltung von Berufen und <code>/rpg home</code> für das Housing-System mit Upgrades für Crafting oder Buffs.</li>
  </ul>

  <h3>Dungeons, PvP & Voice</h3>
  <p>
    Systeme für instanzierten Content und Kommunikation:
  </p>
  <ul>
    <li><strong>Dungeons:</strong> <code>/dungeon enter/queue</code> mit Rollenwahl (Tank, Heal, DPS) und prozeduraler Generierung (WFC - Wave Function Collapse).</li>
    <li><strong>PvP:</strong> Saisonale Ranglisten und Queues via <code>/pvp join/top/season</code>.</li>
    <li><strong>VoiceChat:</strong> Integration von Sprachkanälen für Partys und Gilden (<code>/voicechat party/guild</code>).</li>
  </ul>

  <h3>RPG – Adminbefehle</h3>
  <p>
    Umfangreiche Werkzeuge für Server-Administratoren zur Weltgestaltung:
  </p>
  <ul>
    <li><strong>Welt-Editor:</strong> <code>/rpgadmin zone</code> (Zonenerstellung mit Level-Ranges), <code>/rpgadmin node</code> (Ressourcen-Knoten für Berufe).</li>
    <li><strong>Content-Erstellung:</strong> Erstellung von NPCs (<code>/rpgadmin npc</code>), Quests (<code>/rpgadmin quest</code>), Loot-Tabellen (<code>/rpgadmin loot</code>) und Custom-Mobs (<code>/rpgadmin mob</code>).</li>
    <li><strong>Bau-Manager:</strong> GUI-gestütztes Platzieren von Schematics mit Undo-Funktion (<code>/rpgadmin build</code>).</li>
    <li><strong>Berechtigungen:</strong> Ein eigenes Permission-System mit Rollen-Hierarchien und Audit-Logs (<code>/rpgadmin perms</code>).</li>
    <li><strong>KI-Editor:</strong> <code>/behavior edit</code> öffnet einen grafischen Editor für Behavior-Trees (Verhaltensbäume) der Mobs.</li>
  </ul>

  <h3>In-Game Systeme (Zusammenfassung)</h3>
  <ul>
    <li><strong>Skill-Synergien:</strong> Ermöglicht mächtige Kombinationen von Fähigkeiten innerhalb einer Gruppe.</li>
    <li><strong>Welt-Events:</strong> Serverweite Ereignisse mit gemeinsamen Zielen und Belohnungen.</li>
    <li><strong>Fraktions-System:</strong> Ruf-basierte Rabatte bei Händlern und Zugangsbeschränkungen für Dungeons.</li>
    <li><strong>Matchmaking:</strong> Intelligente Gruppensuche für Dungeons basierend auf Spielerrollen.</li>
  </ul>
</section>
<section id="RPG_Handbuch.md">
    <h2>RPG_Handbuch.md</h2>
    <p>Dieses Dokument dient als umfassendes In-Game-Handbuch für das MineLauncherRPG-System. Es beschreibt die Befehlsstruktur, die Berechtigungssysteme und die verschiedenen Spielmechaniken sowohl für Spieler als auch für Administratoren.</p>

    <h3>1. System-Konfiguration &amp; Start</h3>
    <p>Beschreibt die grundlegenden Schritte zum Starten des Clients und zur Einrichtung von Administrator-Rechten.</p>
    <ul>
        <li><strong>Launcher-CLI:</strong> Startet den Spiel-Client über die Befehlszeile (<code>dotnet run --project C_launcher -- play [Name]</code>).</li>
        <li><strong>Berechtigungen:</strong>
            <ul>
                <li><strong>Variante A (OP):</strong> Schnelle Zuweisung aller <code>rpg.*</code> Rechte via Konsole.</li>
                <li><strong>Variante B (Permissions):</strong> Granulare Rechteverwaltung über Gruppen (z.B. <code>rpg-admin</code>) und spezifische Nodes wie <code>rpg.admin</code>, <code>rpg.editor</code>, <code>rpg.debug</code> und <code>rpg.mod</code>.</li>
            </ul>
        </li>
    </ul>

    <h3>2. Spieler-Befehle (Core-Systeme)</h3>
    <p>Zusammenfassung der Befehle für die Interaktion mit den RPG-Kernsystemen.</p>
    <ul>
        <li><strong>Charakter &amp; Skills:</strong> Zugriff auf das Hauptmenü (<code>/rpg</code>), den Skillbaum (<code>/rpg skilltree</code>) sowie das Lernen, Nutzen und Binden von Fähigkeiten (<code>/rpg bind</code>).</li>
        <li><strong>Quest-System:</strong> Verwaltung von Aufgaben über <code>/rpg quest</code> (list, abandon, complete).</li>
        <li><strong>Klassen &amp; Berufe:</strong> Auswahl von Charakterklassen und Verwaltung von Berufen (<code>/rpg profession</code>).</li>
        <li><strong>Wirtschaft:</strong> Befehle für Gold-Transfers (<code>/rpg money</code>, <code>/rpg pay</code>) und Crafting-Aufträge (<code>/rpg order</code>).</li>
        <li><strong>Housing:</strong> Setzen und Teleportieren zum Eigenheim sowie Upgrades für Handwerk oder Buffs.</li>
    </ul>

    <h3>3. Soziale Systeme &amp; Kommunikation</h3>
    <p>Dokumentation der Gruppen- und Gildenfunktionen.</p>
    <ul>
        <li><strong>Party-System:</strong> Erstellung von Gruppen, Einladungen und ein dedizierter Party-Chat (<code>/p</code>).</li>
        <li><strong>Gilden-System:</strong> Umfangreiche Verwaltung von Gilden inklusive Gildenbank, speziellen Gildenquests und einer ausbaubaren Gildenhalle.</li>
        <li><strong>Voice-Chat:</strong> Steuerung der Sprachkanäle für Party und Gilde.</li>
    </ul>

    <h3>4. Wirtschaft &amp; Wettbewerb</h3>
    <p>Systeme für Handel und kompetitives Spiel.</p>
    <ul>
        <li><strong>Auktionshaus:</strong> Globaler Handel mit Items über <code>/auction</code>.</li>
        <li><strong>Direkter Handel:</strong> Sicherer Gold- und Itemtausch zwischen Spielern via <code>/trade</code>.</li>
        <li><strong>PvP &amp; Dungeons:</strong> Matchmaking-Queues für Arenen und instanziierte Dungeons (inkl. Rollenwahl wie Tank, Heal, DPS).</li>
    </ul>

    <h3>5. Administrator-Handbuch (Editor-Tools)</h3>
    <p>Werkzeuge zur Weltgestaltung und Systemkonfiguration.</p>
    <ul>
        <li><strong>Zonen-Editor:</strong> Erstellung von Gebieten mittels <code>/rpgadmin wand</code> und Definition von Levelbereichen oder Modifikatoren.</li>
        <li><strong>NPC &amp; Quest Design:</strong> Erstellung von NPCs, Verknüpfung mit Dialogen, Shops oder Quests. Unterstützung verschiedener Quest-Typen (KILL, COLLECT, ESCORT, etc.).</li>
        <li><strong>Loot &amp; Mobs:</strong> Konfiguration von Loot-Tabellen mit Seltenheitsgraden (COMMON bis LEGENDARY) und Spawner-Management für Custom Mobs.</li>
        <li><strong>Bau-Manager:</strong> Platzieren von Gebäuden via Schematics, inklusive Undo-Funktion und Move-GUI.</li>
        <li><strong>Permissions-Service:</strong> In-Game GUI zur Verwaltung von Rollen, Vererbungshierarchien und Berechtigungs-Nodes.</li>
        <li><strong>Behavior-Editor:</strong> Grafischer Editor (<code>/behavior edit</code>) zur Gestaltung von KI-Verhaltensbäumen.</li>
    </ul>

    <h3>6. GUI-Übersicht</h3>
    <p>Liste der verfügbaren grafischen Benutzeroberflächen:</p>
    <ul>
        <li><strong>RPG Menü:</strong> Zentrale Anlaufstelle für Charakterwerte.</li>
        <li><strong>Skillbaum-GUI:</strong> Visualisierung der Lernpfade.</li>
        <li><strong>Admin-Dashboard:</strong> Zentrale Steuerung für Zonen, NPCs und Debug-Optionen.</li>
        <li><strong>Permissions-GUI:</strong> Verwaltung des Rollensystems.</li>
        <li><strong>Behavior-Editor:</strong> Interface für die KI-Programmierung.</li>
    </ul>
</section>
<section id="rpg_yaml_dashboard.md">
    <h2>rpg_yaml_dashboard.md</h2>
    <p>Diese Dokumentation beschreibt die Funktionalität und Konfiguration des <code>rpg_yaml_dashboard.py</code> Skripts. Dabei handelt es sich um ein lokales <strong>Streamlit-Dashboard</strong>, das als Administrations- und Entwicklungswerkzeug für das MineLauncherRPG-Projekt dient.</p>

    <h3>1. Hauptfunktionen</h3>
    <ul>
        <li><strong>Visualisierung:</strong> Anzeige von Mobs, Skills, Quests, NPCs, Loot-Tabellen, Verzauberungen und Spawnern.</li>
        <li><strong>Filterung:</strong> Suche und Filterung nach Typen, Boss-Status, XP-Werten und mehr.</li>
        <li><strong>Querreferenzierung:</strong> Analyse von Abhängigkeiten (z. B. welche Spawner nutzen einen bestimmten Mob).</li>
        <li><strong>Icon-Integration:</strong> Automatisches Auslesen von Item-Icons direkt aus der Minecraft Client-JAR.</li>
        <li><strong>Editor:</strong> Bearbeiten von Datensätzen direkt im Browser mit integrierter Backup-Funktion und atomarem Schreibvorgang.</li>
    </ul>

    <h3>2. Erwartete Datenstruktur (YAML)</h3>
    <p>Das Dashboard erwartet YAML-Dateien im Plugin-Ordner, die als Mapping (ID zu Objekt) strukturiert sind. Listen als Root-Element werden nicht unterstützt.</p>
    <ul>
        <li><code>mobs.yml</code></li>
        <li><code>skills.yml</code></li>
        <li><code>quests.yml</code></li>
        <li><code>npcs.yml</code></li>
        <li><code>loot.yml</code></li>
        <li><code>enchantments.yml</code></li>
        <li><code>spawners.yml</code></li>
    </ul>

    <h3>3. Pfad-Konfiguration und Autodetektion</h3>
    <p>Das Skript nutzt die <code>launcher-config.json</code> im Projekt-Root, um Pfade automatisch zu ermitteln:</p>
    <ul>
        <li><strong>Client-JAR:</strong> Wird unter <code>client_files/versions/&lt;version&gt;/&lt;version&gt;.jar</code> gesucht.</li>
        <li><strong>Server-Root:</strong> Standardmäßig im Ordner <code>servers/paper-server/</code>.</li>
        <li><strong>Plugin-Root:</strong> Pfad zu <code>plugins/MineLauncherRPG/</code> innerhalb des Server-Roots.</li>
    </ul>

    <h3>4. Installationsvoraussetzungen</h3>
    <p>Für den Betrieb des Dashboards werden folgende Python-Bibliotheken benötigt:</p>
    <ul>
        <li><code>streamlit</code>: Framework für das UI.</li>
        <li><code>pyyaml</code>: Zum Lesen und Schreiben der Konfigurationsdateien.</li>
        <li><code>pandas</code>: Zur Datenverarbeitung.</li>
        <li><code>pillow</code>: Zur Bildverarbeitung (Icons/Portraits).</li>
    </ul>

    <h3>5. Speicher- und Backup-Mechanismus</h3>
    <p>Beim Speichern eines bearbeiteten Datensatzes führt das Skript folgende Schritte aus:</p>
    <ol>
        <li><strong>Validierung:</strong> Prüfung des eingegebenen YAML-Codes mittels <code>yaml.safe_load</code>.</li>
        <li><strong>Backup:</strong> Erstellung einer <code>.bak</code> Datei der ursprünglichen YAML.</li>
        <li><strong>Atomic Write:</strong> Schreiben in eine temporäre Datei (<code>.tmp</code>) und anschließendes Ersetzen der Originaldatei, um Datenverlust bei Abstürzen zu vermeiden.</li>
        <li><strong>Cache-Refresh:</strong> Automatischer Reload der Daten via <code>st.rerun()</code>.</li>
    </ol>

    <h3>6. Fehlerbehebung (Troubleshooting)</h3>
    <ul>
        <li><strong>Kein Client-JAR:</strong> Überprüfung von <code>client_root</code> und <code>client_version</code> in der Sidebar.</li>
        <li><strong>Fehlende Icons:</strong> Abgleich der Materialnamen mit der Minecraft-Version über den integrierten "Icon-Check".</li>
        <li><strong>Formatierung:</strong> Hinweis, dass PyYAML Kommentare entfernen kann (Alternative: <code>ruamel.yaml</code>).</li>
    </ul>
</section>
<section id="rpg_yaml_dashboard.py">
    <h2>rpg_yaml_dashboard.py</h2>
    <p>Dieses Skript implementiert ein interaktives <strong>Streamlit-Dashboard</strong> zur Verwaltung und Visualisierung von RPG-Konfigurationsdateien (YAML). Es ermöglicht das Auslesen von Mobs, Skills, Quests, NPCs, Loot-Tabellen, Verzauberungen und Spawnern. Ein besonderes Merkmal ist die Integration von Minecraft-Client-Assets, um Item-Icons und Mob-Porträts direkt aus der <code>.jar</code>-Datei des Spiels anzuzeigen.</p>

    <h3>Hauptfunktionen</h3>
    <ul>
        <li><strong>Visualisierung:</strong> Darstellung komplexer YAML-Strukturen in lesbaren Tabellen und Detailansichten.</li>
        <li><strong>Asset-Extraktion:</strong> Automatisches Laden von Texturen aus dem Minecraft-Client zur Anzeige von Icons und Entity-Gesichtern.</li>
        <li><strong>Live-Editor:</strong> Integrierter YAML-Editor pro Datensatz mit Validierung, Backup-Erstellung und atomaren Schreibvorgängen.</li>
        <li><strong>Cross-Referencing:</strong> Verknüpfung von Daten (z. B. welche Spawner nutzen welchen Mob, welche Quests sind mit welchem NPC verbunden).</li>
    </ul>

    <h3>Wichtige Hilfsfunktionen</h3>
    <ul>
        <li><code>wkey(*parts: str) -> str</code>: Erzeugt stabile und eindeutige Keys für Streamlit-Widgets, um Kollisionen zu vermeiden.</li>
        <li><code>strip_mc_codes(text: str) -> str</code>: Entfernt Minecraft-Farbcodes (z. B. <code>&amp;a</code>, <code>§l</code>) aus Strings für eine saubere UI-Darstellung.</li>
        <li><code>atomic_write_text(path: Path, text: str)</code>: Schreibt Dateien sicher, indem zuerst eine temporäre Datei erstellt und diese dann ersetzt wird, um Datenverlust bei Abstürzen zu verhindern.</li>
    </ul>

    <h3>Asset-Management (Minecraft Integration)</h3>
    <ul>
        <li><code>resolve_icon_bytes_from_jar(jar_path, material)</code>: Sucht im Client-JAR nach der passenden PNG-Textur für ein Material (Items oder Blöcke).</li>
        <li><code>resolve_mob_portrait_bytes(client_jar, entity_type)</code>: Eine Pipeline, die versucht, ein Porträt für ein Monster zu finden. Priorität: Spezifisches Spawn-Egg &gt; Face-Crop aus der Entity-Textur &gt; Generisches Spawn-Egg.</li>
        <li><code>make_face_portrait(png_bytes, size)</code>: Schneidet den Kopfbereich aus einer Entity-Textur aus und skaliert ihn (Nearest-Neighbor) für einen konsistenten Pixel-Look.</li>
    </ul>

    <h3>Daten-Normalisierung (DataFrames)</h3>
    <p>Das Skript enthält diverse Funktionen (z. B. <code>mobs_df</code>, <code>skills_df</code>, <code>quests_df</code>), die rohe YAML-Mappings in <strong>Pandas DataFrames</strong> umwandeln. Dies ermöglicht mächtige Filter- und Sortierfunktionen innerhalb des Dashboards.</p>

    <h3>UI-Komponenten (Detail-Renderer)</h3>
    <ul>
        <li><code>render_mob_detail(...)</code>: Zeigt umfassende Informationen zu einem Mob an, inklusive Ausrüstung (mit Icons), Skills, Loot-Tabellen und verknüpften Spawnern.</li>
        <li><code>render_record_yaml_editor(...)</code>: Stellt eine Textarea bereit, in der der YAML-Code eines einzelnen Eintrags bearbeitet und direkt in die Quelldatei zurückgeschrieben werden kann.</li>
        <li><code>render_material_icon_line(...)</code>: Eine UI-Zeile, die ein Item-Icon neben dem Materialnamen anzeigt.</li>
    </ul>

    <h3>Konfiguration &amp; Pfade</h3>
    <p>Das Dashboard versucht, Pfade automatisch über eine <code>launcher-config.json</code> zu erkennen. Einstellbar sind:</p>
    <ul>
        <li><strong>Projekt-Root:</strong> Hauptverzeichnis des Projekts.</li>
        <li><strong>Client-Version:</strong> Bestimmt, aus welcher Minecraft-Version die Icons geladen werden.</li>
        <li><strong>Plugin-Root:</strong> Verzeichnis, in dem die <code>.yml</code> Dateien des RPG-Plugins liegen.</li>
    </ul>
</section>
<section id="Services/ClientLauncherService.cs">
    <h2>Services/ClientLauncherService.cs</h2>
    <p>
        Der <code>ClientLauncherService</code> ist eine zentrale Dienstklasse innerhalb des Launchers, die für die Initialisierung, Installation und den Start des Minecraft-Clients verantwortlich ist. Er nutzt die <code>CmlLib.Core</code> Bibliothek, um die Interaktion mit den Minecraft-Dateien und den Startprozess zu abstrahieren.
    </p>

    <h3>Klasse: ClientLauncherService</h3>
    <p>
        Eine versiegelte (<code>sealed</code>) Klasse, die Logik zum Starten des Spiel-Clients bereitstellt.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <strong>LaunchClientAsync(string playerName, string versionString)</strong>
            <p>
                Diese asynchrone Methode führt den vollständigen Startzyklus des Clients durch.
            </p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>playerName</code> (string): Der Benutzername, der für die Offline-Session verwendet werden soll.</li>
                <li><code>versionString</code> (string): Die spezifische Minecraft-Version, die gestartet werden soll (z. B. "1.20.1").</li>
            </ul>
            <strong>Ablauf:</strong>
            <ol>
                <li>Legt den Pfad für die Spieldateien im Unterordner <code>client_files</code> fest.</li>
                <li>Initialisiert den <code>MinecraftLauncher</code> mit dem definierten Pfad.</li>
                <li>Überprüft die Verfügbarkeit der gewünschten Version in den lokalen Metadaten.</li>
                <li>Erstellt eine Offline-Sitzung (<code>MSession</code>) basierend auf dem Spielernamen.</li>
                <li>Konfiguriert die Startoptionen (<code>MLaunchOption</code>), einschließlich:
                    <ul>
                        <li>Arbeitsspeicher-Limit (festgelegt auf 2048 MB).</li>
                        <li>Automatische Verbindung zum Server (Standard: <code>localhost:25565</code>).</li>
                    </ul>
                </li>
                <li>Lädt fehlende Dateien herunter und erstellt den Prozessaufruf mittels <code>InstallAndBuildProcessAsync</code>.</li>
                <li>Startet den Prozess und wartet asynchron auf dessen Beendigung.</li>
            </ol>
            <strong>Rückgabewert:</strong> <code>Task</code> – Repräsentiert den laufenden asynchronen Vorgang.
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>CmlLib.Core</code>: Hauptbibliothek für die Minecraft-Launcher-Logik.</li>
        <li><code>CmlLib.Core.Auth</code>: Verwaltung von Authentifizierung und Sitzungen.</li>
        <li><code>CmlLib.Core.ProcessBuilder</code>: Erstellung des Betriebssystem-Prozesses für Java/Minecraft.</li>
    </ul>
</section>
<section id="Services/ConfigService.cs">
    <h2>Services/ConfigService.cs</h2>
    <p>
        Die Klasse <code>ConfigService</code> ist eine zentrale Dienstkomponente innerhalb des C-Launchers, die für das Laden, Speichern und Verwalten der Anwendungskonfiguration zuständig ist. Sie stellt sicher, dass Konfigurationseinstellungen persistent in einer JSON-Datei gespeichert werden.
    </p>

    <h3>Klasse: ConfigService</h3>
    <p><strong>Beschreibung:</strong> Eine versiegelte (sealed) Klasse, die Serialisierungslogik kapselt, um die <code>LauncherConfig</code>-Modelle zu handhaben.</p>

    <h4>Eigenschaften</h4>
    <ul>
        <li><code>ConfigPath</code> (string): Der Dateipfad zur Konfigurationsdatei auf dem Datenträger.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>ConfigService(string configPath)</code>
            <p><strong>Zweck:</strong> Konstruktor zur Initialisierung des Dienstes mit einem spezifischen Dateipfad.</p>
            <p><strong>Parameter:</strong> <code>configPath</code> - Der Pfad zur JSON-Konfigurationsdatei.</p>
        </li>
        <li>
            <code>LoadOrCreate()</code>
            <p><strong>Zweck:</strong> Versucht, die Konfiguration von der Festplatte zu laden. Falls die Datei nicht existiert, wird eine neue Instanz von <code>LauncherConfig</code> mit Standardwerten erstellt, gespeichert und zurückgegeben.</p>
            <p><strong>Rückgabewert:</strong> Eine Instanz von <code>LauncherConfig</code>.</p>
        </li>
        <li>
            <code>Save(LauncherConfig config)</code>
            <p><strong>Zweck:</strong> Serialisiert das übergebene Konfigurationsobjekt und schreibt es in die Datei am <code>ConfigPath</code>.</p>
            <p><strong>Parameter:</strong> <code>config</code> - Das zu speichernde <code>LauncherConfig</code>-Objekt.</p>
        </li>
        <li>
            <code>Serialize(LauncherConfig config)</code>
            <p><strong>Zweck:</strong> Konvertiert ein <code>LauncherConfig</code>-Objekt unter Verwendung von <code>JsonSerializer</code> in einen JSON-String.</p>
            <p><strong>Rückgabewert:</strong> Ein formatierter JSON-String (CamelCase, eingerückt).</p>
        </li>
        <li>
            <code>Deserialize(string json)</code>
            <p><strong>Zweck:</strong> Wandelt einen JSON-String zurück in ein <code>LauncherConfig</code>-Objekt um.</p>
            <p><strong>Parameter:</strong> <code>json</code> - Der zu deserialisierende String.</p>
            <p><strong>Rückgabewert:</strong> Ein <code>LauncherConfig</code>-Objekt oder eine neue Instanz, falls die Deserialisierung fehlschlägt.</p>
        </li>
    </ul>

    <h4>Technische Details</h4>
    <p>
        Die Klasse verwendet <code>System.Text.Json</code> mit vordefinierten <code>JsonSerializerOptions</code>:
    </p>
    <ul>
        <li><code>WriteIndented = true</code>: Erzeugt lesbare JSON-Dateien.</li>
        <li><code>PropertyNamingPolicy = JsonNamingPolicy.CamelCase</code>: Verwendet die CamelCase-Schreibweise für JSON-Eigenschaften, um gängigen Standards zu entsprechen.</li>
    </ul>
</section>
<section id="Services/DownloadService.cs">
    <h2>Services/DownloadService.cs</h2>
    <p>
        Der <code>DownloadService</code> ist eine zentrale Komponente für die Beschaffung von Server-Dateien und die Interaktion mit externen APIs (PaperMC und Mojang). Er stellt Methoden bereit, um Dateien asynchron herunterzuladen und die aktuellsten Versionen von Minecraft-Server-Software zu ermitteln.
    </p>

    <h3>Klasse: DownloadService</h3>
    <p><strong>Beschreibung:</strong> Eine versiegelte Klasse (<code>sealed</code>), die einen <code>HttpClient</code> nutzt, um Netzwerkoperationen durchzuführen.</p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>Task DownloadFileAsync(string url, string destinationPath, CancellationToken cancellationToken)</code>
            <p>
                Lädt eine Datei von einer angegebenen URL herunter und speichert sie am Zielort.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>url</code>: Die Quell-URL der Datei.</li>
                        <li><code>destinationPath</code>: Der lokale Pfad, an dem die Datei gespeichert werden soll.</li>
                        <li><code>cancellationToken</code>: Token zum Abbrechen des Vorgangs.</li>
                    </ul>
                </li>
                <li><strong>Besonderheit:</strong> Erstellt automatisch das Zielverzeichnis, falls es noch nicht existiert. Nutzt Streams für einen speichereffizienten Download.</li>
            </ul>
        </li>
        <li>
            <code>Task&lt;PaperBuildInfo&gt; GetLatestPaperBuildAsync(string version, CancellationToken cancellationToken)</code>
            <p>
                Fragt die PaperMC-API ab, um die neueste Build-Nummer für eine spezifische Minecraft-Version zu ermitteln.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>version</code> (z. B. "1.20.1"), <code>cancellationToken</code>.</li>
                <li><strong>Rückgabewert:</strong> Ein <code>PaperBuildInfo</code>-Objekt mit Version und Build-Nummer.</li>
                <li><strong>Fehlerbehandlung:</strong> Wirft eine <code>InvalidOperationException</code>, wenn keine Builds für die Version gefunden werden.</li>
            </ul>
        </li>
        <li>
            <code>Task&lt;string&gt; GetVanillaServerUrlAsync(string version, CancellationToken cancellationToken)</code>
            <p>
                Ermittelt die offizielle Download-URL für einen Vanilla-Minecraft-Server direkt von den Mojang-Metadaten-Servern.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>version</code>, <code>cancellationToken</code>.</li>
                <li><strong>Rückgabewert:</strong> Die URL zur <code>server.jar</code> als String.</li>
                <li><strong>Logik:</strong> Durchsucht zuerst das Version-Manifest und ruft anschließend die spezifischen Versionsdetails ab, um den Download-Link zu extrahieren.</li>
            </ul>
        </li>
    </ul>

    <h3>Datenstrukturen</h3>
    <h4>PaperBuildInfo (Record)</h4>
    <p>Ein leichtgewichtiger Datentyp, der die Minecraft-Version und die zugehörige Build-Nummer von PaperMC speichert.</p>

    <h4>Interne Hilfsklassen</h4>
    <p>
        Die Klasse enthält mehrere private, versiegelte Klassen (<code>PaperVersionResponse</code>, <code>VersionManifest</code>, <code>VersionEntry</code>, etc.), die ausschließlich für die Deserialisierung der JSON-Antworten von der PaperMC- und Mojang-API verwendet werden.
    </p>
</section>
<section id="Services/LauncherService.cs">
    <h2>Services/LauncherService.cs</h2>
    <p>
        Die Klasse <code>LauncherService</code> ist eine zentrale Dienstkomponente innerhalb des Launchers, die für die Instanziierung und den Start des externen Java-Serverprozesses verantwortlich ist. Sie kapselt die Logik zur Konfiguration der Prozessstartparameter.
    </p>

    <h3>Klasse: LauncherService</h3>
    <p><strong>Typ:</strong> <code>public sealed class</code></p>
    <p>
        Diese Klasse ist als <code>sealed</code> markiert, um Vererbung zu verhindern, da sie eine spezifische, abgeschlossene Funktionalität für das Prozessmanagement bietet.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <strong>LaunchServer(LauncherConfig config, string serverDirectory, string jarPath)</strong>
            <p>
                Diese Methode konfiguriert und startet den Java-Prozess für den Server basierend auf der bereitgestellten Konfiguration.
            </p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>config</code> (<code>LauncherConfig</code>): Ein Konfigurationsobjekt, das die Java-Laufzeitpfade sowie die minimalen (<code>MinMemory</code>) und maximalen (<code>MaxMemory</code>) Speichereinstellungen enthält.</li>
                <li><code>serverDirectory</code> (<code>string</code>): Das Arbeitsverzeichnis (Working Directory), in dem der Serverprozess ausgeführt wird. Dies ist wichtig für den Zugriff auf lokale Serverdateien wie <code>server.properties</code> oder den <code>plugins</code>-Ordner.</li>
                <li><code>jarPath</code> (<code>string</code>): Der Dateipfad zur ausführbaren Java-Archivdatei (JAR) des Servers.</li>
            </ul>
            <strong>Funktionsweise:</strong>
            <ol>
                <li>Erstellt eine Argument-Zeile für den Java-Aufruf, inklusive Speicherzuweisung (<code>-Xms</code>, <code>-Xmx</code>) und dem <code>nogui</code>-Flag.</li>
                <li>Initialisiert ein <code>ProcessStartInfo</code>-Objekt mit dem Java-Pfad aus der Konfiguration.</li>
                <li>Deaktiviert <code>UseShellExecute</code>, um eine direkte Prozesssteuerung zu ermöglichen.</li>
                <li>Startet den Prozess mittels <code>Process.Start()</code>.</li>
            </ol>
            <strong>Ausnahmen:</strong>
            <ul>
                <li><code>InvalidOperationException</code>: Wird ausgelöst, wenn der Java-Prozess nicht erfolgreich gestartet werden konnte (z. B. wenn der Pfad zur Java-Executable ungültig ist).</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>System.Diagnostics</code>: Wird für die <code>Process</code> und <code>ProcessStartInfo</code> Klassen verwendet.</li>
        <li><code>CLauncher.Models</code>: Erforderlich für den Zugriff auf das <code>LauncherConfig</code> Datenmodell.</li>
    </ul>
</section>
<section id="Services/ServerService.cs">
    <h2>Services/ServerService.cs</h2>
    <p>Die Klasse <code>ServerService</code> ist eine zentrale Dienstkomponente innerhalb des Launchers, die für die Verwaltung, Konfiguration und Vorbereitung der Minecraft-Serverinstanzen zuständig ist. Sie kapselt die Logik für Dateipfade, Download-URLs und die Manipulation von Konfigurationsdateien wie der <code>server.properties</code> und <code>eula.txt</code>.</p>

    <h3>Klasse: ServerService</h3>
    <p><strong>Beschreibung:</strong> Eine versiegelte (sealed) Klasse, die Hilfsmethoden zur Handhabung von Server-Verzeichnissen und -Dateien bereitstellt.</p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>ResolveServerDirectory(LauncherConfig config, string basePath)</code>
            <p>Bestimmt den absoluten Pfad zum Installationsverzeichnis des Servers basierend auf der Launcher-Konfiguration und einem Basispfad.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>config</code> (LauncherConfig), <code>basePath</code> (string)</li>
                <li><strong>Rückgabewert:</strong> Ein <code>string</code>, der den kombinierten Pfad darstellt.</li>
            </ul>
        </li>
        <li>
            <code>GetServerJarPath(LauncherConfig config, string serverDirectory)</code>
            <p>Ermittelt den vollständigen Pfad zur ausführbaren JAR-Datei des Servers innerhalb des Server-Verzeichnisses.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>config</code> (LauncherConfig), <code>serverDirectory</code> (string)</li>
                <li><strong>Rückgabewert:</strong> Der Pfad zur JAR-Datei als <code>string</code>.</li>
            </ul>
        </li>
        <li>
            <code>BuildDownloadUrl(ServerConfig serverConfig, PaperBuildInfo? paperBuildInfo, string? vanillaUrl)</code>
            <p>Generiert die Download-URL für die Server-Software basierend auf dem konfigurierten Typ (Paper, Bukkit, CraftBukkit oder Vanilla).</p>
            <ul>
                <li><strong>Parameter:</strong> <code>serverConfig</code>, <code>paperBuildInfo</code> (optional für PaperMC), <code>vanillaUrl</code> (optional für Vanilla-Server).</li>
                <li><strong>Besonderheit:</strong> Wirft eine <code>InvalidOperationException</code>, wenn erforderliche Informationen für den gewählten Typ fehlen oder der Typ unbekannt ist.</li>
            </ul>
        </li>
        <li>
            <code>EnsureServerProperties(LauncherConfig config, string serverDirectory)</code>
            <p>Stellt sicher, dass die Datei <code>server.properties</code> existiert und aktualisiert spezifische Werte wie <code>online-mode</code> und <code>server-port</code>, ohne andere vorhandene Einstellungen zu löschen.</p>
            <ul>
                <li><strong>Logik:</strong> Liest bestehende Zeilen ein, ignoriert Kommentare und Leerzeilen, überschreibt Zielwerte und speichert die Datei neu ab.</li>
            </ul>
        </li>
        <li>
            <code>EnsureEula(ServerConfig config, string serverDirectory)</code>
            <p>Erstellt oder aktualisiert die <code>eula.txt</code> im Server-Verzeichnis, um die Endbenutzer-Lizenzvereinbarung (EULA) basierend auf der Benutzerkonfiguration zu akzeptieren.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>config</code> (ServerConfig), <code>serverDirectory</code> (string)</li>
            </ul>
        </li>
        <li>
            <code>BuildPaperUrl(PaperBuildInfo buildInfo)</code> (privat, statisch)
            <p>Hilfsmethode zur Konstruktion der spezifischen Download-URL für die PaperMC-API.</p>
        </li>
    </ul>
</section>
<section id="skill.md">
    <h2>skill.md</h2>
    <p>Diese Datei dient als Referenzdokumentation für die im RPG-Plugin verfügbaren Fähigkeiten (Skills). Sie enthält eine Auflistung der Skill-IDs sowie die entsprechenden Befehle, um diese Fähigkeiten an die Hotbar des Spielers zu binden.</p>

    <h3>Allgemeine Informationen</h3>
    <p>Um einen Skill zu nutzen, muss dieser einem Slot (1-9) zugewiesen werden. Der allgemeine Syntax für den Bind-Befehl lautet:</p>
    <p><code>/rpg bind &lt;slot 1-9&gt; &lt;skillId&gt;</code></p>

    <h3>Kategorien und Skill-IDs</h3>

    <h4>Heiler (Healing)</h4>
    <ul>
        <li>
            <strong>Heilpuls</strong> (ID: <code>heal_pulse</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; heal_pulse</code></p>
        </li>
        <li>
            <strong>Große Heilung</strong> (ID: <code>greater_heal</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; greater_heal</code></p>
        </li>
        <li>
            <strong>Segen</strong> (ID: <code>divine_blessing</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; divine_blessing</code></p>
        </li>
    </ul>

    <h4>Magie (Magic)</h4>
    <ul>
        <li>
            <strong>Flammenstoß</strong> (ID: <code>ember_shot</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; ember_shot</code></p>
        </li>
        <li>
            <strong>Frostbolzen</strong> (ID: <code>frost_bolt</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; frost_bolt</code></p>
        </li>
        <li>
            <strong>Arkane Explosion</strong> (ID: <code>arcane_burst</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; arcane_burst</code></p>
        </li>
    </ul>

    <h4>Angriff (Attack)</h4>
    <ul>
        <li>
            <strong>Machtstoß</strong> (ID: <code>power_strike</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; power_strike</code></p>
        </li>
        <li>
            <strong>Wirbelwind</strong> (ID: <code>whirlwind</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; whirlwind</code></p>
        </li>
        <li>
            <strong>Hinrichtung</strong> (ID: <code>execute</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; execute</code></p>
        </li>
    </ul>

    <h4>Verteidigung (Defense)</h4>
    <ul>
        <li>
            <strong>Schildwall</strong> (ID: <code>shield_wall</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; shield_wall</code></p>
        </li>
        <li>
            <strong>Bollwerk</strong> (ID: <code>fortify</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; fortify</code></p>
        </li>
        <li>
            <strong>Abwehrhaltung</strong> (ID: <code>deflect</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; deflect</code></p>
        </li>
    </ul>

    <h4>Berufe (Profession)</h4>
    <ul>
        <li>
            <strong>Bergbau-Fokus</strong> (ID: <code>mining_focus</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; mining_focus</code></p>
        </li>
        <li>
            <strong>Handwerkskunst</strong> (ID: <code>crafting_insight</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; crafting_insight</code></p>
        </li>
        <li>
            <strong>Alchemie-Meister</strong> (ID: <code>alchemy_mastery</code>)
            <p>Befehl: <code>/rpg bind &lt;slot&gt; alchemy_mastery</code></p>
        </li>
    </ul>
</section>
<section id="Wiki.html">
  <h2>Wiki.html</h2>
  <p>
    Die Datei <code>Wiki.html</code> ist ein umfassendes, eigenständiges Administrations-Wiki für das MineLauncher RPG-Framework. Sie dient als zentrale Dokumentationsquelle für Server-Administratoren und bietet detaillierte Anleitungen zur Konfiguration, Befehlsreferenzen und Systemerklärungen in einem modernen, responsiven Web-Interface.
  </p>

  <h3>Hauptkomponenten & Struktur</h3>
  <ul>
    <li>
      <strong>Design-System (CSS Variables):</strong>
      Definiert ein dunkles Farbschema (<code>--bg</code>, <code>--panel</code>, <code>--accent</code>) für eine professionelle Benutzeroberfläche, die auf dem "Inter"-Font und "JetBrains Mono" für Code-Blöcke basiert.
    </li>
    <li>
      <strong>Navigationsmenü:</strong>
      Ein klebriges (sticky) Seitenmenü, das schnellen Zugriff auf alle Kernbereiche wie Installation, Befehle, Gilden, Dungeons und den Behavior-Editor ermöglicht.
    </li>
    <li>
      <strong>Inhaltsbereiche (Sektionen):</strong>
      <ul>
        <li><code>overview</code> & <code>requirements</code>: Grundlegende Informationen und technische Voraussetzungen (PaperMC 1.20.4+, PostgreSQL).</li>
        <li><code>installation</code> & <code>core-config</code>: Anleitung zur Einrichtung der Datenbank und Übersicht der YAML-Konfigurationsdateien.</li>
        <li><code>player-commands</code>: Tabellarische Auflistung aller RPG-Befehle für Spieler (Skills, Quests, Berufe, Housing).</li>
        <li><code>party-guild</code>: Dokumentation der Sozialsysteme inklusive Gildenbank und Gildenquests.</li>
        <li><code>admin-commands</code>: Umfangreiche Referenz für Administratoren zur Verwaltung von Zonen, NPCs, Loot-Tabellen, Skills und Events.</li>
        <li><code>permissions</code>: Erläuterung des integrierten Rollen- und Berechtigungssystems inklusive In-Game-GUI und Audit-Logs.</li>
        <li><code>buildings</code>: Dokumentation der nativen <code>.schem</code>-Engine für Gebäude und Schemata.</li>
        <li><code>behavior-editor</code>: Einführung in die grafische KI-Logik (Behavior Trees) für Custom Mobs.</li>
      </ul>
    </li>
  </ul>

  <h3>Besondere Funktionen</h3>
  <p>
    Das Wiki dokumentiert spezifische technische Features des Projekts:
  </p>
  <ul>
    <li><strong>Native Schematic Engine:</strong> Unterstützung für Sponge v2 Formate ohne die Abhängigkeit von WorldEdit.</li>
    <li><strong>WFC (Wave Function Collapse):</strong> Erwähnung der prozeduralen Dungeon-Generierung.</li>
    <li><strong>Behavior Trees:</strong> Erklärung der KI-Logik-Knoten wie <code>Selector</code>, <code>Sequence</code> und <code>Cooldown</code>.</li>
    <li><strong>Elo-System:</strong> Dokumentation des PvP-Matchmakings und der Ranglisten.</li>
  </ul>

  <h3>Technische Details</h3>
  <p>
    Die Datei ist als Single-Page-Dokumentation konzipiert. Sie nutzt semantisches HTML5 und CSS3 Media Queries, um eine optimale Darstellung auf Desktop- und Mobilgeräten zu gewährleisten. Code-Beispiele sind in <code>&lt;pre&gt;&lt;code&gt;</code> Blöcken formatiert, um die Syntax von YAML-Konfigurationen und CLI-Befehlen hervorzuheben.
  </p>
</section>
    </main>
</body>
</html>