
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Documentation</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --sidebar-bg: #1e293b;
            --text-color: #e2e8f0;
            --link-color: #38bdf8;
            --link-hover: #7dd3fc;
            --border-color: #334155;
            --h2-color: #67e8f9;
            --h3-color: #a5f3fc;
            --code-bg: #1e293b;
        }
        html { scroll-behavior: smooth; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .sidebar {
            width: 300px;
            flex-shrink: 0;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            height: 100vh;
            overflow-y: auto;
            padding: 1.5rem;
            box-sizing: border-box;
        }
        .sidebar h1 {
            font-size: 1.25rem;
            margin-top: 0;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        .sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .sidebar li a {
            display: block;
            padding: 0.5rem 0;
            color: var(--link-color);
            text-decoration: none;
            font-size: 0.875rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: color 0.2s;
        }
        .sidebar li a:hover {
            color: var(--link-hover);
        }
        .main-content {
            flex-grow: 1;
            height: 100vh;
            overflow-y: auto;
            padding: 2rem 3rem;
            box-sizing: border-box;
        }
        section {
            padding-top: 2rem;
            margin-top: -2rem;
            margin-bottom: 3rem;
            border-bottom: 1px solid var(--border-color);
        }
        section:last-child {
            border-bottom: none;
        }
        h2 {
            font-size: 1.75rem;
            color: var(--h2-color);
            font-family: monospace;
        }
        h3 {
            font-size: 1.25rem;
            color: var(--h3-color);
            margin-top: 2rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }
        p { line-height: 1.6; }
        code {
            background-color: var(--code-bg);
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 6px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
        pre {
            background-color: var(--code-bg);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
        }
        pre code {
            padding: 0;
            background: none;
            font-size: 100%;
        }
        .error {
            color: #f87171;
            background-color: #450a0a;
            border: 1px solid #7f1d1d;
            padding: 1rem;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <aside class="sidebar">
        <h1>Project Files</h1>
        <ul>
            <li><a href="#MineLauncher/MainForm.cs">MineLauncher/MainForm.cs</a></li><li><a href="#MineLauncher/Models/LauncherConfig.cs">MineLauncher/Models/LauncherConfig.cs</a></li><li><a href="#MineLauncher/Program.cs">MineLauncher/Program.cs</a></li><li><a href="#MineLauncher/README.md">MineLauncher/README.md</a></li><li><a href="#MineLauncher/RPG_Handbuch.md">MineLauncher/RPG_Handbuch.md</a></li><li><a href="#MineLauncher/Services/ClientLauncherService.cs">MineLauncher/Services/ClientLauncherService.cs</a></li><li><a href="#MineLauncher/Services/ConfigService.cs">MineLauncher/Services/ConfigService.cs</a></li><li><a href="#MineLauncher/Services/DownloadService.cs">MineLauncher/Services/DownloadService.cs</a></li><li><a href="#MineLauncher/Services/LauncherService.cs">MineLauncher/Services/LauncherService.cs</a></li><li><a href="#MineLauncher/Services/ServerService.cs">MineLauncher/Services/ServerService.cs</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/RPGPlugin.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/RPGPlugin.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorContext.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorContext.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorNode.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorNode.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorStatus.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorStatus.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CastSkillNode.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CastSkillNode.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CompositeNode.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CompositeNode.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CooldownNode.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CooldownNode.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/FleeNode.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/FleeNode.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealSelfNode.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealSelfNode.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealthBelowNode.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealthBelowNode.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/InverterNode.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/InverterNode.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/MeleeAttackNode.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/MeleeAttackNode.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SelectorNode.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SelectorNode.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SequenceNode.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SequenceNode.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/TargetDistanceAboveNode.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/TargetDistanceAboveNode.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/WalkToTargetNode.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/WalkToTargetNode.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/AuctionCommand.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/AuctionCommand.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/DungeonCommand.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/DungeonCommand.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/GuildCommand.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/GuildCommand.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/PartyCommand.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/PartyCommand.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/PvpCommand.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/PvpCommand.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGAdminCommand.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGAdminCommand.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGCommand.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGCommand.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/TradeCommand.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/TradeCommand.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/db/DatabaseService.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/db/DatabaseService.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/db/PlayerDao.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/db/PlayerDao.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/db/SqlPlayerDao.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/db/SqlPlayerDao.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonGenerator.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonGenerator.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonInstance.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonInstance.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Direction.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Direction.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Pattern.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Pattern.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/PatternLoader.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/PatternLoader.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WaveGrid.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WaveGrid.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WfcGenerator.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WfcGenerator.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiHolders.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiHolders.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/gui/SkillTreeGui.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/gui/SkillTreeGui.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ArenaListener.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ArenaListener.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CombatListener.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CombatListener.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CustomMobListener.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CustomMobListener.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/DamageIndicatorListener.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/DamageIndicatorListener.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/GuiListener.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/GuiListener.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ItemStatListener.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ItemStatListener.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcListener.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcListener.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcProtectionListener.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcProtectionListener.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/PlayerListener.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/PlayerListener.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ProfessionListener.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ProfessionListener.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/SkillHotbarListener.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/SkillHotbarListener.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ZoneListener.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ZoneListener.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ArenaManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ArenaManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/AuctionHouseManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/AuctionHouseManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/BehaviorTreeManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/BehaviorTreeManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ClassManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ClassManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/DungeonManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/DungeonManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/FactionManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/FactionManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/GuildManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/GuildManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ItemStatManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ItemStatManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/LootManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/LootManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/MobManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/MobManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/NpcManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/NpcManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PartyManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PartyManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PlayerDataManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PlayerDataManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ProfessionManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ProfessionManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/QuestManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/QuestManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ShopManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ShopManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillHotbarManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillHotbarManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillTreeManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillTreeManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SpawnerManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SpawnerManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/TradeManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/TradeManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ZoneManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ZoneManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Arena.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Arena.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ArenaStatus.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ArenaStatus.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/AuctionListing.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/AuctionListing.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ClassDefinition.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ClassDefinition.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Faction.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Faction.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Guild.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Guild.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildMemberRole.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildMemberRole.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildQuest.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildQuest.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootEntry.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootEntry.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootTable.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootTable.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/MobDefinition.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/MobDefinition.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Npc.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Npc.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/NpcRole.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/NpcRole.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Party.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Party.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/PlayerProfile.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/PlayerProfile.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Profession.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Profession.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Quest.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Quest.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestProgress.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestProgress.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestReward.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestReward.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStep.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStep.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStepType.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStepType.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/RPGStat.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/RPGStat.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Rarity.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Rarity.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopDefinition.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopDefinition.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopItem.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopItem.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Skill.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Skill.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillCategory.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillCategory.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillType.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillType.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Spawner.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Spawner.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/TradeRequest.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/TradeRequest.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Zone.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Zone.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffect.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffect.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectConfig.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectConfig.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectRegistry.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectRegistry.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectType.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectType.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/AggroEffect.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/AggroEffect.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/DamageEffect.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/DamageEffect.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/HealEffect.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/HealEffect.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ParticleEffect.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ParticleEffect.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/PotionStatusEffect.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/PotionStatusEffect.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ProjectileEffect.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ProjectileEffect.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/SoundEffect.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/SoundEffect.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/VelocityEffect.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/VelocityEffect.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/XpEffect.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/XpEffect.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/AuditLog.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/AuditLog.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/EloCalculator.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/EloCalculator.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemBuilder.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemBuilder.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemGenerator.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemGenerator.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/PromptManager.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/PromptManager.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/Text.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/Text.java</a></li><li><a href="#MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/WorldUtils.java">MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/WorldUtils.java</a></li><li><a href="#MineLauncher/plugins/WorldCreatorPlugin/README.md">MineLauncher/plugins/WorldCreatorPlugin/README.md</a></li><li><a href="#MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/FixedBiomeProvider.java">MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/FixedBiomeProvider.java</a></li><li><a href="#MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/SkyIslandsChunkGenerator.java">MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/SkyIslandsChunkGenerator.java</a></li><li><a href="#MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/VoidChunkGenerator.java">MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/VoidChunkGenerator.java</a></li><li><a href="#MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WaterChunkGenerator.java">MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WaterChunkGenerator.java</a></li><li><a href="#MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldCreatorPlugin.java">MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldCreatorPlugin.java</a></li><li><a href="#MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldTypeOption.java">MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldTypeOption.java</a></li>
        </ul>
    </aside>
    <main class="main-content">
        <section id="MineLauncher/MainForm.cs">
    <h2>MineLauncher/MainForm.cs</h2>
    <p>
        Die Klasse <code>MainForm</code> ist das zentrale grafische Benutzerinterface (GUI) des MineLaunchers. Sie basiert auf Windows Forms und bietet Funktionen zur Konfiguration, zum Download und zum Starten von Minecraft-Servern sowie des Clients.
    </p>

    <h3>Klasse: MainForm</h3>
    <p>
        Eine versiegelte (<code>sealed</code>) Klasse, die von <code>Form</code> erbt und die Hauptlogik der Benutzeroberfläche steuert.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>MainForm(string basePath, ConfigService configService, DownloadService downloadService, ServerService serverService, LauncherService launcherService, ClientLauncherService clientLauncherService)</code>: 
            Initialisiert die UI-Komponenten, setzt das Styling und injiziert die notwendigen Dienste für Konfiguration, Download und Prozesssteuerung.
        </li>
    </ul>

    <h4>Wichtige Methoden</h4>
    <ul>
        <li>
            <code>InitConfigAsync()</code>: 
            Speichert die aktuelle Konfiguration und aktualisiert den Editor in der UI.
        </li>
        <li>
            <code>OpenConfig()</code>: 
            Öffnet die Konfigurationsdatei (<code>config.json</code>) im Standard-Texteditor des Betriebssystems.
        </li>
        <li>
            <code>ShowConfig()</code>: 
            Lädt die aktuelle Konfiguration von der Festplatte und zeigt sie im integrierten Editor-Fenster an.
        </li>
        <li>
            <code>SaveConfigFromEditor()</code>: 
            Versucht, den Text aus dem Editor-Fenster zu deserialisieren und als neue Konfiguration zu speichern.
        </li>
        <li>
            <code>DownloadServerAsync()</code>: 
            Ermittelt basierend auf der Konfiguration (Paper oder Vanilla) die korrekte Download-URL, lädt die Server-JAR herunter und bereitet die EULA sowie die <code>server.properties</code> vor.
        </li>
        <li>
            <code>LaunchServerAsync()</code>: 
            Startet den Minecraft-Server. Falls die JAR-Datei nicht vorhanden ist, wird automatisch der Download-Prozess angestoßen.
        </li>
        <li>
            <code>LaunchClientAsync()</code>: 
            Startet den Minecraft-Client unter Verwendung des konfigurierten Benutzernamens und der Version über den <code>ClientLauncherService</code>.
        </li>
        <li>
            <code>RunActionAsync(Func&lt;Task&gt; action)</code>: 
            Eine Hilfsmethode, die Schaltflächen während asynchroner Operationen deaktiviert und eine Fehlerbehandlung für UI-Aktionen bereitstellt.
        </li>
        <li>
            <code>AppendStatus(string message)</code>: 
            Fügt eine Nachricht mit Zeitstempel zum Status-Log-Fenster hinzu.
        </li>
    </ul>

    <h4>UI-Komponenten (Private Felder)</h4>
    <ul>
        <li><code>_statusBox</code>: Ein schreibgeschütztes Textfeld zur Anzeige von Log-Informationen.</li>
        <li><code>_configEditor</code>: Ein mehrzeiliges Textfeld zum direkten Bearbeiten der JSON-Konfiguration.</li>
        <li><code>_initButton, _downloadButton, _launchButton, etc.</code>: Schaltflächen zur Steuerung der verschiedenen Launcher-Funktionen.</li>
    </ul>

    <h4>Styling</h4>
    <p>
        Die Methode <code>StyleButton(Button button)</code> sorgt für ein einheitliches, dunkles Design der Schaltflächen, passend zum Farbschema des Launchers (Dunkelblau/Anthrazit).
    </p>
</section>
<section id="MineLauncher/Models/LauncherConfig.cs">
    <h2>MineLauncher/Models/LauncherConfig.cs</h2>
    <p>Diese Datei definiert die Datenstrukturen für die Konfiguration des Launchers. Sie enthält Klassen, die die Einstellungen für den Installationspfad, den Server, die Java-Laufzeitumgebung und das Spiel selbst repräsentieren. Diese Modelle werden typischerweise für die Serialisierung und Deserialisierung (z. B. von JSON-Dateien) verwendet.</p>

    <h3>Klasse: <code>LauncherConfig</code></h3>
    <p>Die Hauptkonfigurationsklasse, die alle Unterbereiche des Launchers zusammenfasst.</p>
    <ul>
        <li><strong>Eigenschaften:</strong>
            <ul>
                <li><code>InstallRoot</code> (string): Das Basisverzeichnis für Installationen. Standardwert: <code>"servers"</code>.</li>
                <li><code>Server</code> (ServerConfig): Enthält die spezifischen Einstellungen für den Minecraft-Server.</li>
                <li><code>Java</code> (JavaConfig): Enthält die Konfiguration für die Java-Laufzeitumgebung.</li>
                <li><code>Game</code> (GameConfig): Enthält die Einstellungen für den Spiel-Client.</li>
            </ul>
        </li>
    </ul>

    <h3>Klasse: <code>ServerConfig</code></h3>
    <p>Definiert die Parameter für den Betrieb und die Bereitstellung des Minecraft-Servers.</p>
    <ul>
        <li><strong>Eigenschaften:</strong>
            <ul>
                <li><code>Name</code> (string): Der Name des Servers. Standard: <code>"paper-server"</code>.</li>
                <li><code>Type</code> (string): Der Server-Typ (z. B. <code>vanilla</code>, <code>paper</code>, <code>bukkit</code>). Standard: <code>"paper"</code>.</li>
                <li><code>Version</code> (string): Die gewünschte Minecraft-Version. Standard: <code>"1.20.4"</code>.</li>
                <li><code>PaperBuild</code> (int?): Die spezifische Build-Nummer für Paper-Server (optional).</li>
                <li><code>OnlineMode</code> (bool): Legt fest, ob der Server die Authentifizierung über Mojang/Microsoft erzwingt. Standard: <code>true</code>.</li>
                <li><code>Port</code> (int): Der Netzwerk-Port des Servers. Standard: <code>25565</code>.</li>
                <li><code>AcceptEula</code> (bool): Gibt an, ob die Endbenutzer-Lizenzvereinbarung (EULA) akzeptiert wurde. Standard: <code>false</code>.</li>
                <li><code>JarFileName</code> (string): Der Name der ausführbaren JAR-Datei. Standard: <code>"server.jar"</code>.</li>
            </ul>
        </li>
    </ul>

    <h3>Klasse: <code>JavaConfig</code></h3>
    <p>Verwaltet die Einstellungen für die Java-Virtual-Machine (JVM).</p>
    <ul>
        <li><strong>Eigenschaften:</strong>
            <ul>
                <li><code>Path</code> (string): Pfad zur Java-Executable. Standard: <code>"java"</code>.</li>
                <li><code>MinMemory</code> (string): Minimaler Arbeitsspeicher (Xms), z. B. <code>"1G"</code>.</li>
                <li><code>MaxMemory</code> (string): Maximaler Arbeitsspeicher (Xmx), z. B. <code>"2G"</code>.</li>
            </ul>
        </li>
    </ul>

    <h3>Klasse: <code>GameConfig</code></h3>
    <p>Konfiguriert die Parameter für den Start des Minecraft-Clients.</p>
    <ul>
        <li><strong>Eigenschaften:</strong>
            <ul>
                <li><code>ClientVersion</code> (string): Die Version des zu startenden Clients. Standard: <code>"1.20.4"</code>.</li>
                <li><code>GameDirectory</code> (string): Das Verzeichnis, in dem die Spieldaten gespeichert werden. Standard: <code>"client"</code>.</li>
                <li><code>MaxMemoryMb</code> (int): Maximaler Arbeitsspeicher für den Client in Megabyte. Standard: <code>2048</code>.</li>
                <li><code>OfflineMode</code> (bool): Bestimmt, ob der Client im Offline-Modus startet. Standard: <code>true</code>.</li>
                <li><code>OfflineUsername</code> (string): Der zu verwendende Benutzername im Offline-Modus. Standard: <code>"Player"</code>.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="MineLauncher/Program.cs">
    <h2>MineLauncher/Program.cs</h2>
    <p>
        Die Datei <code>Program.cs</code> bildet den Haupteinstiegspunkt (Entry Point) der C#-Anwendung <code>CLauncher</code>. Sie ist verantwortlich für die Initialisierung der Laufzeitumgebung, die Konfiguration der Abhängigkeiten (Dependency Injection im einfachen Sinne) und die Steuerung des Programmflusses zwischen dem grafischen Modus (GUI) und dem Befehlszeilenmodus (CLI).
    </p>

    <h3>Klasse: Program</h3>
    <p>
        Eine interne statische Klasse, die die Logik zum Starten der Anwendung kapselt.
    </p>

    <h4>Methode: Main()</h4>
    <p>
        Dies ist die primäre Methode, die beim Ausführen der Anwendung aufgerufen wird.
    </p>
    <ul>
        <li><strong>Attribut:</strong> <code>[STAThread]</code> – Gibt an, dass das COM-Threadingmodell für die Anwendung das Single-Threaded Apartment ist, was für Windows Forms Anwendungen erforderlich ist.</li>
        <li><strong>Zweck:</strong> 
            <ul>
                <li>Initialisierung der Anwendungskonfiguration (<code>ApplicationConfiguration.Initialize()</code>).</li>
                <li>Einrichtung der Dateipfade für die Konfiguration (<code>launcher-config.json</code>).</li>
                <li>Instanziierung der zentralen Dienste:
                    <ul>
                        <li><code>ConfigService</code>: Verwaltung der Benutzereinstellungen.</li>
                        <li><code>DownloadService</code>: Handhabung von Datei-Downloads via HTTP.</li>
                        <li><code>ServerService</code> &amp; <code>LauncherService</code>: Logik für Server-Interaktionen.</li>
                        <li><code>ClientLauncherService</code>: Starten des eigentlichen Spiel-Clients.</li>
                    </ul>
                </li>
                <li><strong>CLI-Logik:</strong> Wenn Argumente übergeben werden (z. B. <code>play [Name]</code>), wird der Client direkt im Headless-Modus gestartet, ohne die GUI zu laden.</li>
                <li><strong>GUI-Logik:</strong> Wenn keine spezifischen Befehle erkannt werden, startet <code>Application.Run</code> das Hauptfenster (<code>MainForm</code>) und übergibt alle notwendigen Dienste.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>CLauncher.Services</code>: Enthält die Geschäftslogik für Konfiguration, Downloads und Client-Management.</li>
        <li><code>System.Windows.Forms</code>: Wird für den Start der grafischen Benutzeroberfläche verwendet.</li>
        <li><code>System.Net.Http</code>: Stellt den <code>HttpClient</code> für Netzwerkoperationen bereit.</li>
    </ul>
</section>
<section id="MineLauncher/README.md">
    <h2>MineLauncher/README.md</h2>
    <p>
        Diese Datei dient als Hauptdokumentation und Einstiegspunkt für das Projekt <strong>C_launcher</strong>. Sie beschreibt die grundlegende Funktionalität, die Systemvoraussetzungen sowie die Konfigurationsmöglichkeiten des Minecraft-Launchers.
    </p>

    <h3>Zweck der Datei</h3>
    <p>
        Das Dokument informiert Entwickler und Endanwender darüber, wie der Launcher kompiliert, gestartet und konfiguriert wird. Es fungiert als Benutzerhandbuch für die integrierte GUI und die Kommandozeilenschnittstelle (CLI).
    </p>

    <h3>Hauptkomponenten der Dokumentation</h3>
    <ul>
        <li>
            <strong>Projektübersicht:</strong> Beschreibung des Launchers als C#-basierte Anwendung mit Unterstützung für verschiedene Server-Typen (Vanilla, Paper, Bukkit, CraftBukkit) und einen integrierten Client-Launcher.
        </li>
        <li>
            <strong>Voraussetzungen:</strong> Auflistung der benötigten Laufzeitumgebungen, insbesondere Windows, .NET 8 SDK und eine gültige Java-Installation.
        </li>
        <li>
            <strong>Nutzungshinweise:</strong>
            <ul>
                <li><code>dotnet run --project C_launcher</code>: Startet die grafische Benutzeroberfläche (GUI).</li>
                <li><code>dotnet run --project C_launcher -- play [Name]</code>: Startet den Client direkt über die CLI im Offline-Modus.</li>
            </ul>
        </li>
        <li>
            <strong>Konfigurationsstruktur:</strong> Detaillierte Aufschlüsselung der <code>launcher-config.json</code>.
        </li>
    </ul>

    <h3>Konfigurationsparameter (launcher-config.json)</h3>
    <p>Die Datei dokumentiert folgende wichtige Einstellungsbereiche:</p>
    <ul>
        <li><strong>Server-Einstellungen:</strong> Definiert Typ (<code>server.type</code>), Version, EULA-Status und Port des Minecraft-Servers.</li>
        <li><strong>Java-Einstellungen:</strong> Pfad zur Java-Executable (<code>java.path</code>) sowie Speicherzuweisungen (<code>minMemory</code>/<code>maxMemory</code>).</li>
        <li><strong>Game-Einstellungen:</strong> Spezifische Optionen für den Client, wie die Version (<code>game.clientVersion</code>), das Installationsverzeichnis (<code>game.gameDirectory</code>) und Offline-Modus-Parameter (<code>game.offlineUsername</code>).</li>
    </ul>

    <h3>Dateistruktur-Hinweise</h3>
    <p>
        Die Dokumentation stellt klar, dass alle serverrelevanten Dateien isoliert im Unterordner <code>servers/&lt;server.name&gt;</code> verwaltet werden, um eine saubere Trennung zwischen verschiedenen Instanzen zu gewährleisten.
    </p>
</section>
<section id="MineLauncher/RPG_Handbuch.md">
    <h2>MineLauncher/RPG_Handbuch.md</h2>
    <p>Diese Datei dient als umfassendes In-Game-Handbuch für das MineLauncher RPG-System. Sie dokumentiert die Konfiguration von Administratorrechten, die Befehle für Spieler sowie die umfangreichen Werkzeuge für Administratoren zur Weltgestaltung und Quest-Erstellung.</p>

    <h3>1. Administrator-Konfiguration</h3>
    <p>Beschreibt die Zuweisung von Berechtigungen über das Bukkit-System.</p>
    <ul>
        <li><strong>Variante A (OP):</strong> Schnelle Zuweisung aller <code>rpg.*</code> Rechte via Konsole.</li>
        <li><strong>Variante B (Permissions):</strong> Granulare Rechtevergabe (z. B. via LuckPerms) mit Rollen wie <code>rpg.admin</code>, <code>rpg.editor</code>, <code>rpg.debug</code> und <code>rpg.mod</code>.</li>
    </ul>

    <h3>2. Spieler-Funktionen (In-Game)</h3>
    <p>Dokumentation der Befehle und Systeme, die den Spielern zur Verfügung stehen.</p>
    <ul>
        <li><strong>Hauptmenü (<code>/rpg</code>):</strong> Zentraler Zugriffspunkt für Charakterwerte, Skills, Quests und Fraktionen.</li>
        <li><strong>Progression:</strong> Level-Aufstieg durch Kämpfe, Crafting und Abbau von Blöcken; automatische Attribut-Skalierung (HP, Schaden, Speed).</li>
        <li><strong>Skill-System:</strong> Erlernen via GUI und Ausführung über <code>/rpg skill &lt;id&gt;</code> (z. B. <em>dash</em>, <em>heal</em>).</li>
        <li><strong>Quest-Management:</strong> Befehle zum Annehmen, Abbrechen (<code>abandon</code>) und manuellen Abschließen (<code>complete</code>) von Aufgaben.</li>
        <li><strong>Klassen &amp; Respec:</strong> Auswahl der Charakterklasse (<code>/rpg class choose</code>) und Zurücksetzen von Skillpunkten (<code>/rpg respec</code>).</li>
        <li><strong>Party-System:</strong> Befehle zur Gruppenbildung (<code>/party create</code>, <code>invite</code>, <code>join</code>).</li>
    </ul>

    <h3>3. Administrator-Werkzeuge (Editor)</h3>
    <p>Schnittstellen für Admins zur dynamischen Konfiguration des RPG-Plugins während des Spielbetriebs.</p>
    <ul>
        <li><strong>Admin-Dashboard (<code>/rpgadmin</code>):</strong> Grafische Oberfläche für alle Verwaltungsaufgaben.</li>
        <li><strong>Editor-Wand (<code>/rpgadmin wand</code>):</strong> Werkzeug zur Selektion von Welt-Regionen (Pos1/Pos2).</li>
        <li><strong>Zonen-Verwaltung:</strong> Erstellung von Regionen mit Level-Beschränkungen und Modifikatoren (z. B. Schaden oder Verlangsamung).</li>
        <li><strong>NPC-System:</strong> Erstellung von NPCs mit Rollen wie <code>QUESTGIVER</code>, <code>VENDOR</code>, <code>TRAINER</code> etc. und Konfiguration von Dialogen.</li>
        <li><strong>Quest-Editor:</strong> Befehle zum Erstellen von Quests und Hinzufügen von Schritten (Typen: <code>KILL</code>, <code>COLLECT</code>, <code>EXPLORE</code>, etc.).</li>
        <li><strong>Loot-Tabellen:</strong> Dynamische Zuweisung von Beute zu Mob-Typen mit Wahrscheinlichkeiten und Seltenheitsgraden (<code>COMMON</code> bis <code>LEGENDARY</code>).</li>
    </ul>

    <h3>4. System-Hinweise &amp; Wartung</h3>
    <p>Informationen zur Datenhaltung und Fehlerdiagnose.</p>
    <ul>
        <li><strong>Logging:</strong> Alle administrativen Änderungen werden in der <code>audit.log</code> protokolliert.</li>
        <li><strong>Datenstruktur:</strong> Speicherung erfolgt in YAML-Dateien (<code>players.yml</code>, <code>zones.yml</code>, etc.), was eine Versionierung via Git ermöglicht.</li>
        <li><strong>Debug-Modus:</strong> Ein Overlay in der Actionbar zeigt Echtzeit-Informationen über die aktuelle Zone und den Quest-Status an.</li>
    </ul>
</section>
<section id="MineLauncher/Services/ClientLauncherService.cs">
    <h2>MineLauncher/Services/ClientLauncherService.cs</h2>
    <p>
        Der <code>ClientLauncherService</code> ist eine zentrale Dienstklasse innerhalb des Launchers, die für die Initialisierung, den Download und den Start des Minecraft-Clients verantwortlich ist. Sie nutzt die <code>CmlLib.Core</code> Bibliothek, um die komplexen Prozesse der Versionsverwaltung und Prozesssteuerung zu abstrahieren.
    </p>

    <h3>Klasse: <code>ClientLauncherService</code></h3>
    <p>
        Diese Klasse ist als <code>sealed</code> markiert, was bedeutet, dass sie nicht vererbt werden kann. Sie stellt die Logik bereit, um eine spezifische Minecraft-Version für einen bestimmten Spieler zu starten.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <strong><code>LaunchClientAsync(string playerName, string versionString)</code></strong>
            <p>
                Diese asynchrone Methode führt den vollständigen Startprozess des Clients durch.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>playerName</code> (string): Der Benutzername, der für die Offline-Session verwendet werden soll.</li>
                        <li><code>versionString</code> (string): Die ID der Minecraft-Version (z. B. "1.20.1"), die gestartet werden soll.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> <code>Task</code> (Asynchrone Operation ohne Rückgabewert).</li>
                <li><strong>Funktionsweise:</strong>
                    <ol>
                        <li>Legt den Pfad für die Spieldateien im Unterordner <code>client_files</code> fest.</li>
                        <li>Initialisiert den <code>MinecraftLauncher</code> mit dem angegebenen Pfad.</li>
                        <li>Prüft, ob die gewünschte Version lokal vorhanden ist; falls nicht, wird eine entsprechende Meldung ausgegeben (der Download erfolgt automatisch durch die Bibliothek).</li>
                        <li>Erstellt eine Offline-Session für den angegebenen Spielernamen.</li>
                        <li>Konfiguriert die Startoptionen (<code>MLaunchOption</code>), einschließlich RAM-Zuweisung (2048 MB) und automatischer Verbindung zum lokalen Server (<code>localhost:25565</code>).</li>
                        <li>Baut den Prozess über <code>InstallAndBuildProcessAsync</code> auf.</li>
                        <li>Startet den Prozess und wartet asynchron auf dessen Beendigung (<code>WaitForExitAsync</code>).</li>
                    </ol>
                </li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>CmlLib.Core</code>: Hauptbibliothek für die Minecraft-Launcher-Logik.</li>
        <li><code>CmlLib.Core.Auth</code>: Verwaltung der Benutzer-Sessions.</li>
        <li><code>CmlLib.Core.ProcessBuilder</code>: Erstellung des Java-Prozesses für das Spiel.</li>
    </ul>
</section>
<section id="MineLauncher/Services/ConfigService.cs">
    <h2>MineLauncher/Services/ConfigService.cs</h2>
    <p>
        Der <code>ConfigService</code> ist eine zentrale Dienstklasse innerhalb des Launchers, die für die Persistenz der Konfigurationseinstellungen verantwortlich ist. Er übernimmt das Laden, Speichern und Serialisieren der <code>LauncherConfig</code>-Daten unter Verwendung von JSON.
    </p>

    <h3>Klasse: <code>ConfigService</code></h3>
    <p>
        Eine versiegelte (<code>sealed</code>) Klasse, die Methoden zur Verwaltung der Konfigurationsdatei bereitstellt.
    </p>

    <h4>Eigenschaften</h4>
    <ul>
        <li><code>ConfigPath</code> (string): Der Dateipfad, an dem die Konfigurationsdatei gespeichert ist oder erstellt werden soll.</li>
    </ul>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>ConfigService(string configPath)</code>: Initialisiert eine neue Instanz des Dienstes mit dem angegebenen Pfad zur Konfigurationsdatei.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>LoadOrCreate()</code>
            <p>
                Prüft, ob die Konfigurationsdatei existiert. Wenn nicht, wird eine neue Standardinstanz von <code>LauncherConfig</code> erstellt, gespeichert und zurückgegeben. Falls die Datei existiert, wird sie eingelesen und deserialisiert.
            </p>
            <strong>Rückgabewert:</strong> Eine Instanz von <code>LauncherConfig</code>.
        </li>
        <li>
            <code>Save(LauncherConfig config)</code>
            <p>
                Serialisiert das übergebene Konfigurationsobjekt in ein JSON-Format und schreibt dieses in die Datei am <code>ConfigPath</code>.
            </p>
            <strong>Parameter:</strong> <code>config</code> - Das zu speichernde <code>LauncherConfig</code>-Objekt.
        </li>
        <li>
            <code>Serialize(LauncherConfig config)</code>
            <p>
                Konvertiert ein <code>LauncherConfig</code>-Objekt in einen JSON-String. Verwendet dabei <code>CamelCase</code>-Benennung und eingerückte Formatierung (Indented).
            </p>
            <strong>Rückgabewert:</strong> Ein formatierter JSON-String.
        </li>
        <li>
            <code>Deserialize(string json)</code>
            <p>
                Konvertiert einen JSON-String zurück in ein <code>LauncherConfig</code>-Objekt.
            </p>
            <strong>Rückgabewert:</strong> Ein <code>LauncherConfig</code>-Objekt oder eine neue Standardinstanz, falls die Deserialisierung fehlschlägt.
        </li>
    </ul>

    <h4>Technische Details</h4>
    <p>
        Die Klasse nutzt <code>System.Text.Json</code> für die Verarbeitung. Die <code>JsonSerializerOptions</code> sind so konfiguriert, dass die JSON-Ausgabe für Menschen lesbar ist (<code>WriteIndented = true</code>) und die Eigenschaften im <code>camelCase</code>-Stil geschrieben werden.
    </p>
</section>
<section id="MineLauncher/Services/DownloadService.cs">
    <h2>MineLauncher/Services/DownloadService.cs</h2>
    <p>
        Der <code>DownloadService</code> ist eine zentrale Dienstklasse innerhalb des Launchers, die für das Herunterladen von Dateien sowie das Abrufen von Metadaten über verfügbare Minecraft-Server-Versionen (sowohl Vanilla als auch PaperMC) zuständig ist.
    </p>

    <h3>Klasse: DownloadService</h3>
    <p>
        Diese versiegelte Klasse (<code>sealed</code>) nutzt den <code>HttpClient</code>, um asynchrone Netzwerkoperationen durchzuführen.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code><strong>DownloadFileAsync(string url, string destinationPath, CancellationToken cancellationToken)</strong></code>
            <p>Lädt eine Datei von einer angegebenen URL herunter und speichert sie lokal ab. Erstellt automatisch das Zielverzeichnis, falls dieses noch nicht existiert.</p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>url</code>: Die Quell-URL der Datei.</li>
                        <li><code>destinationPath</code>: Der lokale Pfad, an dem die Datei gespeichert werden soll.</li>
                        <li><code>cancellationToken</code>: Token zum Abbrechen des Vorgangs.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Ein <code>Task</code>, der die asynchrone Operation repräsentiert.</li>
            </ul>
        </li>
        <li>
            <code><strong>GetLatestPaperBuildAsync(string version, CancellationToken cancellationToken)</strong></code>
            <p>Fragt die PaperMC-API ab, um die neueste Build-Nummer für eine spezifische Minecraft-Version zu ermitteln.</p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>version</code>: Die Minecraft-Version (z. B. "1.20.1").</li>
                        <li><code>cancellationToken</code>: Token zum Abbrechen des Vorgangs.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Ein <code>PaperBuildInfo</code>-Objekt mit Versions- und Build-Informationen.</li>
                <li><strong>Ausnahmen:</strong> Wirft eine <code>InvalidOperationException</code>, wenn keine Builds gefunden werden.</li>
            </ul>
        </li>
        <li>
            <code><strong>GetVanillaServerUrlAsync(string version, CancellationToken cancellationToken)</strong></code>
            <p>Ermittelt die offizielle Download-URL für einen Minecraft Vanilla-Server direkt von den Mojang-Metadaten-Servern.</p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>version</code>: Die gewünschte Minecraft-Version.</li>
                        <li><code>cancellationToken</code>: Token zum Abbrechen des Vorgangs.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Die URL zum Download der <code>server.jar</code> als <code>string</code>.</li>
                <li><strong>Ausnahmen:</strong> Wirft eine <code>InvalidOperationException</code>, wenn die Version im Manifest fehlt oder keine Server-URL bereitgestellt wird.</li>
            </ul>
        </li>
    </ul>

    <h3>Datenstrukturen</h3>
    <ul>
        <li>
            <code><strong>PaperBuildInfo</strong></code> (Record Struct):
            Ein leichtgewichtiger Container für die PaperMC-Informationen, bestehend aus <code>Version</code> (string) und <code>Build</code> (int).
        </li>
    </ul>

    <h3>Interne Hilfsklassen</h3>
    <p>
        Die Klasse enthält mehrere private, versiegelte Klassen (<code>PaperVersionResponse</code>, <code>VersionManifest</code>, <code>VersionEntry</code>, <code>VersionDetails</code>, etc.), die als Datenmodelle für die Deserialisierung der JSON-Antworten von PaperMC und Mojang dienen.
    </p>
</section>
<section id="MineLauncher/Services/LauncherService.cs">
    <h2>MineLauncher/Services/LauncherService.cs</h2>
    <p>
        Der <code>LauncherService</code> ist eine versiegelte (sealed) Klasse innerhalb des <code>CLauncher.Services</code> Namespaces. 
        Seine primäre Aufgabe besteht darin, den Minecraft-Server-Prozess mit den konfigurierten Java-Parametern zu initialisieren und zu starten.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Name:</strong> <code>LauncherService</code></li>
        <li><strong>Typ:</strong> Klasse (sealed)</li>
        <li><strong>Namespace:</strong> <code>CLauncher.Services</code></li>
        <li><strong>Zweck:</strong> Verwaltung und Ausführung des Server-Startvorgangs.</li>
    </ul>

    <h3>Methoden</h3>
    <div class="method-definition">
        <h4><code>LaunchServer(LauncherConfig config, string serverDirectory, string jarPath)</code></h4>
        <p>
            Diese Methode konfiguriert die Startargumente für die Java Virtual Machine (JVM) und startet den Server-Prozess.
        </p>
        
        <h5>Parameter:</h5>
        <ul>
            <li><code>config</code> (<code>LauncherConfig</code>): Ein Konfigurationsobjekt, das die Java-Einstellungen wie Pfad zur Executable sowie minimalen und maximalen Arbeitsspeicher enthält.</li>
            <li><code>serverDirectory</code> (<code>string</code>): Der Pfad zum Arbeitsverzeichnis, in dem der Server ausgeführt werden soll.</li>
            <li><code>jarPath</code> (<code>string</code>): Der vollständige Pfad zur ausführbaren JAR-Datei des Servers.</li>
        </ul>

        <h5>Funktionsweise:</h5>
        <ol>
            <li>Erstellt einen Argument-String basierend auf den Speicherzuweisungen (<code>-Xms</code> und <code>-Xmx</code>) und dem JAR-Pfad.</li>
            <li>Nutzt <code>ProcessStartInfo</code>, um die Umgebung für den Prozess festzulegen (Arbeitsverzeichnis, Dateiname der Java-Laufzeitumgebung).</li>
            <li>Startet den Prozess mit <code>Process.Start()</code>.</li>
            <li>Führt eine Fehlerprüfung durch: Sollte der Prozess nicht gestartet werden können, wird eine <code>InvalidOperationException</code> ausgelöst.</li>
        </ol>

        <h5>Ausnahmen:</h5>
        <ul>
            <li><code>InvalidOperationException</code>: Wird geworfen, wenn der Java-Prozess nicht erfolgreich gestartet werden konnte.</li>
        </ul>
    </div>
</section>
<section id="MineLauncher/Services/ServerService.cs">
    <h2>MineLauncher/Services/ServerService.cs</h2>
    <p>
        Die Klasse <code>ServerService</code> ist eine zentrale Dienstkomponente innerhalb des Launchers, die für die Verwaltung, Konfiguration und Pfadauflösung von Minecraft-Serverinstanzen zuständig ist. Sie stellt sicher, dass die notwendigen Dateien und Einstellungen vorhanden sind, bevor ein Server gestartet wird.
    </p>

    <h3>Klasse: ServerService</h3>
    <p><strong>Beschreibung:</strong> Eine versiegelte (sealed) Klasse, die Hilfsmethoden für die Handhabung von Server-Verzeichnissen, Download-URLs und Konfigurationsdateien bereitstellt.</p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>ResolveServerDirectory(LauncherConfig config, string basePath)</code>
            <p>Berechnet den absoluten Pfad zum Installationsverzeichnis des Servers basierend auf der Konfiguration und dem Basispfad.</p>
            <p><strong>Parameter:</strong> <code>config</code> (Launcher-Konfiguration), <code>basePath</code> (Basis-Verzeichnis des Launchers).</p>
            <p><strong>Rückgabewert:</strong> Ein <code>string</code> mit dem kombinierten Pfad.</p>
        </li>
        <li>
            <code>GetServerJarPath(LauncherConfig config, string serverDirectory)</code>
            <p>Ermittelt den vollständigen Pfad zur ausführbaren JAR-Datei des Servers.</p>
            <p><strong>Parameter:</strong> <code>config</code> (Launcher-Konfiguration), <code>serverDirectory</code> (Zielverzeichnis des Servers).</p>
            <p><strong>Rückgabewert:</strong> Ein <code>string</code> mit dem Pfad zur JAR-Datei.</p>
        </li>
        <li>
            <code>BuildDownloadUrl(ServerConfig serverConfig, PaperBuildInfo? paperBuildInfo, string? vanillaUrl)</code>
            <p>Generiert die Download-URL für die Server-Software basierend auf dem gewählten Typ (Paper, Bukkit, CraftBukkit oder Vanilla).</p>
            <p><strong>Parameter:</strong> <code>serverConfig</code> (Server-Einstellungen), <code>paperBuildInfo</code> (Metadaten für PaperMC), <code>vanillaUrl</code> (Optionale URL für Vanilla-Server).</p>
            <p><strong>Rückgabewert:</strong> Die URL als <code>string</code>.</p>
            <p><strong>Ausnahmen:</strong> Wirft eine <code>InvalidOperationException</code>, wenn erforderliche Informationen fehlen oder der Server-Typ unbekannt ist.</p>
        </li>
        <li>
            <code>EnsureServerProperties(LauncherConfig config, string serverDirectory)</code>
            <p>Stellt sicher, dass die Datei <code>server.properties</code> existiert und aktualisiert spezifische Werte wie <code>online-mode</code> und <code>server-port</code> gemäß der Launcher-Konfiguration, ohne andere bestehende Einstellungen zu löschen.</p>
            <p><strong>Parameter:</strong> <code>config</code> (Launcher-Konfiguration), <code>serverDirectory</code> (Zielverzeichnis des Servers).</p>
        </li>
        <li>
            <code>EnsureEula(ServerConfig config, string serverDirectory)</code>
            <p>Erstellt oder aktualisiert die <code>eula.txt</code> Datei im Serververzeichnis, um die Annahme der Endbenutzer-Lizenzvereinbarung (EULA) zu hinterlegen.</p>
            <p><strong>Parameter:</strong> <code>config</code> (Server-Einstellungen), <code>serverDirectory</code> (Zielverzeichnis des Servers).</p>
        </li>
        <li>
            <code>BuildPaperUrl(PaperBuildInfo buildInfo)</code> (Privat)
            <p>Interne Hilfsmethode zur Konstruktion der spezifischen Download-URL für die PaperMC-API.</p>
            <p><strong>Parameter:</strong> <code>buildInfo</code> (Versions- und Build-Informationen).</p>
            <p><strong>Rückgabewert:</strong> Die formatierte API-URL.</p>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/RPGPlugin.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/RPGPlugin.java</h2>
    <p>Die Klasse <code>RPGPlugin</code> ist die zentrale Hauptklasse des RPG-Systems. Sie erweitert <code>JavaPlugin</code> und fungiert als Kernstück für die Initialisierung, Verwaltung und Koordination aller Subsysteme wie Quests, Skills, Dungeons, Gilden und Datenbankverbindungen.</p>

    <h3>Klassenbeschreibung</h3>
    <p><code>public class RPGPlugin extends JavaPlugin</code></p>
    <p>Diese Klasse verwaltet den Lebenszyklus des Plugins und hält Referenzen auf alle wichtigen Manager-Klassen. Sie registriert Events, Befehle und startet Hintergrund-Tasks für das HUD, die Mana-Regeneration und Debug-Anzeigen.</p>

    <h3>Wichtige Methoden</h3>
    <ul>
        <li>
            <code>onEnable()</code>: Initialisiert alle Manager, Dienste (Datenbank, PlayerData, etc.), registriert Event-Listener und Befehl-Executoren. Zudem werden hier die Skill-Effekte registriert und Hintergrund-Tasks gestartet.
        </li>
        <li>
            <code>onDisable()</code>: Sorgt für ein sicheres Herunterfahren des Plugins, indem alle Daten (Spielerprofile, Quests, Gilden, Dungeons etc.) gespeichert und Datenbankverbindungen geschlossen werden.
        </li>
        <li>
            <code>useSkill(Player player, String skillId)</code>: Führt einen Skill für einen Spieler aus.
            <ul>
                <li><strong>Parameter:</strong> <code>player</code> (Der ausführende Spieler), <code>skillId</code> (ID des Skills).</li>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> - <code>true</code>, wenn der Skill erfolgreich eingesetzt wurde (inkl. Prüfung von Cooldown, Mana und Voraussetzungen).</li>
            </ul>
        </li>
        <li>
            <code>useMobSkill(LivingEntity caster, Player target, String skillId)</code>: Ermöglicht es NPCs oder Monstern, Skills gegen Spieler einzusetzen. Unterstützt Effekte wie Schaden, Projektile, Trankeffekte, Partikel und Sounds.
        </li>
        <li>
            <code>completeQuestIfReady(Player player, Quest quest, QuestProgress progress)</code>: Überprüft, ob alle Schritte einer Quest erfüllt sind, schließt diese ab und verteilt Belohnungen (XP, Skillpunkte, Fraktionsruf).
        </li>
        <li>
            <code>notifySkillError(Player player, String message)</code>: Sendet eine Fehlermeldung bezüglich der Skill-Nutzung an die Actionbar des Spielers.
        </li>
    </ul>

    <h3>Hintergrund-Tasks</h3>
    <ul>
        <li><strong>HUD Task:</strong> Aktualisiert alle 10 Ticks die Actionbar der Spieler mit Informationen zu Leben, Mana und Gold sowie Cooldown-Fortschritten in der XP-Leiste.</li>
        <li><strong>Mana Regen Task:</strong> Regeneriert alle 2 Sekunden (40 Ticks) einen festen Betrag an Mana für alle Online-Spieler.</li>
        <li><strong>Debug Task:</strong> Zeigt Spielern im Debug-Modus zusätzliche Informationen wie die aktuelle Zone und die Anzahl aktiver Quests an.</li>
    </ul>

    <h3>Manager & Dienste (Auszug)</h3>
    <p>Die Klasse bietet Getter-Methoden für eine Vielzahl von Managern, die den Zugriff auf die Spiellogik ermöglichen:</p>
    <ul>
        <li><code>playerDataManager()</code>: Verwaltung von Spielerprofilen und Statistiken.</li>
        <li><code>skillManager()</code> & <code>skillEffects()</code>: Definition und Ausführung von Fähigkeiten.</li>
        <li><code>questManager()</code>: Verwaltung des Quest-Systems.</li>
        <li><code>dungeonManager()</code> & <code>arenaManager()</code>: Instanziierung von Kampfbereichen.</li>
        <li><code>guildManager()</code> & <code>partyManager()</code>: Soziale Systeme für Spielerzusammenschlüsse.</li>
        <li><code>databaseService()</code>: Schnittstelle zur persistenten Datenspeicherung.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorContext.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorContext.java</h2>

    <p>
        Die Klasse <code>BehaviorContext</code> dient als Datencontainer und Zustandsverwalter für das Behavior-Tree-System (Verhaltensbäume) innerhalb des RPG-Plugins. 
        Sie kapselt alle relevanten Informationen, die ein Verhaltensknoten (BehaviorNode) benötigt, um Entscheidungen zu treffen oder Aktionen für eine Entität (Mob) auszuführen.
    </p>

    <h3>Klasse: BehaviorContext</h3>
    <p>
        Diese Klasse stellt den Kontext bereit, in dem die KI-Logik eines Mobs operiert. Sie verknüpft die technische Instanz des Mobs mit seiner Definition und dem aktuellen Ziel.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>BehaviorContext(RPGPlugin plugin, LivingEntity mob, MobDefinition definition)</code>: 
            Initialisiert einen neuen Kontext mit der Plugin-Instanz, der Bukkit-Entität und der zugehörigen Mob-Konfiguration.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>plugin()</code>: 
            Gibt die Instanz des <code>RPGPlugin</code> zurück, um Zugriff auf globale Manager und Dienste zu ermöglichen.
            <br><strong>Rückgabewert:</strong> <code>RPGPlugin</code>
        </li>
        <li>
            <code>mob()</code>: 
            Gibt die <code>LivingEntity</code> (die Bukkit-Repräsentation des Mobs) zurück, die gesteuert wird.
            <br><strong>Rückgabewert:</strong> <code>LivingEntity</code>
        </li>
        <li>
            <code>definition()</code>: 
            Gibt die <code>MobDefinition</code> zurück, welche die Basis-Attribute und Einstellungen des Mobs enthält.
            <br><strong>Rückgabewert:</strong> <code>MobDefinition</code>
        </li>
        <li>
            <code>target()</code>: 
            Gibt den aktuellen Spieler zurück, den der Mob als Ziel (Aggro) verfolgt.
            <br><strong>Rückgabewert:</strong> <code>Player</code> (kann null sein)
        </li>
        <li>
            <code>setTarget(Player target)</code>: 
            Aktualisiert das aktuelle Ziel des Mobs.
            <br><strong>Parameter:</strong> <code>target</code> - Der anvisierte Spieler.
        </li>
        <li>
            <code>cooldowns()</code>: 
            Gibt eine Map zurück, die Abklingzeiten (Cooldowns) für verschiedene Aktionen oder Fähigkeiten speichert. Der Schlüssel ist der Name der Aktion, der Wert ist der Zeitstempel des Ablaufs.
            <br><strong>Rückgabewert:</strong> <code>Map&lt;String, Long&gt;</code>
        </li>
        <li>
            <code>mobId()</code>: 
            Hilfsmethode zum schnellen Abrufen der Unique ID (UUID) der Entität.
            <br><strong>Rückgabewert:</strong> <code>UUID</code>
        </li>
    </ul>

    <h4>Interne Felder</h4>
    <ul>
        <li><code>plugin</code>: Referenz auf das Haupt-Plugin.</li>
        <li><code>mob</code>: Die physische Entität in der Spielwelt.</li>
        <li><code>definition</code>: Statische Daten des Mob-Typs.</li>
        <li><code>target</code>: Das aktuelle Angriffsziel.</li>
        <li><code>cooldowns</code>: Ein lokaler Speicher für zeitbasierte Sperren von Fähigkeiten.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorNode.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorNode.java</h2>
    <p>
        Die Klasse <code>BehaviorNode</code> ist die abstrakte Basisklasse für alle Knoten innerhalb des Behavior Tree (Verhaltensbaum) Systems des RPG-Plugins. 
        Sie definiert die grundlegende Struktur und die notwendigen Methoden, die jeder Knoten implementieren muss, um Logik innerhalb der Künstlichen Intelligenz (KI) von Entitäten auszuführen.
    </p>

    <h3>Klasse: <code>BehaviorNode</code></h3>
    <p><strong>Typ:</strong> <code>public abstract class</code></p>
    <p>
        Diese Klasse dient als Vorlage für spezifische Verhaltensknoten wie Selektoren, Sequenzen oder Blattknoten (Aktionen/Bedingungen).
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>protected BehaviorNode(String id)</code>: Initialisiert den Knoten mit einer eindeutigen Kennung. 
            Der Zugriff ist auf Unterklassen beschränkt (protected).
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public String id()</code>
            <p>Gibt die eindeutige Identifikation dieses Knotens zurück.</p>
            <p><strong>Rückgabewert:</strong> <code>String</code> - Die ID des Knotens.</p>
        </li>
        <li>
            <code>public abstract BehaviorStatus tick(BehaviorContext context)</code>
            <p>
                Dies ist die Kernmethode des Knotens. Sie wird in jedem Durchlauf des Verhaltensbaums aufgerufen, um die Logik des Knotens auszuführen.
            </p>
            <p><strong>Parameter:</strong></p>
            <ul>
                <li><code>BehaviorContext context</code>: Der aktuelle Kontext, der Informationen über die ausführende Entität und die Umgebung enthält.</li>
            </ul>
            <p><strong>Rückgabewert:</strong> <code>BehaviorStatus</code> - Der Status nach der Ausführung (z. B. SUCCESS, FAILURE oder RUNNING).</p>
        </li>
        <li>
            <code>protected String key(UUID entityId)</code>
            <p>
                Hilfsmethode zur Generierung eines eindeutigen Schlüssels, der die Knoten-ID mit der UUID einer Entität kombiniert. 
                Dies ist nützlich für das Speichern von zustandsbehafteten Informationen innerhalb des Kontexts.
            </p>
            <p><strong>Parameter:</strong></p>
            <ul>
                <li><code>UUID entityId</code>: Die eindeutige ID der Entität.</li>
            </ul>
            <p><strong>Rückgabewert:</strong> <code>String</code> - Ein kombinierter Schlüssel im Format <code>id:entityId</code>.</p>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorStatus.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/BehaviorStatus.java</h2>

    <p>
        Die Datei <code>BehaviorStatus.java</code> definiert eine Enumeration (Aufzählungstyp), die den aktuellen Zustand eines Knotens innerhalb eines Behavior Trees (Verhaltensbaums) repräsentiert. Diese Zustände sind entscheidend für die Steuerung des logischen Flusses der Künstlichen Intelligenz (KI) im RPG-Plugin.
    </p>

    <h3>Enum: BehaviorStatus</h3>
    <p>
        Dieses Enum wird von den verschiedenen Implementierungen von <code>BehaviorNode</code> verwendet, um dem übergeordneten Knoten mitzuteilen, wie die Ausführung verlaufen ist.
    </p>

    <h4>Mögliche Werte:</h4>
    <ul>
        <li>
            <code>SUCCESS</code>: 
            Gibt an, dass der Knoten seine Aufgabe erfolgreich abgeschlossen hat. In einem <code>SequenceNode</code> führt dies dazu, dass der nächste Kindknoten ausgeführt wird.
        </li>
        <li>
            <code>FAILURE</code>: 
            Gibt an, dass der Knoten seine Aufgabe nicht erfüllen konnte oder die Bedingung nicht zutraf. In einem <code>SelectorNode</code> führt dies dazu, dass die nächste Alternative geprüft wird.
        </li>
        <li>
            <code>RUNNING</code>: 
            Gibt an, dass die Aufgabe des Knotens noch nicht abgeschlossen ist und in der nächsten Tick-Verarbeitung fortgesetzt werden muss (z. B. bei einer Bewegung zu einem Ziel).
        </li>
    </ul>

    <h3>Kontext innerhalb der Architektur</h3>
    <p>
        Als Teil des <code>com.example.rpg.behavior</code> Pakets bildet dieser Typ das Rückgrat für die Entscheidungslogik von Mobs und NPCs. Er ermöglicht es komplexen Strukturen wie Selektoren und Sequenzen, basierend auf dem Ergebnis einzelner Aktionen (wie <code>MeleeAttackNode</code> oder <code>HealSelfNode</code>) zu entscheiden, welcher Pfad als Nächstes eingeschlagen werden soll.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CastSkillNode.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CastSkillNode.java</h2>

    <p>
        Die Klasse <code>CastSkillNode</code> ist ein spezialisierter Verhaltensknoten (Behavior Node) innerhalb des Behavior-Tree-Systems des RPG-Plugins. 
        Ihre primäre Aufgabe ist es, eine spezifische Fähigkeit (Skill) auszuführen, die gegen das aktuelle Ziel des Mobs gerichtet ist.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.behavior</code></li>
        <li><strong>Basisklasse:</strong> <code>BehaviorNode</code></li>
        <li><strong>Abhängigkeiten:</strong> <code>org.bukkit.entity.Player</code></li>
    </ul>

    <h3>Konstruktor</h3>
    <p>
        Initialisiert eine neue Instanz des Knotens mit einer eindeutigen ID und der ID des auszuführenden Skills.
    </p>
    <code>public CastSkillNode(String id, String skillId)</code>
    <ul>
        <li><code>id</code>: Die eindeutige Identifikation dieses Knotens im Verhaltensbaum.</li>
        <li><code>skillId</code>: Die technische ID des Skills, der gewirkt werden soll.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>tick(BehaviorContext context)</code></h4>
    <p>
        Führt die Logik des Knotens während eines Ticks des Verhaltensbaums aus.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>context</code>: Der <code>BehaviorContext</code>, der Informationen über den ausführenden Mob, das aktuelle Ziel und die Plugin-Instanz enthält.</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> <code>BehaviorStatus</code>
            <ul>
                <li><code>SUCCESS</code>: Wenn ein Ziel vorhanden ist und der Skill erfolgreich durch das Plugin (<code>useMobSkill</code>) ausgelöst wurde.</li>
                <li><code>FAILURE</code>: Wenn kein Ziel vorhanden ist oder die Ausführung des Skills fehlgeschlagen ist (z. B. aufgrund von Cooldowns oder fehlenden Voraussetzungen).</li>
            </ul>
        </li>
        <li><strong>Logik:</strong>
            Die Methode prüft zunächst, ob ein valides Ziel im Kontext existiert. Ist dies der Fall, wird die Methode <code>useMobSkill</code> des Plugins aufgerufen, um die Interaktion zwischen dem Mob und dem Ziel unter Verwendung der <code>skillId</code> zu verarbeiten.
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CompositeNode.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CompositeNode.java</h2>

    <p>
        Die Klasse <code>CompositeNode</code> ist eine abstrakte Basisklasse innerhalb des Behavior-Tree-Systems des RPG-Plugins. 
        Sie dient als strukturelles Element, das mehrere Kind-Knoten (<code>BehaviorNode</code>) verwalten kann. 
        In einem Behavior Tree bilden Composite-Knoten die Logik-Zweige, die entscheiden, wie und in welcher Reihenfolge ihre Kinder ausgeführt werden (z. B. Sequenzen oder Selektoren).
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.behavior</code></li>
        <li><strong>Typ:</strong> Abstrakte Klasse</li>
        <li><strong>Basisklasse:</strong> <code>BehaviorNode</code></li>
    </ul>

    <h3>Komponenten</h3>
    
    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>protected CompositeNode(String id)</code>: 
            Initialisiert einen neuen Composite-Knoten mit einer eindeutigen Identifikation. Da die Klasse abstrakt ist, wird dieser Konstruktor von spezialisierten Unterklassen wie <code>SequenceNode</code> oder <code>SelectorNode</code> aufgerufen.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public List&lt;BehaviorNode&gt; children()</code>
            <p>
                Gibt die Liste der untergeordneten Knoten zurück, die diesem Composite-Knoten zugewiesen sind.
            </p>
            <ul>
                <li><strong>Rückgabewert:</strong> Eine <code>List</code> von <code>BehaviorNode</code>-Objekten.</li>
            </ul>
        </li>
    </ul>

    <h4>Interne Felder</h4>
    <ul>
        <li>
            <code>private final List&lt;BehaviorNode&gt; children</code>: 
            Eine interne Liste (ArrayList), die alle Kind-Knoten speichert, die Teil dieses Logik-Zweiges sind.
        </li>
    </ul>

    <h3>Kontext im System</h3>
    <p>
        Diese Klasse bildet das Fundament für komplexe Verhaltensmuster. Während einfache Knoten (Leaf Nodes) Aktionen ausführen oder Bedingungen prüfen, steuern die von <code>CompositeNode</code> abgeleiteten Klassen den Kontrollfluss des künstlichen Verhaltens von NPCs oder Mobs.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CooldownNode.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/CooldownNode.java</h2>

    <p>
        Die Klasse <code>CooldownNode</code> ist ein spezialisierter Knoten innerhalb des Behavior-Tree-Systems (Verhaltensbaum) des RPG-Plugins. 
        Sie fungiert als Decorator-Knoten, der die Ausführung eines untergeordneten Knotens basierend auf einer zeitlichen Abklingzeit (Cooldown) steuert.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        <strong>Name:</strong> <code>CooldownNode</code><br>
        <strong>Basisklasse:</strong> <code>BehaviorNode</code><br>
        <strong>Zweck:</strong> Verhindert die zu häufige Ausführung einer Aktion, indem nach einem Erfolg eine Sperrzeit erzwungen wird.
    </p>

    <h3>Konstruktor</h3>
    <p>
        Der Konstruktor initialisiert den Knoten mit einer eindeutigen ID, dem zu überwachenden Kind-Knoten und der gewünschten Cooldown-Dauer.
    </p>
    <ul>
        <li><code>id</code> (String): Die eindeutige Kennung des Knotens.</li>
        <li><code>child</code> (BehaviorNode): Der untergeordnete Knoten, dessen Ausführung durch den Cooldown limitiert werden soll.</li>
        <li><code>cooldownMillis</code> (long): Die Zeitspanne in Millisekunden, die zwischen zwei erfolgreichen Ausführungen liegen muss.</li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>tick(BehaviorContext context)</code>
            <p>
                Diese Methode steuert die Logik des Knotens während eines Updates des Verhaltensbaums:
            </p>
            <ul>
                <li>Zuerst wird geprüft, ob für die aktuelle Mob-ID im <code>BehaviorContext</code> bereits ein Zeitstempel für diesen Knoten existiert.</li>
                <li>Wenn die Differenz zwischen der aktuellen Systemzeit und dem letzten Zeitstempel kleiner als <code>cooldownMillis</code> ist, bricht der Knoten sofort ab und gibt <code>BehaviorStatus.FAILURE</code> zurück.</li>
                <li>Falls kein Cooldown aktiv ist, wird die <code>tick</code>-Methode des Kind-Knotens aufgerufen.</li>
                <li>Gibt der Kind-Knoten <code>BehaviorStatus.SUCCESS</code> zurück, wird der aktuelle Zeitstempel im Kontext gespeichert, um den Cooldown für den nächsten Durchlauf zu starten.</li>
                <li>Der Status des Kind-Knotens wird als Rückgabewert an den Aufrufer weitergegeben.</li>
            </ul>
            <p><strong>Rückgabewert:</strong> <code>BehaviorStatus</code> (SUCCESS, FAILURE oder RUNNING).</p>
        </li>
    </ul>

    <h3>Funktionsweise im Kontext</h3>
    <p>
        Diese Komponente ist essenziell für die KI-Steuerung von Mobs, um beispielsweise zu verhindern, dass Spezialfähigkeiten (Skills) oder Heilzauber in jedem Frame bzw. Tick ohne Pause gewirkt werden. Sie stellt sicher, dass die Spielbalance durch zeitliche Begrenzungen gewahrt bleibt.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/FleeNode.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/FleeNode.java</h2>

    <p>
        Die Klasse <code>FleeNode</code> ist ein spezialisierter Verhaltensknoten (Behavior Node) innerhalb des Behavior-Tree-Systems des RPG-Plugins. 
        Ihre primäre Aufgabe ist es, eine Fluchtlogik für einen Mob zu implementieren, wenn dieser ein Ziel (in der Regel einen Spieler) hat.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.behavior</code></li>
        <li><strong>Basisklasse:</strong> <code>BehaviorNode</code></li>
        <li><strong>Abhängigkeiten:</strong> <code>org.bukkit.Location</code>, <code>org.bukkit.entity.Player</code>, <code>org.bukkit.util.Vector</code></li>
    </ul>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>public FleeNode(String id)</code>: 
            Initialisiert eine neue Instanz des Fluchtknotens mit einer eindeutigen Identifikationsnummer.
        </li>
    </ul>

    <h3>Methoden</h3>
    <div class="method-documentation">
        <h4><code>public BehaviorStatus tick(BehaviorContext context)</code></h4>
        <p>
            Führt die Logik des Knotens in einem einzelnen Tick des Behavior-Trees aus. Der Mob berechnet einen Vektor, der direkt vom Ziel wegführt, und setzt seine Geschwindigkeit entsprechend.
        </p>
        
        <strong>Parameter:</strong>
        <ul>
            <li><code>context</code> (BehaviorContext): Der aktuelle Kontext, der Informationen über den ausführenden Mob und das aktuelle Ziel enthält.</li>
        </ul>

        <strong>Rückgabewerte:</strong>
        <ul>
            <li><code>BehaviorStatus.FAILURE</code>: Wenn kein Ziel vorhanden ist oder die Positionen von Mob und Ziel identisch sind (Vektorlänge Null).</li>
            <li><code>BehaviorStatus.RUNNING</code>: Wenn die Fluchtbewegung erfolgreich eingeleitet wurde.</li>
        </ul>

        <strong>Funktionsweise:</strong>
        <ol>
            <li>Prüft, ob ein valides Ziel im <code>BehaviorContext</code> existiert.</li>
            <li>Berechnet den Richtungsvektor durch Subtraktion der Zielposition von der Mob-Position (<code>mobLoc - targetLoc</code>).</li>
            <li>Normalisiert den Vektor, um eine gleichmäßige Bewegungsrichtung zu erhalten.</li>
            <li>Multipliziert den Vektor mit einem Faktor von <code>0.35</code>, um die Fluchtgeschwindigkeit festzulegen.</li>
            <li>Wendet den resultierenden Vektor als Velocity (Geschwindigkeit) auf den Mob an.</li>
        </ol>
    </div>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealSelfNode.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealSelfNode.java</h2>

    <p>
        Die Klasse <code>HealSelfNode</code> ist ein spezialisierter Verhaltensknoten (Behavior Node) innerhalb des Behavior-Tree-Systems des RPG-Plugins. 
        Ihre primäre Aufgabe ist es, die Lebenspunkte des ausführenden Mobs um einen definierten Wert zu erhöhen.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.behavior</code></li>
        <li><strong>Basisklasse:</strong> <code>BehaviorNode</code></li>
    </ul>

    <h3>Konstruktor</h3>
    <p>
        <code>public HealSelfNode(String id, double amount)</code>
    </p>
    <ul>
        <li><strong>id:</strong> Eine eindeutige Kennung für diesen Knoten innerhalb des Verhaltensbaums.</li>
        <li><strong>amount:</strong> Der Betrag an Heilung (Lebenspunkte), der bei jeder Ausführung angewendet werden soll.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4>tick(BehaviorContext context)</h4>
    <p>
        Diese Methode führt die eigentliche Heilungslogik aus, wenn der Knoten vom Verhaltensbaum aufgerufen wird.
    </p>
    <ul>
        <li><strong>Parameter:</strong> 
            <code>BehaviorContext context</code> - Der aktuelle Kontext der Verhaltenssteuerung, der Zugriff auf den Mob und dessen Definition bietet.
        </li>
        <li><strong>Rückgabewert:</strong> 
            <code>BehaviorStatus.SUCCESS</code> - Der Knoten gibt immer Erfolg zurück, sobald die Heilung angewendet wurde.
        </li>
        <li><strong>Logik:</strong>
            <ul>
                <li>Ermittelt das maximale Leben des Mobs aus der <code>MobDefinition</code> (mindestens 1).</li>
                <li>Berechnet die neue Gesundheit, indem der Heilungsbetrag addiert wird, wobei das Maximum nicht überschritten werden kann (<code>Math.min</code>).</li>
                <li>Aktualisiert die aktuellen Lebenspunkte des Mobs direkt über <code>context.mob().setHealth()</code>.</li>
            </ul>
        </li>
    </ul>

    <h3>Technische Details</h3>
    <p>
        Da der Knoten immer <code>SUCCESS</code> zurückgibt, eignet er sich besonders für Sequenzen, in denen eine Heilung als garantierte Aktion zwischen anderen Verhaltensweisen (wie z.B. einem Rückzug oder einem Angriff) stattfinden soll.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealthBelowNode.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/HealthBelowNode.java</h2>

    <p>
        Die Klasse <code>HealthBelowNode</code> ist ein spezialisierter Verhaltensknoten (Behavior Node) innerhalb des Behavior-Tree-Systems des RPG-Plugins. 
        Sie dient als Bedingungsknoten (Condition Node), der prüft, ob die aktuelle Gesundheit eines Mobs einen definierten Schwellenwert unterschritten hat.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.behavior</code></li>
        <li><strong>Basisklasse:</strong> <code>BehaviorNode</code></li>
    </ul>

    <h3>Konstruktor</h3>
    <p>
        <code>public HealthBelowNode(String id, double threshold)</code>
    </p>
    <ul>
        <li><strong>id:</strong> Eine eindeutige Kennung für diesen Knoten.</li>
        <li><strong>threshold:</strong> Der Schwellenwert für die Gesundheit als Dezimalzahl (z. B. <code>0.3</code> für 30%).</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4>tick(BehaviorContext context)</h4>
    <p>
        Diese Methode führt die Logik des Knotens aus und evaluiert den aktuellen Gesundheitszustand des Mobs im Verhältnis zu seiner maximalen Gesundheit.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>context</code>: Der <code>BehaviorContext</code>, der Informationen über den Mob und dessen Definition enthält.</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> 
            <code>BehaviorStatus</code>
            <ul>
                <li><code>SUCCESS</code>: Wenn das aktuelle Gesundheitsverhältnis kleiner als der definierte Schwellenwert (<code>threshold</code>) ist.</li>
                <li><code>FAILURE</code>: Wenn die Gesundheit über oder gleich dem Schwellenwert liegt.</li>
            </ul>
        </li>
        <li><strong>Logik:</strong> 
            Die maximale Gesundheit wird aus der Mob-Definition bezogen (mindestens 1, um Division durch Null zu vermeiden). 
            Die aktuelle Gesundheit wird direkt vom Mob-Objekt abgefragt. Das Ergebnis wird durch den Vergleich <code>(current / maxHealth) &lt; threshold</code> ermittelt.
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/InverterNode.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/InverterNode.java</h2>

    <p>
        Die Klasse <code>InverterNode</code> ist ein spezialisierter Knoten innerhalb des Behavior Tree Systems des RPG-Plugins. 
        Sie fungiert als Dekorator-Knoten, der das Ergebnis seines Kind-Knotens umkehrt (invertiert).
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>InverterNode</code> erweitert die abstrakte Basisklasse <code>BehaviorNode</code>. Ihr Hauptzweck ist die Implementierung einer logischen NOT-Operation für das Verhalten von Entitäten.
    </p>

    <h3>Konstruktor</h3>
    <ul>
        <li>
            <code>InverterNode(String id, BehaviorNode child)</code>: 
            Initialisiert den Knoten mit einer eindeutigen ID und dem zu invertierenden Kind-Knoten.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public BehaviorStatus tick(BehaviorContext context)</code>
            <p>
                Führt die Logik des Knotens aus, indem die <code>tick</code>-Methode des Kind-Knotens aufgerufen wird. Das Ergebnis wird basierend auf folgenden Regeln transformiert:
            </p>
            <ul>
                <li><strong>SUCCESS:</strong> Wird zu <code>FAILURE</code> umgewandelt.</li>
                <li><strong>FAILURE:</strong> Wird zu <code>SUCCESS</code> umgewandelt.</li>
                <li><strong>RUNNING:</strong> Bleibt <code>RUNNING</code>, da der Prozess noch nicht abgeschlossen ist.</li>
            </ul>
            <p>
                <strong>Parameter:</strong> <code>context</code> - Der aktuelle Kontext des Verhaltens (enthält Informationen über die Entität und die Umgebung).<br>
                <strong>Rückgabewert:</strong> Der invertierte <code>BehaviorStatus</code>.
            </p>
        </li>
    </ul>

    <h3>Logik-Zusammenfassung</h3>
    <p>
        Dieser Knoten ist besonders nützlich für Bedingungsprüfungen. Wenn beispielsweise ein Knoten prüft, ob ein Ziel in Reichweite ist (SUCCESS), kann der <code>InverterNode</code> genutzt werden, um eine Aktion auszuführen, wenn das Ziel <em>nicht</em> in Reichweite ist (FAILURE wird zu SUCCESS).
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/MeleeAttackNode.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/MeleeAttackNode.java</h2>
    <p>
        Die Klasse <code>MeleeAttackNode</code> ist ein spezialisierter Verhaltensknoten (Behavior Node) innerhalb des Behavior-Tree-Systems des RPG-Plugins. 
        Ihre primäre Aufgabe ist die Ausführung eines Nahkampfangriffs durch einen Mob auf ein Ziel (Spieler).
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.behavior</code></li>
        <li><strong>Basisklasse:</strong> <code>BehaviorNode</code></li>
        <li><strong>Abhängigkeiten:</strong> <code>org.bukkit.entity.Player</code></li>
    </ul>

    <h3>Konstruktoren</h3>
    <div class="constructor">
        <h4><code>MeleeAttackNode(String id)</code></h4>
        <p>Initialisiert eine neue Instanz des Nahkampfknotens mit einer eindeutigen Identifikationsnummer.</p>
        <ul>
            <li><strong>Parameter:</strong>
                <ul>
                    <li><code>id</code>: Ein eindeutiger String zur Identifizierung des Knotens im Verhaltensbaum.</li>
                </ul>
            </li>
        </ul>
    </div>

    <h3>Methoden</h3>
    <div class="method">
        <h4><code>tick(BehaviorContext context)</code></h4>
        <p>
            Führt die Logik des Knotens aus. Diese Methode prüft, ob ein Ziel vorhanden ist und ob sich dieses in Schlagdistanz befindet.
        </p>
        <ul>
            <li><strong>Logik-Ablauf:</strong>
                <ol>
                    <li>Abrufen des aktuellen Ziels aus dem <code>BehaviorContext</code>.</li>
                    <li>Falls kein Ziel vorhanden ist (<code>null</code>), wird <code>FAILURE</code> zurückgegeben.</li>
                    <li>Berechnung der quadrierten Distanz zwischen dem Mob und dem Ziel. Ist die Distanz größer als 9 (entspricht einer Reichweite von 3 Blöcken), schlägt die Aktion fehl (<code>FAILURE</code>).</li>
                    <li>Befindet sich das Ziel in Reichweite, wird dem Ziel Schaden in Höhe des in der Mob-Definition hinterlegten Schadenswertes zugefügt.</li>
                    <li>Bei erfolgreichem Angriff wird <code>SUCCESS</code> zurückgegeben.</li>
                </ol>
            </li>
            <li><strong>Parameter:</strong>
                <ul>
                    <li><code>context</code>: Der aktuelle Kontext der Verhaltenssteuerung, der Informationen über den Mob, das Ziel und die Definitionen enthält.</li>
                </ul>
            </li>
            <li><strong>Rückgabewert:</strong> 
                <code>BehaviorStatus</code> – <code>SUCCESS</code> bei erfolgreichem Angriff, ansonsten <code>FAILURE</code>.
            </li>
        </ul>
    </div>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SelectorNode.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SelectorNode.java</h2>

    <p>
        Die Klasse <code>SelectorNode</code> ist ein fundamentaler Bestandteil des Behavior-Tree-Systems (Verhaltensbaum) innerhalb des RPG-Plugins. 
        Sie fungiert als logisches "ODER"-Gatter für die Entscheidungsfindung von NPCs oder Mobs.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>SelectorNode</code> erbt von <code>CompositeNode</code>. Ein Selector (auch "Fallback" genannt) führt seine Kindknoten nacheinander aus, 
        bis einer von ihnen entweder erfolgreich ist (<code>SUCCESS</code>) oder sich noch in der Ausführung befindet (<code>RUNNING</code>).
    </p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code><strong>SelectorNode(String id)</strong></code>: 
            Initialisiert einen neuen Selector-Knoten mit einer eindeutigen Identifikationsnummer.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code><strong>BehaviorStatus tick(BehaviorContext context)</strong></code>
            <p>
                Diese Methode steuert die Logik der Knotenausführung während eines Spiel-Ticks.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>BehaviorContext context</code> – Der aktuelle Kontext, der Informationen über die Umgebung und den ausführenden Akteur enthält.</li>
                <li><strong>Funktionsweise:</strong> 
                    Iteriert durch alle untergeordneten Knoten (<code>children()</code>). 
                    Sobald ein Kindknoten <code>SUCCESS</code> oder <code>RUNNING</code> zurückgibt, bricht der Selector ab und gibt diesen Status sofort an den Elternknoten zurück. 
                    Nur wenn <strong>alle</strong> Kindknoten fehlschlagen (<code>FAILURE</code>), gibt der Selector selbst <code>FAILURE</code> zurück.
                </li>
                <li><strong>Rückgabewert:</strong> 
                    <code>BehaviorStatus.SUCCESS</code> oder <code>BehaviorStatus.RUNNING</code>, falls ein Kindknoten diesen Status meldet; 
                    ansonsten <code>BehaviorStatus.FAILURE</code>.
                </li>
            </ul>
        </li>
    </ul>

    <h3>Zusammenfassung der Logik</h3>
    <p>
        In einem Verhaltensbaum wird der <code>SelectorNode</code> oft verwendet, um Prioritäten zu setzen. 
        Beispiel: Ein Mob versucht zuerst zu "Heilen" (Kind 1), wenn das nicht nötig/möglich ist zu "Angreifen" (Kind 2), und wenn das nicht möglich ist zu "Patrouillieren" (Kind 3).
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SequenceNode.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/SequenceNode.java</h2>

    <p>
        Die Klasse <code>SequenceNode</code> ist ein fundamentaler Bestandteil des Behavior-Tree-Systems (Verhaltensbaum) innerhalb des RPG-Plugins. 
        Sie fungiert als logisches "UND"-Gatter für das Verhalten von Entitäten.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>SequenceNode</code> erbt von <code>CompositeNode</code>. Ein Sequence-Knoten führt seine Kind-Knoten nacheinander aus. 
        Er bricht sofort ab, wenn ein Kind-Knoten fehlschlägt oder noch in Bearbeitung ist. Nur wenn alle Kind-Knoten erfolgreich abgeschlossen wurden, 
        gibt die Sequenz selbst den Status "Erfolg" zurück.
    </p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code><strong>SequenceNode(String id)</strong></code>: 
            Initialisiert eine neue Instanz des Sequence-Knotens mit einer eindeutigen Identifikationsnummer (ID).
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code><strong>public BehaviorStatus tick(BehaviorContext context)</strong></code>
            <p>
                Diese Methode steuert die Logik der Sequenz während eines Spiel-Ticks.
            </p>
            <strong>Logik:</strong>
            <ul>
                <li>Iteriert über alle untergeordneten Knoten (<code>children()</code>).</li>
                <li>Wenn ein Kind <code>BehaviorStatus.FAILURE</code> zurückgibt, stoppt die Sequenz und gibt ebenfalls <code>FAILURE</code> zurück.</li>
                <li>Wenn ein Kind <code>BehaviorStatus.RUNNING</code> zurückgibt, wird die Ausführung unterbrochen und <code>RUNNING</code> zurückgegeben, damit der Zustand im nächsten Tick fortgesetzt werden kann.</li>
                <li>Wenn alle Kinder <code>BehaviorStatus.SUCCESS</code> zurückgeben, schließt die Sequenz mit <code>BehaviorStatus.SUCCESS</code> ab.</li>
            </ul>
            <strong>Parameter:</strong>
            <ul>
                <li><code>context</code>: Der <code>BehaviorContext</code>, der Informationen über die ausführende Entität und die Umgebung enthält.</li>
            </ul>
            <strong>Rückgabewert:</strong>
            <ul>
                <li><code>BehaviorStatus</code>: Der resultierende Status der Sequenz (SUCCESS, FAILURE oder RUNNING).</li>
            </ul>
        </li>
    </ul>

    <h3>Zusammenfassung der Verhaltenslogik</h3>
    <table border="1" style="border-collapse: collapse; width: 100%; text-align: left;">
        <thead>
            <tr style="background-color: #f2f2f2;">
                <th style="padding: 8px;">Status des Kind-Knotens</th>
                <th style="padding: 8px;">Reaktion der Sequenz</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="padding: 8px;"><code>FAILURE</code></td>
                <td style="padding: 8px;">Bricht sofort ab und gibt <strong>FAILURE</strong> zurück.</td>
            </tr>
            <tr>
                <td style="padding: 8px;"><code>RUNNING</code></td>
                <td style="padding: 8px;">Pausiert die Sequenz und gibt <strong>RUNNING</strong> zurück.</td>
            </tr>
            <tr>
                <td style="padding: 8px;"><code>SUCCESS</code></td>
                <td style="padding: 8px;">Fährt mit dem nächsten Kind-Knoten in der Liste fort.</td>
            </tr>
        </tbody>
    </table>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/TargetDistanceAboveNode.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/TargetDistanceAboveNode.java</h2>

    <p>
        Die Klasse <code>TargetDistanceAboveNode</code> ist ein spezialisierter Verhaltensknoten (Behavior Node) innerhalb des Behavior-Tree-Systems des RPG-Plugins. 
        Sie dient als Bedingungsknoten, der prüft, ob die Entfernung zwischen einem Mob und seinem aktuellen Ziel einen definierten Schwellenwert überschreitet.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.behavior</code></li>
        <li><strong>Basisklasse:</strong> <code>BehaviorNode</code></li>
    </ul>

    <h3>Konstruktor</h3>
    <p>
        <code>public TargetDistanceAboveNode(String id, double distance)</code>
    </p>
    <ul>
        <li><code>id</code>: Eine eindeutige Identifikation für diesen Knoten.</li>
        <li><code>distance</code>: Der Distanz-Schwellenwert (in Blöcken), gegen den geprüft wird.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4>tick(BehaviorContext context)</h4>
    <p>
        Führt die Logik des Knotens aus, um den aktuellen Status zu ermitteln.
    </p>
    <ul>
        <li><strong>Parameter:</strong> 
            <ul>
                <li><code>context</code>: Der <code>BehaviorContext</code>, der Informationen über den ausführenden Mob und das aktuelle Ziel (Player) enthält.</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> <code>BehaviorStatus</code>
            <ul>
                <li><code>SUCCESS</code>: Wenn ein Ziel existiert und die Entfernung zum Ziel größer als der konfigurierte <code>distance</code>-Wert ist.</li>
                <li><code>FAILURE</code>: Wenn kein Ziel vorhanden ist oder die Entfernung kleiner oder gleich dem Schwellenwert ist.</li>
            </ul>
        </li>
        <li><strong>Logik:</strong> 
            Die Methode berechnet die euklidische Distanz zwischen dem Standort des Mobs und dem Standort des Spielers (Target). 
            Dabei wird die Bukkit-Methode <code>distance()</code> verwendet.
        </li>
    </ul>

    <h3>Verwendung im Behavior Tree</h3>
    <p>
        Dieser Knoten wird typischerweise verwendet, um Entscheidungen basierend auf der Reichweite zu treffen. 
        Beispielsweise kann er in einer Sequenz vor einem <code>WalkToTargetNode</code> geschaltet werden, um sicherzustellen, dass der Mob sich nur bewegt, wenn er noch zu weit vom Spieler entfernt ist.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/WalkToTargetNode.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/behavior/WalkToTargetNode.java</h2>

    <p>
        Die Klasse <code>WalkToTargetNode</code> ist ein spezialisierter Verhaltensknoten (Behavior Node) innerhalb des Behavior-Tree-Systems des RPG-Plugins. 
        Ihr Hauptzweck besteht darin, eine Entität (Mob) dazu zu veranlassen, sich aktiv auf ein definiertes Ziel (einen Spieler) zuzubewegen.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.behavior</code></li>
        <li><strong>Basisklasse:</strong> <code>BehaviorNode</code></li>
        <li><strong>Abhängigkeiten:</strong> <code>org.bukkit.entity.Mob</code>, <code>org.bukkit.entity.Player</code></li>
    </ul>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>WalkToTargetNode(String id)</code>: Initialisiert den Knoten mit einer eindeutigen Identifikationsnummer (ID).
        </li>
    </ul>

    <h3>Methoden</h3>
    <div class="method-documentation">
        <h4><code>tick(BehaviorContext context)</code></h4>
        <p>
            Diese Methode wird bei jedem Update-Zyklus des Behavior Trees aufgerufen, um die Logik der Bewegung auszuführen.
        </p>
        
        <h5>Parameter:</h5>
        <ul>
            <li><code>context</code>: Ein <code>BehaviorContext</code>-Objekt, das Informationen über den aktuellen Zustand, den ausführenden Mob und das aktuelle Ziel enthält.</li>
        </ul>

        <h5>Rückgabewerte (BehaviorStatus):</h5>
        <ul>
            <li><code>BehaviorStatus.RUNNING</code>: Wird zurückgegeben, wenn der Mob erfolgreich angewiesen wurde, sich zum Ziel zu bewegen.</li>
            <li><code>BehaviorStatus.FAILURE</code>: Wird zurückgegeben, wenn kein Ziel vorhanden ist oder wenn die ausführende Entität kein valider <code>Mob</code> ist (und somit keine Pfadfindung unterstützt).</li>
        </ul>

        <h5>Logik:</h5>
        <ol>
            <li>Prüft, ob im Kontext ein Ziel (Player) gesetzt ist.</li>
            <li>Validiert, ob die Entität im Kontext eine Instanz von <code>Mob</code> ist.</li>
            <li>Setzt das Ziel des Mobs mittels <code>setTarget(target)</code>.</li>
            <li>Nutzt den Pathfinder der Bukkit-API (<code>mob.getPathfinder().moveTo(target)</code>), um die Wegfindung zum Spieler zu starten.</li>
        </ol>
    </div>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/AuctionCommand.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/AuctionCommand.java</h2>
    <p>
        Die Klasse <code>AuctionCommand</code> implementiert das Auktionshaussystem für das RPG-Plugin. 
        Sie ermöglicht es Spielern, Gegenstände zum Verkauf anzubieten, verfügbare Auktionen einzusehen und Gegenstände von anderen Spielern zu erwerben.
    </p>

    <h3>Klasse: AuctionCommand</h3>
    <p>
        Diese Klasse implementiert das <code>CommandExecutor</code> Interface von Bukkit und verarbeitet alle Interaktionen mit dem Befehl <code>/auction</code>.
    </p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>
                Der Haupteinstiegspunkt für den Befehl. Überprüft, ob der Sender ein Spieler ist, und leitet die Anfrage basierend auf den Argumenten (<code>list</code>, <code>sell</code>, <code>buy</code>) an die entsprechenden privaten Methoden weiter.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>sender</code>, <code>command</code>, <code>label</code>, <code>args</code></li>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> (true, wenn der Befehl erfolgreich verarbeitet wurde)</li>
            </ul>
        </li>

        <li>
            <code>listAuctions(Player player)</code>
            <p>
                Listet alle aktuell im <code>AuctionHouseManager</code> registrierten Auktionen für den Spieler auf. Zeigt die Auktions-ID und den Preis in Gold an.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>player</code> - Der Spieler, der die Liste anfordert.</li>
            </ul>
        </li>

        <li>
            <code>sellAuction(Player player, String[] args)</code>
            <p>
                Erstellt eine neue Auktion. Der Spieler muss einen Preis angeben und den zu verkaufenden Gegenstand in der Haupthand halten.
            </p>
            <ul>
                <li><strong>Logik:</strong> Validiert den Preis, serialisiert das Item über den <code>AuctionHouseManager</code>, generiert eine eindeutige 8-stellige ID und entfernt das Item aus dem Inventar des Spielers.</li>
                <li><strong>Parameter:</strong> <code>player</code>, <code>args</code> (enthält den Preis)</li>
            </ul>
        </li>

        <li>
            <code>buyAuction(Player player, String[] args)</code>
            <p>
                Verarbeitet den Kauf eines Gegenstands aus dem Auktionshaus.
            </p>
            <ul>
                <li><strong>Logik:</strong> Prüft die Existenz der Auktion und das Gold-Guthaben des Käufers. Bei Erfolg wird das Gold abgezogen, das Item deserialisiert und dem Käufer übergeben. Falls der Verkäufer online ist, erhält dieser den Erlös direkt auf sein Profil gutgeschrieben.</li>
                <li><strong>Parameter:</strong> <code>player</code>, <code>args</code> (enthält die Auktions-ID)</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten:</h3>
    <ul>
        <li><code>RPGPlugin</code>: Zugriff auf Manager-Klassen (AuctionHouse, PlayerData).</li>
        <li><code>AuctionListing</code>: Datenmodell für eine einzelne Auktion.</li>
        <li><code>Text</code>: Utility-Klasse für die Formatierung von Chat-Nachrichten (MiniMessage).</li>
        <li><code>AuctionHouseManager</code>: Zentrale Verwaltung der Auktionsdaten und Item-Serialisierung.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/DungeonCommand.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/DungeonCommand.java</h2>
    <p>
        Die Klasse <code>DungeonCommand</code> implementiert das <code>CommandExecutor</code>-Interface von Bukkit und ist für die Verarbeitung von Spielerbefehlen im Zusammenhang mit dem Dungeon-System verantwortlich. Sie ermöglicht es Spielern, Dungeons zu betreten, zu verlassen oder neue Instanzen basierend auf einem Thema zu generieren.
    </p>

    <h3>Klasse: DungeonCommand</h3>
    <p><strong>Zweck:</strong> Zentrale Steuerung der Dungeon-Interaktionen über Chat-Befehle.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>DungeonCommand(RPGPlugin plugin)</code>: Initialisiert den Command-Executor mit einer Instanz des Haupt-Plugins, um Zugriff auf die verschiedenen Manager (Dungeon, Party etc.) zu erhalten.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p><strong>Beschreibung:</strong> Verarbeitet den eingehenden Befehl <code>/dungeon</code>. Prüft, ob der Absender ein Spieler ist und leitet die Anfrage basierend auf dem ersten Argument (Sub-Command) weiter.</p>
            <p><strong>Parameter:</strong></p>
            <ul>
                <li><code>sender</code>: Der Absender des Befehls (muss ein <code>Player</code> sein).</li>
                <li><code>args</code>: Argumente des Befehls (<code>enter</code>, <code>leave</code>, <code>generate</code>).</li>
            </ul>
            <p><strong>Rückgabewert:</strong> <code>boolean</code> - Gibt <code>true</code> zurück, wenn der Befehl verarbeitet wurde.</p>
        </li>

        <li>
            <code>enterDungeon(Player player)</code>
            <p><strong>Beschreibung:</strong> Teleportiert den Spieler zum Eingang des Dungeons, sofern dieser konfiguriert ist. Nutzt den <code>DungeonManager</code> für die Logik.</p>
        </li>

        <li>
            <code>leaveDungeon(Player player)</code>
            <p><strong>Beschreibung:</strong> Entfernt den Spieler aus der aktuellen Dungeon-Instanz über den <code>DungeonManager</code>.</p>
        </li>

        <li>
            <code>generateDungeon(Player player, String[] args)</code>
            <p><strong>Beschreibung:</strong> Initiiert die Generierung eines neuen Dungeons. Wenn der Spieler Teil einer Gruppe (Party) ist, werden alle online befindlichen Gruppenmitglieder in die Generierungsanfrage einbezogen. Andernfalls wird der Dungeon nur für den einzelnen Spieler erstellt.</p>
            <p><strong>Parameter:</strong></p>
            <ul>
                <li><code>player</code>: Der ausführende Spieler.</li>
                <li><code>args</code>: Enthält das gewünschte Thema (Theme) des Dungeons als zweites Argument.</p>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Zugriff auf Manager-Klassen.</li>
        <li><code>DungeonManager</code>: Verwaltung der Dungeon-Logik und Instanzen.</li>
        <li><code>PartyManager</code>: Abfrage von Gruppeninformationen für die Dungeon-Generierung.</li>
        <li><code>Text</code>: Utility-Klasse zur Formatierung von Chat-Nachrichten (MiniMessage).</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/GuildCommand.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/GuildCommand.java</h2>
    <p>
        Die Klasse <code>GuildCommand</code> implementiert den <code>CommandExecutor</code> für das Gilden-System des RPG-Plugins. 
        Sie ermöglicht Spielern die Erstellung und Verwaltung von Gilden, die Interaktion über einen Gilden-Chat, die Verwaltung einer Gildenbank sowie das Bearbeiten von Gilden-Quests.
    </p>

    <h3>Klasse: GuildCommand</h3>
    <p><strong>Hauptverantwortlichkeit:</strong> Verarbeitung aller Befehle, die mit <code>/guild</code> oder dem Kürzel <code>/g</code> (für den Chat) beginnen.</p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Der Einstiegspunkt für die Befehlsverarbeitung. Prüft, ob der Sender ein Spieler ist, und leitet die Argumente an die entsprechenden Unterfunktionen (create, invite, info, etc.) weiter.</p>
        </li>
        <li>
            <code>createGuild(Player player, String[] args)</code>
            <p>Erstellt eine neue Gilde mit einer eindeutigen ID und einem Namen, sofern der Spieler noch nicht Mitglied einer Gilde ist.</p>
        </li>
        <li>
            <code>invitePlayer(Player player, String[] args)</code>
            <p>Sendet eine Einladung an einen anderen Online-Spieler. Erfordert den Rang eines Offiziers oder Leiters innerhalb der Gilde.</p>
        </li>
        <li>
            <code>acceptInvite(Player player)</code>
            <p>Erlaubt einem Spieler, einer Gilde beizutreten, von der er eine aktive Einladung erhalten hat.</p>
        </li>
        <li>
            <code>leaveGuild(Player player)</code>
            <p>Entfernt den Spieler aus seiner aktuellen Gilde.</p>
        </li>
        <li>
            <code>disbandGuild(Player player)</code>
            <p>Löscht die Gilde vollständig. Diese Aktion kann nur vom Gildenleiter ausgeführt werden.</p>
        </li>
        <li>
            <code>guildInfo(Player player)</code>
            <p>Zeigt Informationen über die Gilde an, einschließlich Name, Mitgliederliste und aktuellem Goldbestand der Gildenbank.</p>
        </li>
        <li>
            <code>guildChat(Player player, String[] args)</code>
            <p>Sendet eine Nachricht an alle online befindlichen Mitglieder der eigenen Gilde.</p>
        </li>
        <li>
            <code>bankCommand(Player player, String[] args)</code>
            <p>Verwaltet Unterbefehle für die Gildenbank (<code>balance</code>, <code>deposit</code>, <code>withdraw</code>).</p>
            <ul>
                <li><code>depositGuild</code>: Zahlt Gold vom Spielerkonto in die Gildenbank ein.</li>
                <li><code>withdrawGuild</code>: Hebt Gold von der Gildenbank ab (nur für Offiziere/Leiter).</li>
            </ul>
        </li>
        <li>
            <code>questCommand(Player player, String[] args)</code>
            <p>Verwaltet das Gilden-Quest-System (<code>list</code>, <code>create</code>, <code>progress</code>, <code>complete</code>).</p>
            <ul>
                <li><code>listQuests</code>: Listet alle verfügbaren Quests und deren Fortschritt auf.</li>
                <li><code>createQuest</code>: Erstellt eine neue Quest mit Zielvorgabe (nur für Offiziere/Leiter).</li>
                <li><code>progressQuest</code>: Erhöht den Fortschritt einer Quest manuell.</li>
            </ul>
        </li>
    </ul>

    <h4>Hilfsfunktionen</h4>
    <ul>
        <li><code>isOfficerOrLeader(Guild guild, UUID member)</code>: Überprüft, ob ein Mitglied über administrative Rechte (Offizier oder Leiter) in der Gilde verfügt.</li>
        <li><code>parseAmount(Player player, String input)</code>: Validiert numerische Eingaben für Goldbeträge oder Quest-Ziele.</li>
        <li><code>join(String[] args, int start)</code>: Hilfsmethode zum Zusammenfügen von Befehlsargumenten zu einem einzelnen String (z. B. für Gilden- oder Questnamen).</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/PartyCommand.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/PartyCommand.java</h2>
    <p>
        Die Klasse <code>PartyCommand</code> implementiert den <code>CommandExecutor</code> für das Party-System des RPG-Plugins. 
        Sie ermöglicht es Spielern, Gruppen zu erstellen, andere Spieler einzuladen, beizutreten, die Gruppe zu verlassen und innerhalb der Gruppe zu chatten.
    </p>

    <h3>Klasse: PartyCommand</h3>
    <p><strong>Beschreibung:</strong> Hauptklasse für die Verarbeitung des <code>/party</code> Befehls.</p>
    
    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Verarbeitet die eingehenden Befehle. Überprüft, ob der Absender ein Spieler ist, und leitet die Argumente an die entsprechenden Unterfunktionen (create, invite, join, leave, chat) weiter.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>sender</code>, <code>command</code>, <code>label</code>, <code>args</code></li>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> (true, wenn der Befehl verarbeitet wurde)</li>
            </ul>
        </li>
        <li>
            <code>createParty(Player player)</code>
            <p>Erstellt eine neue Party für den Spieler, sofern dieser nicht bereits Mitglied einer anderen Party ist. Nutzt den <code>PartyManager</code> zur Erstellung.</p>
        </li>
        <li>
            <code>invitePlayer(Player player, String[] args)</code>
            <p>Sendet eine Einladung an einen anderen Online-Spieler. Erfordert, dass der Einladende bereits in einer Party ist.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>player</code> (Absender), <code>args</code> (enthält den Ziel-Spielernamen)</li>
            </ul>
        </li>
        <li>
            <code>joinParty(Player player, String[] args)</code>
            <p>Ermöglicht es einem Spieler, der Party eines Gruppenleiters beizutreten. Prüft, ob der Ziel-Leader online ist und ob der beitretende Spieler nicht bereits in einer Gruppe ist.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>player</code> (Beitretender), <code>args</code> (enthält den Namen des Leaders)</li>
            </ul>
        </li>
        <li>
            <code>leaveParty(Player player)</code>
            <p>Entfernt den Spieler aus seiner aktuellen Party über den <code>PartyManager</code>.</p>
        </li>
        <li>
            <code>partyChat(Player player, String[] args)</code>
            <p>Sendet eine Nachricht an alle Mitglieder der aktuellen Party des Spielers. Die Nachricht wird mit dem Präfix <code>[Party]</code> in Aqua-Farbe formatiert.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>player</code> (Absender), <code>args</code> (enthält die Nachrichtenteile)</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Zugriff auf den <code>PartyManager</code>.</li>
        <li><code>PartyManager</code>: Logik zur Verwaltung der Party-Instanzen und Mitglieder.</li>
        <li><code>Text</code>: Hilfsklasse zur Formatierung von Chat-Nachrichten (MiniMessage).</li>
        <li><code>Bukkit API</code>: Interaktion mit dem Minecraft-Server (Spieler-Suche, Befehls-Interface).</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/PvpCommand.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/PvpCommand.java</h2>
    <p>
        Die Klasse <code>PvpCommand</code> implementiert den <code>CommandExecutor</code> für den Minecraft-Befehl <code>/pvp</code>. 
        Sie dient als Schnittstelle für Spieler, um am PvP-System (Player versus Player) teilzunehmen und Statistiken einzusehen.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Name:</strong> <code>PvpCommand</code></li>
        <li><strong>Paket:</strong> <code>com.example.rpg.command</code></li>
        <li><strong>Schnittstellen:</strong> <code>CommandExecutor</code></li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>onCommand(CommandSender sender, Command command, String label, String[] args)</code></h4>
    <p>
        Verarbeitet die eingehenden Befehle für <code>/pvp</code>. Überprüft zunächst, ob der Absender ein Spieler ist und wertet anschließend die Argumente aus.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>sender</code>: Der Absender des Befehls (muss ein <code>Player</code> sein).</li>
                <li><code>command</code>: Das ausgeführte Kommando-Objekt.</li>
                <li><code>label</code>: Der verwendete Alias des Befehls.</li>
                <li><code>args</code>: Die Argumente des Befehls (z. B. <code>join</code> oder <code>top</code>).</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> <code>boolean</code> - Gibt <code>true</code> zurück, wenn der Befehl erfolgreich verarbeitet wurde.</li>
        <li><strong>Unterstützte Sub-Commands:</strong>
            <ul>
                <li><code>join</code>: Reiht den Spieler über den <code>ArenaManager</code> in die Warteschlange für PvP-Kämpfe ein.</li>
                <li><code>top</code>: Ruft die Methode <code>showTop</code> auf, um die Bestenliste anzuzeigen.</li>
            </ul>
        </li>
    </ul>

    <h4><code>showTop(Player player)</code></h4>
    <p>
        Diese private Hilfsmethode ruft die Top-10-Spieler basierend auf ihrem Elo-Wert ab und gibt diese formatiert im Chat des Spielers aus.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>player</code>: Der Spieler, dem die Rangliste angezeigt werden soll.</li>
            </ul>
        </li>
        <li><strong>Funktionsweise:</strong>
            <ul>
                <li>Bezieht die Profile über <code>plugin.arenaManager().topPlayers(10)</code>.</li>
                <li>Versucht, den Spielernamen über die UUID aufzulösen; falls nicht verfügbar, wird ein Teil der UUID angezeigt.</li>
                <li>Gibt Platzierung, Name und Elo-Punkte in Gold/Grau/Weiß formatiert aus.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Hauptklasse des Plugins für den Zugriff auf Manager-Instanzen.</li>
        <li><code>ArenaManager</code>: Verarbeitet die Warteschlange und die Bestenlisten-Logik.</li>
        <li><code>PlayerProfile</code>: Datenmodell für die Spielerstatistiken (insbesondere Elo).</li>
        <li><code>Text</code>: Utility-Klasse zur Formatierung von Chat-Nachrichten (MiniMessage).</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGAdminCommand.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGAdminCommand.java</h2>
    <p>
        Die Klasse <code>RPGAdminCommand</code> ist der zentrale Command-Executor für administrative Aufgaben innerhalb des RPG-Plugins. 
        Sie ermöglicht es Administratoren, Spielweltelemente wie Zonen, NPCs, Quests, Loot-Tabellen, Skills und Spawner direkt im Spiel zu erstellen und zu konfigurieren.
    </p>

    <h3>Hauptklasse: RPGAdminCommand</h3>
    <p><strong>Implementiert:</strong> <code>CommandExecutor</code></p>
    <p>
        Diese Klasse verarbeitet den Befehl <code>/rpgadmin</code>. Sie prüft die Berechtigungen des Absenders (<code>rpg.admin</code>) 
        und delegiert die verschiedenen Unterbefehle an spezialisierte private Methoden.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Einstiegspunkt für den Befehl. Validiert den Spielerstatus und die Berechtigungen. Ohne Argumente wird das Admin-GUI-Menü geöffnet.</p>
        </li>
        <li>
            <code>giveWand(Player player)</code>
            <p>Gibt dem Spieler einen "Editor Wand" (Zauberstab), der zur Markierung von Positionen (Pos1/Pos2) für Zonen verwendet wird.</p>
        </li>
        <li>
            <code>handleZone(Player player, String[] args)</code>
            <p>Verwaltet Zonen-Operationen wie <code>create</code>, <code>setlevel</code> (Levelbereich festlegen) und <code>setmod</code> (Multiplikatoren für Schaden/Geschwindigkeit).</p>
        </li>
        <li>
            <code>handleNpc(Player player, String[] args)</code>
            <p>Ermöglicht die Erstellung von NPCs, das Setzen von Dialogen sowie die Verknüpfung von NPCs mit Quests oder Shops.</p>
        </li>
        <li>
            <code>handleQuest(Player player, String[] args)</code>
            <p>Dient der Erstellung von Quests und dem Hinzufügen von Quest-Schritten (z.B. "Töte X Monster").</p>
        </li>
        <li>
            <code>handleLoot(Player player, String[] args)</code>
            <p>Verwaltet Loot-Tabellen und fügt neue Einträge mit Wahrscheinlichkeiten, Mengen und Seltenheitsgraden hinzu.</p>
        </li>
        <li>
            <code>handleSkill(Player player, String[] args)</code>
            <p>Erlaubt das Erstellen von Skills, das Ändern von Attributen (Mana, Cooldown) und das Hinzufügen von Effekten.</p>
        </li>
        <li>
            <code>handleMob(Player player, String[] args)</code>
            <p>Spawnt eine definierte Custom-Mob-Instanz an der Position des Spielers.</p>
        </li>
        <li>
            <code>handleSpawner(Player player, String[] args)</code>
            <p>Konfiguriert Mob-Spawner in bestimmten Zonen, inklusive Spawn-Limits und Wahrscheinlichkeiten für verschiedene Mob-Typen.</p>
        </li>
    </ul>

    <h3>Hilfsfunktionen</h3>
    <p>Die Klasse enthält diverse private Hilfsmethoden für ein sicheres Parsing von Benutzereingaben:</p>
    <ul>
        <li><code>readPosition</code>: Liest die mit dem Editor-Stab gespeicherten Koordinaten aus den persistenten Daten des Spielers.</li>
        <li><code>parseInt</code> / <code>parseDouble</code>: Wandelt Strings sicher in Zahlen um, ohne Exceptions auszulösen.</li>
        <li><code>parseEnum</code>: Versucht einen String einem Enum-Wert (z.B. <code>Rarity</code> oder <code>NpcRole</code>) zuzuordnen.</li>
        <li><code>parseParamValue</code>: Erkennt automatisch, ob ein Parameter-Wert als Zahl (Integer/Double) oder String interpretiert werden soll.</li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Zugriff auf Manager-Klassen (ZoneManager, NpcManager, etc.) und Konfigurationen.</li>
        <li><code>ItemBuilder</code>: Erstellung des Editor-Werkzeugs.</li>
        <li><code>Text</code>: Verarbeitung von MiniMessage-formatierten Nachrichten.</li>
        <li><code>Bukkit API</code>: Interaktion mit der Spielwelt, Entities und dem Persistent Data Container.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGCommand.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/RPGCommand.java</h2>
    <p>
        Die Klasse <code>RPGCommand</code> implementiert das Interface <code>CommandExecutor</code> von Bukkit und dient als zentraler Einstiegspunkt für alle spielerbezogenen RPG-Befehle. Sie verarbeitet den Hauptbefehl <code>/rpg</code> und delegiert die Logik an verschiedene Sub-Befehle weiter.
    </p>

    <h3>Klasse: RPGCommand</h3>
    <p><strong>Beschreibung:</strong> Haupt-Command-Handler für das RPG-System.</p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Verarbeitet eingehende Befehle. Überprüft, ob der Sender ein Spieler ist, und leitet die Anfrage basierend auf dem ersten Argument an die entsprechende interne Methode weiter. Ohne Argumente wird das Hauptmenü des Spielers geöffnet.</p>
        </li>
        <li>
            <code>handleSkill(Player player, String[] args)</code>
            <p>Ermöglicht es einem Spieler, einen spezifischen Skill über seine ID auszuführen (<code>/rpg skill &lt;id&gt;</code>).</p>
        </li>
        <li>
            <code>handleQuest(Player player, String[] args)</code>
            <p>Verwaltet Quest-Interaktionen. Unterstützt die Unterbefehle <code>list</code> (öffnet das Quest-GUI), <code>abandon</code> (bricht eine Quest ab) und <code>complete</code> (schließt eine Quest ab, falls die Bedingungen erfüllt sind).</p>
        </li>
        <li>
            <code>handleRespec(Player player)</code>
            <p>Setzt die Charakterentwicklung des Spielers zurück. Alle gelernten Skills werden entfernt, Skillpunkte basierend auf dem Level neu berechnet und die Attribute auf den Basiswert (5) zurückgesetzt.</p>
        </li>
        <li>
            <code>handleClass(Player player, String[] args)</code>
            <p>Verwaltet die Klassenwahl. Erlaubt das Auflisten verfügbarer Klassen (<code>list</code>) und das Auswählen einer Klasse (<code>choose</code>), wodurch auch die Start-Skills der Klasse vergeben werden.</p>
        </li>
        <li>
            <code>handleBind(Player player, String[] args)</code>
            <p>Bindet einen gelernten Skill an einen bestimmten Slot (1-9) in der Skill-Hotbar des Spielers.</p>
        </li>
        <li>
            <code>handleMoney(Player player)</code>
            <p>Zeigt dem Spieler seinen aktuellen Goldbestand an.</p>
        </li>
        <li>
            <code>handlePay(Player player, String[] args)</code>
            <p>Ermöglicht den Transfer von Gold zwischen Spielern. Überprüft die Online-Verfügbarkeit des Empfängers und ob der Sender über ausreichend Guthaben verfügt.</p>
        </li>
        <li>
            <code>handleProfession(Player player, String[] args)</code>
            <p>Verwaltet Berufe. Bietet eine Übersicht über die aktuellen Berufslevel (<code>list</code>) oder erlaubt das manuelle Setzen von Leveln (<code>set</code>).</p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Hauptinstanz des Plugins für den Zugriff auf Manager und Services.</li>
        <li><code>PlayerProfile</code>: Datenmodell für die RPG-Fortschritte des Spielers.</li>
        <li><code>Text</code>: Utility-Klasse zur Formatierung von Nachrichten (MiniMessage).</li>
        <li><code>GuiManager</code> &amp; <code>SkillTreeGui</code>: Zur Anzeige grafischer Benutzeroberflächen.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/TradeCommand.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/command/TradeCommand.java</h2>
    <p>
        Die Klasse <code>TradeCommand</code> implementiert den <code>CommandExecutor</code> für das Handelssystem des RPG-Plugins. 
        Sie ermöglicht es Spielern, Handelsanfragen zu senden, Goldangebote zu unterbreiten und Transaktionen sicher abzuschließen.
    </p>

    <h3>Klasse: TradeCommand</h3>
    <p><strong>Beschreibung:</strong> Hauptklasse für die Verarbeitung des <code>/trade</code> Befehls.</p>
    
    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Verarbeitet die eingehenden Befehle. Überprüft, ob der Sender ein Spieler ist, und leitet die Argumente an die entsprechenden Sub-Methoden weiter.</p>
            <p><strong>Rückgabewert:</strong> <code>boolean</code> - True, wenn der Befehl ausgeführt wurde.</p>
        </li>
        <li>
            <code>requestTrade(Player player, String[] args)</code>
            <p>Initiiert eine Handelsanfrage an einen anderen Spieler. Erfordert den Namen des Zielspielers als Argument.</p>
        </li>
        <li>
            <code>acceptTrade(Player player)</code>
            <p>Akzeptiert eine bestehende Handelsanfrage, die an den ausführenden Spieler gerichtet wurde.</p>
        </li>
        <li>
            <code>offerGold(Player player, String[] args)</code>
            <p>Setzt den Goldbetrag fest, den der Spieler im aktuellen Handel anbieten möchte.</p>
        </li>
        <li>
            <code>requestGold(Player player, String[] args)</code>
            <p>Setzt den Goldbetrag fest, den der Spieler vom Handelspartner fordert.</p>
        </li>
        <li>
            <code>readyTrade(Player player)</code>
            <p>Markiert den Spieler als "bereit". Wenn beide Handelspartner bereit sind, wird die Transaktion automatisch abgeschlossen.</p>
        </li>
        <li>
            <code>completeTrade(TradeRequest request)</code>
            <p>Führt die eigentliche Transaktion durch. Überprüft die Goldbestände beider Spieler, verrechnet die Beträge in den Spielerprofilen und schließt den Handel ab.</p>
        </li>
        <li>
            <code>cancelTrade(Player player)</code>
            <p>Bricht den aktuellen Handel oder die aktuelle Anfrage ab und bereinigt die Daten im <code>TradeManager</code>.</p>
        </li>
    </ul>

    <h3>Integrierte Logik &amp; Sicherheit</h3>
    <ul>
        <li><strong>Validierung:</strong> Es wird geprüft, ob Spieler online sind und ob sie über genügend Gold verfügen, bevor die Transaktion finalisiert wird.</li>
        <li><strong>Feedback:</strong> Die Spieler erhalten über das <code>Text</code>-Utility formatierte Nachrichten (MiniMessage) über den Status des Handels.</li>
        <li><strong>Zustandsverwaltung:</strong> Die Klasse kommuniziert eng mit dem <code>TradeManager</code> und dem <code>PlayerDataManager</code>, um den Status der <code>TradeRequest</code>-Objekte zu verwalten.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/db/DatabaseService.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/db/DatabaseService.java</h2>
    <p>
        Die Klasse <code>DatabaseService</code> ist die zentrale Komponente für die Datenbankverwaltung des RPG-Plugins. 
        Sie nutzt das <strong>HikariCP</strong> Connection-Pooling-Framework, um effiziente Verbindungen zu einer PostgreSQL-Datenbank herzustellen. 
        Zudem stellt sie einen asynchronen Executor-Service bereit, um Datenbankoperationen außerhalb des Haupt-Server-Threads (Main-Thread) auszuführen.
    </p>

    <h3>Klasse: DatabaseService</h3>
    <p>Verwaltet den Lebenszyklus der Datenbankverbindung, die Initialisierung der Tabellen und die Bereitstellung von Datenbankressourcen.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>DatabaseService(JavaPlugin plugin)</code>: Initialisiert den Service. Liest die Konfigurationsdaten (Host, Port, Name, Benutzer, Passwort, Pool-Größe) aus der <code>config.yml</code> des Plugins aus. 
            Falls der PostgreSQL-Treiber nicht gefunden wird, wird eine Fehlermeldung protokolliert.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>getConnection()</code>: 
            <br><strong>Rückgabewert:</strong> <code>Connection</code>
            <br>Liefert eine aktive Verbindung aus dem Hikari-Verbindungspool. Wirft eine <code>SQLException</code>, falls keine Verbindung möglich ist.
        </li>
        <li>
            <code>executor()</code>: 
            <br><strong>Rückgabewert:</strong> <code>ExecutorService</code>
            <br>Gibt den internen Thread-Pool zurück, der für asynchrone Datenbankzugriffe verwendet werden sollte, um Lags auf dem Minecraft-Server zu vermeiden.
        </li>
        <li>
            <code>initTables()</code>: 
            <br>Erstellt die notwendigen Tabellen in der Datenbank, falls diese noch nicht existieren. 
            Dazu gehören:
            <ul>
                <li><code>rpg_players</code>: Speichert Spielerdaten wie Level, XP, Gold, Klasse, Gilde, Elo sowie komplexe Datenstrukturen (Berufe, Stats, Skills, Quests) im JSONB-Format.</li>
                <li><code>rpg_skills</code>: Speichert spezifische Skill-Daten der Spieler.</li>
                <li><code>rpg_quests</code>: Speichert Quest-Fortschritte der Spieler.</li>
            </ul>
        </li>
        <li>
            <code>shutdown()</code>: 
            <br>Beendet den Executor-Service und schließt den Hikari-Datenbank-Pool ordnungsgemäß.
        </li>
        <li>
            <code>createDataSource(HikariConfig hikariConfig)</code> (privat): 
            <br>Versucht die Datenquelle zu initialisieren. Falls die Datenbank nicht existiert, wird versucht, diese automatisch zu erstellen.
        </li>
        <li>
            <code>createDatabase()</code> (privat): 
            <br>Verbindet sich mit der Standard-Datenbank <code>postgres</code>, um die im Plugin konfigurierte Zieldatenbank zu erstellen, falls diese noch nicht vorhanden ist.
        </li>
    </ul>

    <h4>Wichtige Felder</h4>
    <ul>
        <li><code>dataSource</code>: Die Instanz von <code>HikariDataSource</code> für das Connection-Pooling.</li>
        <li><code>executor</code>: Ein <code>FixedThreadPool</code> zur Parallelisierung von Datenbankanfragen.</li>
        <li><code>jdbcUrl</code>: Die generierte Verbindungs-URL für den PostgreSQL-Server.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/db/PlayerDao.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/db/PlayerDao.java</h2>

    <p>
        Das Interface <code>PlayerDao</code> (Data Access Object) definiert die abstrakte Schicht für den Zugriff auf Spielerdaten innerhalb des RPG-Systems. 
        Es entkoppelt die Geschäftslogik von der konkreten Datenbankimplementierung (z. B. SQL oder NoSQL) und ermöglicht asynchrone Datenbankoperationen.
    </p>

    <h3>Interface: PlayerDao</h3>
    <p><strong>Zweck:</strong> Bereitstellung von Methoden zum Speichern und Laden von Spielerprofilen.</p>

    <ul>
        <li>
            <strong>Methode: <code>savePlayer(PlayerProfile profile)</code></strong>
            <ul>
                <li><strong>Beschreibung:</strong> Speichert den aktuellen Zustand eines Spielerprofils in der Datenbank.</li>
                <li><strong>Parameter:</strong> 
                    <code>profile</code> (PlayerProfile) - Das zu persistierende Profilobjekt, welches Statistiken, Fortschritte und Attribute enthält.
                </li>
                <li><strong>Rückgabewert:</strong> 
                    <code>CompletableFuture&lt;Void&gt;</code> - Ein Future, das abgeschlossen wird, sobald der Speichervorgang erfolgreich beendet wurde. Ermöglicht nicht-blockierende E/A-Operationen.
                </li>
            </ul>
        </li>
        <li>
            <strong>Methode: <code>loadPlayer(UUID uuid)</code></strong>
            <ul>
                <li><strong>Beschreibung:</strong> Lädt ein Spielerprofil basierend auf der eindeutigen Identifikationsnummer (UUID) des Spielers.</li>
                <li><strong>Parameter:</strong> 
                    <code>uuid</code> (UUID) - Die eindeutige Kennung des Minecraft-Spielers.
                </li>
                <li><strong>Rückgabewert:</strong> 
                    <code>CompletableFuture&lt;PlayerProfile&gt;</code> - Ein Future, das nach Abschluss das geladene <code>PlayerProfile</code>-Objekt liefert oder <code>null</code>, falls kein Eintrag existiert.
                </li>
            </ul>
        </li>
    </ul>

    <h3>Zusammenhang im Projekt</h3>
    <p>
        Dieses Interface wird typischerweise von Klassen wie <code>SqlPlayerDao</code> implementiert, um die tatsächliche Kommunikation mit einer SQL-Datenbank über den <code>DatabaseService</code> abzuwickeln. Die Verwendung von <code>CompletableFuture</code> stellt sicher, dass der Haupt-Server-Thread von Minecraft nicht durch langsame Datenbankanfragen blockiert wird.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/db/SqlPlayerDao.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/db/SqlPlayerDao.java</h2>
    <p>
        Die Klasse <code>SqlPlayerDao</code> ist eine konkrete Implementierung des <code>PlayerDao</code>-Interfaces. 
        Sie ist für die Persistenz von Spielerprofilen in einer SQL-Datenbank (optimiert für PostgreSQL mit JSONB-Unterstützung) verantwortlich. 
        Dabei werden komplexe Java-Objekte wie Statistiken, Quests und Fähigkeiten mithilfe der GSON-Bibliothek in JSON-Formate serialisiert und deserialisiert.
    </p>

    <h3>Klasse: SqlPlayerDao</h3>
    <p><strong>Zweck:</strong> Verwaltung des Datenzugriffs für <code>PlayerProfile</code>-Objekte über SQL-Abfragen.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>SqlPlayerDao(DatabaseService databaseService)</code>: Initialisiert das DAO mit dem bereitgestellten Datenbankdienst für die Verbindungsverwaltung.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>savePlayer(PlayerProfile profile)</code>
            <p>Speichert ein Spielerprofil asynchron in der Datenbank. Verwendet ein <code>INSERT ... ON CONFLICT DO UPDATE</code> Statement, um bestehende Datensätze zu aktualisieren oder neue anzulegen.</p>
            <p><strong>Parameter:</strong> <code>PlayerProfile profile</code> - Das zu speichernde Profil.</p>
            <p><strong>Rückgabewert:</strong> <code>CompletableFuture&lt;Void&gt;</code></p>
        </li>
        <li>
            <code>loadPlayer(UUID uuid)</code>
            <p>Lädt ein Spielerprofil asynchron anhand der UUID aus der Datenbank. Konvertiert die gespeicherten JSON-Daten zurück in die entsprechenden Java-Kollektionen und Objekte.</p>
            <p><strong>Parameter:</strong> <code>UUID uuid</code> - Die eindeutige ID des Spielers.</p>
            <p><strong>Rückgabewert:</strong> <code>CompletableFuture&lt;PlayerProfile&gt;</code> - Ein Future, das das geladene Profil oder <code>null</code> enthält, falls kein Spieler gefunden wurde.</p>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li><code>statsToMap(Map&lt;RPGStat, Integer&gt; stats)</code>: Konvertiert die Enum-basierten Statistiken in eine String-basierte Map für die JSON-Serialisierung.</li>
        <li><code>questsToMap(Map&lt;String, QuestProgress&gt; quests)</code>: Bereitet Quest-Fortschrittsdaten für die Speicherung als JSON vor.</li>
        <li><code>loadQuests(String json, PlayerProfile profile)</code>: Rekonstruiert <code>QuestProgress</code>-Objekte aus einem JSON-String und fügt sie dem Profil hinzu.</li>
        <li><code>applyMap(String json, Map&lt;String, T&gt; target, Type type)</code>: Hilfsmethode zum Deserialisieren und Befüllen von Maps.</li>
        <li><code>fromJson(String json, Type type)</code>: Generische Hilfsmethode zur Konvertierung von JSON-Strings in Java-Objekte mittels GSON.</li>
    </ul>

    <h4>Wichtige Felder</h4>
    <ul>
        <li><code>databaseService</code>: Der Dienst zur Bereitstellung von Datenbankverbindungen und dem Executor für asynchrone Aufgaben.</li>
        <li><code>gson</code>: Instanz der Google Gson Bibliothek zur JSON-Verarbeitung.</li>
        <li><code>TypeToken</code> Definitionen: Verschiedene Typ-Definitionen (z.B. <code>mapStringInt</code>, <code>listString</code>), um die Typsicherheit bei der Deserialisierung generischer Kollektionen zu gewährleisten.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonGenerator.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonGenerator.java</h2>
    <p>
        Die Klasse <code>DungeonGenerator</code> ist für die prozedurale Erstellung von Dungeon-Instanzen innerhalb der Minecraft-Welt verantwortlich. 
        Sie unterstützt sowohl einen einfachen rasterbasierten Algorithmus als auch eine fortgeschrittene Generierung mittels <strong>Wave Function Collapse (WFC)</strong>.
    </p>

    <h3>Klasse: DungeonGenerator</h3>
    <p>Verwaltet die Logik zur Erstellung von Räumen, Korridoren, Spawnern und Boss-Gegnern.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>DungeonGenerator(RPGPlugin plugin)</code>: Initialisiert den Generator mit der Plugin-Instanz und dem WFC-Generator.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>generate(String theme, List&lt;Player&gt; party)</code>
            <p>Erstellt einen klassischen Dungeon basierend auf einem 4x4 Gitter. Räume werden ausgehoben (carved) und durch Korridore verbunden.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>theme</code> (Thema des Dungeons), <code>party</code> (Liste der Spieler, die teleportiert werden).</li>
                <li><strong>Rückgabewert:</strong> Eine neue <code>DungeonInstance</code>.</li>
            </ul>
        </li>
        <li>
            <code>generateWfc(String theme, List&lt;Player&gt; party, Consumer&lt;DungeonInstance&gt; callback)</code>
            <p>Nutzt den <code>WfcGenerator</code>, um einen komplexeren Dungeon asynchron zu generieren. Nach Abschluss der Berechnung wird der Dungeon in der Welt platziert.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>theme</code>, <code>party</code>, <code>callback</code> (wird nach Fertigstellung aufgerufen).</li>
            </ul>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>buildFromPatterns(World world, Pattern[][][] patterns, int originY)</code>
            <p>Iteriert durch das generierte WFC-Muster-Array und platziert die entsprechenden Blöcke in der Welt. Berechnet zudem den Startpunkt und den am weitesten entfernten Punkt für den Boss-Raum.</p>
        </li>
        <li>
            <code>placePattern(World world, Pattern pattern, int baseX, int baseY, int baseZ)</code>
            <p>Platziert ein spezifisches 2x2x2 Block-Muster (Pattern) an den angegebenen Koordinaten.</p>
        </li>
        <li>
            <code>carveRoom(World world, int startX, int startY, int startZ, int size, Material material)</code>
            <p>Erzeugt einen physischen Raum in der Welt, indem Blöcke gesetzt und Luftbereiche für den Innenraum geschaffen werden.</p>
        </li>
        <li>
            <code>carveCorridor(World world, int startX, int startY, int startZ, Material material)</code>
            <p>Erstellt Verbindungsgänge zwischen den Räumen.</p>
        </li>
        <li>
            <code>spawnSpawners(List&lt;Location&gt; roomCenters)</code>
            <p>Platziert Mobs in den Zentren der generierten Räume. Verwendet definierte Spawner oder einen Zombie als Fallback.</p>
        </li>
        <li>
            <code>spawnBoss(Location bossRoom)</code>
            <p>Beschwört den Boss-Gegner (standardmäßig "boss_zombie") am Ende des Dungeons und fügt ein <code>TextDisplay</code> als Namensschild hinzu.</p>
        </li>
        <li>
            <code>spawnSigns(Location start, Location bossRoom, String theme)</code>
            <p>Erstellt schwebende Texte (TextDisplays) am Start und am Boss-Raum zur Orientierung der Spieler.</p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>WfcGenerator</code>: Logik für den Wave Function Collapse Algorithmus.</li>
        <li><code>DungeonInstance</code>: Datenobjekt, das die generierte Welt und wichtige Orte speichert.</li>
        <li><code>MobManager</code> &amp; <code>SpawnerManager</code>: Zugriff auf benutzerdefinierte RPG-Entitäten.</li>
        <li><code>Bukkit API</code>: Welt-Manipulation, Entity-Spawning und Task-Scheduling.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonInstance.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/DungeonInstance.java</h2>

    <p>Die Klasse <code>DungeonInstance</code> dient als Datenmodell für eine spezifische Instanz eines Dungeons innerhalb der Spielwelt. Sie kapselt die notwendigen Informationen über die Welt, in der der Dungeon generiert wurde, sowie wichtige Navigationspunkte.</p>

    <h3>Klasse: DungeonInstance</h3>
    <p>Diese Klasse repräsentiert einen fertig generierten Dungeon und stellt Zugriffsmethoden auf dessen räumliche Eckpunkte bereit.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>DungeonInstance(World world, Location start, Location bossRoom)</code>
            <p>Initialisiert eine neue Instanz eines Dungeons.</p>
            <ul>
                <li><strong>world:</strong> Die Bukkit-Welt, in der sich der Dungeon befindet.</li>
                <li><strong>start:</strong> Der Startpunkt (Spawn-Punkt) für Spieler innerhalb des Dungeons.</li>
                <li><strong>bossRoom:</strong> Die Position des Boss-Raums oder des Endziels des Dungeons.</li>
            </ul>
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>world()</code>
            <p>Gibt die Bukkit-Welt zurück, die mit dieser Dungeon-Instanz verknüpft ist.</p>
            <p><strong>Rückgabewert:</strong> <code>World</code> - Die Instanz der Welt.</p>
        </li>
        <li>
            <code>start()</code>
            <p>Gibt den Startpunkt des Dungeons zurück.</p>
            <p><strong>Rückgabewert:</strong> <code>Location</code> - Die Koordinaten des Eingangs/Startbereichs.</p>
        </li>
        <li>
            <code>bossRoom()</code>
            <p>Gibt die Position des Boss-Raums zurück.</p>
            <p><strong>Rückgabewert:</strong> <code>Location</code> - Die Koordinaten des Boss-Raums.</p>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Direction.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Direction.java</h2>
    <p>
        Diese Datei definiert die Enumeration <code>Direction</code>, die im Kontext des Wave Function Collapse (WFC) Algorithmus zur Dungeon-Generierung verwendet wird. Sie dient dazu, räumliche Beziehungen zwischen verschiedenen Mustern (Patterns) oder Blöcken innerhalb des Grids darzustellen.
    </p>

    <h3>Enum: Direction</h3>
    <p>
        Repräsentiert die sechs möglichen Richtungen im dreidimensionalen Raum, die für die Nachbarschaftsprüfung und die Platzierung von Elementen relevant sind.
    </p>

    <h4>Aufzählungswerte:</h4>
    <ul>
        <li><code>UP</code>: Oben</li>
        <li><code>DOWN</code>: Unten</li>
        <li><code>NORTH</code>: Norden</li>
        <li><code>SOUTH</code>: Süden</li>
        <li><code>EAST</code>: Osten</li>
        <li><code>WEST</code>: Westen</li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong><code>opposite()</code></strong>
            <p>
                Gibt die exakt entgegengesetzte Richtung des aktuellen Enum-Wertes zurück. Dies ist essenziell für den WFC-Algorithmus, um Konsistenzregeln zwischen zwei benachbarten Zellen zu prüfen (z. B. wenn Zelle A nördlich von Zelle B liegt, muss Zelle B südlich von Zelle A liegen).
            </p>
            <ul>
                <li><strong>Rückgabewert:</strong> Ein <code>Direction</code>-Objekt, das die Gegenrichtung darstellt.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Pattern.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/Pattern.java</h2>
    <p>
        Die Klasse <code>Pattern</code> ist eine fundamentale Datenstruktur innerhalb des <strong>Wave Function Collapse (WFC)</strong> Algorithmus zur Generierung von Dungeons. 
        Sie repräsentiert ein einzelnes Bauelement (Kachel oder Modul), das Informationen über seine physische Beschaffenheit (Blöcke) und seine Verbindungsregeln (Sockets) zu benachbarten Elementen enthält.
    </p>

    <h3>Klasse: <code>Pattern</code></h3>
    <p>
        Diese Klasse speichert die Definition eines Musters, einschließlich seiner Identifikation, der enthaltenen Materialien und der Wahrscheinlichkeit seines Auftretens.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>Pattern(String id, Material[] blocks, double weight)</code>: 
            Initialisiert ein neues Muster mit einer eindeutigen ID, einem Array von Bukkit-Materialien und einem Gewichtungswert für die Generierungswahrscheinlichkeit.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>id()</code>: 
            Gibt die eindeutige Kennung des Musters zurück.
            <br><strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>blocks()</code>: 
            Gibt das Array der Materialien zurück, aus denen dieses Muster besteht.
            <br><strong>Rückgabewert:</strong> <code>Material[]</code>
        </li>
        <li>
            <code>weight()</code>: 
            Gibt die Gewichtung des Musters zurück. Höhere Werte erhöhen die Chance, dass dieses Muster vom WFC-Algorithmus gewählt wird.
            <br><strong>Rückgabewert:</strong> <code>double</code>
        </li>
        <li>
            <code>setSocket(Direction direction, String socket)</code>: 
            Definiert einen "Socket" (eine Art Steckverbindung) für eine bestimmte Richtung. Sockets bestimmen, welche Muster nebeneinander platziert werden dürfen (nur identische Sockets passen zusammen).
            <br><strong>Parameter:</strong> <code>Direction direction</code> (Richtung), <code>String socket</code> (Socket-Bezeichner).
        </li>
        <li>
            <code>socket(Direction direction)</code>: 
            Ruft den Socket-Bezeichner für die angegebene Richtung ab.
            <br><strong>Rückgabewert:</strong> <code>String</code> (Standardmäßig "AIR", falls kein Socket definiert wurde).
        </li>
        <li>
            <code>socketDown()</code>: 
            Eine Hilfsmethode, die spezifisch den Socket für die Richtung <code>DOWN</code> zurückgibt.
            <br><strong>Rückgabewert:</strong> <code>String</code>
        </li>
    </ul>

    <h4>Interne Datenstrukturen</h4>
    <ul>
        <li><code>Map&lt;Direction, String&gt; sockets</code>: Eine <code>EnumMap</code>, die die Richtungen (UP, DOWN, NORTH, etc.) auf ihre jeweiligen Socket-IDs mappt, um die Kompatibilität zwischen Mustern zu prüfen.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/PatternLoader.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/PatternLoader.java</h2>
    <p>
        Die Klasse <code>PatternLoader</code> ist eine Hilfskomponente innerhalb des Wave Function Collapse (WFC) Algorithmus zur Dungeon-Generierung. 
        Ihre Hauptaufgabe besteht darin, vordefinierte Muster (Patterns) zu erstellen, die räumliche Strukturen wie Luft, Böden, Wände und Korridore repräsentieren. 
        Diese Muster enthalten Informationen über die enthaltenen Blöcke sowie die "Sockets" (Anschlussstellen), die bestimmen, welche Muster nebeneinander platziert werden können.
    </p>

    <h3>Methoden</h3>

    <ul>
        <li>
            <code>public List&lt;Pattern&gt; loadDefaultPatterns()</code>
            <p>
                Erstellt und initialisiert eine Liste von Standard-Mustern für den Dungeon-Generator. 
                Dazu gehören:
            </p>
            <ul>
                <li><strong>air:</strong> Ein leeres Muster (nur Luft).</li>
                <li><strong>floor:</strong> Ein Boden-Muster aus Steinziegeln.</li>
                <li><strong>wall_north:</strong> Ein Wand-Muster mit einer Begrenzung in nördlicher Richtung.</li>
                <li><strong>corridor_ns:</strong> Ein Korridor-Muster, das Verbindungen nach Norden und Süden offen lässt.</li>
            </ul>
            <p><strong>Rückgabewert:</strong> Eine Liste von <code>Pattern</code>-Objekten.</p>
        </li>

        <li>
            <code>private Material[] fill(Material material)</code>
            <p>
                Erzeugt ein Array von Materialien (Größe 8, entsprechend einem 2x2x2 Block-Gitter), das komplett mit dem angegebenen Material gefüllt ist.
            </p>
            <p><strong>Parameter:</strong> <code>material</code> - Das zu verwendende Bukkit-Material.</p>
            <p><strong>Rückgabewert:</strong> Ein Array von <code>Material</code>.</p>
        </li>

        <li>
            <code>private Material[] floorBlocks()</code>
            <p>
                Erzeugt die Block-Daten für ein Boden-Muster. Die untere Ebene (y=0) wird mit <code>STONE_BRICKS</code> gefüllt, während die obere Ebene (y=1) aus Luft besteht.
            </p>
            <p><strong>Rückgabewert:</strong> Ein Array von <code>Material</code>, das ein 2x2x2 Gitter repräsentiert.</p>
        </li>

        <li>
            <code>private Material[] wallBlocks(Direction direction)</code>
            <p>
                Erzeugt die Block-Daten für ein Wand-Muster basierend auf einer Himmelsrichtung. Es nutzt <code>floorBlocks()</code> als Basis und fügt in der oberen Ebene <code>COBBLESTONE_WALL</code> hinzu.
            </p>
            <p><strong>Parameter:</strong> <code>direction</code> - Die Richtung, in der die Wand platziert werden soll.</p>
            <p><strong>Rückgabewert:</strong> Ein Array von <code>Material</code>.</p>
        </li>

        <li>
            <code>private boolean isWallCell(Direction direction, int x, int z)</code>
            <p>
                Hilfsmethode zur Bestimmung, ob eine spezifische Koordinate innerhalb des 2x2 Gitters basierend auf der Richtung eine Wand sein sollte.
            </p>
            <p><strong>Parameter:</strong> 
                <code>direction</code> - Die Zielrichtung der Wand, 
                <code>x</code> - X-Koordinate (0-1), 
                <code>z</code> - Z-Koordinate (0-1).
            </p>
            <p><strong>Rückgabewert:</strong> <code>boolean</code> - Wahr, wenn die Zelle eine Wand ist.</p>
        </li>

        <li>
            <code>private Material[] corridorBlocks()</code>
            <p>
                Aktuell ein Alias für <code>floorBlocks()</code>, um die Block-Struktur für Korridore bereitzustellen.
            </p>
            <p><strong>Rückgabewert:</strong> Ein Array von <code>Material</code>.</p>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WaveGrid.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WaveGrid.java</h2>
    <p>
        Die Klasse <code>WaveGrid</code> ist eine zentrale Datenstruktur für den <strong>Wave Function Collapse (WFC)</strong> Algorithmus innerhalb des Dungeon-Generators. 
        Sie repräsentiert ein dreidimensionales Gitter, in dem jede Zelle eine Liste von möglichen Mustern (Patterns) hält, bis diese zu einem einzigen Zustand "kollabiert".
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>WaveGrid</code> verwaltet den aktuellen Zustand der Entropie für jede Koordinate im Raum. Zu Beginn enthält jede Zelle alle verfügbaren Muster. 
        Während des Generierungsprozesses werden die Möglichkeiten basierend auf Nachbarschaftsregeln reduziert.
    </p>

    <h3>Konstruktor</h3>
    <ul>
        <li>
            <code>WaveGrid(int width, int height, int depth, List&lt;Pattern&gt; initial)</code>: 
            Initialisiert ein neues Gitter mit den angegebenen Dimensionen. Jede Zelle wird mit der vollständigen Liste der initialen <code>Pattern</code>-Objekte befüllt.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public List&lt;Pattern&gt; possibilities(int x, int y, int z)</code>
            <p>Gibt die Liste der aktuell noch möglichen Muster für die angegebene Koordinate zurück.</p>
        </li>
        <li>
            <code>public void setPossibilities(int x, int y, int z, List&lt;Pattern&gt; list)</code>
            <p>Aktualisiert die Liste der möglichen Muster für eine spezifische Zelle. Dies wird verwendet, um die Möglichkeiten während der Propagation einzuschränken.</p>
        </li>
        <li>
            <code>public boolean collapsed(int x, int y, int z)</code>
            <p>Prüft, ob die Zelle an der angegebenen Position bereits final festgelegt (kollabiert) wurde.</p>
        </li>
        <li>
            <code>public void setCollapsed(int x, int y, int z, boolean value)</code>
            <p>Markiert eine Zelle als kollabiert oder gibt sie wieder frei.</p>
        </li>
        <li>
            <code>public int width()</code>, <code>public int height()</code>, <code>public int depth()</code>
            <p>Geben die jeweilige Ausdehnung des Gitters in der X-, Y- oder Z-Achse zurück.</p>
        </li>
    </ul>

    <h3>Datenstruktur</h3>
    <p>
        Intern verwendet die Klasse zwei dreidimensionale Arrays:
    </p>
    <ul>
        <li><code>possibilities</code>: Ein Array von Listen, das die potenziellen <code>Pattern</code>-Objekte speichert.</li>
        <li><code>collapsed</code>: Ein Boolean-Array, das den Status der jeweiligen Zelle nachverfolgt.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WfcGenerator.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/dungeon/wfc/WfcGenerator.java</h2>
    <p>
        Die Klasse <code>WfcGenerator</code> implementiert den <strong>Wave Function Collapse (WFC)</strong> Algorithmus zur prozeduralen Generierung von Dungeon-Strukturen. 
        Der Algorithmus nutzt vordefinierte Muster (Patterns) und deren Nachbarschaftsregeln (Sockets), um ein konsistentes 3D-Gitter zu füllen.
    </p>

    <h3>Hauptkomponenten</h3>

    <h4>Klasse: <code>WfcGenerator</code></h4>
    <p>
        Verantwortlich für die Orchestrierung des Generierungsprozesses, einschließlich der Fehlerbehandlung durch Wiederholungsversuche (Backtracking-Ersatz).
    </p>

    <ul>
        <li>
            <code>public CompletableFuture&lt;Pattern[][][]&gt; generate(int width, int height, int depth)</code>
            <p>
                Startet den Generierungsprozess asynchron. Versucht bis zu 5 Mal, ein gültiges Ergebnis zu erzielen, bevor es <code>null</code> zurückgibt, falls ein Widerspruch (Contradiction) auftritt.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>width</code>, <code>height</code>, <code>depth</code> - Die Dimensionen des zu generierenden Bereichs.</li>
                <li><strong>Rückgabewert:</strong> Ein <code>CompletableFuture</code>, das ein 3D-Array von <code>Pattern</code>-Objekten enthält.</li>
            </ul>
        </li>

        <li>
            <code>private Pattern[][][] runAttempt(int width, int height, int depth, List&lt;Pattern&gt; patterns)</code>
            <p>
                Führt einen einzelnen Generierungsversuch durch. Initialisiert das <code>WaveGrid</code> und führt die Iterationen aus (Zelle wählen, kollabieren, propagieren).
            </p>
        </li>

        <li>
            <code>private int[] findLowestEntropyCell(WaveGrid grid)</code>
            <p>
                Sucht die Zelle im Gitter mit der geringsten Entropie (die wenigsten verbleibenden Möglichkeiten), die noch nicht kollabiert ist. Dies ist ein Kernschritt des WFC-Algorithmus zur Minimierung von Fehlern.
            </p>
        </li>

        <li>
            <code>private Pattern pickWeighted(List&lt;Pattern&gt; options)</code>
            <p>
                Wählt zufällig ein Muster aus den verfügbaren Optionen einer Zelle aus, wobei die individuelle Gewichtung (<code>weight</code>) der Muster berücksichtigt wird.
            </p>
        </li>

        <li>
            <code>private boolean propagate(WaveGrid grid, int startX, int startY, int startZ)</code>
            <p>
                Propagiert die Einschränkungen einer kollabierten Zelle auf ihre Nachbarn. Wenn die Möglichkeiten eines Nachbarn reduziert werden, wird dieser ebenfalls in die Warteschlange zur weiteren Propagation aufgenommen.
            </p>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>false</code>, wenn ein Widerspruch auftritt (eine Zelle hat keine gültigen Muster mehr), ansonsten <code>true</code>.</li>
            </ul>
        </li>

        <li>
            <code>private boolean compatible(List&lt;Pattern&gt; sourceOptions, Pattern neighbor, Direction direction)</code>
            <p>
                Prüft, ob ein potenzielles Nachbarmuster mit den verbleibenden Möglichkeiten der aktuellen Zelle in einer bestimmten Richtung kompatibel ist, indem die "Sockets" verglichen werden.
            </p>
        </li>
    </ul>

    <h3>Hilfsmethoden</h3>
    <ul>
        <li><code>inside(...)</code>: Prüft, ob Koordinaten innerhalb der Gittergrenzen liegen.</li>
        <li><code>offsetX/Y/Z(Direction direction)</code>: Gibt den Koordinaten-Offset basierend auf der Himmelsrichtung oder vertikalen Ausrichtung zurück.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiHolders.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiHolders.java</h2>
    <p>
        Die Klasse <code>GuiHolders</code> dient der robusten Identifikation von grafischen Benutzeroberflächen (GUIs) innerhalb des Minecraft-Plugins. 
        Anstatt sich auf den Titel eines Inventars zu verlassen (welcher durch Farben oder Lokalisierungen variieren kann), nutzt dieses System spezifische 
        <code>InventoryHolder</code>-Typen, um Menüs eindeutig zu identifizieren.
    </p>

    <h3>Hauptklasse: GuiHolders</h3>
    <p>
        Dies ist eine finale Utility-Klasse, die als Container für verschiedene statische Holder-Klassen fungiert. 
        Der Konstruktor ist privat, um eine Instanziierung zu verhindern.
    </p>

    <h3>Innere Klassen (InventoryHolders)</h3>
    <p>
        Jede der folgenden Klassen implementiert das Bukkit-Interface <code>InventoryHolder</code>. 
        Die Methode <code>getInventory()</code> wirft in allen Fällen eine <code>UnsupportedOperationException</code>, 
        da diese Holder lediglich als "Marker" dienen und das eigentliche Inventar-Objekt separat verwaltet wird.
    </p>

    <ul>
        <li>
            <strong>PlayerMenuHolder</strong>: 
            Markiert das Hauptmenü für Spieler.
        </li>
        <li>
            <strong>AdminMenuHolder</strong>: 
            Markiert das Administrations-Menü.
        </li>
        <li>
            <strong>QuestListHolder</strong>: 
            Markiert die Übersicht der verfügbaren oder aktiven Quests.
        </li>
        <li>
            <strong>SkillListHolder</strong>: 
            Markiert die Liste der verfügbaren Fähigkeiten.
        </li>
        <li>
            <strong>SkillTreeHolder</strong>: 
            Markiert die grafische Darstellung des Skill-Baums.
        </li>
        <li>
            <strong>ShopHolder</strong>: 
            Markiert ein Shop-Inventar. Im Gegensatz zu den anderen Holdern speichert dieser zusätzliche Daten:
            <ul>
                <li><code>shopId</code> (String): Die eindeutige Kennung des spezifischen Shops, der geöffnet wurde.</li>
                <li><code>shopId()</code>: Gibt die ID des Shops zurück.</li>
            </ul>
        </li>
    </ul>

    <h3>Technische Details</h3>
    <p>
        Durch die Verwendung dieser Holder kann in Event-Listenern (wie dem <code>GuiListener</code>) einfach geprüft werden, 
        ob ein Inventar zu einem bestimmten Typ gehört:
        <br>
        <code>if (event.getInventory().getHolder() instanceof GuiHolders.ShopHolder) { ... }</code>
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/gui/GuiManager.java</h2>
    <p>
        Die Klasse <code>GuiManager</code> ist eine zentrale Komponente zur Verwaltung und Anzeige von grafischen Benutzeroberflächen (GUIs) innerhalb des Minecraft-Servers. Sie nutzt das Bukkit-Inventarsystem, um interaktive Menüs für Spieler und Administratoren zu erstellen.
    </p>

    <h3>Klasse: GuiManager</h3>
    <p>
        Diese Klasse koordiniert den Zugriff auf verschiedene Manager (Player, Quest, Skill, Class, Faction) und wandelt deren Daten in visuelle Inventar-Elemente um.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>GuiManager(...)</code>: Initialisiert den Manager mit allen notwendigen Abhängigkeiten und NamespacedKeys für die Identifizierung von Items in den GUIs.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>openPlayerMenu(Player player)</code>
            <p>Öffnet das Hauptmenü für den Spieler. Es zeigt eine Übersicht über den Charakterstatus (Level, XP, Klasse), aktive Quests, verfügbare Skills und Fraktionsruf.</p>
        </li>
        <li>
            <code>openAdminMenu(Player player)</code>
            <p>Öffnet ein Administrationsmenü, das Verknüpfungen zu Editoren für Zonen, NPCs, Quests, Loot-Tabellen und Skill-Konfigurationen bietet.</p>
        </li>
        <li>
            <code>openQuestList(Player player)</code>
            <p>Erstellt eine Liste aller verfügbaren Quests. Jede Quest wird als Buch dargestellt, das Informationen über Mindestlevel und Beschreibung enthält. Die Quest-ID wird im <code>PersistentDataContainer</code> des Items gespeichert.</p>
        </li>
        <li>
            <code>openSkillList(Player player)</code>
            <p>Zeigt dem Spieler eine Übersicht aller lernbaren Skills an. Die Anzeige umfasst Kategorie, Typ, Cooldown, Manakosten, aktuelle Ränge und die spezifischen Effekte des Skills.</p>
        </li>
        <li>
            <code>openShop(Player player, ShopDefinition shop)</code>
            <p>Öffnet ein Shop-Interface basierend auf einer <code>ShopDefinition</code>. Es zeigt Items mit ihren jeweiligen Kauf- und Verkaufspreisen an den definierten Slot-Positionen an.</p>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>resolveClassName(String classId)</code>
            <p>Wandelt eine technische Klassen-ID in einen lesbaren Namen um, indem sie den <code>ClassManager</code> konsultiert. Gibt "Keine" zurück, falls keine Klasse zugewiesen ist.</p>
        </li>
    </ul>

    <h3>Technische Details</h3>
    <ul>
        <li><strong>GUI-Identifikation:</strong> Verwendet spezielle <code>InventoryHolder</code> (aus <code>GuiHolders</code>), um Menü-Interaktionen im <code>GuiListener</code> eindeutig identifizieren zu können.</li>
        <li><strong>Item-Erstellung:</strong> Nutzt den <code>ItemBuilder</code> und die <code>Text</code>-Utility (MiniMessage), um formatierte Item-Namen und Lore-Texte zu generieren.</li>
        <li><strong>Persistenz:</strong> Speichert Metadaten (wie Quest- oder Skill-IDs) direkt auf den <code>ItemStack</code>-Objekten mittels <code>PersistentDataContainer</code>.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/gui/SkillTreeGui.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/gui/SkillTreeGui.java</h2>
    <p>
        Die Klasse <code>SkillTreeGui</code> ist für die Darstellung und Verwaltung des grafischen Skillbaums (GUI) innerhalb von Minecraft verantwortlich. 
        Sie ermöglicht es Spielern, ihre verfügbaren Fähigkeiten einzusehen, deren Voraussetzungen zu prüfen und neue Skills zu erlernen.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Klasse:</strong> <code>SkillTreeGui</code></li>
        <li><strong>Paket:</strong> <code>com.example.rpg.gui</code></li>
        <li><strong>Zweck:</strong> Erstellung und Anzeige eines interaktiven Inventar-Menüs zur Visualisierung der Skill-Progression.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>public SkillTreeGui(RPGPlugin plugin)</code></h4>
    <p>Der Konstruktor initialisiert die GUI-Klasse mit der Hauptinstanz des Plugins.</p>
    <ul>
        <li><code>plugin</code>: Die Instanz des <code>RPGPlugin</code>, um auf Manager und Konfigurationen zuzugreifen.</li>
    </ul>

    <h4><code>public void open(Player player)</code></h4>
    <p>
        Öffnet das Skillbaum-Inventar für den angegebenen Spieler. Diese Methode führt folgende Schritte aus:
    </p>
    <ul>
        <li>Erstellt ein neues Inventar mit dem Titel "Skillbaum" (Größe: 54 Slots).</li>
        <li>Berechnet das Layout basierend auf der Struktur des <code>SkillTreeManager</code>.</li>
        <li>Iteriert durch die Skills und bestimmt den Status für den Spieler (Gelernt, Freigeschaltet oder Gesperrt).</li>
        <li>Erzeugt visuelle Repräsentationen (Items) für jeden Skill:
            <ul>
                <li><code>ENCHANTED_BOOK</code>: Skill bereits gelernt (Grün).</li>
                <li><code>BOOK</code>: Skill verfügbar zum Lernen (Gelb).</li>
                <li><code>BARRIER</code>: Skill gesperrt (Rot).</li>
            </ul>
        </li>
        <li>Speichert die Skill-ID in den <code>PersistentDataContainer</code> des Items, um Interaktionen im <code>GuiListener</code> zu ermöglichen.</li>
        <li>Fügt dekorative Elemente (Glasscheiben) als Verbindungslinien zwischen den Skills ein.</li>
    </ul>

    <h4><code>private Map&lt;String, Integer&gt; layout(SkillTreeManager treeManager)</code></h4>
    <p>
        Berechnet die Positionen (Slots) der einzelnen Skills im Inventar basierend auf ihrer Hierarchie im Skillbaum.
    </p>
    <ul>
        <li><strong>Algorithmus:</strong> Verwendet eine Breitensuche (BFS) mit einer <code>ArrayDeque</code>, um die Knoten des Baums zu durchlaufen.</li>
        <li><strong>Logik:</strong> Die Tiefe des Knotens bestimmt die Zeile, während die Anzahl der Geschwisterknoten die Spaltenposition beeinflusst.</li>
        <li><strong>Rückgabewert:</strong> Eine Map, die Skill-IDs ihren jeweiligen Slot-Indizes im Inventar zuordnet.</li>
    </ul>

    <h4><code>private int depth(SkillTreeManager.SkillNode node)</code></h4>
    <p>
        Hilfsmethode zur Bestimmung der Tiefe eines Knotens innerhalb der Baumstruktur.
    </p>
    <ul>
        <li><strong>Parameter:</strong> <code>node</code> - Der zu prüfende Skill-Knoten.</li>
        <li><strong>Rückgabewert:</strong> Ganzzahl (int), die angibt, wie viele Ebenen der Knoten von der Wurzel entfernt ist.</li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>SkillTreeManager</code>: Liefert die logische Struktur des Skillbaums.</li>
        <li><code>PlayerProfile</code>: Enthält die Daten des Spielers über bereits gelernte Fähigkeiten.</li>
        <li><code>ItemBuilder</code>: Utility-Klasse zur einfachen Erstellung von ItemStack-Objekten mit Lore und Namen.</li>
        <li><code>GuiHolders.SkillTreeHolder</code>: Ein spezieller InventoryHolder zur Identifizierung dieses GUIs in Event-Listenern.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ArenaListener.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ArenaListener.java</h2>
    <p>
        Die Klasse <code>ArenaListener</code> ist ein Event-Listener für das Bukkit-Framework. Ihre Hauptaufgabe besteht darin, spezifische Spielerereignisse abzufangen, die für das Arena-System (PvP/Wettkampf) des RPG-Plugins relevant sind, und diese an den zentralen Manager weiterzuleiten.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Name:</strong> <code>ArenaListener</code></li>
        <li><strong>Interface:</strong> Implementiert <code>org.bukkit.event.Listener</code></li>
        <li><strong>Zweck:</strong> Überwachung von Spielerereignissen (wie Tod), um Arena-Logik auszulösen.</li>
    </ul>

    <h3>Konstruktor</h3>
    <p>
        <code>public ArenaListener(RPGPlugin plugin)</code>
    </p>
    <ul>
        <li><strong>Parameter:</strong> <code>RPGPlugin plugin</code> - Die Instanz des Haupt-Plugins, um Zugriff auf die Manager-Klassen zu erhalten.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4>onDeath</h4>
    <p>
        <code>public void onDeath(PlayerDeathEvent event)</code>
    </p>
    <p>
        Diese Methode wird automatisch aufgerufen, wenn ein Spieler auf dem Server stirbt. Sie dient als Brücke zwischen dem Bukkit-Event-System und der internen Arena-Logik.
    </p>
    <ul>
        <li><strong>Annotation:</strong> <code>@EventHandler</code> - Markiert die Methode als Event-Handler für Bukkit.</li>
        <li><strong>Parameter:</strong> <code>PlayerDeathEvent event</code> - Das von Bukkit bereitgestellte Event-Objekt, das Details zum Tod des Spielers enthält.</li>
        <li><strong>Funktionsweise:</strong> 
            Extrahiert das <code>Player</code>-Objekt aus dem Event und ruft die Methode <code>handleDeath(player)</code> im <code>ArenaManager</code> auf. Dadurch wird sichergestellt, dass das Arena-System korrekt reagieren kann (z. B. Beenden eines Kampfes, Punktevergabe oder Teleportation), falls sich der Spieler zum Zeitpunkt des Todes in einer Arena befand.
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CombatListener.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CombatListener.java</h2>
    <p>
        Die Klasse <code>CombatListener</code> ist eine zentrale Komponente des RPG-Systems, die auf verschiedene Bukkit-Events reagiert, um Kampflogik, Erfahrungspunkte-Verteilung (XP), Beute-Generierung (Loot) und Quest-Fortschritte zu verarbeiten.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Name:</strong> <code>CombatListener</code></li>
        <li><strong>Interface:</strong> <code>org.bukkit.event.Listener</code></li>
        <li><strong>Beschreibung:</strong> Übernimmt die Überwachung von Spielerinteraktionen wie Kämpfen, Blockabbau und Crafting, um RPG-Mechaniken auszulösen.</li>
    </ul>

    <h3>Methoden</h3>
    
    <ul>
        <li>
            <code>onFriendlyFire(EntityDamageByEntityEvent event)</code>
            <p>
                Verhindert "Friendly Fire" innerhalb einer Gruppe. Wenn ein Spieler ein anderes Mitglied seiner eigenen Party angreift, wird das Event abgebrochen.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>EntityDamageByEntityEvent</code> - Das Event, das ausgelöst wird, wenn eine Entität Schaden durch eine andere erleidet.</li>
            </ul>
        </li>

        <li>
            <code>onEntityDeath(EntityDeathEvent event)</code>
            <p>
                Verarbeitet den Tod von Entitäten. Diese Methode ist für mehrere Kernaspekte verantwortlich:
            </p>
            <ul>
                <li><strong>XP-Verteilung:</strong> Berechnet Erfahrungspunkte basierend auf dem Entitätstyp und verteilt diese an den Killer oder die gesamte Party (innerhalb eines Radius von 30 Blöcken), sofern konfiguriert.</li>
                <li><strong>Loot-System:</strong> Konsultiert den <code>LootManager</code>, um basierend auf Wahrscheinlichkeiten und dem Level des Spielers RPG-Gegenstände zu generieren und den Drops hinzuzufügen.</li>
                <li><strong>Quest-Fortschritt:</strong> Überprüft, ob der Tod der Entität ein Ziel in den aktiven Quests der beteiligten Spieler (Killer/Party) erfüllt (Typ: <code>KILL</code>) und aktualisiert den Fortschritt entsprechend.</li>
            </ul>
            <ul>
                <li><strong>Parameter:</strong> <code>EntityDeathEvent</code> - Das Event beim Tod einer Entität.</li>
            </ul>
        </li>

        <li>
            <code>onBlockBreak(BlockBreakEvent event)</code>
            <p>
                Gewährt dem Spieler eine geringe Menge an Erfahrungspunkten (1 XP) für das Abbauen von Blöcken und aktualisiert die Spielerattribute.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>BlockBreakEvent</code> - Das Event beim Abbauen eines Blocks.</li>
            </ul>
        </li>

        <li>
            <code>onCraft(CraftItemEvent event)</code>
            <p>
                Gewährt dem Spieler Erfahrungspunkte (2 XP) für das Herstellen von Gegenständen und aktualisiert die Spielerattribute.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>CraftItemEvent</code> - Das Event beim Craften eines Items.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Hauptinstanz des Plugins für den Zugriff auf Manager (Party, PlayerData, Loot, Quest, ItemGenerator).</li>
        <li><code>PlayerProfile</code>: Zur Speicherung und Aktualisierung von XP und Attributen.</li>
        <li><code>LootTable</code> &amp; <code>LootEntry</code>: Zur Bestimmung der Beute nach einem Kampf.</li>
        <li><code>QuestProgress</code> &amp; <code>QuestStep</code>: Zur Nachverfolgung von Quest-Zielen.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CustomMobListener.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/CustomMobListener.java</h2>
    <p>
        Die Klasse <code>CustomMobListener</code> ist eine zentrale Komponente des RPG-Systems, die für die Verwaltung und Steuerung von benutzerdefinierten Mobs (Custom Mobs) verantwortlich ist. Sie implementiert das Bukkit-<code>Listener</code>-Interface und verarbeitet Ereignisse wie Schaden, Tod und Heilung, während sie gleichzeitig die KI-Verhaltensbäume (Behavior Trees) und visuelle Elemente wie Lebensbalken steuert.
    </p>

    <h3>Klasse: CustomMobListener</h3>
    <p>
        Diese Klasse fungiert als Brücke zwischen den Standard-Minecraft-Entitäten und den erweiterten RPG-Mob-Definitionen.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public CustomMobListener(RPGPlugin plugin)</code>
            <p>Konstruktor, der das Plugin-Objekt initialisiert und den <code>NamespacedKey</code> für die Identifizierung von Custom Mobs erstellt.</p>
        </li>
        <li>
            <code>@EventHandler public void onDamage(EntityDamageByEntityEvent event)</code>
            <p>Überschreibt den Schaden, den ein Custom Mob verursacht, basierend auf den Werten in seiner <code>MobDefinition</code>.</p>
        </li>
        <li>
            <code>@EventHandler public void onDeath(EntityDeathEvent event)</code>
            <p>
                Verarbeitet den Tod eines Mobs. Diese Methode:
                <ul>
                    <li>Entfernt den Lebensbalken und stoppt die KI-Schleife.</li>
                    <li>Vergibt Erfahrungspunkte (XP) an den Killer.</li>
                    <li>Generiert Beute (Loot) basierend auf der verknüpften <code>LootTable</code> und <code>LootEntry</code>-Wahrscheinlichkeiten.</li>
                </ul>
            </p>
        </li>
        <li>
            <code>public void applyDefinition(LivingEntity entity, MobDefinition mob)</code>
            <p>
                Wendet eine <code>MobDefinition</code> auf eine lebende Entität an. Dies beinhaltet das Setzen der maximalen Gesundheit, der Ausrüstung (Haupthand, Helm) und das Starten der KI-Logik sowie des Lebensbalkens.
            </p>
        </li>
        <li>
            <code>@EventHandler public void onMobDamage(EntityDamageEvent event)</code>
            <p>Aktualisiert den visuellen Lebensbalken (TextDisplay) des Mobs, wenn dieser Schaden erleidet.</p>
        </li>
        <li>
            <code>@EventHandler public void onMobHeal(EntityRegainHealthEvent event)</code>
            <p>Aktualisiert den visuellen Lebensbalken des Mobs, wenn dieser geheilt wird.</p>
        </li>
        <li>
            <code>private void startBehaviorLoop(LivingEntity entity, MobDefinition mob)</code>
            <p>
                Initiiert einen Scheduler-Task, der pro Tick (1L) ausgeführt wird. Er sucht nach Zielen in der Nähe und führt den Verhaltensbaum (Behavior Tree) des Mobs aus.
            </p>
        </li>
        <li>
            <code>private Player findTarget(LivingEntity entity)</code>
            <p>Sucht den nächstgelegenen Spieler in einem Umkreis von 20 Blöcken (400 distanceSquared) als Ziel für den Mob.</p>
        </li>
        <li>
            <code>private void attachHealthBar(LivingEntity entity, MobDefinition mob, double health)</code>
            <p>Erzeugt ein <code>TextDisplay</code> über dem Kopf des Mobs, das als dynamischer Lebensbalken fungiert.</p>
        </li>
        <li>
            <code>private String buildHealthText(MobDefinition mob, double health)</code>
            <p>Generiert einen formatierten String mit Farbcodes, der den Namen des Mobs und einen grafischen Fortschrittsbalken (z. B. <code>[||||||||||]</code>) für die HP anzeigt.</p>
        </li>
    </ul>

    <h4>Interne Datenstrukturen</h4>
    <ul>
        <li><code>behaviorTasks</code>: Speichert die laufenden Bukkit-Tasks der KI-Schleifen pro Entität-UUID.</li>
        <li><code>behaviorContexts</code>: Hält den <code>BehaviorContext</code> für jeden aktiven Mob bereit.</li>
        <li><code>healthBars</code>: Verwaltet die <code>TextDisplay</code>-Entitäten, die für die Anzeige der Lebensbalken zuständig sind.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/DamageIndicatorListener.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/DamageIndicatorListener.java</h2>
    <p>
        Die Klasse <code>DamageIndicatorListener</code> ist eine Listener-Komponente für den Minecraft-Server (Bukkit/Spigot API). 
        Ihre Hauptaufgabe besteht darin, visuelle Schadens- und Heilungsindikatoren direkt in der Spielwelt über den betroffenen Entitäten anzuzeigen. 
        Dies geschieht mithilfe von <code>TextDisplay</code>-Entitäten, die kurzzeitig erscheinen und nach oben schweben.
    </p>

    <h3>Klassen-Definition</h3>
    <p>
        <code>public class DamageIndicatorListener implements Listener</code>
    </p>
    <ul>
        <li><strong>Abhängigkeiten:</strong> Nutzt <code>RPGPlugin</code> für den Zugriff auf den Scheduler und die Adventure-API für die Textformatierung.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4>onDamage(EntityDamageEvent event)</h4>
    <p>
        Wird aufgerufen, wenn eine Entität Schaden erleidet.
    </p>
    <ul>
        <li><strong>Logik:</strong> Prüft, ob der Schaden größer als 0 ist. Bestimmt die Farbe des Indikators basierend auf der Schadensursache (Türkis für Magie, Rot für physischen Schaden).</li>
        <li><strong>Anzeige:</strong> Erzeugt einen Text im Format <code>-X ❤</code>.</li>
    </ul>

    <h4>onRegain(EntityRegainHealthEvent event)</h4>
    <p>
        Wird aufgerufen, wenn eine Entität Lebenspunkte regeneriert.
    </p>
    <ul>
        <li><strong>Logik:</strong> Erzeugt einen grünen Indikator im Format <code>+X ❤</code>.</li>
    </ul>

    <h4>isMagicDamage(EntityDamageEvent.DamageCause cause)</h4>
    <p>
        Eine private Hilfsmethode zur Kategorisierung von Schadensarten.
    </p>
    <ul>
        <li><strong>Parameter:</strong> <code>cause</code> - Die Ursache des Schadens.</li>
        <li><strong>Rückgabewert:</strong> <code>boolean</code> - True, wenn es sich um magischen Schaden handelt (z. B. MAGIC, POISON, WITHER).</li>
    </ul>

    <h4>spawnIndicator(Location base, String text, NamedTextColor color)</h4>
    <p>
        Verantwortlich für das Erzeugen und Animieren der <code>TextDisplay</code>-Entität.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>base</code>: Die Ursprungsposition (meist die Position der Entität).</li>
                <li><code>text</code>: Der anzuzeigende String.</li>
                <li><code>color</code>: Die Farbe des Textes.</li>
            </ul>
        </li>
        <li><strong>Animation:</strong> Startet einen Scheduler-Task, der das Display pro Tick (1/20 Sekunde) um 0.04 Blöcke nach oben bewegt.</li>
        <li><strong>Lebenszyklus:</strong> Die Entität wird automatisch nach 20 Ticks (ca. 1 Sekunde) entfernt.</li>
    </ul>

    <h4>offset()</h4>
    <p>
        Generiert einen zufälligen Versatz (Offset) für die Positionierung des Indikators.
    </p>
    <ul>
        <li><strong>Zweck:</strong> Verhindert, dass mehrere Indikatoren exakt an derselben Stelle erscheinen, indem sie leicht gestreut werden.</li>
        <li><strong>Rückgabewert:</strong> <code>double</code> - Ein Zufallswert zwischen -0.3 und 0.3.</li>
    </ul>

    <h3>Technische Details</h3>
    <ul>
        <li><strong>Billboard-Modus:</strong> Die Indikatoren sind auf <code>CENTER</code> eingestellt, sodass sie sich immer zum Spieler drehen.</li>
        <li><strong>Sichtbarkeit:</strong> <code>setSeeThrough(true)</code> ermöglicht es, die Zahlen auch durch Wände hindurch zu sehen.</li>
        <li><strong>Performance:</strong> Verwendet asynchrone/getaktete Tasks des Bukkit-Schedulers für die flüssige Aufwärtsbewegung.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/GuiListener.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/GuiListener.java</h2>
    <p>
        Die Klasse <code>GuiListener</code> ist eine zentrale Komponente für die Verarbeitung von Interaktionen innerhalb der grafischen Benutzeroberflächen (GUIs) des RPG-Systems. Sie implementiert das Bukkit-Interface <code>Listener</code> und reagiert auf Inventar-Klicks, um Aktionen wie das Erlernen von Skills, das Annehmen von Quests oder den Handel in Shops zu steuern.
    </p>

    <h3>Klassen-Definition</h3>
    <code>public class GuiListener implements Listener</code>
    <p>
        Diese Klasse verarbeitet alle Klick-Events in benutzerdefinierten Inventaren, die durch das Plugin geöffnet wurden. Sie nutzt <code>GuiHolders</code>, um zu identifizieren, welches spezifische Menü ein Spieler gerade bedient.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>onClick(InventoryClickEvent event)</code>
            <p>
                Der Haupt-EventHandler für <code>InventoryClickEvent</code>. Überprüft den <code>InventoryHolder</code> des angeklickten Inventars und delegiert die Logik basierend auf dem Menütyp (Spielermenü, Adminmenü, Questliste, Skillliste, Skilltree oder Shop).
            </p>
        </li>
        <li>
            <code>resolveQuest(ItemStack item)</code>
            <p>
                Extrahiert die Quest-ID aus den <code>PersistentDataContainer</code>-Metadaten eines Items und gibt das entsprechende <code>Quest</code>-Objekt zurück.
            </p>
            <p><strong>Parameter:</strong> <code>ItemStack item</code> - Das Item, das die Quest-Informationen enthält.</p>
            <p><strong>Rückgabewert:</strong> Das gefundene <code>Quest</code>-Objekt oder <code>null</code>.</p>
        </li>
        <li>
            <code>resolveSkill(ItemStack item)</code>
            <p>
                Extrahiert die Skill-ID aus den Metadaten eines Items und gibt das entsprechende <code>Skill</code>-Objekt zurück.
            </p>
            <p><strong>Parameter:</strong> <code>ItemStack item</code> - Das Item, das die Skill-Informationen enthält.</p>
            <p><strong>Rückgabewert:</strong> Das gefundene <code>Skill</code>-Objekt oder <code>null</code>.</p>
        </li>
        <li>
            <code>handleShopClick(Player player, Inventory inventory, int slot, ItemStack clicked, GuiHolders.ShopHolder holder, boolean rightClick)</code>
            <p>
                Verarbeitet die Kauf- und Verkaufslogik innerhalb eines Shop-Inventars.
                <ul>
                    <li><strong>Linksklick:</strong> Kauft ein Item, sofern genug Gold vorhanden ist.</li>
                    <li><strong>Rechtsklick:</strong> Verkauft ein Item aus dem Inventar des Spielers gegen Gold.</li>
                </ul>
            </p>
        </li>
        <li>
            <code>removeOne(Inventory inventory, Material material)</code>
            <p>
                Hilfsmethode, die genau eine Einheit eines bestimmten Materials aus dem Inventar des Spielers entfernt.
            </p>
        </li>
    </ul>

    <h3>Logik-Highlights</h3>
    <ul>
        <li><strong>Quest-Validierung:</strong> Prüft vor der Annahme einer Quest das Mindestlevel, ob die Quest bereits aktiv ist oder ob eine nicht-wiederholbare Quest bereits abgeschlossen wurde.</li>
        <li><strong>Skill-System:</strong> Verifiziert beim Erlernen von Skills die Verfügbarkeit von Skillpunkten und ob notwendige Vorraussetzungen (Required Skills) erfüllt sind.</li>
        <li><strong>Persistenz:</strong> Nach Transaktionen im Shop oder Änderungen an Skills/Quests wird das <code>PlayerProfile</code> über den <code>PlayerDataManager</code> gespeichert.</li>
        <li><strong>Feedback:</strong> Nutzt die <code>Text</code>-Utility für farbige Chat-Nachrichten und spielt Sounds bei erfolgreichen Transaktionen ab.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ItemStatListener.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ItemStatListener.java</h2>

    <p>
        Die Klasse <code>ItemStatListener</code> ist eine Listener-Komponente innerhalb des RPG-Plugins. 
        Ihre Hauptaufgabe besteht darin, Änderungen an der Ausrüstung eines Spielers zu überwachen und sicherzustellen, 
        dass Set-Boni (Set-Effekte) basierend auf den getragenen Gegenständen korrekt berechnet und aktualisiert werden.
    </p>

    <h3>Klassen-Definition</h3>
    <p>
        <code>public class ItemStatListener implements Listener</code>
    </p>
    <p>
        Diese Klasse implementiert das <code>Listener</code>-Interface von Bukkit, um auf Spielereignisse reagieren zu können.
    </p>

    <h3>Konstruktor</h3>
    <ul>
        <li>
            <code>ItemStatListener(RPGPlugin plugin)</code>: Initialisiert den Listener mit einer Instanz des Haupt-Plugins, 
            um Zugriff auf den <code>ItemStatManager</code> zu erhalten.
        </li>
    </ul>

    <h3>Event-Handler</h3>
    
    <h4>onInventoryClick</h4>
    <p>
        <code>public void onInventoryClick(InventoryClickEvent event)</code>
    </p>
    <p>
        Dieses Ereignis wird ausgelöst, wenn ein Spieler in seinem Inventar auf einen Gegenstand klickt.
    </p>
    <ul>
        <li><strong>Zweck:</strong> Da das Wechseln von Rüstung oder Waffen oft über Klicks im Inventar geschieht, triggert diese Methode eine Überprüfung der Set-Boni.</li>
        <li><strong>Besonderheit:</strong> Die Aktualisierung wird über den Scheduler (<code>runTask</code>) asynchron bzw. im nächsten Tick ausgeführt, um sicherzustellen, dass die Inventaränderung bereits vollständig verarbeitet wurde, bevor die Boni neu berechnet werden.</li>
    </ul>

    <h4>onJoin</h4>
    <p>
        <code>public void onJoin(PlayerJoinEvent event)</code>
    </p>
    <p>
        Dieses Ereignis wird ausgelöst, wenn ein Spieler den Server betritt.
    </p>
    <ul>
        <li><strong>Zweck:</strong> Stellt sicher, dass die Set-Boni eines Spielers sofort beim Login korrekt angewendet werden, basierend auf der Ausrüstung, die er beim Verlassen des Servers getragen hat.</li>
        <li><strong>Parameter:</strong> <code>PlayerJoinEvent event</code> - Das Event, das den beitretenden Spieler enthält.</li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Die Hauptklasse des Plugins.</li>
        <li><code>ItemStatManager</code>: Wird über das Plugin aufgerufen, um die eigentliche Logik der <code>updateSetBonus</code>-Methode auszuführen.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcListener.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcListener.java</h2>
    <p>
        Die Klasse <code>NpcListener</code> ist eine Event-Listener-Komponente für das RPG-System. Sie ist dafür verantwortlich, Interaktionen zwischen Spielern und Nicht-Spieler-Charakteren (NPCs) zu verarbeiten. Sie erkennt, ob eine angeklickte Entität ein registrierter NPC ist, und löst entsprechende Aktionen wie Dialoge, Quest-Angebote oder Shop-Eröffnungen aus.
    </p>

    <h3>Klassen-Details</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.listener</code></li>
        <li><strong>Implementierte Interfaces:</strong> <code>org.bukkit.event.Listener</code></li>
    </ul>

    <h3>Konstruktor</h3>
    <p>
        <code>public NpcListener(RPGPlugin plugin)</code>
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>plugin</code> (RPGPlugin): Die Instanz des Haupt-Plugins, um Zugriff auf Manager wie <code>NpcManager</code>, <code>GuiManager</code> und <code>ShopManager</code> zu erhalten.</li>
            </ul>
        </li>
    </ul>

    <h3>Methoden</h3>
    
    <h4>onInteract(PlayerInteractEntityEvent event)</h4>
    <p>
        Diese Methode wird aufgerufen, wenn ein Spieler mit der rechten Maustaste auf eine Entität klickt. Sie steuert die Logik für die NPC-Interaktion.
    </p>
    <ul>
        <li><strong>Annotation:</strong> <code>@EventHandler</code></li>
        <li><strong>Funktionsweise:</strong>
            <ol>
                <li>Prüft, ob die Entität im <code>PersistentDataContainer</code> einen NPC-Schlüssel besitzt.</li>
                <li>Ruft die NPC-ID ab und validiert die Existenz des NPC-Modells über den <code>NpcManager</code>.</li>
                <li><strong>Dialog-System:</strong> Wenn der NPC Dialogzeilen hinterlegt hat, werden diese dem Spieler im Chat formatiert ausgegeben.</li>
                <li><strong>Rollen-Logik:</strong>
                    <ul>
                        <li><code>NpcRole.QUESTGIVER</code>: Informiert den Spieler über verfügbare Quests und öffnet das Quest-Menü.</li>
                        <li><code>NpcRole.VENDOR</code>: Sucht den verknüpften Shop über den <code>ShopManager</code> und öffnet das Shop-GUI für den Spieler.</li>
                    </ul>
                </li>
            </ol>
        </li>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>event</code> (PlayerInteractEntityEvent): Das Bukkit-Event, das die Interaktionsdaten enthält.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>NpcManager</code>: Zur Identifizierung und zum Abruf von NPC-Daten.</li>
        <li><code>GuiManager</code>: Zum Öffnen von Benutzeroberflächen (Shops, Quests).</li>
        <li><code>ShopManager</code>: Zum Laden von Shop-Definitionen basierend auf der NPC-Konfiguration.</li>
        <li><code>Text-Utility</code>: Zur Formatierung von Chat-Nachrichten mittels MiniMessage.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcProtectionListener.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/NpcProtectionListener.java</h2>
    <p>
        Die Klasse <code>NpcProtectionListener</code> ist eine Listener-Komponente für das RPG-Plugin. Ihr Hauptzweck besteht darin, Nicht-Spieler-Charaktere (NPCs) vor Schaden und unerwünschten Interaktionen durch die Spielwelt oder andere Entitäten zu schützen, ohne auf externe Plugins angewiesen zu sein.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class NpcProtectionListener implements Listener</code>
    </p>
    <p>
        Diese Klasse implementiert das Bukkit-Interface <code>Listener</code> und registriert Events, die den Schutzstatus von NPCs sicherstellen. NPCs werden anhand von persistenten Daten identifiziert, die im <code>NpcManager</code> definiert sind.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>private boolean isNpc(Entity entity)</code>
            <p>
                Überprüft, ob eine gegebene Entität ein NPC ist. Dies geschieht durch Abfrage des <code>PersistentDataContainer</code> der Entität unter Verwendung des im <code>NpcManager</code> hinterlegten Schlüssels.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>Entity entity</code> - Die zu prüfende Entität.</li>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> - Wahr, wenn die Entität als NPC markiert ist.</li>
            </ul>
        </li>
        <li>
            <code>public void onDamage(EntityDamageEvent event)</code>
            <p>
                Wird ausgelöst, wenn eine Entität Schaden erleidet. Wenn die betroffene Entität ein NPC ist, wird das Event abgebrochen (<code>setCancelled(true)</code>), wodurch der NPC unverwundbar wird.
            </p>
        </li>
        <li>
            <code>public void onTarget(EntityTargetEvent event)</code>
            <p>
                Wird ausgelöst, wenn eine Entität (z. B. ein Monster) ein neues Ziel anvisiert. Wenn das Ziel ein NPC ist, wird das Event abgebrochen, sodass NPCs von aggressiven Mobs ignoriert werden.
            </p>
        </li>
    </ul>

    <h3>Besondere Hinweise</h3>
    <p>
        Laut Code-Kommentar wird das <code>PlayerInteractAtEntityEvent</code> bewusst <strong>nicht</strong> abgebrochen. Dies stellt sicher, dass normale Rechtsklick-Interaktionen (wie das Öffnen von Shops oder Quest-Dialogen) weiterhin funktionieren, während der physische Schutz durch die anderen Events gewährleistet bleibt.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/PlayerListener.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/PlayerListener.java</h2>
    <p>
        Die Klasse <code>PlayerListener</code> ist eine zentrale Komponente für die Verwaltung von Spieler-Events innerhalb des RPG-Systems. 
        Sie kümmert sich um das Laden von Spielerprofilen beim Betreten des Servers, die Verarbeitung von Chat-Eingaben für interaktive Prompts und die Handhabung von Editor-Werkzeugen (Wands).
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        <code>public class PlayerListener implements Listener</code>
    </p>
    <ul>
        <li><strong>Zweck:</strong> Überwachung und Steuerung von Spieler-Aktionen wie Login, Chat und Interaktionen.</li>
        <li><strong>Abhängigkeiten:</strong> Nutzt den <code>RPGPlugin</code>-Kern, den <code>PlayerDataManager</code> und den <code>PromptManager</code>.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>onJoin(PlayerJoinEvent event)</code></h4>
    <p>
        Wird aufgerufen, wenn ein Spieler den Server betritt.
    </p>
    <ul>
        <li><strong>Funktionsweise:</strong> 
            Der Spieler wird initial "eingefroren" (freeze), während sein Profil asynchron aus der Datenbank geladen wird. 
            Sobald die Daten verfügbar sind, werden die RPG-Attribute angewendet und der Spieler wird wieder freigegeben (unfreeze).
        </li>
    </ul>

    <h4><code>onChat(AsyncPlayerChatEvent event)</code></h4>
    <p>
        Verarbeitet Chat-Nachrichten asynchron.
    </p>
    <ul>
        <li><strong>Funktionsweise:</strong> 
            Prüft über den <code>PromptManager</code>, ob der Spieler gerade eine Eingabe für ein System (z.B. ein Admin-Menü oder ein Quest-Dialog) tätigen muss. 
            Falls ja, wird das Event abgebrochen, um die Nachricht nicht im öffentlichen Chat anzuzeigen.
        </li>
    </ul>

    <h4><code>onWandUse(PlayerInteractEvent event)</code></h4>
    <p>
        Ermöglicht Administratoren die Nutzung eines "Editor-Stabs" (Wand).
    </p>
    <ul>
        <li><strong>Funktionsweise:</strong> 
            Wenn ein Spieler mit der Berechtigung <code>rpg.editor</code> einen speziell markierten Stick (Wand) benutzt, kann er durch Links- oder Rechtsklick auf Blöcke zwei Positionen (Pos1 und Pos2) markieren. 
            Diese Koordinaten werden im <code>PersistentDataContainer</code> des Spielers gespeichert.
        </li>
    </ul>

    <h4><code>freeze(Player player)</code> (Privat)</h4>
    <p>
        Setzt den Spieler in einen Wartezustand.
    </p>
    <ul>
        <li><strong>Details:</strong> Speichert die aktuelle Lauf- und Fluggeschwindigkeit zwischen und setzt diese auf 0. Zudem wird der Spieler unverwundbar gemacht und die Kollision deaktiviert.</li>
    </ul>

    <h4><code>unfreeze(Player player)</code> (Privat)</h4>
    <p>
        Hebt den Wartezustand eines Spielers auf.
    </p>
    <ul>
        <li><strong>Details:</strong> Stellt die ursprünglichen Geschwindigkeitswerte wieder her und reaktiviert Verwundbarkeit sowie Kollision.</li>
    </ul>

    <h4><code>serializeLocation(org.bukkit.Location location)</code> (Privat)</h4>
    <p>
        Hilfsmethode zur Serialisierung von Standortdaten.
    </p>
    <ul>
        <li><strong>Rückgabewert:</strong> Ein String im Format <code>Weltname,X,Y,Z</code>.</li>
    </ul>

    <h3>Interne Statusverwaltung</h3>
    <ul>
        <li><code>walkSpeed</code>: Map zur temporären Speicherung der Laufgeschwindigkeit während des Ladevorgangs.</li>
        <li><code>flySpeed</code>: Map zur temporären Speicherung der Fluggeschwindigkeit während des Ladevorgangs.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ProfessionListener.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ProfessionListener.java</h2>
    <p>
        Die Klasse <code>ProfessionListener</code> ist eine Listener-Komponente für das RPG-System. Sie überwacht Spielerinteraktionen wie das Abbauen von Blöcken und das Herstellen von Gegenständen, um Erfahrungspunkte (XP) in verschiedenen Berufen (Professions) zu vergeben oder Level-Beschränkungen durchzusetzen.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Name:</strong> <code>ProfessionListener</code></li>
        <li><strong>Implementiert:</strong> <code>org.bukkit.event.Listener</code></li>
        <li><strong>Zweck:</strong> Verknüpfung von Spielwelt-Ereignissen mit dem Berufe-System (Mining, Herbalism, Blacksmithing).</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>ProfessionListener(RPGPlugin plugin)</code></h4>
    <p>Der Konstruktor initialisiert den Listener mit der Hauptinstanz des Plugins.</p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>plugin</code>: Die Instanz des <code>RPGPlugin</code>, um auf Manager wie <code>ProfessionManager</code> zuzugreifen.</li>
            </ul>
        </li>
    </ul>

    <h4><code>onBlockBreak(BlockBreakEvent event)</code></h4>
    <p>
        Diese Methode wird aufgerufen, wenn ein Spieler einen Block abbaut. Sie prüft, ob der abgebaute Block Erfahrungspunkte für die Berufe "Mining" (Bergbau) oder "Herbalism" (Kräuterkunde) gewährt.
    </p>
    <ul>
        <li><strong>Event-Typ:</strong> <code>BlockBreakEvent</code></li>
        <li><strong>Logik:</strong>
            <ul>
                <li>Ignoriert bereits abgebrochene Events.</li>
                <li>Ermittelt den Materialtyp des Blocks.</li>
                <li>Fragt beim <code>ProfessionManager</code> ab, ob für dieses Material XP hinterlegt sind.</li>
                <li>Vergibt die entsprechenden XP an das <code>PlayerProfile</code> des Spielers.</li>
            </ul>
        </li>
    </ul>

    <h4><code>onCraft(CraftItemEvent event)</code></h4>
    <p>
        Diese Methode wird ausgelöst, wenn ein Spieler einen Gegenstand herstellt. Sie verwaltet den Beruf "Blacksmithing" (Schmiedekunst).
    </p>
    <ul>
        <li><strong>Event-Typ:</strong> <code>CraftItemEvent</code></li>
        <li><strong>Logik:</strong>
            <ul>
                <li>Prüft, ob der Akteur ein Spieler ist und ob ein gültiges Item-Resultat vorliegt.</li>
                <li>Überprüft, ob für das Herstellen des Gegenstands ein bestimmtes Schmiede-Level erforderlich ist.</li>
                <li>Falls das Level des Spielers nicht ausreicht, wird das Event abgebrochen und eine Fehlermeldung gesendet.</li>
                <li>Bei Erfolg werden dem Spieler XP für den Beruf "Blacksmithing" gutgeschrieben, sofern für das Item XP definiert sind.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Zugriff auf Daten- und Berufs-Manager.</li>
        <li><code>PlayerProfile</code>: Repräsentation der RPG-Daten des Spielers.</li>
        <li><code>ProfessionManager</code>: Zentrale Logik für XP-Berechnung und Level-Abfragen.</li>
        <li><code>Text</code>: Utility-Klasse für formatierte Chat-Nachrichten (MiniMessage).</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/SkillHotbarListener.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/SkillHotbarListener.java</h2>

    <p>
        Die Klasse <code>SkillHotbarListener</code> ist eine Listener-Komponente für das Bukkit-Framework. 
        Ihre Hauptaufgabe besteht darin, Spielerinteraktionen abzufangen und zu prüfen, ob der Spieler versucht, eine Fähigkeit (Skill) über die Hotbar auszulösen.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        <strong>Name:</strong> <code>SkillHotbarListener</code><br>
        <strong>Implementiert:</strong> <code>org.bukkit.event.Listener</code><br>
        <strong>Zweck:</strong> Überwachung von Rechtsklicks in der Hotbar zur Aktivierung gebundener Fähigkeiten.
    </p>

    <h3>Konstruktor</h3>
    <ul>
        <li>
            <code>SkillHotbarListener(RPGPlugin plugin)</code>: Initialisiert den Listener mit einer Instanz des Haupt-Plugins, um Zugriff auf die Manager-Klassen (PlayerData, SkillHotbar, etc.) zu erhalten.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>onInteract(PlayerInteractEvent event)</code>
            <p>
                Diese Methode wird bei jeder Interaktion eines Spielers (Rechtsklick/Linksklick auf Luft oder Blöcke) aufgerufen.
            </p>
            <p><strong>Logik:</strong></p>
            <ul>
                <li>Prüft, ob die Interaktion mit der Haupthand (<code>EquipmentSlot.HAND</code>) durchgeführt wurde.</li>
                <li>Filtert nach Rechtsklicks (<code>RIGHT_CLICK_AIR</code> oder <code>RIGHT_CLICK_BLOCK</code>).</li>
                <li>Ermittelt den aktuell ausgewählten Slot in der Hotbar des Spielers (indexiert von 1 bis 9).</li>
                <li>Ruft das <code>PlayerProfile</code> des Spielers über den <code>PlayerDataManager</code> ab.</li>
                <li>Fragt den <code>SkillHotbarManager</code> ab, ob für den aktuellen Slot und das Profil eine <code>skillId</code> hinterlegt ist.</li>
                <li>Falls eine gültige <code>skillId</code> gefunden wird, wird die Methode <code>plugin.useSkill(player, skillId)</code> aufgerufen, um die Fähigkeit auszuführen.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>RPGPlugin</code>: Zentraler Einstiegspunkt für die Plugin-Logik.</li>
        <li><code>PlayerDataManager</code>: Zum Abrufen von Spielerprofilen.</li>
        <li><code>SkillHotbarManager</code>: Zur Verwaltung der Tastenbelegungen (Bindings) zwischen Hotbar-Slots und Skills.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ZoneListener.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/listener/ZoneListener.java</h2>
    <p>
        Die Klasse <code>ZoneListener</code> ist eine Event-Listener-Komponente für den Minecraft-Server (Bukkit/Spigot API). 
        Ihre Hauptaufgabe besteht darin, die Bewegungen von Spielern zu überwachen, um festzustellen, wann sie definierte RPG-Zonen betreten oder verlassen. 
        Dies triggert visuelle Benachrichtigungen, Statuseffekte und Quest-Fortschritte.
    </p>

    <h3>Klasse: ZoneListener</h3>
    <p>
        Implementiert das <code>Listener</code>-Interface und verwaltet den Zustand der aktuellen Aufenthaltsorte aller aktiven Spieler.
    </p>

    <h4>Felder</h4>
    <ul>
        <li><code>plugin</code> (RPGPlugin): Eine Referenz auf das Haupt-Plugin für den Zugriff auf Manager (Zone, PlayerData, Quest).</li>
        <li><code>lastZone</code> (Map&lt;UUID, String&gt;): Speichert die ID der letzten Zone, in der sich ein Spieler befand, um redundante Benachrichtigungen bei jeder kleinen Bewegung zu vermeiden.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>onMove(PlayerMoveEvent event)</code>
            <p>
                Diese Methode wird bei jeder Bewegung eines Spielers aufgerufen. Sie prüft, ob der Spieler eine Zonengrenze überschritten hat.
            </p>
            <ul>
                <li><strong>Logik:</strong> Vergleicht die Zone am Zielort (<code>event.getTo()</code>) mit der zuletzt gespeicherten Zone des Spielers.</li>
                <li><strong>Aktionen beim Betreten:</strong> Sendet eine Nachricht in Aqua-Farbe, wendet ggf. einen Verlangsamungseffekt (Slow) an, falls die Zone einen <code>slowMultiplier</code> &lt; 1.0 besitzt, und prüft Quest-Bedingungen.</li>
                <li><strong>Aktionen beim Verlassen:</strong> Sendet eine graue Nachricht an den Spieler.</li>
            </ul>
        </li>
        <li>
            <code>handleExploreQuests(Player player, Zone zone)</code>
            <p>
                Eine private Hilfsmethode, die den Fortschritt von Erkundungs-Quests aktualisiert.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>player</code> (Der betroffene Spieler), <code>zone</code> (Die betretene Zone).</li>
                <li><strong>Funktionsweise:</strong> Durchläuft alle aktiven Quests des Spielers. Wenn ein Quest-Schritt vom Typ <code>EXPLORE</code> ist und die Ziel-ID mit der ID der betretenen Zone übereinstimmt, wird der Fortschritt erhöht. Abschließend wird geprüft, ob die Quest dadurch abgeschlossen werden kann.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>ZoneManager</code>: Zur Bestimmung der Zone an einer bestimmten Koordinate.</li>
        <li><code>PlayerDataManager</code> &amp; <code>PlayerProfile</code>: Zum Abrufen und Speichern von Quest-Fortschritten.</li>
        <li><code>QuestManager</code>: Zum Validieren von Quest-Daten.</li>
        <li><code>Bukkit API</code>: Verwendung von <code>PlayerMoveEvent</code>, <code>PotionEffect</code> und <code>ChatColor</code>.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ArenaManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ArenaManager.java</h2>
    <p>
        Der <code>ArenaManager</code> ist eine zentrale Komponente des RPG-Plugins, die für die Verwaltung von PvP-Arenen, die Warteschlange der Spieler und die Berechnung von ELO-Rankings zuständig ist. Er steuert den gesamten Lebenszyklus eines PvP-Matches, von der Anmeldung bis zur Ergebnisverarbeitung.
    </p>

    <h3>Klasse: ArenaManager</h3>
    <p>
        Diese Klasse verwaltet die Instanzen der Arenen, ordnet Spieler laufenden Kämpfen zu und persistiert Arena-Daten in einer Konfigurationsdatei.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public ArenaManager(RPGPlugin plugin)</code>
            <p>Initialisiert den Manager, lädt die <code>arenas.yml</code> und erstellt Standardwerte, falls die Datei nicht existiert.</p>
        </li>
        <li>
            <code>public void joinQueue(Player player)</code>
            <p>
                Fügt einen Spieler der PvP-Warteschlange hinzu. Prüft vorher, ob der Spieler bereits in einer Arena oder in der Warteschlange ist. Startet automatisch einen Match-Check.
            </p>
        </li>
        <li>
            <code>public void removeFromQueue(Player player)</code>
            <p>Entfernt einen Spieler manuell aus der Warteschlange.</p>
        </li>
        <li>
            <code>public Optional&lt;Arena&gt; arenaFor(Player player)</code>
            <p>Gibt die Arena zurück, in der sich der Spieler aktuell befindet, sofern vorhanden.</p>
        </li>
        <li>
            <code>public void handleDeath(Player loser)</code>
            <p>
                Wird aufgerufen, wenn ein Spieler in einer Arena stirbt. Identifiziert den Gewinner und leitet das Ende des Matches ein.
            </p>
        </li>
        <li>
            <code>public List&lt;PlayerProfile&gt; topPlayers(int limit)</code>
            <p>
                Gibt eine Liste der Spielerprofile zurück, sortiert nach deren ELO-Wert absteigend, begrenzt durch das angegebene Limit.
            </p>
        </li>
        <li>
            <code>private void tryStartMatch()</code>
            <p>
                Prüft, ob genügend Spieler in der Warteschlange sind und eine Arena im Status <code>WAITING</code> verfügbar ist. Wenn ja, werden die Spieler teleportiert und das Match gestartet.
            </p>
        </li>
        <li>
            <code>private void endMatch(Arena arena, Player winner, Player loser)</code>
            <p>
                Beendet ein Match, berechnet die neuen ELO-Werte für beide Kontrahenten mittels <code>EloCalculator</code>, speichert die Profile und setzt die Arena zurück.
            </p>
        </li>
        <li>
            <code>private void teleportPlayers(Arena arena, Player p1, Player p2)</code>
            <p>Teleportiert beide Spieler an die in der Arena-Konfiguration definierten Spawn-Punkte.</p>
        </li>
        <li>
            <code>private void load()</code>
            <p>Lädt alle Arena-Definitionen aus der <code>arenas.yml</code> in den Arbeitsspeicher.</p>
        </li>
        <li>
            <code>private void save()</code>
            <p>Speichert die aktuelle Konfiguration physisch auf der Festplatte.</p>
        </li>
    </ul>

    <h4>Datenstrukturen</h4>
    <ul>
        <li><code>Map&lt;String, Arena&gt; arenas</code>: Speichert alle verfügbaren Arenen anhand ihrer ID.</li>
        <li><code>Map&lt;UUID, Arena&gt; arenaByPlayer</code>: Schneller Zugriff, um zu prüfen, welcher Spieler welcher Arena zugeordnet ist.</li>
        <li><code>Queue&lt;UUID&gt; queue</code>: Eine FIFO-Warteschlange für Spieler, die auf einen Kampf warten.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/AuctionHouseManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/AuctionHouseManager.java</h2>
    <p>
        Der <code>AuctionHouseManager</code> ist eine zentrale Verwaltungskomponente für das Auktionshaus-System des RPG-Plugins. 
        Er ist verantwortlich für das Erstellen, Speichern, Laden und Löschen von Verkaufsangeboten (Auction Listings). 
        Die Daten werden persistent in einer Datei namens <code>auctions.yml</code> im Datenordner des Plugins gespeichert.
    </p>

    <h3>Klasse: AuctionHouseManager</h3>
    <p>Diese Klasse verwaltet den Lebenszyklus von Auktionsangeboten und bietet Hilfsmethoden zur Serialisierung von Minecraft-Items.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>AuctionHouseManager(JavaPlugin plugin)</code>: Initialisiert den Manager, erstellt die Referenz zur <code>auctions.yml</code> und lädt bestehende Auktionen aus der Konfiguration.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>listings()</code>: 
            Gibt eine <code>Map&lt;String, AuctionListing&gt;</code> aller aktuell aktiven Auktionsangebote zurück.
        </li>
        <li>
            <code>getListing(String id)</code>: 
            Sucht ein spezifisches Auktionsangebot anhand seiner eindeutigen ID.
            <br><strong>Rückgabewert:</strong> Das <code>AuctionListing</code> oder <code>null</code>, falls nicht gefunden.
        </li>
        <li>
            <code>addListing(AuctionListing listing)</code>: 
            Fügt ein neues Angebot zur internen Map hinzu und speichert es sofort in der Konfigurationsdatei.
        </li>
        <li>
            <code>removeListing(String id)</code>: 
            Entfernt ein Angebot aus der Map und löscht den entsprechenden Eintrag aus der <code>auctions.yml</code>.
        </li>
        <li>
            <code>saveListing(AuctionListing listing)</code>: 
            Überträgt die Daten eines <code>AuctionListing</code>-Objekts in die YAML-Konfiguration. Gespeichert werden der Verkäufer (UUID), der Preis und die serialisierten Item-Daten.
        </li>
        <li>
            <code>serializeItem(ItemStack item)</code>: 
            Konvertiert ein <code>ItemStack</code>-Objekt in einen Base64-kodierten String. Dies ermöglicht das Speichern komplexer Item-Metadaten (Verzauberungen, Lore, etc.) in einer Textdatei.
            <br><strong>Parameter:</strong> <code>item</code> - Das zu serialisierende Item.
            <br><strong>Rückgabewert:</strong> Base64-String oder <code>null</code> bei Fehlern.
        </li>
        <li>
            <code>deserializeItem(String data)</code>: 
            Rekonstruiert ein <code>ItemStack</code> aus einem Base64-kodierten String.
            <br><strong>Parameter:</strong> <code>data</code> - Der serialisierte String.
            <br><strong>Rückgabewert:</strong> Das <code>ItemStack</code>-Objekt oder <code>null</code> bei Fehlern.
        </li>
        <li>
            <code>load()</code> (privat): 
            Liest alle Einträge aus der <code>auctions.yml</code> ein und instanziiert die entsprechenden <code>AuctionListing</code>-Objekte.
        </li>
        <li>
            <code>save()</code> (privat): 
            Schreibt den aktuellen Stand der <code>YamlConfiguration</code> physisch auf die Festplatte.
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>com.example.rpg.model.AuctionListing</code>: Datenmodell für ein einzelnes Angebot.</li>
        <li><code>org.bukkit.configuration.file.YamlConfiguration</code>: Zur Handhabung der Datenspeicherung im YAML-Format.</li>
        <li><code>org.bukkit.util.io.BukkitObjectInputStream/OutputStream</code>: Zur binären Serialisierung von Minecraft-Gegenständen.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/BehaviorTreeManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/BehaviorTreeManager.java</h2>
    <p>
        Der <code>BehaviorTreeManager</code> ist eine zentrale Verwaltungskomponente für die Künstliche Intelligenz (KI) von Mobs im RPG-System. 
        Er ist verantwortlich für das Laden, Parsen und Bereitstellen von Verhaltensbäumen (Behavior Trees), die über YAML-Konfigurationsdateien definiert werden.
    </p>

    <h3>Klasse: BehaviorTreeManager</h3>
    <p>
        Diese Klasse verwaltet eine Sammlung von <code>BehaviorNode</code>-Strukturen, die das Entscheidungsverhalten von Entitäten steuern.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>BehaviorTreeManager(JavaPlugin plugin)</code>: Initialisiert den Manager, erstellt den Ordner <code>behaviors</code> im Plugin-Verzeichnis, 
            erzeugt bei Bedarf eine Beispielkonfiguration für den "Skeleton King" und lädt alle vorhandenen Verhaltensbäume.
        </li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>getTree(String name)</code>: Ruft einen geladenen Verhaltensbaum anhand seines Namens ab.
            <ul>
                <li><strong>Parameter:</strong> <code>name</code> - Der Name der YAML-Datei (ohne Endung).</li>
                <li><strong>Rückgabewert:</strong> Der entsprechende <code>BehaviorNode</code> oder ein Standard-Baum (Default Tree), falls der Name nicht gefunden wurde.</li>
            </ul>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>loadAll()</code>: Durchsucht das Verzeichnis nach <code>.yml</code> Dateien und deserialisiert diese in ausführbare Knotenstrukturen.
        </li>
        <li>
            <code>parseNode(ConfigurationSection section, String fallbackId)</code>: Extrahiert den Knotentyp und die ID aus einer Konfigurationssektion.
        </li>
        <li>
            <code>buildNode(String type, String id, ConfigurationSection section)</code>: Eine Factory-Methode, die basierend auf dem Typ-String die entsprechende Implementierung von <code>BehaviorNode</code> instanziiert. Unterstützte Typen sind unter anderem:
            <ul>
                <li><code>selector</code>, <code>sequence</code> (Composite Nodes)</li>
                <li><code>inverter</code>, <code>cooldown</code> (Decorator Nodes)</li>
                <li><code>melee_attack</code>, <code>cast_skill</code>, <code>flee</code>, <code>heal_self</code>, <code>walk_to_target</code> (Action Nodes)</li>
                <li><code>health_below</code>, <code>target_distance_above</code> (Condition Nodes)</li>
            </ul>
        </li>
        <li>
            <code>buildComposite(CompositeNode node, ConfigurationSection section)</code>: Hilfsmethode zum rekursiven Aufbau von zusammengesetzten Knoten (Selector/Sequence) und deren Kindknoten.
        </li>
        <li>
            <code>defaultTree()</code>: Erstellt einen einfachen Standard-Verhaltensbaum, der Mobs dazu veranlasst, das Ziel zu verfolgen und im Nahkampf anzugreifen.
        </li>
        <li>
            <code>seedSkeletonKing()</code>: Generiert eine beispielhafte <code>skeleton_king.yml</code> Datei, falls diese noch nicht existiert. Dieser Baum demonstriert komplexe Logik wie Heilung bei niedriger Gesundheit und Fernkampfangriffe bei Distanz.
        </li>
    </ul>

    <h4>Datenstruktur</h4>
    <p>
        Die Verhaltensbäume werden in einer <code>Map&lt;String, BehaviorNode&gt;</code> gespeichert, wobei der Schlüssel der Dateiname der Konfiguration ist.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ClassManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ClassManager.java</h2>
    <p>
        Der <code>ClassManager</code> ist eine zentrale Verwaltungskomponente innerhalb des RPG-Plugins. Er ist verantwortlich für das Laden, Speichern und Bereitstellen der verschiedenen Charakterklassen (z. B. Krieger, Magier), die in einer YAML-Konfigurationsdatei definiert sind.
    </p>

    <h3>Klasse: ClassManager</h3>
    <p>
        Diese Klasse verwaltet die Instanzen von <code>ClassDefinition</code> und synchronisiert diese mit der Datei <code>classes.yml</code> im Datenordner des Plugins.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>public ClassManager(JavaPlugin plugin)</code>: Initialisiert den Manager, lädt die Konfigurationsdatei und erstellt Standardwerte (Seeding), falls die Datei noch nicht existiert.
        </li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>public ClassDefinition getClass(String id)</code>: 
            Sucht eine Klasse anhand ihrer eindeutigen ID.
            <br><strong>Rückgabewert:</strong> Die <code>ClassDefinition</code> oder <code>null</code>, falls nicht gefunden.
        </li>
        <li>
            <code>public Map&lt;String, ClassDefinition&gt; classes()</code>: 
            Gibt eine Map aller aktuell geladenen Klassen zurück.
        </li>
        <li>
            <code>public void saveClass(ClassDefinition definition)</code>: 
            Überträgt die Daten einer spezifischen Klassendefinition in die Konfiguration und speichert die Datei.
        </li>
        <li>
            <code>public void saveAll()</code>: 
            Bereinigt die aktuelle Konfiguration und schreibt alle im Speicher befindlichen Klassen erneut in die Datei.
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>private void load()</code>: 
            Liest alle Klassendefinitionen aus der <code>classes.yml</code> ein und füllt die interne Map.
        </li>
        <li>
            <code>private void seedDefaults()</code>: 
            Erstellt initiale Standardklassen (Krieger, Ranger, Magier) mit vordefinierten Start-Skills, um eine Grundkonfiguration bereitzustellen.
        </li>
        <li>
            <code>private void save()</code>: 
            Führt den eigentlichen Schreibvorgang auf die Festplatte durch und fängt potenzielle <code>IOException</code>-Fehler ab.
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>com.example.rpg.model.ClassDefinition</code>: Das Datenmodell für eine Klasse.</li>
        <li><code>org.bukkit.configuration.file.YamlConfiguration</code>: Zur Handhabung der YAML-basierten Speicherung.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/DungeonManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/DungeonManager.java</h2>
    <p>
        Der <code>DungeonManager</code> ist eine zentrale Verwaltungskomponente des RPG-Plugins, die für die Erstellung, den Zugriff und die Lebenszyklus-Steuerung von Dungeon-Instanzen verantwortlich ist. Er koordiniert den Transport von Spielern in Dungeons, speichert Rückkehrpunkte und verwaltet die dynamische Generierung von Welten.
    </p>

    <h3>Klasse: DungeonManager</h3>
    <p>
        Diese Klasse fungiert als Schnittstelle zwischen den Spielern und dem Dungeon-System. Sie nutzt den <code>DungeonGenerator</code>, um neue Instanzen zu erzeugen, und hält eine Liste aller aktiven Instanzen vor.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public DungeonManager(RPGPlugin plugin)</code>
            <p>Konstruktor der Klasse. Initialisiert den Dungeon-Generator und lädt die Konfigurationsdaten für Ein- und Ausgänge.</p>
        </li>
        <li>
            <code>public Location getEntrance()</code>
            <p>Gibt den in der Konfiguration definierten globalen Eingangspunkt für Dungeons zurück.</p>
        </li>
        <li>
            <code>public void enterDungeon(Player player)</code>
            <p>Teleportiert einen Spieler zum Dungeon-Eingang und speichert seine aktuelle Position als Rückkehrpunkt in der <code>returnLocations</code>-Map.</p>
        </li>
        <li>
            <code>public void leaveDungeon(Player player)</code>
            <p>Entfernt den Spieler aus der Dungeon-Instanz. Der Spieler wird bevorzugt an seinen ursprünglichen Rückkehrpunkt teleportiert. Falls dieser nicht existiert, wird der globale Ausgang oder der Welt-Spawn genutzt.</p>
        </li>
        <li>
            <code>public void generateDungeon(Player player, String theme, List&lt;Player&gt; party)</code>
            <p>
                Initiiert die Generierung eines neuen Dungeons für eine Gruppe von Spielern. 
                Unterstützt verschiedene Generierungsmodi (z. B. "wfc" für Wave Function Collapse). 
                Nach der Generierung wird ein automatischer Timer (15 Minuten) gestartet, um den Dungeon wieder zu schließen.
            </p>
            <ul>
                <li><strong>player:</strong> Der auslösende Spieler.</li>
                <li><strong>theme:</strong> Das visuelle oder strukturelle Thema des Dungeons.</li>
                <li><strong>party:</strong> Eine Liste der Spieler, die den Dungeon betreten sollen.</li>
            </ul>
        </li>
        <li>
            <code>public void closeDungeon(DungeonInstance instance)</code>
            <p>Schließt eine spezifische Dungeon-Instanz, entfernt alle verknüpften Spieler-Referenzen und löscht die temporäre Welt mithilfe von <code>WorldUtils</code>.</p>
        </li>
        <li>
            <code>public void shutdown()</code>
            <p>Wird beim Deaktivieren des Plugins aufgerufen. Schließt alle aktiven Dungeons und bereinigt die Welten, um Datenmüll zu vermeiden.</p>
        </li>
        <li>
            <code>private void load()</code>
            <p>Lädt die Koordinaten für den globalen Dungeon-Eingang und -Ausgang aus der <code>config.yml</code> des Plugins.</p>
        </li>
    </ul>

    <h4>Interne Datenstrukturen</h4>
    <ul>
        <li><code>returnLocations</code>: Speichert die ursprüngliche Position eines Spielers vor dem Betreten eines Dungeons (Key: UUID des Spielers).</li>
        <li><code>activeInstances</code>: Verknüpft Spieler-UUIDs mit ihrer aktuell zugewiesenen <code>DungeonInstance</code>.</li>
        <li><code>allInstances</code>: Eine Liste aller derzeit existierenden Dungeon-Instanzen zur globalen Verwaltung.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/FactionManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/FactionManager.java</h2>
    <p>
        Der <code>FactionManager</code> ist eine zentrale Verwaltungskomponente für das Fraktionssystem des RPG-Plugins. 
        Er ist verantwortlich für das Laden, Speichern und Bereitstellen von Fraktionsdaten aus einer YAML-Konfigurationsdatei (<code>factions.yml</code>).
    </p>

    <h3>Klasse: FactionManager</h3>
    <p>
        Diese Klasse verwaltet eine Sammlung von <code>Faction</code>-Objekten und synchronisiert diese mit dem Dateisystem.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>FactionManager(JavaPlugin plugin)</code>: Initialisiert den Manager, erstellt die <code>factions.yml</code> falls sie nicht existiert, 
            befüllt sie gegebenenfalls mit Standardwerten und lädt die vorhandenen Fraktionen in den Speicher.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public Faction getFaction(String id)</code>: 
            Sucht eine Fraktion anhand ihrer eindeutigen ID.
            <br><strong>Parameter:</strong> <code>id</code> - Die ID der gesuchten Fraktion.
            <br><strong>Rückgabewert:</strong> Das <code>Faction</code>-Objekt oder <code>null</code>, falls nicht gefunden.
        </li>
        <li>
            <code>public Map&lt;String, Faction&gt; factions()</code>: 
            Gibt eine Map aller aktuell geladenen Fraktionen zurück.
            <br><strong>Rückgabewert:</strong> Eine Map mit Fraktions-IDs als Schlüssel und <code>Faction</code>-Objekten als Werte.
        </li>
        <li>
            <code>public void saveFaction(Faction faction)</code>: 
            Speichert eine einzelne Fraktion in der Konfigurationsdatei und schreibt die Änderungen auf die Festplatte.
            <br><strong>Parameter:</strong> <code>faction</code> - Das zu speichernde Fraktionsobjekt.
        </li>
        <li>
            <code>public void saveAll()</code>: 
            Bereinigt die aktuelle Konfiguration und speichert alle im Speicher befindlichen Fraktionen erneut in die Datei.
        </li>
        <li>
            <code>private void load()</code>: 
            Liest alle Fraktionsdaten aus der <code>factions.yml</code> aus und instanziiert die entsprechenden <code>Faction</code>-Objekte.
        </li>
        <li>
            <code>private void seedDefaults()</code>: 
            Erstellt eine Standardfraktion ("Abenteurergilde"), falls die Konfigurationsdatei neu angelegt wurde.
        </li>
        <li>
            <code>private void save()</code>: 
            Interne Hilfsmethode, die die <code>YamlConfiguration</code> physisch in der Datei speichert und mögliche <code>IOException</code>-Fehler abfängt.
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>com.example.rpg.model.Faction</code>: Das Datenmodell für eine Fraktion.</li>
        <li><code>org.bukkit.configuration.file.YamlConfiguration</code>: Zur Handhabung der YAML-basierten Speicherung.</li>
        <li><code>org.bukkit.plugin.java.JavaPlugin</code>: Zugriff auf den Datenordner und Logger des Plugins.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/GuildManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/GuildManager.java</h2>
    <p>Der <code>GuildManager</code> ist eine zentrale Verwaltungskomponente für das Gilden-System des RPG-Plugins. Er ist verantwortlich für das Erstellen, Auflösen, Speichern und Laden von Gilden sowie für die Verwaltung von Mitgliedschaften, Rollen und der Gildenbank.</p>

    <h3>Klasse: GuildManager</h3>
    <p>Diese Klasse verwaltet die Laufzeitdaten aller Gilden und synchronisiert diese mit der Konfigurationsdatei <code>guilds.yml</code>.</p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>public GuildManager(RPGPlugin plugin)</code>
            <p>Konstruktor, der den Manager initialisiert, die Datei <code>guilds.yml</code> lädt und die Gilden-Daten in den Speicher einliest.</p>
        </li>
        <li>
            <code>public Optional&lt;Guild&gt; guildById(String id)</code>
            <p>Sucht eine Gilde anhand ihrer eindeutigen ID.</p>
            <p><strong>Rückgabewert:</strong> Ein <code>Optional</code>, das die Gilde enthält oder leer ist.</p>
        </li>
        <li>
            <code>public Optional&lt;Guild&gt; guildFor(UUID member)</code>
            <p>Ermittelt die Gilde, in der ein bestimmter Spieler Mitglied ist.</p>
            <p><strong>Parameter:</strong> <code>member</code> - Die UUID des Spielers.</p>
        </li>
        <li>
            <code>public void createGuild(String id, String name, Player leader)</code>
            <p>Erstellt eine neue Gilde mit dem angegebenen Namen und setzt den Ersteller als Anführer (Leader). Aktualisiert zudem das Spielerprofil.</p>
        </li>
        <li>
            <code>public void disbandGuild(Guild guild)</code>
            <p>Löst eine Gilde vollständig auf, entfernt alle Mitglieder und löscht die Daten aus der Konfiguration.</p>
        </li>
        <li>
            <code>public void invite(UUID target, String guildId)</code>
            <p>Registriert eine ausstehende Einladung für einen Spieler zu einer bestimmten Gilde.</p>
        </li>
        <li>
            <code>public Optional&lt;Guild&gt; acceptInvite(UUID playerId)</code>
            <p>Lässt einen Spieler einer Gilde beitreten, sofern eine Einladung vorliegt. Aktualisiert die Mitgliederliste und das Spielerprofil.</p>
        </li>
        <li>
            <code>public void leaveGuild(UUID member)</code>
            <p>Entfernt einen Spieler aus seiner aktuellen Gilde. Falls der Anführer die Gilde verlässt, wird die Gilde automatisch aufgelöst.</p>
        </li>
        <li>
            <code>public void setRole(Guild guild, UUID member, GuildMemberRole role)</code>
            <p>Ändert den Rang eines Mitglieds innerhalb einer Gilde (z. B. Beförderung zum Offizier).</p>
        </li>
        <li>
            <code>public void deposit(Guild guild, int amount)</code>
            <p>Zahlt einen Goldbetrag in die Gildenbank ein.</p>
        </li>
        <li>
            <code>public boolean withdraw(Guild guild, int amount)</code>
            <p>Hebt Gold von der Gildenbank ab, sofern ausreichend Guthaben vorhanden ist.</p>
            <p><strong>Rückgabewert:</strong> <code>true</code>, wenn die Abhebung erfolgreich war, sonst <code>false</code>.</p>
        </li>
        <li>
            <code>public void saveAll()</code>
            <p>Speichert alle aktuell geladenen Gilden und deren Fortschritt (inkl. Quests) permanent in der YAML-Datei.</p>
        </li>
    </ul>

    <h4>Interne Logik:</h4>
    <ul>
        <li><code>load()</code>: Liest die gesamte <code>guilds.yml</code> aus, rekonstruiert die <code>Guild</code>-Objekte und stellt die Verknüpfungen zwischen Spieler-UUIDs und Gilden-IDs wieder her.</li>
        <li><code>saveGuild(Guild guild)</code>: Serialisiert eine einzelne Gilde inklusive ihrer Mitgliederliste und dem Status der Gilden-Quests in die Konfigurationssektion.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ItemStatManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ItemStatManager.java</h2>
    <p>
        Der <code>ItemStatManager</code> ist eine zentrale Komponente des RPG-Systems, die für die Verwaltung, Generierung und Anwendung von Attributen (Stats) und Set-Boni auf Gegenständen (ItemStacks) verantwortlich ist. Er nutzt den <code>PersistentDataContainer</code> von Bukkit, um Daten dauerhaft auf Items zu speichern.
    </p>

    <h3>Klasse: ItemStatManager</h3>
    <p>
        Diese Klasse verwaltet die NamespacedKeys für verschiedene Attribute und definiert die Logik für zufällige Item-Affixe sowie Set-Effekte.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>ItemStatManager(JavaPlugin plugin)</code>: Initialisiert die NamespacedKeys für Stärke, kritische Trefferchance, Lebenspunkte und Set-IDs unter Verwendung der Plugin-Instanz.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public void applyAffixes(ItemStack item)</code>
            <p>
                Verleiht einem Gegenstand zufällige Präfixe, Suffixe und RPG-Attribute. 
                Dabei werden zufällige Werte für Stärke, Krit-Chance und Leben generiert und im <code>PersistentDataContainer</code> des Items gespeichert. Zudem wird dem Item eine zufällige Set-ID zugewiesen.
            </p>
        </li>
        <li>
            <code>public void updateLore(ItemMeta meta)</code>
            <p>
                Aktualisiert die Beschreibung (Lore) eines Items basierend auf den gespeicherten persistenten Daten. 
                Die Attribute werden formatiert (z. B. Prozentanzeige für Krit-Chance) und farblich hervorgehoben dargestellt.
            </p>
        </li>
        <li>
            <code>public void updateSetBonus(Player player)</code>
            <p>
                Überprüft die angelegte Rüstung eines Spielers auf Set-Boni. Wenn ein Spieler vier Teile desselben Sets trägt (z. B. "ember", "guardian" oder "swift"), erhält er einen entsprechenden permanenten Trankeffekt (z. B. Feuerschutz, Resistenz oder Schnelligkeit).
            </p>
        </li>
        <li>
            <code>public NamespacedKey strengthKey() / critKey() / healthKey() / setIdKey()</code>
            <p>Getter-Methoden, die den Zugriff auf die internen <code>NamespacedKey</code>-Objekte ermöglichen, um an anderer Stelle im Plugin auf die Item-Daten zuzugreifen.</p>
        </li>
    </ul>

    <h4>Interne Hilfsmethoden</h4>
    <ul>
        <li><code>private String randomFrom(List&lt;String&gt; values)</code>: Wählt ein zufälliges Element aus einer Liste von Strings aus.</li>
        <li><code>private String prettyName(String material)</code>: Formatiert Materialnamen (z. B. "DIAMOND_SWORD") in eine lesbarere Form ("diamond sword").</li>
    </ul>

    <h4>Definierte Set-Boni</h4>
    <ul>
        <li><strong>ember:</strong> Verleiht <code>FIRE_RESISTANCE</code> (Feuerschutz).</li>
        <li><strong>guardian:</strong> Verleiht <code>DAMAGE_RESISTANCE</code> (Resistenz).</li>
        <li><strong>swift:</strong> Verleiht <code>SPEED</code> (Schnelligkeit).</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/LootManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/LootManager.java</h2>
    <p>Der <code>LootManager</code> ist eine zentrale Verwaltungsklasse innerhalb des RPG-Plugins, die für das Laden, Speichern und Bereitstellen von Beutetabellen (Loot Tables) verantwortlich ist. Er ermöglicht es, Belohnungen für verschiedene Entitäten (z. B. Mobs) über eine Konfigurationsdatei (<code>loot.yml</code>) zu definieren.</p>

    <h3>Klasse: LootManager</h3>
    <p>Diese Klasse verwaltet die Persistenz von Beutedaten unter Verwendung der Bukkit-YAML-Konfiguration.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>LootManager(JavaPlugin plugin)</code>: Initialisiert den Manager, erstellt die <code>loot.yml</code> falls sie nicht existiert, füllt sie ggf. mit Standardwerten (Seeding) und lädt die vorhandenen Tabellen in den Speicher.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public Map&lt;String, LootTable&gt; tables()</code>
            <p>Gibt eine Map aller aktuell geladenen Beutetabellen zurück, wobei die ID der Tabelle als Schlüssel dient.</p>
        </li>
        <li>
            <code>public LootTable getTable(String id)</code>
            <p>Sucht eine spezifische Beutetabelle anhand ihrer eindeutigen ID.</p>
            <p><strong>Parameter:</strong> <code>id</code> - Die ID der Tabelle.</p>
            <p><strong>Rückgabewert:</strong> Die <code>LootTable</code> oder <code>null</code>, falls nicht gefunden.</p>
        </li>
        <li>
            <code>public LootTable getTableFor(String key)</code>
            <p>Sucht eine Beutetabelle basierend auf dem Ziel-Key (z. B. dem Namen eines Mob-Typs wie "ZOMBIE").</p>
            <p><strong>Parameter:</strong> <code>key</code> - Der Bezeichner, für den die Tabelle gelten soll.</p>
            <p><strong>Rückgabewert:</strong> Die erste passende <code>LootTable</code> oder <code>null</code>.</p>
        </li>
        <li>
            <code>public void saveTable(LootTable table)</code>
            <p>Speichert eine einzelne Beutetabelle in der Konfigurationsdatei. Dabei werden alle Einträge (Material, Chance, Mengen, Seltenheit) in eine Map-Struktur umgewandelt.</p>
        </li>
        <li>
            <code>public void saveAll()</code>
            <p>Bereinigt die aktuelle Konfigurationsdatei und schreibt alle im Speicher befindlichen Tabellen erneut hinein.</p>
        </li>
        <li>
            <code>private void load()</code>
            <p>Liest alle Beutetabellen aus der <code>loot.yml</code> aus. Falls Felder fehlen, werden Standardwerte (z. B. "IRON_NUGGET", Chance 0.3) verwendet.</p>
        </li>
        <li>
            <code>private void seedDefaults()</code>
            <p>Erstellt eine initiale Beispiel-Beutetabelle ("forest_mobs" für Zombies), falls keine Datei vorhanden ist.</p>
        </li>
        <li>
            <code>private void save()</code>
            <p>Führt den eigentlichen Schreibvorgang der <code>YamlConfiguration</code> auf die Festplatte aus und fängt mögliche <code>IOException</code>-Fehler ab.</p>
        </li>
    </ul>

    <h3>Datenstruktur in der Konfiguration</h3>
    <p>Die Daten werden in der <code>loot.yml</code> wie folgt strukturiert:</p>
    <pre><code>
ID_DER_TABELLE:
  appliesTo: "ENTITY_NAME"
  entries:
    - material: "MATERIAL_NAME"
      chance: 0.5
      minAmount: 1
      maxAmount: 3
      rarity: "COMMON"
    </code></pre>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/MobManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/MobManager.java</h2>
    <p>
        Die Klasse <code>MobManager</code> ist für die Verwaltung, Speicherung und das Laden von benutzerdefinierten Mob-Definitionen innerhalb des RPG-Plugins verantwortlich. 
        Sie fungiert als Schnittstelle zwischen der persistenten Speicherung in einer YAML-Datei (<code>mobs.yml</code>) und der Laufzeitumgebung des Servers.
    </p>

    <h3>Klasse: MobManager</h3>
    <p>
        Diese Klasse verwaltet eine Sammlung von <code>MobDefinition</code>-Objekten und stellt sicher, dass Standardwerte vorhanden sind, falls keine Konfigurationsdatei existiert.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>MobManager(JavaPlugin plugin)</code>: Initialisiert den Manager, legt den Dateipfad zur <code>mobs.yml</code> fest und lädt die vorhandenen Mob-Daten. 
            Falls die Datei nicht existiert, werden Standard-Mobs (Seed) erstellt.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public MobDefinition getMob(String id)</code>
            <p>Sucht eine Mob-Definition anhand ihrer eindeutigen ID.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>id</code> - Die ID des gesuchten Mobs.</li>
                <li><strong>Rückgabewert:</strong> Das <code>MobDefinition</code>-Objekt oder <code>null</code>, falls nicht gefunden.</li>
            </ul>
        </li>
        <li>
            <code>public Map&lt;String, MobDefinition&gt; mobs()</code>
            <p>Gibt eine Map aller aktuell geladenen Mob-Definitionen zurück.</p>
        </li>
        <li>
            <code>public void saveMob(MobDefinition mob)</code>
            <p>Speichert eine einzelne Mob-Definition in der Konfigurationsdatei. Dabei werden Attribute wie Name, Typ, Gesundheit, Schaden, Ausrüstung, Skills, XP und Loot-Tabellen serialisiert.</p>
        </li>
        <li>
            <code>public void saveAll()</code>
            <p>Bereinigt die aktuelle Konfiguration und speichert alle im Speicher befindlichen Mob-Definitionen erneut in die Datei.</p>
        </li>
        <li>
            <code>private void load()</code>
            <p>Liest alle Mob-Definitionen aus der <code>mobs.yml</code> ein und konvertiert sie in <code>MobDefinition</code>-Objekte. Beinhaltet Standardwerte für fehlende Felder (z.B. Standard-Typ "ZOMBIE").</p>
        </li>
        <li>
            <code>private void seedDefaults()</code>
            <p>Erstellt vordefinierte Beispiel-Mobs (z.B. "Seuchenbringer" und "Skelettkönig"), um eine initiale Konfiguration bereitzustellen.</p>
        </li>
        <li>
            <code>private void save()</code>
            <p>Schreibt den aktuellen Stand der <code>YamlConfiguration</code> physisch auf die Festplatte. Fehler beim Schreibvorgang werden im Plugin-Log protokolliert.</p>
        </li>
    </ul>

    <h4>Verwaltete Datenfelder</h4>
    <ul>
        <li><code>plugin</code>: Referenz auf das Haupt-Plugin (Bukkit/Spigot).</li>
        <li><code>file</code>: Die Datei-Referenz zur <code>mobs.yml</code>.</li>
        <li><code>config</code>: Das <code>YamlConfiguration</code>-Objekt zur Handhabung der YAML-Struktur.</li>
        <li><code>mobs</code>: Eine interne <code>HashMap</code>, die Mob-IDs auf ihre Definitionen mappt.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/NpcManager.java">
    <h2>NpcManager.java</h2>
    <p>Der <code>NpcManager</code> ist eine zentrale Verwaltungskomponente innerhalb des RPG-Plugins. Er ist verantwortlich für das Laden, Speichern, Erstellen und Verwalten von Nicht-Spieler-Charakteren (NPCs) in der Spielwelt. Die Daten werden persistent in einer <code>npcs.yml</code> Datei gespeichert.</p>

    <h3>Klasse: NpcManager</h3>
    <p>Diese Klasse fungiert als Singleton-ähnlicher Manager für alle NPC-bezogenen Operationen.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>NpcManager(JavaPlugin plugin)</code>: Initialisiert den Manager, lädt die Konfigurationsdatei <code>npcs.yml</code> und registriert den <code>NamespacedKey</code> für die Identifizierung von NPC-Entities in der Minecraft-Welt.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>npcKey()</code>: 
            <br><strong>Rückgabewert:</strong> <code>NamespacedKey</code>
            <br>Gibt den Schlüssel zurück, der verwendet wird, um die NPC-ID in den persistenten Daten der Bukkit-Entity zu speichern.
        </li>
        <li>
            <code>npcs()</code>: 
            <br><strong>Rückgabewert:</strong> <code>Map&lt;String, Npc&gt;</code>
            <br>Gibt eine Map aller aktuell geladenen NPCs zurück, indiziert durch ihre ID.
        </li>
        <li>
            <code>getNpc(String id)</code>: 
            <br><strong>Parameter:</strong> <code>id</code> - Die eindeutige Kennung des NPCs.
            <br><strong>Rückgabewert:</strong> <code>Npc</code>
            <br>Sucht einen spezifischen NPC anhand seiner ID.
        </li>
        <li>
            <code>spawnAll()</code>: 
            <br>Iteriert durch alle geladenen NPCs und ruft <code>spawnNpc</code> für jeden Eintrag auf.
        </li>
        <li>
            <code>spawnNpc(Npc npc)</code>: 
            <br><strong>Parameter:</strong> <code>npc</code> - Das zu spawnende NPC-Objekt.
            <br>Erzeugt eine <code>Villager</code>-Entity an der im NPC-Objekt hinterlegten Position. Die Entity wird als unbesiegbar (invulnerable), lautlos (silent) und ohne KI (AI) konfiguriert. Zudem wird die NPC-ID in den <code>PersistentDataContainer</code> der Entity geschrieben.
        </li>
        <li>
            <code>saveNpc(Npc npc)</code>: 
            <br><strong>Parameter:</strong> <code>npc</code> - Das zu speichernde NPC-Objekt.
            <br>Überträgt die Daten eines einzelnen NPCs (Name, Rolle, Position, Dialoge, Quest-Links, Shop-ID) in die YAML-Konfiguration.
        </li>
        <li>
            <code>saveAll()</code>: 
            <br>Bereinigt die aktuelle Konfiguration und speichert alle im Speicher befindlichen NPCs erneut in die Datei.
        </li>
        <li>
            <code>load()</code> (privat): 
            <br>Liest die <code>npcs.yml</code> aus, instanziiert die <code>Npc</code>-Modelle und füllt die interne Map. Verarbeitet dabei auch die Rollen (z.B. QUESTGIVER) und Standortdaten.
        </li>
        <li>
            <code>save()</code> (privat): 
            <br>Schreibt den aktuellen Stand der <code>YamlConfiguration</code> physisch auf die Festplatte.
        </li>
    </ul>

    <h3>Technische Details</h3>
    <ul>
        <li><strong>Entity-Typ:</strong> Aktuell werden alle NPCs als <code>Villager</code> gespawnt.</li>
        <li><strong>Persistenz:</strong> Die Verknüpfung zwischen der Minecraft-Entity und dem Datenmodell erfolgt über die <code>UUID</code> und einen <code>NamespacedKey</code> ("npc_id").</li>
        <li><strong>Datenfelder:</strong> Gespeichert werden unter anderem <code>dialog</code> (Liste von Texten), <code>questLink</code> (Verknüpfung zu Quests) und <code>shopId</code> (Verknüpfung zu einem Shop).</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PartyManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PartyManager.java</h2>
    <p>
        Der <code>PartyManager</code> ist eine zentrale Verwaltungskomponente für das Gruppen-System (Party-System) des RPG-Plugins. 
        Er verwaltet die Zuordnungen zwischen Spielern und ihren jeweiligen Gruppen und stellt Methoden zum Erstellen, Beitreten und Verlassen von Gruppen bereit.
    </p>

    <h3>Klasse: PartyManager</h3>
    <p>
        Diese Klasse nutzt eine interne Map, um den schnellen Zugriff auf die Gruppe eines Spielers anhand seiner <code>UUID</code> zu ermöglichen.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public Party createParty(UUID leader)</code>
            <p>
                Erstellt eine neue Gruppe mit dem angegebenen Spieler als Anführer.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>leader</code> - Die UUID des Spielers, der die Gruppe gründet.</li>
                <li><strong>Rückgabewert:</strong> Das neu erstellte <code>Party</code>-Objekt.</li>
            </ul>
        </li>
        <li>
            <code>public Optional&lt;Party&gt; getParty(UUID member)</code>
            <p>
                Sucht nach der Gruppe, in der der angegebene Spieler aktuell Mitglied ist.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>member</code> - Die UUID des zu suchenden Spielers.</li>
                <li><strong>Rückgabewert:</strong> Ein <code>Optional</code>, das die Gruppe enthält, sofern der Spieler in einer ist.</li>
            </ul>
        </li>
        <li>
            <code>public void addMember(Party party, UUID member)</code>
            <p>
                Fügt einen Spieler einer bestehenden Gruppe hinzu und registriert diese Verbindung im Manager.
            </p>
            <ul>
                <li><strong>Parameter:</strong> 
                    <ul>
                        <li><code>party</code> - Die Zielgruppe.</li>
                        <li><code>member</code> - Die UUID des Spielers, der beitreten soll.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code>public void removeMember(UUID member)</code>
            <p>
                Entfernt einen Spieler aus seiner aktuellen Gruppe. Die Methode enthält Logik für Sonderfälle:
            </p>
            <ul>
                <li>Wenn der Spieler der <strong>Anführer</strong> ist, wird die gesamte Gruppe aufgelöst und alle Mitglieder werden aus der internen Verwaltung entfernt.</li>
                <li>Wenn die Gruppe nach dem Entfernen leer ist, wird sie vollständig gelöscht.</li>
                <li><strong>Parameter:</strong> <code>member</code> - Die UUID des Spielers, der die Gruppe verlassen soll oder entfernt wird.</li>
            </ul>
        </li>
    </ul>

    <h4>Interne Datenstruktur</h4>
    <p>
        <code>private final Map&lt;UUID, Party&gt; partiesByMember</code>: Eine HashMap, die Spieler-UUIDs direkt auf <code>Party</code>-Instanzen mappt, um eine O(1) Abfragezeit für die Gruppenzugehörigkeit zu gewährleisten.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PlayerDataManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/PlayerDataManager.java</h2>
    <p>
        Die Klasse <code>PlayerDataManager</code> ist eine zentrale Verwaltungskomponente für Spielerprofile innerhalb des RPG-Systems. 
        Sie fungiert als Brücke zwischen der Datenbank-Ebene (DAO) und der Laufzeitumgebung des Minecraft-Servers, indem sie Profile im Arbeitsspeicher hält (Caching) und asynchrone Lade- sowie Speichervorgänge koordiniert.
    </p>

    <h3>Klasse: PlayerDataManager</h3>
    <p>
        Verwaltet die Instanzen von <code>PlayerProfile</code> für alle aktiven Spieler und stellt sicher, dass Daten konsistent geladen und gespeichert werden.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>PlayerDataManager(JavaPlugin plugin, PlayerDao playerDao)</code>: Initialisiert den Manager mit der Plugin-Instanz (für Logging) und dem Datenzugriffsobjekt (DAO).</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>getProfile(UUID uuid)</code>
            <p>Ruft das Profil eines Spielers anhand seiner UUID ab. Falls das Profil noch nicht im Cache existiert, wird eine neue Instanz erstellt.</p>
            <strong>Parameter:</strong> <code>UUID uuid</code> - Die eindeutige ID des Spielers.<br>
            <strong>Rückgabewert:</strong> <code>PlayerProfile</code> - Das (ggf. neu erstellte) Profil.
        </li>
        <li>
            <code>getProfile(Player player)</code>
            <p>Überladene Hilfsmethode, die das Profil direkt über ein Bukkit-Player-Objekt abruft.</p>
            <strong>Parameter:</strong> <code>Player player</code> - Das Spieler-Objekt.<br>
            <strong>Rückgabewert:</strong> <code>PlayerProfile</code> - Das zugehörige Profil.
        </li>
        <li>
            <code>profiles()</code>
            <p>Gibt die interne Map aller aktuell geladenen Profile zurück.</p>
            <strong>Rückgabewert:</strong> <code>Map&lt;UUID, PlayerProfile&gt;</code> - Eine Map der aktiven Profile.
        </li>
        <li>
            <code>loadProfileAsync(UUID uuid)</code>
            <p>Lädt ein Spielerprofil asynchron aus der Datenbank. Bei Fehlern wird eine Warnung geloggt und ein leeres Standardprofil erstellt. Das geladene Profil wird automatisch im Cache registriert.</p>
            <strong>Parameter:</strong> <code>UUID uuid</code> - Die ID des zu ladenden Spielers.<br>
            <strong>Rückgabewert:</strong> <code>CompletableFuture&lt;PlayerProfile&gt;</code> - Ein Future, das nach Abschluss des Ladevorgangs das Profil liefert.
        </li>
        <li>
            <code>saveProfile(PlayerProfile profile)</code>
            <p>Speichert ein spezifisches Spielerprofil asynchron in der Datenbank.</p>
            <strong>Parameter:</strong> <code>PlayerProfile profile</code> - Das zu speichernde Profil.
        </li>
        <li>
            <code>saveAll()</code>
            <p>Iteriert über alle aktuell im Cache befindlichen Profile und stößt für jedes Profil den Speichervorgang an. Diese Methode wird typischerweise beim Server-Shutdown oder bei regelmäßigen Backups aufgerufen.</p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>PlayerDao</code>: Wird für die Persistierung der Daten verwendet.</li>
        <li><code>PlayerProfile</code>: Das Datenmodell, das die RPG-spezifischen Spielerwerte enthält.</li>
        <li><code>JavaPlugin</code>: Wird für den Zugriff auf den Logger benötigt.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ProfessionManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ProfessionManager.java</h2>
    <p>
        Der <code>ProfessionManager</code> ist eine zentrale Komponente zur Verwaltung des Berufssystems (Professions) innerhalb des RPG-Plugins. 
        Er kümmert sich um das Laden von Berufsdefinitionen aus einer Konfigurationsdatei, die Berechnung von Erfahrungspunkten (XP), 
        Level-Aufstiege sowie die Vergabe von Belohnungen.
    </p>

    <h3>Klasse: ProfessionManager</h3>
    <p>Verwaltet die Logik für Berufe wie Bergbau, Kräuterkunde oder Schmiedekunst.</p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>public ProfessionManager(JavaPlugin plugin)</code>
            <p>Initialisiert den Manager, lädt die <code>professions.yml</code> und erstellt Standardwerte (Seeds), falls die Datei nicht existiert.</p>
        </li>
        <li>
            <code>public int getLevel(PlayerProfile profile, String profession)</code>
            <p>Gibt das aktuelle Level eines Spielers in einem bestimmten Beruf zurück. Standardwert ist 1.</p>
        </li>
        <li>
            <code>public void setLevel(PlayerProfile profile, String profession, int level)</code>
            <p>Setzt das Level eines Spielers für einen Beruf manuell fest (Minimum 1).</p>
        </li>
        <li>
            <code>public int addXp(PlayerProfile profile, String profession, int xp, Player player)</code>
            <p>
                Fügt einem Spieler XP in einem Beruf hinzu. Berechnet automatisch Level-Aufstiege basierend auf einem Schwellenwert (Level * 100). 
                Löst bei einem Level-Up Belohnungen aus.
            </p>
            <p><strong>Rückgabewert:</strong> Das neue Level des Spielers.</p>
        </li>
        <li>
            <code>public int xpForMaterial(String profession, String material)</code>
            <p>Gibt an, wie viele XP das Interagieren mit einem bestimmten Material (z.B. COAL_ORE) für den jeweiligen Beruf gewährt.</p>
        </li>
        <li>
            <code>public int requiredLevelForCraft(String profession, String resultMaterial)</code>
            <p>Gibt das benötigte Mindestlevel zurück, um einen bestimmten Gegenstand in einem Beruf herzustellen.</p>
        </li>
        <li>
            <code>private void fireLevelRewards(String profession, int level, Player player)</code>
            <p>
                Führt Befehle aus der Konfiguration aus, wenn ein Spieler ein bestimmtes Level erreicht, und sendet eine Benachrichtigung an den Spieler.
            </p>
        </li>
        <li>
            <code>private void load()</code>
            <p>Liest alle Berufsdefinitionen, XP-Quellen, Handwerksvoraussetzungen und Belohnungen aus der YAML-Konfiguration ein.</p>
        </li>
        <li>
            <code>private void seedDefaults()</code>
            <p>Erstellt eine Standardkonfiguration mit den Berufen "Bergbau", "Kräuterkunde" und "Schmiedekunst".</p>
        </li>
    </ul>

    <h3>Innere Klasse: ProfessionDefinition</h3>
    <p>Eine Datenstruktur, die die statischen Eigenschaften eines Berufs definiert.</p>
    <ul>
        <li><code>id</code>: Eindeutiger technischer Name des Berufs.</li>
        <li><code>displayName</code>: Der für den Spieler sichtbare Name.</li>
        <li><code>xpSources</code>: Map von Materialien zu den XP-Werten, die sie gewähren.</li>
        <li><code>craftRequirements</code>: Map von Materialien zu den benötigten Leveln für die Herstellung.</li>
        <li><code>levelRewards</code>: Map von Level-Meilensteinen zu einer Liste von Konsolenbefehlen, die ausgeführt werden.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/QuestManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/QuestManager.java</h2>
    <p>
        Die Klasse <code>QuestManager</code> ist für die Verwaltung, Speicherung und das Laden von Quests innerhalb des RPG-Systems verantwortlich. 
        Sie fungiert als zentrale Schnittstelle zwischen der persistenten Datenspeicherung in einer YAML-Datei (<code>quests.yml</code>) und der Laufzeitumgebung des Plugins.
    </p>

    <h3>Klasse: QuestManager</h3>
    <p>
        Diese Klasse verwaltet eine Sammlung von Quests und stellt Methoden bereit, um Quest-Daten zu manipulieren und mit der Konfigurationsdatei zu synchronisieren.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>QuestManager(JavaPlugin plugin)</code>: Initialisiert den Manager, legt die <code>quests.yml</code> im Datenordner des Plugins fest und lädt die vorhandenen Quests. 
            Falls die Datei nicht existiert, werden Standard-Quests (Seed) erstellt.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>getQuest(String id)</code>: 
            Gibt ein <code>Quest</code>-Objekt basierend auf der übergebenen ID zurück.
            <br><strong>Rückgabewert:</strong> Das gefundene <code>Quest</code>-Objekt oder <code>null</code>.
        </li>
        <li>
            <code>quests()</code>: 
            Gibt eine Map aller aktuell geladenen Quests zurück.
            <br><strong>Rückgabewert:</strong> <code>Map&lt;String, Quest&gt;</code>.
        </li>
        <li>
            <code>saveQuest(Quest quest)</code>: 
            Konvertiert ein Quest-Objekt in eine Konfigurationssektion und speichert dessen Attribute (Name, Beschreibung, Wiederholbarkeit, Mindestlevel, Schritte und Belohnungen) in der Konfiguration.
        </li>
        <li>
            <code>saveAll()</code>: 
            Löscht die aktuelle Konfiguration im Speicher und schreibt alle im Manager registrierten Quests erneut hinein, gefolgt von einem Schreibvorgang auf die Festplatte.
        </li>
        <li>
            <code>load()</code> (privat): 
            Liest die <code>quests.yml</code> aus, iteriert über alle Einträge und instanziiert die entsprechenden <code>Quest</code>-, <code>QuestStep</code>- und <code>QuestReward</code>-Objekte.
        </li>
        <li>
            <code>seedDefaults()</code> (privat): 
            Erstellt eine initiale Beispiel-Quest ("Wolfsplage"), falls keine Quest-Datei vorhanden ist, um dem Administrator eine Vorlage zu bieten.
        </li>
        <li>
            <code>save()</code> (privat): 
            Führt den eigentlichen Schreibvorgang der <code>YamlConfiguration</code> auf die Festplatte durch und fängt mögliche <code>IOException</code>-Fehler ab.
        </li>
    </ul>

    <h4>Datenstruktur</h4>
    <p>
        Die Quests werden intern in einer <code>HashMap&lt;String, Quest&gt;</code> gespeichert, wobei die ID der Quest als Schlüssel dient. 
        Ein Quest-Objekt umfasst dabei:
    </p>
    <ul>
        <li><strong>Metadaten:</strong> Name, Beschreibung, Mindestlevel.</li>
        <li><strong>Logik:</strong> Ob die Quest wiederholbar ist.</li>
        <li><strong>Schritte (Steps):</strong> Eine Liste von Aufgaben (z.B. <code>KILL</code>-Aufgaben mit Ziel und Anzahl).</li>
        <li><strong>Belohnungen (Rewards):</strong> Erfahrungspunkte (XP), Skillpunkte und Fraktionsreputation.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ShopManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ShopManager.java</h2>
    <p>
        Die Klasse <code>ShopManager</code> ist für die Verwaltung, Speicherung und das Laden von In-Game-Shops innerhalb des RPG-Systems verantwortlich. 
        Sie fungiert als Schnittstelle zwischen der persistenten Datenspeicherung in einer YAML-Datei (<code>shops.yml</code>) und der Laufzeitumgebung des Plugins.
    </p>

    <h3>Klasse: ShopManager</h3>
    <p><strong>Paket:</strong> <code>com.example.rpg.manager</code></p>
    <p><strong>Beschreibung:</strong> Verwaltet eine Sammlung von <code>ShopDefinition</code>-Objekten und stellt Methoden bereit, um Shop-Daten zu manipulieren und zu persistieren.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>ShopManager(JavaPlugin plugin)</code>: Initialisiert den Manager, legt die Datei <code>shops.yml</code> im Datenordner des Plugins fest und lädt die vorhandenen Konfigurationen. 
            Falls die Datei nicht existiert, werden Standardwerte (Seed) erstellt.
        </li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>getShop(String id)</code>: 
            <br><strong>Zweck:</strong> Ruft eine spezifische Shop-Definition anhand ihrer ID ab.
            <br><strong>Parameter:</strong> <code>id</code> (String) - Die eindeutige Kennung des Shops.
            <br><strong>Rückgabewert:</strong> <code>ShopDefinition</code> oder <code>null</code>, falls nicht gefunden.
        </li>
        <li>
            <code>shops()</code>: 
            <br><strong>Zweck:</strong> Gibt eine Map aller aktuell geladenen Shops zurück.
            <br><strong>Rückgabewert:</strong> <code>Map&lt;String, ShopDefinition&gt;</code>.
        </li>
        <li>
            <code>saveShop(ShopDefinition shop)</code>: 
            <br><strong>Zweck:</strong> Speichert eine einzelne Shop-Definition in die Konfigurationsdatei. Konvertiert Shop-Items in ein speicherbares Map-Format.
            <br><strong>Parameter:</strong> <code>shop</code> (ShopDefinition) - Das zu speichernde Shop-Objekt.
        </li>
        <li>
            <code>saveAll()</code>: 
            <br><strong>Zweck:</strong> Bereinigt die aktuelle Konfiguration und speichert alle im Speicher befindlichen Shops erneut in die Datei.
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li>
            <code>load()</code>: 
            <br><strong>Zweck:</strong> Liest die <code>shops.yml</code> aus, parst die Shop-Daten sowie die zugehörigen Items (Material, Name, Preise, Slot) und füllt die interne Map.
        </li>
        <li>
            <code>seedDefaults()</code>: 
            <br><strong>Zweck:</strong> Erstellt eine initiale Beispiel-Konfiguration (z. B. einen "Dorfschmied" mit Eisenschwert und Heiltrank), falls keine Datei vorhanden ist.
        </li>
        <li>
            <code>save()</code>: 
            <br><strong>Zweck:</strong> Schreibt das <code>YamlConfiguration</code>-Objekt physisch auf die Festplatte. Behandelt <code>IOException</code>-Fehler durch Logging.
        </li>
    </ul>

    <h4>Datenstruktur der Items</h4>
    <p>Ein Shop-Item innerhalb der Konfiguration umfasst folgende Attribute:</p>
    <ul>
        <li><code>slot</code>: Die Position im Inventar-GUI.</li>
        <li><code>material</code>: Der Bukkit-Materialname (z.B. <code>IRON_SWORD</code>).</li>
        <li><code>name</code>: Der Anzeigename des Items (unterstützt Farbcodes).</li>
        <li><code>buyPrice</code>: Kosten für den Spieler beim Kauf.</li>
        <li><code>sellPrice</code>: Erlös für den Spieler beim Verkauf.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillHotbarManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillHotbarManager.java</h2>
    <p>
        Der <code>SkillHotbarManager</code> ist eine zentrale Komponente zur Verwaltung der Zuweisungen von Fähigkeiten (Skills) zu den Hotbar-Slots eines Spielers. 
        Er ermöglicht es, die Verknüpfung zwischen einem numerischen Slot und einer spezifischen Skill-ID dauerhaft im Spielerprofil zu speichern und abzurufen.
    </p>

    <h3>Klasse: SkillHotbarManager</h3>
    <p>
        Diese Klasse fungiert als Schnittstelle zwischen der Benutzeroberfläche (oder Listenern) und der Datenhaltungsschicht für Skill-Belegungen.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>SkillHotbarManager(PlayerDataManager playerDataManager)</code>: 
            Initialisiert den Manager mit einer Instanz des <code>PlayerDataManager</code>, um Änderungen an den Spielerprofilen persistent zu speichern.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>void bindSkill(PlayerProfile profile, int slot, String skillId)</code>
            <p>
                Verknüpft eine spezifische Skill-ID mit einem Hotbar-Slot im Profil des Spielers.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>profile</code>: Das <code>PlayerProfile</code> des betroffenen Spielers.</li>
                        <li><code>slot</code>: Die Index-Nummer des Hotbar-Slots (üblicherweise 0-8).</li>
                        <li><code>skillId</code>: Die eindeutige Kennung des zuzuweisenden Skills.</li>
                    </ul>
                </li>
                <li><strong>Besonderheit:</strong> Nach der Zuweisung wird das Profil automatisch über den <code>PlayerDataManager</code> gespeichert.</li>
            </ul>
        </li>
        <li>
            <code>String getBinding(PlayerProfile profile, int slot)</code>
            <p>
                Ruft die aktuell gespeicherte Skill-ID für einen bestimmten Slot ab.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>profile</code>: Das <code>PlayerProfile</code> des Spielers.</li>
                        <li><code>slot</code>: Der abzufragende Hotbar-Slot.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Die <code>skillId</code> als String oder <code>null</code>, falls dem Slot kein Skill zugewiesen ist.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillManager.java</h2>
    <p>
        Der <code>SkillManager</code> ist eine zentrale Verwaltungskomponente für das Skill-System des RPG-Plugins. 
        Er ist verantwortlich für das Laden, Speichern und Initialisieren von Fähigkeiten (Skills) aus einer YAML-Konfigurationsdatei (<code>skills.yml</code>). 
        Zudem definiert er Standard-Skills für verschiedene Kategorien wie Heilung, Magie, Kampf und Berufe.
    </p>

    <h3>Klasse: SkillManager</h3>
    <p>Verwaltet die Persistenz und den Zugriff auf alle verfügbaren Skills im Plugin.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>SkillManager(JavaPlugin plugin)</code>: Initialisiert den Manager, erstellt die <code>skills.yml</code> falls sie nicht existiert (mit Standardwerten) und lädt die vorhandenen Skills in den Speicher.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>getSkill(String id)</code>
            <p>Sucht einen Skill anhand seiner eindeutigen ID.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>id</code> - Die ID des gesuchten Skills.</li>
                <li><strong>Rückgabewert:</strong> Das <code>Skill</code>-Objekt oder <code>null</code>, falls nicht gefunden.</li>
            </ul>
        </li>
        <li>
            <code>skills()</code>
            <p>Gibt eine Map aller geladenen Skills zurück.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>Map&lt;String, Skill&gt;</code></li>
            </ul>
        </li>
        <li>
            <code>saveSkill(Skill skill)</code>
            <p>Speichert einen einzelnen Skill in der Konfigurationsdatei.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>skill</code> - Das zu speichernde Skill-Objekt.</li>
            </ul>
        </li>
        <li>
            <code>saveAll()</code>
            <p>Bereinigt die aktuelle Konfiguration und speichert alle im Speicher befindlichen Skills erneut ab.</p>
        </li>
    </ul>

    <h4>Private Hilfsmethoden</h4>
    <ul>
        <li><code>load()</code>: Liest alle Skill-Definitionen aus der YAML-Datei und transformiert sie in <code>Skill</code>-Objekte. Unterstützt auch die Migration von alten "Legacy"-Effektformaten.</li>
        <li><code>seedDefaults()</code>: Erzeugt eine umfangreiche Liste von Standard-Skills (z.B. Heilpuls, Frostbolzen, Wirbelwind, Schildwall), inklusive deren Abhängigkeiten im Skill-Baum (<code>requiredSkill</code>) und deren Effekte.</li>
        <li><code>serializeEffects(List&lt;SkillEffectConfig&gt; effects)</code>: Wandelt eine Liste von Effekt-Konfigurationen in ein speicherbares Map-Format für YAML um.</li>
        <li><code>loadEffects(ConfigurationSection section)</code>: Extrahiert Effekt-Konfigurationen aus einem YAML-Abschnitt.</li>
        <li><code>mapLegacyEffect(String legacy)</code>: Hilfsmethode zur Abwärtskompatibilität, die alte Effekt-Strings in das neue <code>SkillEffectConfig</code>-System überführt.</li>
        <li><code>save()</code>: Schreibt die <code>YamlConfiguration</code> physisch auf die Festplatte.</li>
    </ul>

    <h3>Standardmäßig definierte Skills</h3>
    <p>Der Manager initialisiert beim ersten Start unter anderem folgende Skill-Ketten:</p>
    <ul>
        <li><strong>Heilung:</strong> Heilpuls &rarr; Große Heilung &rarr; Segen</li>
        <li><strong>Magie:</strong> Flammenstoß &rarr; Frostbolzen &rarr; Arkane Explosion</li>
        <li><strong>Kampf:</strong> Machtstoß &rarr; Wirbelwind &rarr; Hinrichtung</li>
        <li><strong>Verteidigung:</strong> Schildwall &rarr; Bollwerk &rarr; Abwehrhaltung</li>
        <li><strong>Berufe:</strong> Bergbau-Fokus &rarr; Handwerkskunst &rarr; Alchemie-Meister</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillTreeManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SkillTreeManager.java</h2>
    <p>
        Der <code>SkillTreeManager</code> ist eine zentrale Komponente zur Verwaltung und Strukturierung der Skill-Hierarchien innerhalb des RPG-Systems. 
        Er transformiert eine flache Liste von Fähigkeiten (Skills) in eine Baumstruktur, basierend auf deren Abhängigkeiten.
    </p>

    <h3>Klasse: SkillTreeManager</h3>
    <p>
        Diese Klasse verwaltet die logische Verknüpfung von Skills und ermöglicht die Identifizierung von Basis-Skills (Roots) sowie deren nachfolgenden Erweiterungen.
    </p>
    <ul>
        <li>
            <strong>Konstruktor:</strong> <code>SkillTreeManager(SkillManager skillManager)</code>
            <br>Initialisiert den Manager und führt sofort einen <code>rebuild()</code> aus, um die Baumstruktur aus den verfügbaren Skills zu generieren.
        </li>
        <li>
            <strong>Methode: <code>rebuild()</code></strong>
            <p>
                Löscht die aktuelle Struktur und baut den Skill-Baum neu auf. Dabei werden alle Skills aus dem <code>SkillManager</code> geladen, in <code>SkillNode</code>-Objekte gekapselt und anhand der <code>requiredSkill</code>-Eigenschaft miteinander verknüpft.
            </p>
        </li>
        <li>
            <strong>Methode: <code>roots()</code></strong>
            <p>
                Gibt eine Liste aller Wurzel-Knoten (Skills ohne Voraussetzungen) zurück, sortiert nach ihrer ID.
                <br><strong>Rückgabewert:</strong> <code>List&lt;SkillNode&gt;</code>
            </p>
        </li>
        <li>
            <strong>Methode: <code>nodes()</code></strong>
            <p>
                Gibt eine Map aller registrierten Skill-Knoten zurück, wobei die Skill-ID als Schlüssel dient.
                <br><strong>Rückgabewert:</strong> <code>Map&lt;String, SkillNode&gt;</code>
            </p>
        </li>
    </ul>

    <h3>Innere Klasse: SkillNode</h3>
    <p>
        Repräsentiert einen einzelnen Knoten im Skill-Baum. Ein Knoten enthält Informationen über den Skill selbst, seinen Eltern-Skill (Voraussetzung) und seine Kinder-Skills (Folge-Skills).
    </p>
    <ul>
        <li><strong>Eigenschaften:</strong>
            <ul>
                <li><code>skill</code>: Das zugrunde liegende <code>Skill</code>-Modell.</li>
                <li><code>parent</code>: Der übergeordnete <code>SkillNode</code> (Voraussetzung).</li>
                <li><code>children</code>: Eine Liste von <code>SkillNode</code>-Objekten, die diesen Skill als Voraussetzung haben.</li>
            </ul>
        </li>
        <li><strong>Methoden:</strong>
            <ul>
                <li><code>skill()</code>: Liefert das <code>Skill</code>-Objekt zurück.</li>
                <li><code>parent()</code>: Liefert den Eltern-Knoten zurück.</li>
                <li><code>setParent(SkillNode parent)</code>: Setzt die Referenz auf den Eltern-Knoten.</li>
                <li><code>children()</code>: Liefert die Liste der Kind-Knoten zurück.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SpawnerManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/SpawnerManager.java</h2>
    <p>
        Der <code>SpawnerManager</code> ist eine zentrale Komponente des RPG-Systems, die für die Verwaltung und das automatische Erscheinen (Spawning) von benutzerdefinierten Mobs in bestimmten Zonen verantwortlich ist. Er steuert die Persistenz der Spawner-Daten in einer Konfigurationsdatei und führt einen Hintergrund-Task aus, der die Mob-Population in der Welt reguliert.
    </p>

    <h3>Klasse: SpawnerManager</h3>
    <p>
        Diese Klasse verwaltet eine Sammlung von <code>Spawner</code>-Objekten und interagiert mit der Bukkit-API, um Entitäten in der Spielwelt zu erzeugen.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>SpawnerManager(RPGPlugin plugin)</code>: Initialisiert den Manager, lädt die <code>spawners.yml</code>, erstellt Standardwerte falls die Datei nicht existiert, und startet den Spawning-Task.</li>
    </ul>

    <h4>Öffentliche Methoden</h4>
    <ul>
        <li>
            <code>getSpawner(String id)</code>: 
            Gibt ein spezifisches <code>Spawner</code>-Objekt anhand seiner ID zurück.
            <br><strong>Rückgabewert:</strong> <code>Spawner</code> oder <code>null</code>.
        </li>
        <li>
            <code>spawners()</code>: 
            Gibt eine Map aller registrierten Spawner zurück.
            <br><strong>Rückgabewert:</strong> <code>Map&lt;String, Spawner&gt;</code>.
        </li>
        <li>
            <code>saveSpawner(Spawner spawner)</code>: 
            Speichert die Konfiguration eines einzelnen Spawners in der YAML-Konfiguration.
        </li>
        <li>
            <code>saveAll()</code>: 
            Bereinigt die aktuelle Konfigurationsdatei und schreibt alle im Speicher befindlichen Spawner-Daten erneut hinein.
        </li>
    </ul>

    <h4>Private Hilfsmethoden & Logik</h4>
    <ul>
        <li>
            <code>startTask()</code>: 
            Startet einen wiederkehrenden Bukkit-Task (alle 40 Ticks), der prüft, ob in den Zonen neue Mobs gespawnt werden müssen. Er berücksichtigt dabei das Spawn-Intervall, die maximale Anzahl an Mobs pro Zone und ob sich Spieler in der Nähe befinden.
        </li>
        <li>
            <code>hasPlayersInZone(Zone zone)</code>: 
            Prüft, ob sich mindestens ein Spieler innerhalb der Grenzen der angegebenen Zone aufhält.
        </li>
        <li>
            <code>countMobsInZone(Zone zone)</code>: 
            Zählt alle lebenden Entitäten in einer Zone, die über einen speziellen PersistentData-Key als "Custom Mob" markiert sind.
        </li>
        <li>
            <code>pickMob(Spawner spawner)</code>: 
            Wählt basierend auf den konfigurierten Wahrscheinlichkeiten (Weights) eine <code>MobDefinition</code> aus der Liste des Spawners aus.
        </li>
        <li>
            <code>spawnMobInZone(Zone zone, MobDefinition mob)</code>: 
            Berechnet eine zufällige Position innerhalb der Zonen-Koordinaten (X/Z) und ermittelt die höchste Block-Position (Y), um den Mob sicher in der Welt zu platzieren.
        </li>
        <li>
            <code>randomBetween(int min, int max)</code>: 
            Hilfsmethode zur Generierung einer Zufallszahl innerhalb eines Bereichs, unabhängig davon, welcher Wert als Minimum oder Maximum übergeben wurde.
        </li>
    </ul>

    <h4>Datenhaltung</h4>
    <p>
        Die Daten werden in der Datei <code>spawners.yml</code> im Plugin-Ordner gespeichert. Ein Spawner-Eintrag umfasst:
    </p>
    <ul>
        <li><code>zoneId</code>: Die ID der Zone, in der die Mobs erscheinen.</li>
        <li><code>maxMobs</code>: Die maximale Anzahl an Mobs, die dieser Spawner gleichzeitig in der Zone halten darf.</li>
        <li><code>spawnInterval</code>: Die Zeitspanne (in Ticks) zwischen den Spawn-Versuchen.</li>
        <li><code>mobs</code>: Eine Liste von Mob-IDs mit zugehörigen Gewichtungen für die Zufallsauswahl.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/TradeManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/TradeManager.java</h2>
    <p>
        Die Klasse <code>TradeManager</code> ist eine zentrale Komponente zur Verwaltung von Handelsanfragen (Trade Requests) zwischen Spielern innerhalb des RPG-Systems. Sie stellt sicher, dass Anfragen korrekt zugewiesen und nach Abschluss oder Abbruch wieder bereinigt werden.
    </p>

    <h3>Klasse: TradeManager</h3>
    <p><strong>Beschreibung:</strong> Verwaltet die aktiven Handelsbeziehungen zwischen zwei Spielern mittels einer Map, die UUIDs mit <code>TradeRequest</code>-Objekten verknüpft.</p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>public void requestTrade(UUID requester, UUID target)</code>
            <p>Erstellt eine neue Handelsanfrage zwischen zwei Spielern.</p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>requester</code>: Die UUID des Spielers, der den Handel initiiert.</li>
                        <li><code>target</code>: Die UUID des Spielers, der die Anfrage erhält.</li>
                    </ul>
                </li>
                <li><strong>Funktionsweise:</strong> Ein neues <code>TradeRequest</code>-Objekt wird erstellt und in der internen Map sowohl für den Initiator als auch für das Ziel gespeichert.</li>
            </ul>
        </li>
        <li>
            <code>public TradeRequest getRequest(UUID player)</code>
            <p>Ruft die aktuelle Handelsanfrage für einen bestimmten Spieler ab.</p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>player</code>: Die UUID des Spielers, dessen Anfrage gesucht wird.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Das zugehörige <code>TradeRequest</code>-Objekt oder <code>null</code>, falls keine aktive Anfrage existiert.</li>
            </ul>
        </li>
        <li>
            <code>public void clear(UUID player)</code>
            <p>Entfernt eine Handelsanfrage aus dem System.</p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>player</code>: Die UUID eines der am Handel beteiligten Spieler.</li>
                    </ul>
                </li>
                <li><strong>Funktionsweise:</strong> Sucht die mit dem Spieler verknüpfte Anfrage und entfernt diese für beide Teilnehmer (Initiator und Ziel) aus der Map, um Speicherlecks zu vermeiden und den Status zurückzusetzen.</li>
            </ul>
        </li>
    </ul>

    <h3>Interne Datenstruktur</h3>
    <p>
        Die Klasse verwendet eine <code>Map&lt;UUID, TradeRequest&gt;</code> namens <code>requests</code>. Da ein Handel immer zwei Parteien betrifft, wird dasselbe <code>TradeRequest</code>-Objekt unter zwei verschiedenen Schlüsseln (den UUIDs beider Spieler) gespeichert, um einen schnellen Zugriff von beiden Seiten zu ermöglichen.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ZoneManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/manager/ZoneManager.java</h2>
    <p>Der <code>ZoneManager</code> ist eine zentrale Verwaltungskomponente innerhalb des RPG-Plugins. Er ist verantwortlich für das Laden, Speichern und Verwalten von Gebietsdefinitionen (<code>Zone</code>). Diese Zonen definieren räumliche Bereiche in der Spielwelt, die spezifische Eigenschaften wie Level-Anforderungen oder Modifikatoren für Schaden und Geschwindigkeit besitzen.</p>

    <h3>Klasse: ZoneManager</h3>
    <p>Diese Klasse fungiert als Schnittstelle zwischen der persistenten Speicherung in einer YAML-Datei und der Laufzeitumgebung des Plugins.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>ZoneManager(JavaPlugin plugin)</code>: Initialisiert den Manager, erstellt die Verknüpfung zur <code>zones.yml</code> im Datenordner des Plugins und lädt die vorhandenen Zonen-Daten.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public Map&lt;String, Zone&gt; zones()</code>
            <p>Gibt eine Map aller aktuell geladenen Zonen zurück, wobei die ID der Zone als Schlüssel dient.</p>
        </li>
        <li>
            <code>public Zone getZone(String id)</code>
            <p>Sucht eine spezifische Zone anhand ihrer eindeutigen ID.</p>
            <p><strong>Parameter:</strong> <code>id</code> - Die ID der gesuchten Zone.</p>
            <p><strong>Rückgabewert:</strong> Das <code>Zone</code>-Objekt oder <code>null</code>, falls nicht gefunden.</p>
        </li>
        <li>
            <code>public Zone getZoneAt(Location location)</code>
            <p>Ermittelt, in welcher Zone sich eine bestimmte Position in der Welt befindet.</p>
            <p><strong>Parameter:</strong> <code>location</code> - Die zu prüfende Bukkit-Location.</p>
            <p><strong>Rückgabewert:</strong> Die erste Zone, die diese Position umschließt, oder <code>null</code>.</p>
        </li>
        <li>
            <code>public void saveZone(Zone zone)</code>
            <p>Überträgt die Daten eines einzelnen <code>Zone</code>-Objekts in die Konfigurationsstruktur und speichert die Datei auf die Festplatte.</p>
        </li>
        <li>
            <code>public void saveAll()</code>
            <p>Bereinigt die aktuelle Konfiguration und speichert alle im Speicher befindlichen Zonen erneut in die <code>zones.yml</code>.</p>
        </li>
        <li>
            <code>private void load()</code>
            <p>Interne Methode zum Einlesen der Zonen aus der Konfigurationsdatei. Hierbei werden Attribute wie Name, Welt, Level-Bereiche (min/max) sowie Multiplikatoren für Verlangsamung und Schaden geladen.</p>
        </li>
        <li>
            <code>private void save()</code>
            <p>Interne Hilfsmethode, die die <code>YamlConfiguration</code> physisch in das Dateisystem schreibt und eventuelle <code>IOException</code>-Fehler im Logger protokolliert.</p>
        </li>
    </ul>

    <h3>Datenstruktur</h3>
    <p>Die Zonen werden in einer <code>HashMap&lt;String, Zone&gt;</code> gespeichert, was einen schnellen Zugriff über die ID ermöglicht. Die räumliche Prüfung in <code>getZoneAt</code> erfolgt iterativ über alle registrierten Zonen.</p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Arena.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Arena.java</h2>
    <p>
        Die Klasse <code>Arena</code> ist ein Datenmodell, das eine PvP-Arena innerhalb des RPG-Plugins repräsentiert. 
        Sie speichert Informationen über die räumliche Begrenzung der Arena, die Startpunkte für zwei Spieler sowie den aktuellen Status und die Teilnehmer eines Kampfes.
    </p>

    <h3>Klasse: Arena</h3>
    <p>
        Diese Klasse dient als Container für alle relevanten Daten einer Arena-Instanz. Sie verwendet Getter- und Setter-Methoden zur Verwaltung der Attribute.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>Arena(String id)</code>: Erstellt eine neue Arena-Instanz mit einer eindeutigen Identifikationsnummer.</li>
    </ul>

    <h4>Wichtige Attribute</h4>
    <ul>
        <li><code>id</code>: Die eindeutige Kennung der Arena (final).</li>
        <li><code>world</code>: Der Name der Minecraft-Welt, in der sich die Arena befindet.</li>
        <li><code>x1, y1, z1</code> und <code>x2, y2, z2</code>: Koordinatenpaare, die den physischen Bereich (Bounding Box) der Arena definieren.</li>
        <li><code>spawn1x, spawn1y, spawn1z</code>: Die Koordinaten des Startpunkts für den ersten Spieler.</li>
        <li><code>spawn2x, spawn2y, spawn2z</code>: Die Koordinaten des Startpunkts für den zweiten Spieler.</li>
        <li><code>status</code>: Der aktuelle Zustand der Arena (Standard: <code>ArenaStatus.WAITING</code>).</li>
        <li><code>playerOne</code> und <code>playerTwo</code>: Die <code>UUID</code>s der aktuell in der Arena kämpfenden Spieler.</li>
    </ul>

    <h4>Methoden</h4>
    <p>Die Klasse implementiert Standard-Getter und -Setter für alle oben genannten Attribute. Hier sind die wichtigsten funktionalen Gruppen:</p>
    <ul>
        <li>
            <strong>Identifikation &amp; Welt:</strong>
            <code>id()</code>, <code>world()</code>, <code>setWorld(String world)</code>.
        </li>
        <li>
            <strong>Positionsdaten:</strong>
            Methoden wie <code>x1()</code>, <code>setX1(int x)</code> etc. zur Definition der Arena-Grenzen.
        </li>
        <li>
            <strong>Spawn-Management:</strong>
            Methoden wie <code>spawn1x()</code>, <code>setSpawn1x(int x)</code> etc. zur Festlegung der Teleport-Ziele bei Kampfbeginn.
        </li>
        <li>
            <strong>Status- &amp; Spielerverwaltung:</strong>
            <ul>
                <li><code>status()</code> / <code>setStatus(ArenaStatus status)</code>: Abfrage und Aktualisierung des Arena-Zustands (z.B. WAITING, FIGHTING).</li>
                <li><code>playerOne()</code> / <code>setPlayerOne(UUID uuid)</code>: Verwaltung des ersten Teilnehmers.</li>
                <li><code>playerTwo()</code> / <code>setPlayerTwo(UUID uuid)</code>: Verwaltung des zweiten Teilnehmers.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ArenaStatus.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ArenaStatus.java</h2>
    <p>
        Die Datei <code>ArenaStatus.java</code> definiert eine Enumeration (Aufzählungstyp), die den aktuellen Zustand einer Arena innerhalb des RPG-Systems repräsentiert. 
        Diese Zustände werden primär vom <code>ArenaManager</code> und <code>ArenaListener</code> verwendet, um den Ablauf von Kämpfen zu steuern.
    </p>

    <h3>Enum: ArenaStatus</h3>
    <p>
        Dieses Enum dient zur Statusverfolgung einer Arena-Instanz. Es stellt sicher, dass Logik (wie z.B. das Beitreten von Spielern oder das Verursachen von Schaden) nur in den jeweils gültigen Phasen ausgeführt wird.
    </p>

    <h4>Mögliche Werte:</h4>
    <ul>
        <li>
            <code>WAITING</code>: 
            Die Arena befindet sich in der Wartephase. Spieler können der Arena beitreten, aber der Kampf hat noch nicht begonnen.
        </li>
        <li>
            <code>FIGHTING</code>: 
            Der Kampf ist aktiv. In diesem Status findet die Interaktion zwischen den Kontrahenten statt und das System überwacht die Lebenspunkte der Teilnehmer.
        </li>
        <li>
            <code>ENDING</code>: 
            Der Kampf ist abgeschlossen. In dieser Phase werden Gewinner ermittelt, Belohnungen verteilt (z.B. via <code>EloCalculator</code>) und die Arena für die nächste Runde zurückgesetzt.
        </li>
    </ul>

    <h4>Verwendung im System:</h4>
    <p>
        Der Status wird in der Klasse <code>Arena</code> gespeichert und beeinflusst maßgeblich das Verhalten des <code>ArenaListener</code>, um beispielsweise zu verhindern, dass Spieler Schaden nehmen, bevor der Kampf offiziell gestartet wurde (Status <code>WAITING</code>).
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/AuctionListing.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/AuctionListing.java</h2>
    <p>
        Die Klasse <code>AuctionListing</code> ist ein Datenmodell innerhalb des RPG-Plugins, das ein einzelnes Angebot im Auktionshaus repräsentiert. 
        Sie dient als Container für Informationen über den Verkäufer, das angebotene Item und den festgelegten Preis.
    </p>

    <h3>Klasse: AuctionListing</h3>
    <p>
        Diese Klasse definiert die Struktur eines Auktionsangebots. Sie verwendet eine eindeutige ID zur Identifizierung und speichert die Metadaten des Items als String (serialisierte Daten).
    </p>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>AuctionListing(String id)</code>: Erstellt ein neues Auktionsangebot mit einer spezifischen ID.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>id()</code>: 
            <strong>Rückgabewert:</strong> <code>String</code> – Die eindeutige Kennung des Auktionsangebots.
        </li>
        <li>
            <code>seller()</code>: 
            <strong>Rückgabewert:</strong> <code>UUID</code> – Die Unique ID des Spielers, der das Item zum Verkauf anbietet.
        </li>
        <li>
            <code>setSeller(UUID seller)</code>: 
            Legt den Verkäufer für dieses Angebot fest.
        </li>
        <li>
            <code>itemData()</code>: 
            <strong>Rückgabewert:</strong> <code>String</code> – Die serialisierten Daten des Items (z. B. Base64 oder JSON-Repräsentation des Minecraft-Items).
        </li>
        <li>
            <code>setItemData(String itemData)</code>: 
            Speichert die Item-Informationen im Angebot.
        </li>
        <li>
            <code>price()</code>: 
            <strong>Rückgabewert:</strong> <code>int</code> – Der geforderte Kaufpreis für das Item.
        </li>
        <li>
            <code>setPrice(int price)</code>: 
            Setzt den Preis für das Auktionsangebot fest.
        </li>
    </ul>

    <h4>Eigenschaften (Private Felder)</h4>
    <ul>
        <li><code>id</code>: Eindeutiger Identifikator des Listings (final).</li>
        <li><code>seller</code>: Die UUID des verkaufenden Spielers.</li>
        <li><code>itemData</code>: String-Repräsentation des Items.</li>
        <li><code>price</code>: Der numerische Wert der Kosten.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ClassDefinition.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ClassDefinition.java</h2>
    <p>
        Die Klasse <code>ClassDefinition</code> ist ein Datenmodell innerhalb des RPG-Plugins, das die grundlegenden Eigenschaften einer Charakterklasse (z. B. Krieger, Magier) definiert. Sie dient als Vorlage für die Initialisierung von Spielercharakteren und legt fest, welche Fähigkeiten eine Klasse von Beginn an besitzt.
    </p>

    <h3>Klassenübersicht</h3>
    <p><strong>Name:</strong> <code>ClassDefinition</code></p>
    <p><strong>Paket:</strong> <code>com.example.rpg.model</code></p>
    <p><strong>Beschreibung:</strong> Repräsentiert eine Rollenspiel-Klassendefinition mit einer eindeutigen ID, einem Anzeigenamen und einer Liste von Start-Skills.</p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>public ClassDefinition(String id)</code>: Erzeugt eine neue Klassendefinition mit der angegebenen technischen ID.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public String id()</code>
            <p>Gibt die eindeutige technische Identifikation der Klasse zurück.</p>
            <p><strong>Rückgabewert:</strong> <code>String</code> (Die ID der Klasse)</p>
        </li>
        <li>
            <code>public String name()</code>
            <p>Gibt den lesbaren Anzeigenamen der Klasse zurück.</p>
            <p><strong>Rückgabewert:</strong> <code>String</code> (Der Name der Klasse)</p>
        </li>
        <li>
            <code>public void setName(String name)</code>
            <p>Legt den Anzeigenamen der Klasse fest.</p>
            <p><strong>Parameter:</strong> <code>name</code> - Der neue Name der Klasse.</p>
        </li>
        <li>
            <code>public List&lt;String&gt; startSkills()</code>
            <p>Gibt eine Liste der Skill-IDs zurück, die ein Spieler automatisch erhält, wenn er diese Klasse wählt.</p>
            <p><strong>Rückgabewert:</strong> <code>List&lt;String&gt;</code> (Liste von Skill-Identifikatoren)</p>
        </li>
        <li>
            <code>public void setStartSkills(List&lt;String&gt; startSkills)</code>
            <p>Definiert die Liste der Start-Fähigkeiten für diese Klasse.</p>
            <p><strong>Parameter:</strong> <code>startSkills</code> - Eine Liste von Strings, die die IDs der Start-Skills repräsentieren.</p>
        </li>
    </ul>

    <h3>Eigenschaften (Felder)</h3>
    <ul>
        <li><code>id</code> (final): Die interne, unveränderliche Kennung der Klasse.</li>
        <li><code>name</code>: Der Name, der im Spiel oder in Menüs angezeigt wird.</li>
        <li><code>startSkills</code>: Eine Liste von Zeichenfolgen, die auf die initial verfügbaren Fähigkeiten verweisen.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Faction.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Faction.java</h2>
    <p>
        Die Klasse <code>Faction</code> ist ein einfaches Datenmodell (POJO), das eine Fraktion innerhalb des RPG-Systems repräsentiert. 
        Sie dient zur Identifizierung und Benennung von Gruppierungen, denen Spieler oder NPCs zugeordnet werden können.
    </p>

    <h3>Klasse: Faction</h3>
    <p><strong>Paket:</strong> <code>com.example.rpg.model</code></p>
    <p><strong>Beschreibung:</strong> Hält die Basisdaten einer Fraktion, bestehend aus einer eindeutigen ID und einem Anzeigenamen.</p>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>public Faction(String id)</code>: Erstellt eine neue Fraktionsinstanz mit der angegebenen ID.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>public String id()</code>
            <ul>
                <li><strong>Beschreibung:</strong> Gibt die eindeutige Kennung der Fraktion zurück.</li>
                <li><strong>Rückgabewert:</strong> <code>String</code> - Die ID der Fraktion.</li>
            </ul>
        </li>
        <li>
            <code>public String name()</code>
            <ul>
                <li><strong>Beschreibung:</strong> Gibt den Anzeigenamen der Fraktion zurück.</li>
                <li><strong>Rückgabewert:</strong> <code>String</code> - Der Name der Fraktion.</li>
            </ul>
        </li>
        <li>
            <code>public void setName(String name)</code>
            <ul>
                <li><strong>Beschreibung:</strong> Setzt oder aktualisiert den Anzeigenamen der Fraktion.</li>
                <li><strong>Parameter:</strong> <code>name</code> - Der neue Name der Fraktion.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Guild.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Guild.java</h2>
    <p>
        Die Klasse <code>Guild</code> repräsentiert eine Gilde innerhalb des RPG-Systems. Sie dient als Datenmodell zur Verwaltung von Gildeninformationen, Mitgliedern, deren Rollen sowie gildeninternen Quests und Finanzen.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Diese Klasse speichert den Zustand einer Gilde, einschließlich der Identifikation, des Namens, des Anführers und der Ressourcen.
    </p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>public Guild(String id)</code>: Erstellt eine neue Gilden-Instanz mit einer eindeutigen ID.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public String id()</code>: Gibt die eindeutige Identifikationsnummer (ID) der Gilde zurück.
        </li>
        <li>
            <code>public String name()</code>: Gibt den Anzeigenamen der Gilde zurück.
        </li>
        <li>
            <code>public void setName(String name)</code>: Setzt oder ändert den Namen der Gilde.
        </li>
        <li>
            <code>public UUID leader()</code>: Gibt die <code>UUID</code> des Gildenleiters zurück.
        </li>
        <li>
            <code>public void setLeader(UUID leader)</code>: Legt einen neuen Gildenleiter anhand seiner <code>UUID</code> fest.
        </li>
        <li>
            <code>public int bankGold()</code>: Gibt den aktuellen Goldbestand in der Gildenbank zurück.
        </li>
        <li>
            <code>public void setBankGold(int bankGold)</code>: Aktualisiert den Goldbestand der Gilde. Der Wert wird automatisch auf minimal 0 begrenzt.
        </li>
        <li>
            <code>public Map&lt;UUID, GuildMemberRole&gt; members()</code>: Gibt eine Map aller Gildenmitglieder zurück, wobei die <code>UUID</code> des Spielers dem jeweiligen <code>GuildMemberRole</code>-Status zugeordnet ist.
        </li>
        <li>
            <code>public Map&lt;String, GuildQuest&gt; quests()</code>: Gibt eine Map der aktiven oder verfügbaren Gilden-Quests zurück.
        </li>
    </ul>

    <h3>Eigenschaften (Felder)</h3>
    <ul>
        <li><code>id</code>: Eindeutiger String zur Identifizierung der Gilde.</li>
        <li><code>name</code>: Der Name der Gilde.</li>
        <li><code>leader</code>: Die <code>UUID</code> des Spielers, der die Gilde leitet.</li>
        <li><code>bankGold</code>: Ein ganzzahliger Wert, der das Vermögen der Gilde darstellt.</li>
        <li><code>members</code>: Eine interne Sammlung (HashMap) zur Verwaltung der Mitglieder und ihrer Ränge.</li>
        <li><code>quests</code>: Eine interne Sammlung (HashMap) zur Verwaltung von <code>GuildQuest</code>-Objekten.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildMemberRole.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildMemberRole.java</h2>
    <p>
        Diese Datei definiert die Enumeration <code>GuildMemberRole</code>, welche die verschiedenen Hierarchiestufen innerhalb eines Gilden-Systems im RPG-Plugin festlegt.
    </p>

    <h3>GuildMemberRole (Enum)</h3>
    <p>
        Das Enum dient zur Identifizierung der Berechtigungsstufe eines Spielers innerhalb einer Gilde. Es wird primär vom <code>GuildManager</code> und in der <code>Guild</code>-Klasse verwendet, um administrative Rechte zu prüfen.
    </p>

    <h4>Aufzählungswerte:</h4>
    <ul>
        <li>
            <code>LEADER</code>: Der Gildenleiter. Verfügt über die volle Kontrolle über die Gilde, einschließlich der Auflösung der Gilde und der Ernennung von Offizieren.
        </li>
        <li>
            <code>OFFICER</code>: Ein Gildenoffizier. Besitzt in der Regel administrative Rechte wie das Einladen oder Entfernen von Mitgliedern, untersteht jedoch dem Leiter.
        </li>
        <li>
            <code>MEMBER</code>: Ein reguläres Gildenmitglied ohne administrative Privilegien.
        </li>
    </ul>

    <h4>Verwendung:</h4>
    <p>
        Diese Rollen werden genutzt, um den Zugriff auf Befehle wie <code>/guild kick</code>, <code>/guild invite</code> oder <code>/guild promote</code> innerhalb des <code>GuildCommand</code>-Handlers zu validieren.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildQuest.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/GuildQuest.java</h2>
    <p>
        Die Klasse <code>GuildQuest</code> repräsentiert eine Quest innerhalb des Gildensystems des RPG-Plugins. 
        Sie dient als Datenmodell zur Speicherung von Quest-Informationen, dem aktuellen Fortschritt und dem Abschlussstatus.
    </p>

    <h3>Klasse: GuildQuest</h3>
    <p><strong>Paket:</strong> <code>com.example.rpg.model</code></p>
    <p>
        Diese Klasse verwaltet die Identität, die Beschreibung und die Zielvorgaben einer Gildenquest. 
        Sie stellt sicher, dass Fortschritt und Ziele innerhalb logischer Grenzen bleiben (z. B. keine negativen Werte).
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>GuildQuest(String id)</code>: Erstellt eine neue Instanz einer Gildenquest mit einer eindeutigen ID.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>id()</code>: 
            Gibt die eindeutige Kennung (ID) der Quest zurück.
            <br><em>Rückgabewert:</em> <code>String</code>
        </li>
        <li>
            <code>name()</code> / <code>setName(String name)</code>: 
            Getter und Setter für den Anzeigenamen der Quest.
        </li>
        <li>
            <code>description()</code> / <code>setDescription(String description)</code>: 
            Getter und Setter für die detaillierte Beschreibung der Quest-Aufgabe.
        </li>
        <li>
            <code>goal()</code> / <code>setGoal(int goal)</code>: 
            Verwaltet das Ziel der Quest (z. B. Anzahl zu tötender Monster). 
            Der Setter stellt sicher, dass das Ziel mindestens <code>1</code> beträgt.
        </li>
        <li>
            <code>progress()</code> / <code>setProgress(int progress)</code>: 
            Verwaltet den aktuellen Fortschritt der Gilde. 
            Der Setter stellt sicher, dass der Fortschritt nicht unter <code>0</code> sinkt.
        </li>
        <li>
            <code>completed()</code> / <code>setCompleted(boolean completed)</code>: 
            Gibt an, ob die Quest erfolgreich abgeschlossen wurde, oder setzt diesen Status.
            <br><em>Rückgabewert:</em> <code>boolean</code>
        </li>
    </ul>

    <h4>Besonderheiten</h4>
    <p>
        Die Klasse implementiert eine einfache Validierung in den Setter-Methoden für <code>goal</code> und <code>progress</code>, 
        um inkonsistente Zustände durch die Verwendung von <code>Math.max()</code> zu verhindern.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootEntry.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootEntry.java</h2>

    <p>Die Klasse <code>LootEntry</code> ist ein Datenmodell innerhalb des RPG-Plugins, das einen einzelnen Eintrag in einer Beutetabelle (Loot Table) definiert. Sie legt fest, welcher Gegenstand mit welcher Wahrscheinlichkeit und in welcher Menge fallen gelassen werden kann.</p>

    <h3>Klasse: LootEntry</h3>
    <p>Diese Klasse dient als Container für die Definition von Beute-Drops, die typischerweise von Mobs oder Truhen generiert werden.</p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>LootEntry(String material, double chance, int minAmount, int maxAmount, Rarity rarity)</code>
            <p>Initialisiert einen neuen Beuteeintrag mit den spezifizierten Parametern.</p>
        </li>
    </ul>

    <h4>Attribute / Felder</h4>
    <ul>
        <li><code>material</code> (String): Der Bezeichner des Materials oder Items (z. B. Minecraft-Materialname).</li>
        <li><code>chance</code> (double): Die Drop-Wahrscheinlichkeit (üblicherweise ein Wert zwischen 0.0 und 1.0 oder ein Prozentwert).</li>
        <li><code>minAmount</code> (int): Die minimale Anzahl an Items, die bei einem erfolgreichen Drop generiert werden.</li>
        <li><code>maxAmount</code> (int): Die maximale Anzahl an Items, die bei einem erfolgreichen Drop generiert werden.</li>
        <li><code>rarity</code> (Rarity): Die Seltenheitsstufe des Gegenstands (verweist auf das Enum <code>Rarity</code>).</li>
    </ul>

    <h4>Methoden</h4>
    <p>Die Klasse implementiert Standard-Getter und Setter für alle Attribute. Auffällig ist hierbei die Verwendung eines modernen Namensschemas für die Getter (z. B. <code>material()</code> statt <code>getMaterial()</code>).</p>
    <ul>
        <li><code>material()</code> / <code>setMaterial(String)</code>: Zugriff auf den Materialnamen.</li>
        <li><code>chance()</code> / <code>setChance(double)</code>: Zugriff auf die Drop-Chance.</li>
        <li><code>minAmount()</code> / <code>setMinAmount(int)</code>: Zugriff auf die Mindestmenge.</li>
        <li><code>maxAmount()</code> / <code>setMaxAmount(int)</code>: Zugriff auf die Maximalmenge.</li>
        <li><code>rarity()</code> / <code>setRarity(Rarity)</code>: Zugriff auf die Seltenheit des Eintrags.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootTable.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/LootTable.java</h2>
    <p>
        Die Klasse <code>LootTable</code> repräsentiert eine Beutetabelle innerhalb des RPG-Systems. Sie dient als Container für verschiedene Beuteeinträge (<code>LootEntry</code>) und definiert, worauf diese Tabelle angewendet wird (z. B. auf einen bestimmten Mob-Typ oder eine Truhe).
    </p>

    <h3>Klassenübersicht</h3>
    <p><strong>Name:</strong> <code>LootTable</code></p>
    <p><strong>Paket:</strong> <code>com.example.rpg.model</code></p>
    <p><strong>Beschreibung:</strong> Verwaltet eine Liste von möglichen Belohnungen und deren Zuordnung zu Spielobjekten.</p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>public LootTable(String id)</code>: Erstellt eine neue Instanz der Beutetabelle mit einer eindeutigen Identifikationsnummer.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public String id()</code>
            <p>Gibt die eindeutige ID der Beutetabelle zurück.</p>
            <p><strong>Rückgabewert:</strong> Die ID als <code>String</code>.</p>
        </li>
        <li>
            <code>public String appliesTo()</code>
            <p>Gibt an, für welches Objekt oder welche Kategorie diese Tabelle gilt.</p>
            <p><strong>Rückgabewert:</strong> Ein <code>String</code>, der das Zielobjekt beschreibt.</p>
        </li>
        <li>
            <code>public void setAppliesTo(String appliesTo)</code>
            <p>Legt fest, auf welches Objekt diese Beutetabelle angewendet werden soll.</p>
            <p><strong>Parameter:</strong> <code>appliesTo</code> - Die Kennung des Zielobjekts.</p>
        </li>
        <li>
            <code>public List&lt;LootEntry&gt; entries()</code>
            <p>Gibt die Liste aller in dieser Tabelle enthaltenen Beuteeinträge zurück.</p>
            <p><strong>Rückgabewert:</strong> Eine <code>List</code> von <code>LootEntry</code>-Objekten.</p>
        </li>
        <li>
            <code>public void setEntries(List&lt;LootEntry&gt; entries)</code>
            <p>Überschreibt die aktuelle Liste der Beuteeinträge.</p>
            <p><strong>Parameter:</strong> <code>entries</code> - Eine Liste mit neuen <code>LootEntry</code>-Instanzen.</p>
        </li>
    </ul>

    <h3>Eigenschaften (Private Felder)</h3>
    <ul>
        <li><code>id</code> (final): Die eindeutige Kennung der Tabelle.</li>
        <li><code>appliesTo</code>: Definiert den Anwendungsbereich (z.B. Mob-ID).</li>
        <li><code>entries</code>: Eine Liste vom Typ <code>ArrayList</code>, die die einzelnen Gewinnchancen und Items speichert.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/MobDefinition.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/MobDefinition.java</h2>
    <p>
        Die Klasse <code>MobDefinition</code> dient als Datenmodell zur Definition von benutzerdefinierten Kreaturen (Mobs) innerhalb des RPG-Plugins. 
        Sie kapselt alle grundlegenden Attribute, Ausrüstungsgegenstände, Fähigkeiten und Verhaltensweisen, die einen spezifischen Mob-Typ charakterisieren.
    </p>

    <h3>Klasse: MobDefinition</h3>
    <p>
        Diese Klasse fungiert primär als POJO (Plain Old Java Object) für die Konfiguration von Mobs. Sie wird verwendet, um Daten aus Konfigurationsdateien zu laden und dem <code>MobManager</code> zur Verfügung zu stellen.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>MobDefinition(String id)</code>: Erstellt eine neue Definition mit einer eindeutigen Identifikationsnummer (ID).</li>
    </ul>

    <h4>Eigenschaften (Felder)</h4>
    <ul>
        <li><code>id</code> (String): Die eindeutige Kennung des Mobs.</li>
        <li><code>name</code> (String): Der Anzeigename des Mobs im Spiel.</li>
        <li><code>type</code> (String): Der Basistyp der Entität (z. B. ZOMBIE, SKELETON).</li>
        <li><code>health</code> (double): Die maximalen Lebenspunkte des Mobs.</li>
        <li><code>damage</code> (double): Der Basisschaden, den der Mob verursacht.</li>
        <li><code>mainHand</code> (String): Die ID des Gegenstands, den der Mob in der Haupthand hält.</li>
        <li><code>helmet</code> (String): Die ID des Helms, den der Mob trägt.</li>
        <li><code>skills</code> (List&lt;String&gt;): Eine Liste von Skill-IDs, über die der Mob verfügt.</li>
        <li><code>skillIntervalSeconds</code> (int): Das Zeitintervall in Sekunden, in dem der Mob seine Fähigkeiten einsetzt.</li>
        <li><code>xp</code> (int): Die Menge an Erfahrungspunkten, die ein Spieler beim Töten dieses Mobs erhält.</li>
        <li><code>lootTable</code> (String): Die ID der Beutetabelle (LootTable), die beim Tod des Mobs verwendet wird.</li>
        <li><code>behaviorTree</code> (String): Die ID des Verhaltensbaums (Behavior Tree), der die KI-Logik des Mobs steuert.</li>
    </ul>

    <h4>Methoden</h4>
    <p>
        Die Klasse implementiert Getter- und Setter-Methoden für alle oben genannten Felder. Die Getter folgen dabei einer modernen Namenskonvention ohne das Präfix "get" (z. B. <code>health()</code> statt <code>getHealth()</code>), während die Setter das klassische "set"-Präfix verwenden.
    </p>
    <ul>
        <li><code>id()</code>: Gibt die ID zurück.</li>
        <li><code>name()</code> / <code>setName(String)</code>: Zugriff auf den Anzeigenamen.</li>
        <li><code>health()</code> / <code>setHealth(double)</code>: Zugriff auf die Lebenspunkte.</li>
        <li><code>skills()</code> / <code>setSkills(List&lt;String&gt;)</code>: Zugriff auf die Liste der Fähigkeiten.</li>
        <li><code>behaviorTree()</code> / <code>setBehaviorTree(String)</code>: Zugriff auf die KI-Definition.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Npc.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Npc.java</h2>
    <p>
        Die Klasse <code>Npc</code> ist ein Datenmodell, das einen Nicht-Spieler-Charakter (NPC) innerhalb des RPG-Systems repräsentiert. 
        Sie dient als Container für alle relevanten Informationen eines NPCs, einschließlich seiner Identität, seiner Position in der Spielwelt, 
        seiner Dialoge und seiner funktionalen Verknüpfungen zu anderen Systemen wie Quests oder Shops.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Die Klasse speichert sowohl persistente Daten (wie die ID und den Namen) als auch flüchtige Laufzeitdaten (wie die Minecraft-UUID).
    </p>

    <h3>Wichtige Attribute</h3>
    <ul>
        <li><code>id</code>: Eine eindeutige Zeichenfolge zur Identifizierung des NPC-Typs oder der Instanz in Konfigurationsdateien.</li>
        <li><code>uuid</code>: Die <code>java.util.UUID</code> der tatsächlich in der Minecraft-Welt gespawnten Entität.</li>
        <li><code>name</code>: Der Anzeigename des NPCs, der über seinem Kopf oder in Dialogen erscheint.</li>
        <li><code>role</code>: Ein Objekt vom Typ <code>NpcRole</code>, das die Funktion des NPCs definiert (z. B. Händler, Questgeber).</li>
        <li><code>world, x, y, z, yaw, pitch</code>: Speichern die genaue Position und Blickrichtung des NPCs.</li>
        <li><code>dialog</code>: Eine Liste von Strings, die die Gesprächsinhalte des NPCs enthalten.</li>
        <li><code>questLink</code>: Eine optionale ID, die diesen NPC mit einer bestimmten Quest verknüpft.</li>
        <li><code>shopId</code>: Eine optionale ID, die diesen NPC mit einem Shop-Inventar verknüpft.</li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>Npc(String id)</code>: Konstruktor zur Initialisierung eines NPCs mit einer festen ID.
        </li>
        <li>
            <code>setLocation(Location location)</code>: 
            Extrahiert Weltnamen, Koordinaten und Blickwinkel aus einem Bukkit-<code>Location</code>-Objekt und speichert sie in den entsprechenden Feldern der Klasse.
        </li>
        <li>
            <code>setRawLocation(String world, double x, double y, double z, float yaw, float pitch)</code>: 
            Ermöglicht das manuelle Setzen der Positionsdaten ohne Abhängigkeit von einem Bukkit-Objekt.
        </li>
        <li>
            <code>toLocation(org.bukkit.World world)</code>: 
            Konvertiert die gespeicherten Koordinaten zurück in ein Bukkit-<code>Location</code>-Objekt für die Verwendung in der Spielwelt.
            <br><strong>Parameter:</strong> <code>world</code> - Die Bukkit-Welt, in der die Location erstellt werden soll.
            <br><strong>Rückgabewert:</strong> Ein neues <code>Location</code>-Objekt.
        </li>
        <li>
            <code>Getter und Setter</code>: Standardmethoden für den Zugriff auf und die Modifikation von Attributen wie <code>name</code>, <code>role</code>, <code>dialog</code>, <code>questLink</code> und <code>shopId</code>.
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/NpcRole.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/NpcRole.java</h2>

    <p>
        Die Datei <code>NpcRole.java</code> definiert eine Enumeration (Aufzählungstyp), die die verschiedenen funktionalen Rollen festlegt, die ein Non-Player Character (NPC) innerhalb des RPG-Systems einnehmen kann. Diese Rollen bestimmen maßgeblich, wie Spieler mit dem jeweiligen NPC interagieren können.
    </p>

    <h3>Klasse: NpcRole (Enum)</h3>
    <p>
        Dieser Enum dient als Identifikator für die Logik-Zuweisung bei Interaktionen. Je nach zugewiesener Rolle öffnet das System unterschiedliche Menüs oder startet spezifische Prozesse (z. B. Quest-Dialoge oder Handelsfenster).
    </p>

    <h4>Aufzählungswerte:</h4>
    <ul>
        <li>
            <code>QUESTGIVER</code>: Kennzeichnet einen NPC, der Quests anbietet, Fortschritte überprüft oder Belohnungen für abgeschlossene Aufgaben vergibt.
        </li>
        <li>
            <code>VENDOR</code>: Ein Händler, bei dem Spieler Gegenstände kaufen oder verkaufen können (verknüpft mit dem <code>ShopManager</code>).
        </li>
        <li>
            <code>TRAINER</code>: Ein Ausbilder, der es Spielern ermöglicht, neue Fähigkeiten zu erlernen oder bestehende Skills zu verbessern.
        </li>
        <li>
            <code>TELEPORTER</code>: Ein NPC, der den Spieler gegen Gebühr oder unter bestimmten Bedingungen an andere Orte in der Spielwelt transportiert.
        </li>
        <li>
            <code>BANKER</code>: Ermöglicht den Zugriff auf das globale oder lokale Lagersystem für Items und Währungen.
        </li>
        <li>
            <code>FACTION_AGENT</code>: Ein Vertreter einer Fraktion, der für fraktionsspezifische Interaktionen, Ruf-Management oder spezielle Fraktions-Quests zuständig ist.
        </li>
    </ul>

    <h3>Zusammenhang im System</h3>
    <p>
        Die <code>NpcRole</code> wird in der Klasse <code>Npc</code> verwendet und vom <code>NpcManager</code> sowie dem <code>NpcListener</code> ausgewertet, um bei einem Rechtsklick des Spielers die entsprechende Aktion auszulösen.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Party.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Party.java</h2>
    <p>
        Die Klasse <code>Party</code> repräsentiert eine Gruppe von Spielern innerhalb des RPG-Systems. 
        Sie verwaltet die Identität des Gruppenleiters sowie eine Liste aller Gruppenmitglieder.
    </p>

    <h3>Klasse: Party</h3>
    <p>
        Diese Klasse dient als Datenmodell für das Party-System und ermöglicht die Verwaltung von Spielerzusammenschlüssen.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>Party(UUID leader)</code>: Erstellt eine neue Party mit dem angegebenen Spieler als Leiter. 
            Der Leiter wird automatisch als erstes Mitglied zur Gruppe hinzugefügt.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>leader()</code>
            <p><strong>Rückgabewert:</strong> <code>UUID</code> - Die eindeutige ID des Gruppenleiters.</p>
        </li>
        <li>
            <code>members()</code>
            <p><strong>Rückgabewert:</strong> <code>Set&lt;UUID&gt;</code> - Eine Menge (Set) aller UUIDs der aktuellen Gruppenmitglieder.</p>
        </li>
        <li>
            <code>addMember(UUID uuid)</code>
            <p>Fügt einen neuen Spieler anhand seiner UUID zur Gruppe hinzu.</p>
            <p><strong>Parameter:</strong> <code>uuid</code> - Die ID des hinzuzufügenden Spielers.</p>
        </li>
        <li>
            <code>removeMember(UUID uuid)</code>
            <p>Entfernt einen Spieler aus der Gruppe.</p>
            <p><strong>Parameter:</strong> <code>uuid</code> - Die ID des zu entfernenden Spielers.</p>
        </li>
    </ul>

    <h4>Eigenschaften (Privat)</h4>
    <ul>
        <li><code>leader</code> (UUID): Der permanente Leiter der Gruppe.</li>
        <li><code>members</code> (Set&lt;UUID&gt;): Eine Sammlung von UUIDs, die alle Mitglieder der Party (einschließlich des Leiters) enthält.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/PlayerProfile.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/PlayerProfile.java</h2>
    <p>
        Die Klasse <code>PlayerProfile</code> ist das zentrale Datenmodell für Spieler innerhalb des RPG-Systems. 
        Sie verwaltet alle persistenten Informationen wie Statistiken, Level-Fortschritt, Quests, Gilden-Zugehörigkeiten und Fähigkeiten.
    </p>

    <h3>Klasse: PlayerProfile</h3>
    <p>
        Diese Klasse speichert den Zustand eines Spielers und bietet Methoden zur Manipulation von Erfahrungspunkten sowie zur Anwendung von Attributen auf das Minecraft-Entity des Spielers.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>PlayerProfile(UUID uuid)</code>: Erstellt ein neues Profil für die angegebene UUID und initialisiert alle Basis-Statistiken (RPGStat) mit einem Standardwert von 5.</li>
    </ul>

    <h4>Wichtige Felder / Eigenschaften</h4>
    <ul>
        <li><code>uuid</code>: Die eindeutige Kennung des Spielers.</li>
        <li><code>level</code> / <code>xp</code>: Aktuelles Level und Erfahrungspunkte.</li>
        <li><code>skillPoints</code>: Verfügbare Punkte zum Erlernen oder Verbessern von Fähigkeiten.</li>
        <li><code>mana</code> / <code>maxMana</code>: Aktuelle und maximale Ressourcen für Zauber.</li>
        <li><code>classId</code>: Die ID der gewählten Charakterklasse.</li>
        <li><code>stats</code>: Eine Map der <code>RPGStat</code>-Werte (z.B. Stärke, Intelligenz).</li>
        <li><code>learnedSkills</code>: Map der erlernten Fähigkeiten und deren Stufen.</li>
        <li><code>activeQuests</code> / <code>completedQuests</code>: Verwaltung des Quest-Fortschritts.</li>
        <li><code>skillCooldowns</code>: Speichert den Zeitpunkt der letzten Nutzung einer Fähigkeit (persistent).</li>
        <li><code>skillBindings</code>: Zuordnung von Fähigkeiten zu Hotbar-Slots.</li>
        <li><code>gold</code>: Die In-Game-Währung des Spielers.</li>
        <li><code>elo</code>: Das Matchmaking-Rating für PvP-Aktivitäten.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>addXp(int amount)</code>
            <p>Fügt dem Spieler Erfahrungspunkte hinzu. Führt automatisch einen Level-Aufstieg durch, wenn die benötigten XP erreicht werden, und gewährt Skill-Punkte.</p>
        </li>
        <li>
            <code>xpNeeded()</code>
            <p>Berechnet die für das nächste Level benötigten Erfahrungspunkte basierend auf einer linearen Formel (<code>100 + (level - 1) * 50</code>).</p>
            <strong>Rückgabewert:</strong> <code>int</code> - Benötigte XP.
        </li>
        <li>
            <code>applyAttributes(Player player)</code>
            <p>
                Überträgt die RPG-Statistiken auf die nativen Minecraft-Attribute des Spielers. 
                Beeinflusst unter anderem den Angriffsschaden (Stärke), die maximale Gesundheit (Konstitution), 
                die Angriffsgeschwindigkeit und Bewegungsgeschwindigkeit (Geschicklichkeit) sowie das maximale Mana (Intelligenz).
            </p>
            <strong>Parameter:</strong> <code>Player player</code> - Das Bukkit-Player-Objekt, auf das die Attribute angewendet werden sollen.
        </li>
        <li>
            <code>setGold(int gold)</code> / <code>setElo(int elo)</code>
            <p>Setter-Methoden mit Validierung, um sicherzustellen, dass die Werte nicht unter 0 fallen.</p>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Profession.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Profession.java</h2>

    <p>
        Die Datei definiert das Enum <code>Profession</code>, welches die grundlegenden Kategorien von Berufen innerhalb des RPG-Systems festlegt. 
        Diese Kategorisierung dient dazu, verschiedene Tätigkeiten der Spieler logisch zu gruppieren, beispielsweise für das Fortschrittssystem oder die Zuweisung von Erfahrungspunkten.
    </p>

    <h3>Profession (Enum)</h3>
    <p>
        Repräsentiert den Typ eines Berufs, dem ein Spieler oder eine Tätigkeit zugeordnet werden kann.
    </p>

    <h4>Aufzählungswerte:</h4>
    <ul>
        <li>
            <code>GATHERING</code>: 
            Repräsentiert Sammelberufe. Dies umfasst Tätigkeiten, bei denen Ressourcen aus der Spielwelt gewonnen werden (z. B. Bergbau, Holzfällen oder Kräuterkunde).
        </li>
        <li>
            <code>CRAFTING</code>: 
            Repräsentiert Handwerksberufe. Dies umfasst Tätigkeiten, bei denen aus vorhandenen Ressourcen neue Gegenstände hergestellt werden (z. B. Schmieden, Alchemie oder Schneiderei).
        </li>
    </ul>

    <h4>Verwendung:</h4>
    <p>
        Dieses Enum wird voraussichtlich vom <code>ProfessionManager</code> und in <code>ProfessionListener</code> verwendet, um zu unterscheiden, welche Art von Aktion ein Spieler gerade ausführt und welche Boni oder Fortschritte darauf angewendet werden sollen.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Quest.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Quest.java</h2>
    <p>
        Die Klasse <code>Quest</code> ist ein zentrales Datenmodell innerhalb des RPG-Plugins. Sie definiert die Struktur einer Quest, einschließlich ihrer Anforderungen, der einzelnen Aufgaben (Steps) und der Belohnungen.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Diese Klasse dient als Container für alle Informationen, die eine Quest im Spiel beschreiben. Sie verknüpft logische Abläufe (Schritte) mit Metadaten wie Level-Voraussetzungen und Wiederholbarkeit.
    </p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>Quest(String id)</code>: Erstellt eine neue Quest-Instanz mit einer eindeutigen Identifikationsnummer.
        </li>
    </ul>

    <h3>Eigenschaften (Felder)</h3>
    <ul>
        <li><code>id</code> (String): Die eindeutige Kennung der Quest (final).</li>
        <li><code>name</code> (String): Der Anzeigename der Quest.</li>
        <li><code>description</code> (String): Eine detaillierte Beschreibung der Quest-Handlung oder der Ziele.</li>
        <li><code>repeatable</code> (boolean): Gibt an, ob die Quest nach Abschluss erneut absolviert werden kann.</li>
        <li><code>minLevel</code> (int): Das erforderliche Mindestlevel des Spielers, um die Quest zu starten.</li>
        <li><code>steps</code> (List&lt;QuestStep&gt;): Eine Liste der einzelnen Etappen oder Aufgaben, die für den Abschluss der Quest erfüllt werden müssen.</li>
        <li><code>reward</code> (QuestReward): Ein Objekt, das die Belohnungen definiert, die der Spieler nach erfolgreichem Abschluss erhält.</li>
    </ul>

    <h3>Methoden</h3>
    <p>Die Klasse verwendet Standard-Getter und Setter für den Zugriff auf die privaten Felder. Bemerkenswert ist die Namensgebung der Getter, die dem modernen Java-Stil (ähnlich wie Records) ohne das Präfix "get" folgen:</p>
    <ul>
        <li><code>id()</code>: Gibt die ID der Quest zurück.</li>
        <li><code>name()</code> / <code>setName(String name)</code>: Zugriff auf den Questnamen.</li>
        <li><code>description()</code> / <code>setDescription(String description)</code>: Zugriff auf die Questbeschreibung.</li>
        <li><code>repeatable()</code> / <code>setRepeatable(boolean repeatable)</code>: Steuerung der Wiederholbarkeit.</li>
        <li><code>minLevel()</code> / <code>setMinLevel(int minLevel)</code>: Verwaltung der Level-Voraussetzung.</li>
        <li><code>steps()</code> / <code>setSteps(List&lt;QuestStep&gt; steps)</code>: Verwaltung der Quest-Schritte.</li>
        <li><code>reward()</code> / <code>setReward(QuestReward reward)</code>: Verwaltung der Belohnungsstruktur.</li>
    </ul>

    <h3>Zugehörige Modelle</h3>
    <p>
        Die Klasse <code>Quest</code> arbeitet eng mit anderen Modellen im Paket <code>com.example.rpg.model</code> zusammen, insbesondere:
    </p>
    <ul>
        <li><code>QuestStep</code>: Definiert die spezifischen Ziele innerhalb der Quest.</li>
        <li><code>QuestReward</code>: Definiert Gegenstände, Erfahrungspunkte oder Währungen als Belohnung.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestProgress.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestProgress.java</h2>
    <p>
        Die Klasse <code>QuestProgress</code> dient als Datenmodell zur Verwaltung des aktuellen Fortschritts eines Spielers innerhalb einer spezifischen Quest. 
        Sie speichert, wie weit einzelne Quest-Schritte fortgeschritten sind und ob die Quest insgesamt abgeschlossen wurde.
    </p>

    <h3>Klasse: QuestProgress</h3>
    <p>
        Diese Klasse hält die Beziehung zwischen einer Quest-ID und dem Fortschritt der zugehörigen Aufgaben (Steps).
    </p>

    <h4>Felder</h4>
    <ul>
        <li><code>questId</code> (String): Die eindeutige Kennung der Quest.</li>
        <li><code>stepProgress</code> (Map&lt;Integer, Integer&gt;): Eine Map, die den Index des Quest-Schritts auf den aktuellen numerischen Fortschrittswert mappt.</li>
        <li><code>completed</code> (boolean): Gibt an, ob die Quest bereits erfolgreich beendet wurde.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>questId()</code>
            <p>Gibt die ID der Quest zurück.</p>
            <strong>Rückgabewert:</strong> <code>String</code>
        </li>
        <li>
            <code>stepProgress()</code>
            <p>Gibt die Map mit allen Fortschrittsdaten der einzelnen Schritte zurück.</p>
            <strong>Rückgabewert:</strong> <code>Map&lt;Integer, Integer&gt;</code>
        </li>
        <li>
            <code>incrementStep(int index, int amount)</code>
            <p>Erhöht den Fortschritt eines bestimmten Schritts um einen angegebenen Wert.</p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>index</code>: Der Index des Quest-Schritts.</li>
                <li><code>amount</code>: Der Wert, um den der Fortschritt erhöht werden soll.</li>
            </ul>
        </li>
        <li>
            <code>incrementStepClamped(int index, int amount, int required)</code>
            <p>
                Erhöht den Fortschritt, stellt jedoch sicher, dass der Wert nicht über das erforderliche Ziel (<code>required</code>) hinausgeht. 
                Dies sorgt für stabilen Fortschritt und deterministische Auswertungen.
            </p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>index</code>: Der Index des Quest-Schritts.</li>
                <li><code>amount</code>: Der zu addierende Wert.</li>
                <li><code>required</code>: Der Maximalwert (Zielwert) für diesen Schritt.</li>
            </ul>
        </li>
        <li>
            <code>getStepProgress(int index)</code>
            <p>Ruft den aktuellen Fortschrittswert für einen spezifischen Schritt ab.</p>
            <strong>Rückgabewert:</strong> <code>int</code> (Standardmäßig 0, falls kein Fortschritt existiert).
        </li>
        <li>
            <code>completed()</code>
            <p>Prüft, ob die Quest als abgeschlossen markiert ist.</p>
            <strong>Rückgabewert:</strong> <code>boolean</code>
        </li>
        <li>
            <code>setCompleted(boolean completed)</code>
            <p>Setzt den Status der Quest auf abgeschlossen oder offen.</p>
            <strong>Parameter:</strong> <code>completed</code> (boolean)
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestReward.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestReward.java</h2>
    <p>
        Die Klasse <code>QuestReward</code> ist ein Datenmodell innerhalb des RPG-Plugins, das die Belohnungen definiert, die ein Spieler nach dem erfolgreichen Abschluss einer Quest erhält. Sie dient als Container für verschiedene Arten von Fortschrittswerten und Fraktionsbeziehungen.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        <code>public class QuestReward</code>
    </p>
    <p>
        Diese Klasse verwaltet Erfahrungspunkte (XP), Fertigkeitspunkte (Skill Points) und Ruf-Modifikatoren für verschiedene Fraktionen.
    </p>

    <h3>Attribute</h3>
    <ul>
        <li><code>xp</code> (int): Die Menge an Erfahrungspunkten, die dem Spieler gutgeschrieben werden.</li>
        <li><code>skillPoints</code> (int): Die Anzahl der Fertigkeitspunkte, die der Spieler zur Verbesserung seiner Fähigkeiten erhält.</li>
        <li><code>factionRep</code> (Map&lt;String, Integer&gt;): Eine Map, die Fraktionsnamen (Strings) auf Ganzzahlwerte (Integer) abbildet, um Rufänderungen bei verschiedenen Gruppierungen darzustellen.</li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public int xp()</code>
            <p>Gibt die Anzahl der Erfahrungspunkte zurück.</p>
        </li>
        <li>
            <code>public void setXp(int xp)</code>
            <p>Legt die Anzahl der zu vergebenden Erfahrungspunkte fest.</p>
        </li>
        <li>
            <code>public int skillPoints()</code>
            <p>Gibt die Anzahl der Fertigkeitspunkte zurück.</p>
        </li>
        <li>
            <code>public void setSkillPoints(int skillPoints)</code>
            <p>Legt die Anzahl der zu vergebenden Fertigkeitspunkte fest.</p>
        </li>
        <li>
            <code>public Map&lt;String, Integer&gt; factionRep()</code>
            <p>Gibt die Map der Fraktionsruf-Belohnungen zurück.</p>
        </li>
        <li>
            <code>public void setFactionRep(Map&lt;String, Integer&gt; factionRep)</code>
            <p>Setzt die gesamte Map für die Fraktionsruf-Belohnungen.</p>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStep.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStep.java</h2>

    <p>
        Die Klasse <code>QuestStep</code> ist ein Datenmodell innerhalb des RPG-Plugins, das einen einzelnen Arbeitsschritt oder eine Teilaufgabe innerhalb einer Quest repräsentiert. 
        Sie definiert, was ein Spieler tun muss (Typ), worauf sich die Aktion bezieht (Ziel) und wie oft diese Aktion ausgeführt werden muss (Anzahl).
    </p>

    <h3>Klasse: QuestStep</h3>
    <p><strong>Paket:</strong> <code>com.example.rpg.model</code></p>
    
    <h4>Beschreibung</h4>
    <p>
        Diese Klasse dient als Container für die Anforderungen eines Quest-Abschnitts. Sie wird typischerweise von der <code>QuestManager</code>-Logik verwendet, 
        um den Fortschritt eines Spielers gegen vordefinierte Ziele zu prüfen.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>QuestStep(QuestStepType type, String target, int amount)</code>: 
            Initialisiert einen neuen Quest-Schritt mit dem angegebenen Typ, dem Zielobjekt und der benötigten Menge.
        </li>
    </ul>

    <h4>Felder / Eigenschaften</h4>
    <ul>
        <li>
            <code>type</code> (QuestStepType): 
            Der Typ der Aufgabe (z. B. KILL, COLLECT, TALK). Bestimmt die Logik, wie dieser Schritt erfüllt werden kann.
        </li>
        <li>
            <code>target</code> (String): 
            Die Identifikation des Ziels. Dies kann die ID eines Mobs, der Name eines Items oder die ID eines NPCs sein.
        </li>
        <li>
            <code>amount</code> (int): 
            Die erforderliche Anzahl an Interaktionen oder Gegenständen, um diesen Schritt abzuschließen.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>type()</code> / <code>setType(QuestStepType type)</code>: 
            Getter und Setter für den Typ des Quest-Schritts.
        </li>
        <li>
            <code>target()</code> / <code>setTarget(String target)</code>: 
            Getter und Setter für das Ziel des Quest-Schritts.
        </li>
        <li>
            <code>amount()</code> / <code>setAmount(int amount)</code>: 
            Getter und Setter für die benötigte Anzahl.
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStepType.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/QuestStepType.java</h2>

    <p>
        Die Enumeration <code>QuestStepType</code> definiert die verschiedenen Arten von Aufgaben oder Zielen, die innerhalb eines Quest-Schritts (QuestStep) im RPG-System vorkommen können. 
        Sie dient als Identifikator für die Logik, die zur Überprüfung des Fortschritts eines Spielers herangezogen wird.
    </p>

    <h3>Enum-Werte</h3>
    <ul>
        <li>
            <code>KILL</code>: Erfordert das Besiegen einer bestimmten Anzahl von Kreaturen oder Mobs.
        </li>
        <li>
            <code>COLLECT</code>: Erfordert das Sammeln oder Beschaffen einer bestimmten Menge eines Gegenstands.
        </li>
        <li>
            <code>TALK</code>: Erfordert die Interaktion bzw. das Gespräch mit einem bestimmten NPC.
        </li>
        <li>
            <code>EXPLORE</code>: Erfordert das Erreichen oder Entdecken eines bestimmten Ortes oder einer Zone.
        </li>
        <li>
            <code>CRAFT</code>: Erfordert die Herstellung eines spezifischen Gegenstands über das Crafting-System.
        </li>
        <li>
            <code>USE_ITEM</code>: Erfordert die Verwendung eines bestimmten Items (z. B. das Aktivieren eines Quest-Gegenstands).
        </li>
        <li>
            <code>DEFEND</code>: Erfordert das Verteidigen eines Ziels oder Bereichs über einen festgelegten Zeitraum.
        </li>
        <li>
            <code>ESCORT</code>: Erfordert das Begleiten und Schützen eines NPCs zu einem Zielort.
        </li>
    </ul>

    <h3>Kontext innerhalb der Architektur</h3>
    <p>
        Diese Enumeration wird primär in der Klasse <code>QuestStep</code> verwendet, um festzulegen, welche Bedingung erfüllt sein muss, damit der Schritt als abgeschlossen gilt. 
        Der <code>QuestManager</code> nutzt diese Typen, um Events (wie das Töten eines Monsters oder das Aufheben eines Items) den aktiven Quests der Spieler zuzuordnen.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/RPGStat.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/RPGStat.java</h2>
    <p>
        Diese Datei definiert das Enum <code>RPGStat</code>, welches die grundlegenden Charakterattribute (Stats) innerhalb des RPG-Systems repräsentiert. Diese Attribute dienen als Basis für Berechnungen von Schaden, Verteidigung, kritischen Treffern und anderen Spielmechaniken.
    </p>

    <h3>Enum: RPGStat</h3>
    <p>
        Das Enum <code>RPGStat</code> stellt eine feste Liste von Attributen bereit, die Spielern, Mobs oder Gegenständen zugewiesen werden können.
    </p>

    <h4>Verfügbare Attribute (Konstanten):</h4>
    <ul>
        <li>
            <code>STRENGTH</code> (Stärke): 
            Wird üblicherweise zur Berechnung von physischem Schaden und Nahkampfangriffen verwendet.
        </li>
        <li>
            <code>DEXTERITY</code> (Geschicklichkeit): 
            Beeinflusst oft die Angriffsgeschwindigkeit, Fernkampfschaden oder die Ausweichchance.
        </li>
        <li>
            <code>CONSTITUTION</code> (Konstitution): 
            Bestimmt in der Regel die maximalen Lebenspunkte (HP) und die Widerstandsfähigkeit des Charakters.
        </li>
        <li>
            <code>INTELLIGENCE</code> (Intelligenz): 
            Wird primär für magischen Schaden, Manavorrat oder die Effektivität von Fähigkeiten genutzt.
        </li>
        <li>
            <code>LUCK</code> (Glück): 
            Beeinflusst meist die Chance auf kritische Treffer oder die Qualität der Beute (Loot).
        </li>
    </ul>

    <h4>Verwendung im Projekt:</h4>
    <p>
        Als zentrales Datenmodell wird dieses Enum von verschiedenen Managern und Listenern referenziert, insbesondere im <code>ItemStatManager</code> zur Attributvergabe auf Ausrüstung und im <code>PlayerDataManager</code> zur Verwaltung der Spielerwerte.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Rarity.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Rarity.java</h2>
    <p>
        Die Datei definiert das Enum <code>Rarity</code>, welches die verschiedenen Seltenheitsstufen für Gegenstände oder Entitäten innerhalb des RPG-Systems festlegt. 
        Jede Stufe ist mit einer spezifischen Farbe für die Anzeige und einer Gewichtung für die Wahrscheinlichkeitsberechnung (z. B. beim Loot-System) verknüpft.
    </p>

    <h3>Enum: Rarity</h3>
    <p>
        Dieses Enum repräsentiert die Seltenheitsgrade und stellt Metadaten für die visuelle Darstellung und die Spielbalance bereit.
    </p>

    <h4>Aufzählungswerte (Constants)</h4>
    <ul>
        <li><code>COMMON</code>: Gewöhnlich. Farbe: Weiß, Gewichtung: 1.0.</li>
        <li><code>UNCOMMON</code>: Ungewöhnlich. Farbe: Grün, Gewichtung: 0.6.</li>
        <li><code>RARE</code>: Selten. Farbe: Blau, Gewichtung: 0.35.</li>
        <li><code>EPIC</code>: Episch. Farbe: Dunkellila, Gewichtung: 0.15.</li>
        <li><code>LEGENDARY</code>: Legendär. Farbe: Gold, Gewichtung: 0.05.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>color()</code>: 
            <p>Gibt die zugehörige <code>NamedTextColor</code> zurück, die für die Formatierung von Texten (z. B. Item-Namen) in der Minecraft-Welt verwendet wird.</p>
            <strong>Rückgabewert:</strong> <code>NamedTextColor</code>
        </li>
        <li>
            <code>weight()</code>: 
            <p>Gibt den numerischen Gewichtungswert der Seltenheitsstufe zurück. Dieser Wert wird typischerweise von Systemen wie dem <code>LootManager</code> verwendet, um die Drop-Chancen zu berechnen.</p>
            <strong>Rückgabewert:</strong> <code>double</code>
        </li>
    </ul>

    <h4>Technische Details</h4>
    <p>
        Das Enum nutzt die <code>net.kyori.adventure</code> API für die Farbverwaltung, was eine moderne und flexible Textgestaltung innerhalb des Minecraft-Plugins ermöglicht.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopDefinition.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopDefinition.java</h2>
    <p>
        Die Klasse <code>ShopDefinition</code> ist ein Datenmodell innerhalb des RPG-Plugins, das die Struktur und den Inhalt eines virtuellen Händlers (Shops) definiert. Sie dient als Container für Metadaten wie den Anzeigenamen und die Zuordnung von Verkaufsgegenständen zu bestimmten Inventarplätzen.
    </p>

    <h3>Klassenübersicht</h3>
    <p><strong>Name:</strong> <code>ShopDefinition</code></p>
    <p><strong>Paket:</strong> <code>com.example.rpg.model</code></p>
    <p><strong>Beschreibung:</strong> Repräsentiert die Konfiguration eines Shops, einschließlich seiner eindeutigen ID, des Titels für das GUI-Fenster und einer Liste von Gegenständen.</p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>public ShopDefinition(String id)</code>: Erzeugt eine neue Shop-Definition mit einer eindeutigen Kennung.
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public String id()</code>
            <p>Gibt die eindeutige Identifikationszeichenfolge des Shops zurück.</p>
            <p><strong>Rückgabewert:</strong> Die Shop-ID als <code>String</code>.</p>
        </li>
        <li>
            <code>public String title()</code>
            <p>Gibt den Titel des Shops zurück, der normalerweise in der Kopfzeile des Inventar-GUIs angezeigt wird.</p>
            <p><strong>Rückgabewert:</strong> Der Anzeigename des Shops.</p>
        </li>
        <li>
            <code>public void setTitle(String title)</code>
            <p>Legt den Titel für den Shop fest.</p>
            <p><strong>Parameter:</strong> <code>title</code> - Der neue Anzeigename.</p>
        </li>
        <li>
            <code>public Map&lt;Integer, ShopItem&gt; items()</code>
            <p>Gibt die Map der im Shop verfügbaren Gegenstände zurück.</p>
            <p><strong>Rückgabewert:</strong> Eine <code>Map</code>, bei der der Schlüssel (<code>Integer</code>) den Slot-Index im Inventar und der Wert das entsprechende <code>ShopItem</code> darstellt.</p>
        </li>
        <li>
            <code>public void setItems(Map&lt;Integer, ShopItem&gt; items)</code>
            <p>Ersetzt die aktuelle Liste der Shop-Gegenstände durch eine neue Map.</p>
            <p><strong>Parameter:</strong> <code>items</code> - Eine Map von Slot-Indizes zu <code>ShopItem</code>-Objekten.</p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>com.example.rpg.model.ShopItem</code>: Repräsentiert die einzelnen Gegenstände, die innerhalb dieser Definition verkauft werden.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopItem.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/ShopItem.java</h2>
    <p>
        Die Klasse <code>ShopItem</code> ist ein Datenmodell innerhalb des RPG-Plugins, das ein einzelnes Item repräsentiert, welches in einem In-Game-Shop zum Kauf oder Verkauf angeboten wird. Sie dient als Container für die Konfiguration von Shop-Einträgen.
    </p>

    <h3>Klasse: ShopItem</h3>
    <p>
        Diese Klasse definiert die Eigenschaften eines Gegenstands in einem Shop-Inventar, einschließlich seiner Position im GUI und seiner ökonomischen Werte.
    </p>

    <h4>Felder / Eigenschaften</h4>
    <ul>
        <li><code>slot</code> (int): Der Index des Inventar-Slots, in dem das Item im Shop-Menü angezeigt wird.</li>
        <li><code>material</code> (String): Der technische Name des Minecraft-Materials (z. B. "DIAMOND_SWORD").</li>
        <li><code>name</code> (String): Der Anzeigename des Items im Shop.</li>
        <li><code>buyPrice</code> (int): Der Preis, den ein Spieler bezahlen muss, um das Item zu kaufen.</li>
        <li><code>sellPrice</code> (int): Der Betrag, den ein Spieler erhält, wenn er das Item an den Shop verkauft.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>slot()</code> / <code>setSlot(int slot)</code>
            <p>Getter und Setter für die Position des Items im Shop-Layout.</p>
        </li>
        <li>
            <code>material()</code> / <code>setMaterial(String material)</code>
            <p>Getter und Setter für den Materialtyp des Items.</p>
        </li>
        <li>
            <code>name()</code> / <code>setName(String name)</code>
            <p>Getter und Setter für den benutzerdefinierten Anzeigenamen des Items.</p>
        </li>
        <li>
            <code>buyPrice()</code> / <code>setBuyPrice(int buyPrice)</code>
            <p>Getter und Setter für den Kaufpreis.</p>
        </li>
        <li>
            <code>sellPrice()</code> / <code>setSellPrice(int sellPrice)</code>
            <p>Getter und Setter für den Verkaufspreis.</p>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Skill.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Skill.java</h2>
    <p>
        Die Klasse <code>Skill</code> ist ein Datenmodell innerhalb des RPG-Plugins, das eine spezifische Fähigkeit (Skill) repräsentiert. 
        Sie dient als Container für alle relevanten Metadaten, Kosten und Effekte, die mit einer Fähigkeit verknüpft sind.
    </p>

    <h3>Klasse: Skill</h3>
    <p>
        Diese Klasse definiert die Struktur einer Fähigkeit, einschließlich ihrer Identifikation, Kategorisierung und der Liste der auszuführenden Effekte.
    </p>

    <h4>Attribute</h4>
    <ul>
        <li><code>id</code> (String): Die eindeutige Kennung des Skills (final).</li>
        <li><code>name</code> (String): Der Anzeigename der Fähigkeit.</li>
        <li><code>type</code> (SkillType): Der Typ der Fähigkeit (z. B. Aktiv, Passiv).</li>
        <li><code>category</code> (SkillCategory): Die Kategorie, zu der der Skill gehört (z. B. Kampf, Magie).</li>
        <li><code>cooldown</code> (int): Die Abklingzeit in Ticks oder Sekunden, bevor der Skill erneut verwendet werden kann.</li>
        <li><code>manaCost</code> (int): Die Menge an Mana, die für die Aktivierung benötigt wird.</li>
        <li><code>requiredSkill</code> (String): Die ID einer Voraussetzung, die erfüllt sein muss, um diesen Skill zu erlernen oder zu nutzen.</li>
        <li><code>effects</code> (List&lt;SkillEffectConfig&gt;): Eine Liste von Konfigurationen für Effekte, die beim Auslösen des Skills angewendet werden.</li>
    </ul>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>Skill(String id)</code>: Erstellt eine neue Instanz eines Skills mit der angegebenen ID.
        </li>
    </ul>

    <h4>Wichtige Methoden</h4>
    <ul>
        <li><code>id()</code>: Gibt die eindeutige ID des Skills zurück.</li>
        <li><code>name()</code> / <code>setName(String name)</code>: Getter und Setter für den Anzeigenamen.</li>
        <li><code>type()</code> / <code>setType(SkillType type)</code>: Getter und Setter für den Skill-Typ.</li>
        <li><code>category()</code> / <code>setCategory(SkillCategory category)</code>: Getter und Setter für die Skill-Kategorie.</li>
        <li><code>cooldown()</code> / <code>setCooldown(int cooldown)</code>: Getter und Setter für die Abklingzeit.</li>
        <li><code>manaCost()</code> / <code>setManaCost(int manaCost)</code>: Getter und Setter für die Manakosten.</li>
        <li><code>effects()</code> / <code>setEffects(List&lt;SkillEffectConfig&gt; effects)</code>: Verwaltet die Liste der Effekte, die an diesen Skill gebunden sind.</li>
        <li><code>requiredSkill()</code> / <code>setRequiredSkill(String requiredSkill)</code>: Getter und Setter für die ID der Skill-Voraussetzung.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillCategory.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillCategory.java</h2>

    <p>
        Die Datei <code>SkillCategory.java</code> definiert ein Java-Enum, das die verschiedenen Kategorien von Fähigkeiten (Skills) innerhalb des RPG-Systems klassifiziert. 
        Diese Kategorisierung dient der logischen Gruppierung von Talenten, der Steuerung von Skill-Bäumen und der Zuweisung von Effekten.
    </p>

    <h3>Enum: SkillCategory</h3>
    <p>
        Dieses Enum stellt die verfügbaren Skill-Kategorien bereit, die von anderen Systemen (wie dem <code>SkillManager</code> oder der <code>SkillTreeGui</code>) zur Filterung und Anzeige genutzt werden.
    </p>

    <h4>Verfügbare Kategoriewerte:</h4>
    <ul>
        <li>
            <code>HEALING</code>: Repräsentiert Heilzauber und regenerative Fähigkeiten, die darauf abzielen, Lebenspunkte wiederherzustellen.
        </li>
        <li>
            <code>MAGIC</code>: Umfasst allgemeine magische Fähigkeiten, arkane Zauber oder Utility-Spells, die nicht primär auf Direktschaden oder Heilung fokussiert sind.
        </li>
        <li>
            <code>ATTACK</code>: Bezeichnet offensive Fähigkeiten, die darauf ausgelegt sind, Gegnern Schaden zuzufügen (sowohl Nah- als auch Fernkampf).
        </li>
        <li>
            <code>DEFENSE</code>: Beinhaltet defensive Talente, Schilde oder Buffs, die die Schadensresistenz des Spielers erhöhen.
        </li>
        <li>
            <code>PROFESSION</code>: Bezieht sich auf berufsbezogene Fähigkeiten (z. B. Bergbau, Schmieden), die außerhalb des direkten Kampfgeschehens relevant sind.
        </li>
    </ul>

    <h4>Verwendung im Projekt:</h4>
    <p>
        Die <code>SkillCategory</code> wird primär in der Klasse <code>Skill</code> verwendet, um festzulegen, zu welchem Zweig ein Skill gehört. Dies ermöglicht es dem Plugin, spezifische Boni basierend auf der Kategorie zu vergeben oder die Benutzeroberfläche im Skill-Baum entsprechend zu strukturieren.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillType.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/SkillType.java</h2>

    <p>
        Die Datei <code>SkillType.java</code> definiert eine Enumeration (Aufzählungstyp), die die grundlegende Art der Aktivierung oder Wirkungsweise einer Fähigkeit (Skill) im RPG-System festlegt.
    </p>

    <h3>Enum: SkillType</h3>
    <p>
        Dieses Enum dient zur Unterscheidung zwischen Fähigkeiten, die vom Spieler aktiv ausgelöst werden müssen, und solchen, die dauerhaft oder automatisch im Hintergrund wirken.
    </p>

    <h4>Aufzählungswerte:</h4>
    <ul>
        <li>
            <code>ACTIVE</code>: Repräsentiert eine aktive Fähigkeit. Diese erfordert in der Regel eine Interaktion des Spielers (z. B. Tastendruck oder Auswahl im Hotbar), verbraucht oft Ressourcen (wie Mana oder Ausdauer) und hat meist eine Abklingzeit (Cooldown).
        </li>
        <li>
            <code>PASSIVE</code>: Repräsentiert eine passive Fähigkeit. Diese wirkt dauerhaft auf den Charakter oder wird durch bestimmte Ereignisse automatisch ausgelöst, ohne dass der Spieler die Fähigkeit manuell aktivieren muss (z. B. Attributsboni oder Chance auf kritische Treffer).
        </li>
    </ul>

    <h4>Verwendung:</h4>
    <p>
        Das <code>SkillType</code>-Enum wird primär in der Klasse <code>Skill</code> verwendet, um die Logik der Skill-Verarbeitung zu steuern. Es hilft dem <code>SkillManager</code> und dem <code>SkillHotbarManager</code> zu entscheiden, ob ein Skill einem Slot zugewiesen werden kann oder ob seine Effekte permanent appliziert werden müssen.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Spawner.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Spawner.java</h2>
    <p>
        Die Klasse <code>Spawner</code> ist ein Datenmodell innerhalb des RPG-Plugins, das die Konfiguration für einen automatisierten Mob-Generator (Spawner) definiert. 
        Sie legt fest, in welcher Zone Mobs erscheinen, wie viele maximal gleichzeitig existieren dürfen und welche Wahrscheinlichkeiten für verschiedene Mob-Typen gelten.
    </p>

    <h3>Klasse: Spawner</h3>
    <p>
        Diese Klasse dient als Container für die Konfigurationsdaten eines Spawners. Sie wird primär vom <code>SpawnerManager</code> verwendet, um die Spielwelt mit Gegnern zu bevölkern.
    </p>

    <h4>Felder / Eigenschaften</h4>
    <ul>
        <li><code>id</code> (String): Eine eindeutige Kennung für diesen spezifischen Spawner.</li>
        <li><code>zoneId</code> (String): Die ID der <code>Zone</code>, in der dieser Spawner aktiv ist.</li>
        <li><code>maxMobs</code> (int): Die maximale Anzahl an Entitäten, die dieser Spawner gleichzeitig in der Welt halten darf.</li>
        <li><code>spawnInterval</code> (int): Das Zeitintervall (üblicherweise in Sekunden oder Ticks), in dem der Spawner versucht, neue Mobs zu generieren.</li>
        <li><code>mobs</code> (Map&lt;String, Double&gt;): Eine Map, die Mob-IDs auf ihre jeweilige Spawn-Wahrscheinlichkeit (Gewichtung) abbildet.</li>
    </ul>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>public Spawner(String id)</code>: Erzeugt eine neue Spawner-Instanz mit der angegebenen eindeutigen ID.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li><code>public String id()</code>: Gibt die eindeutige ID des Spawners zurück.</li>
        <li><code>public String zoneId()</code> / <code>setZoneId(String zoneId)</code>: Getter und Setter für die zugehörige Zonen-ID.</li>
        <li><code>public int maxMobs()</code> / <code>setMaxMobs(int maxMobs)</code>: Getter und Setter für das Limit der gleichzeitig existierenden Mobs.</li>
        <li><code>public int spawnInterval()</code> / <code>setSpawnInterval(int spawnInterval)</code>: Getter und Setter für das Zeitintervall zwischen den Spawn-Vorgängen.</li>
        <li><code>public Map&lt;String, Double&gt; mobs()</code> / <code>setMobs(Map&lt;String, Double&gt; mobs)</code>: Getter und Setter für die Liste der verfügbaren Mobs und deren Gewichtung.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/TradeRequest.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/TradeRequest.java</h2>
    <p>
        Die Klasse <code>TradeRequest</code> ist ein Datenmodell innerhalb des RPG-Plugins, das eine aktive Handelsanfrage zwischen zwei Spielern repräsentiert. 
        Sie speichert den Status des Handels, einschließlich der beteiligten Parteien, der angebotenen Goldmengen und des Bereitschaftsstatus beider Teilnehmer.
    </p>

    <h3>Klasse: TradeRequest</h3>
    <p>
        Diese Klasse dient als Container für alle relevanten Informationen während eines laufenden Handelsprozesses.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li>
            <code>TradeRequest(UUID requester, UUID target)</code>: Initialisiert eine neue Handelsanfrage.
            <ul>
                <li><strong>requester:</strong> Die <code>UUID</code> des Spielers, der den Handel initiiert hat.</li>
                <li><strong>target:</strong> Die <code>UUID</code> des Spielers, an den die Anfrage gerichtet ist.</li>
            </ul>
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>requester()</code>: Gibt die <code>UUID</code> des Initiators zurück.
            <br><strong>Rückgabewert:</strong> <code>UUID</code>
        </li>
        <li>
            <code>target()</code>: Gibt die <code>UUID</code> des Zielspielers zurück.
            <br><strong>Rückgabewert:</strong> <code>UUID</code>
        </li>
        <li>
            <code>goldOffer()</code> / <code>setGoldOffer(int goldOffer)</code>: Getter und Setter für die Menge an Gold, die der Initiator anbietet.
        </li>
        <li>
            <code>goldRequest()</code> / <code>setGoldRequest(int goldRequest)</code>: Getter und Setter für die Menge an Gold, die der Initiator vom Zielspieler fordert.
        </li>
        <li>
            <code>requesterReady()</code> / <code>setRequesterReady(boolean requesterReady)</code>: Verwaltet den Bereitschaftsstatus des Initiators. Ein Handel kann in der Regel nur abgeschlossen werden, wenn beide Parteien "ready" sind.
        </li>
        <li>
            <code>targetReady()</code> / <code>setTargetReady(boolean targetReady)</code>: Verwaltet den Bereitschaftsstatus des Zielspielers.
        </li>
    </ul>

    <h4>Eigenschaften (Felder)</h4>
    <ul>
        <li><code>requester</code>: Eindeutige ID des Anfragenden (final).</li>
        <li><code>target</code>: Eindeutige ID des Empfängers (final).</li>
        <li><code>goldOffer</code>: Betrag an Gold, den der Anfragende gibt.</li>
        <li><code>goldRequest</code>: Betrag an Gold, den der Anfragende erhalten möchte.</li>
        <li><code>requesterReady</code>: Status, ob der Anfragende dem Handel zugestimmt hat.</li>
        <li><code>targetReady</code>: Status, ob der Empfänger dem Handel zugestimmt hat.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Zone.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/model/Zone.java</h2>
    <p>
        Die Klasse <code>Zone</code> repräsentiert einen definierten räumlichen Bereich innerhalb der Spielwelt des RPG-Plugins. 
        Sie dient dazu, Regionen zu markieren, die spezifische Eigenschaften wie Level-Anforderungen oder Modifikatoren für Bewegung und Schaden besitzen.
    </p>

    <h3>Klasse: Zone</h3>
    <p>
        Diese Klasse speichert die Metadaten und die räumlichen Begrenzungen (Bounding Box) einer Zone.
    </p>

    <h4>Konstruktor</h4>
    <ul>
        <li><code>Zone(String id)</code>: Erstellt eine neue Zone mit einer eindeutigen Identifikationsnummer.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>id()</code>: 
            Gibt die eindeutige ID der Zone zurück.
        </li>
        <li>
            <code>name() / setName(String name)</code>: 
            Getter und Setter für den Anzeigenamen der Zone.
        </li>
        <li>
            <code>world() / setWorld(String world)</code>: 
            Verwaltet den Namen der Welt (Bukkit World), in der sich diese Zone befindet.
        </li>
        <li>
            <code>minLevel() / setMinLevel(int level)</code> und <code>maxLevel() / setMaxLevel(int level)</code>: 
            Definiert den empfohlenen Levelbereich für Spieler in dieser Zone.
        </li>
        <li>
            <code>slowMultiplier() / setSlowMultiplier(double multiplier)</code>: 
            Gibt einen Multiplikator für die Bewegungsgeschwindigkeit zurück oder setzt diesen (Standard: 1.0).
        </li>
        <li>
            <code>damageMultiplier() / setDamageMultiplier(double multiplier)</code>: 
            Gibt einen Multiplikator für den verursachten oder erlittenen Schaden in dieser Zone zurück oder setzt diesen (Standard: 1.0).
        </li>
        <li>
            <code>setBounds(Location pos1, Location pos2)</code>: 
            Berechnet die minimalen und maximalen Eckpunkte der Zone basierend auf zwei gegebenen Bukkit-Locations, um eine quaderförmige Auswahl zu erstellen.
        </li>
        <li>
            <code>contains(Location location)</code>: 
            Prüft, ob sich eine gegebene <code>Location</code> innerhalb der Grenzen dieser Zone befindet. Berücksichtigt dabei sowohl die Welt als auch die X-, Y- und Z-Koordinaten.
            <br><strong>Rückgabewert:</strong> <code>boolean</code> (true, wenn die Location innerhalb der Zone liegt).
        </li>
        <li>
            <code>setCoordinates(int x1, int y1, int z1, int x2, int y2, int z2)</code>: 
            Ermöglicht das direkte Setzen der Grenzkoordinaten der Zone.
        </li>
        <li>
            <code>x1(), y1(), z1(), x2(), y2(), z2()</code>: 
            Getter-Methoden für die einzelnen Koordinaten der Zonenbegrenzung.
        </li>
    </ul>

    <h4>Eigenschaften (Felder)</h4>
    <ul>
        <li><code>id</code>: Eindeutiger Bezeichner (final).</li>
        <li><code>name</code>: Anzeigename der Region.</li>
        <li><code>world</code>: Name der Minecraft-Welt.</li>
        <li><code>minLevel / maxLevel</code>: Level-Restriktionen.</li>
        <li><code>slowMultiplier</code>: Faktor für Verlangsamungseffekte.</li>
        <li><code>damageMultiplier</code>: Faktor für Schadensmodifikationen.</li>
        <li><code>x1, y1, z1</code>: Die minimalen Koordinaten-Eckpunkte.</li>
        <li><code>x2, y2, z2</code>: Die maximalen Koordinaten-Eckpunkte.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffect.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffect.java</h2>
    <p>
        Das Interface <code>SkillEffect</code> definiert die grundlegende Struktur für alle Effekte, die durch Fähigkeiten (Skills) im RPG-System ausgelöst werden können. Es dient als Abstraktionsschicht, um verschiedene Aktionen wie Heilung, Schaden oder visuelle Effekte einheitlich zu behandeln.
    </p>

    <h3>Interface: <code>SkillEffect</code></h3>
    <p>
        Dieses Interface stellt die Schnittstelle bereit, über die das Plugin Skill-Effekte ausführt und beschreibt.
    </p>

    <h4>Methoden:</h4>
    <ul>
        <li>
            <code>void apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code>
            <p>
                Führt den Effekt auf den angegebenen Spieler aus.
            </p>
            <ul>
                <li><strong>player:</strong> Das <code>Player</code>-Objekt von Bukkit, auf das der Effekt angewendet wird oder das den Effekt auslöst.</li>
                <li><strong>profile:</strong> Das RPG-Profil des Spielers (<code>PlayerProfile</code>), um statistische Daten oder Fortschritte zu berücksichtigen.</li>
                <li><strong>params:</strong> Eine Map mit Konfigurationsparametern für den Effekt (z. B. Schadenshöhe, Radius, Dauer).</li>
            </ul>
        </li>
        <li>
            <code>default List&lt;Component&gt; describe(Map&lt;String, Object&gt; params)</code>
            <p>
                Generiert eine textuelle Beschreibung des Effekts basierend auf den übergebenen Parametern. Dies wird typischerweise für Tooltips in GUIs verwendet.
            </p>
            <ul>
                <li><strong>params:</strong> Die Konfigurationsparameter des Effekts.</li>
                <li><strong>Rückgabewert:</strong> Eine Liste von <code>Component</code>-Objekten (Adventure API), die die Beschreibung enthalten. Standardmäßig wird eine leere Liste zurückgegeben.</li>
            </ul>
        </li>
    </ul>

    <h3>Zusammenhang im System</h3>
    <p>
        Implementierungen dieses Interfaces (wie <code>DamageEffect</code> oder <code>HealEffect</code>) werden im <code>SkillEffectRegistry</code> registriert und über <code>SkillEffectConfig</code> instanziiert. Dies ermöglicht ein modulares System, in dem neue Effekte hinzugefügt werden können, ohne den Kerncode der Skill-Logik zu verändern.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectConfig.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectConfig.java</h2>
    <p>
        Die Klasse <code>SkillEffectConfig</code> dient als Datencontainer für die Konfiguration eines spezifischen Skill-Effekts. 
        Sie verknüpft einen Effekttyp mit einer flexiblen Map von Parametern, um verschiedene Verhaltensweisen (wie Schaden, Heilung oder Partikel) 
        innerhalb des RPG-Systems zu definieren.
    </p>

    <h3>Klasse: SkillEffectConfig</h3>
    <p>
        Diese Klasse kapselt die notwendigen Informationen, um einen <code>SkillEffect</code> zu instanziieren oder zu beschreiben.
    </p>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>SkillEffectConfig(SkillEffectType type, Map&lt;String, Object&gt; params)</code>: 
            Erstellt eine neue Konfiguration. Wenn die übergebene Parameter-Map nicht null ist, werden alle darin enthaltenen Werte in die interne Konfiguration kopiert.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>type()</code>: 
            Gibt den <code>SkillEffectType</code> zurück, der den Basistyp des Effekts definiert.
            <br><strong>Rückgabewert:</strong> <code>SkillEffectType</code>
        </li>
        <li>
            <code>setType(SkillEffectType type)</code>: 
            Aktualisiert den Typ des Effekts.
        </li>
        <li>
            <code>params()</code>: 
            Gibt die Map der Parameter zurück, die spezifische Einstellungen für den Effekt enthalten (z. B. Schadenshöhe, Radius, Dauer).
            <br><strong>Rückgabewert:</strong> <code>Map&lt;String, Object&gt;</code>
        </li>
        <li>
            <code>setParams(Map&lt;String, Object&gt; params)</code>: 
            Ersetzt die aktuelle Parameter-Map durch eine neue.
        </li>
        <li>
            <code>describe()</code>: 
            Erzeugt eine menschenlesbare String-Repräsentation der Konfiguration. Wenn Parameter vorhanden sind, werden diese im Format <code>TYP (key1=value1, key2=value2)</code> aufgelistet, andernfalls wird nur der Name des Typs zurückgegeben.
            <br><strong>Rückgabewert:</strong> <code>String</code>
        </li>
    </ul>

    <h4>Eigenschaften (Private Felder)</h4>
    <ul>
        <li><code>type</code>: Der Typ des Effekts (aus dem Enum <code>SkillEffectType</code>).</li>
        <li><code>params</code>: Eine <code>HashMap</code>, die Schlüssel-Wert-Paare für die Feinjustierung des Effekts speichert.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectRegistry.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectRegistry.java</h2>
    <p>
        Die Klasse <code>SkillEffectRegistry</code> fungiert als zentrales Register für alle verfügbaren Fertigkeitseffekte (Skill Effects) innerhalb des RPG-Systems. Sie ermöglicht die Zuordnung von Logik-Implementierungen zu spezifischen Effekt-Typen und steuert deren Ausführung.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Diese Klasse nutzt das Registry-Entwurfsmuster, um eine entkoppelte Verwaltung von Effekten zu gewährleisten. Sie speichert die Zuordnungen in einer effizienten <code>EnumMap</code>.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code><strong>register(SkillEffectType type, SkillEffect effect)</strong></code>
            <p>
                Registriert eine neue Effekt-Implementierung für einen bestimmten <code>SkillEffectType</code>.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>type</code>: Der Typ des Effekts (aus dem Enum <code>SkillEffectType</code>).</li>
                        <li><code>effect</code>: Die Instanz der <code>SkillEffect</code>-Implementierung, die die Logik enthält.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Gibt die Instanz der Registry selbst zurück (Fluent Interface), um verkettete Registrierungen zu ermöglichen.</li>
            </ul>
        </li>
        <li>
            <code><strong>apply(SkillEffectConfig config, org.bukkit.entity.Player player, com.example.rpg.model.PlayerProfile profile)</strong></code>
            <p>
                Sucht den entsprechenden Effekt basierend auf der Konfiguration und wendet ihn auf den angegebenen Spieler an.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>config</code>: Das Konfigurationsobjekt, das den Typ des Effekts und die spezifischen Parameter enthält.</li>
                        <li><code>player</code>: Die Bukkit-Entity des Spielers, auf den der Effekt angewendet wird.</li>
                        <li><code>profile</code>: Das RPG-Profil des Spielers für statistische Berechnungen oder Modifikationen.</li>
                    </ul>
                </li>
                <li><strong>Logik:</strong> Wenn für den in der Konfiguration angegebenen Typ kein Effekt registriert ist, bricht die Methode ohne Fehler ab. Andernfalls wird die <code>apply</code>-Methode des jeweiligen <code>SkillEffect</code>-Objekts mit den Parametern aus der Konfiguration aufgerufen.</li>
            </ul>
        </li>
    </ul>

    <h3>Technische Details</h3>
    <p>
        Die Verwendung einer <code>EnumMap&lt;SkillEffectType, SkillEffect&gt;</code> sorgt für eine performante Speicherung und einen schnellen Zugriff auf die Effekt-Instanzen, was besonders bei häufig ausgelösten Fertigkeiten im Spielbetrieb kritisch ist.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectType.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/SkillEffectType.java</h2>
    <p>
        Diese Datei definiert das Enum <code>SkillEffectType</code>. Es dient als zentraler Katalog für alle verfügbaren Effekt-Typen, die innerhalb des RPG-Skill-Systems angewendet werden können. Diese Typen werden verwendet, um die Logik in der <code>SkillEffectRegistry</code> zu steuern und die entsprechenden Effekt-Klassen (wie <code>HealEffect</code> oder <code>DamageEffect</code>) zuzuordnen.
    </p>

    <h3>Enum: SkillEffectType</h3>
    <p>
        Das Enum definiert die folgenden Konstanten, die jeweils eine spezifische Art von Skill-Auswirkung repräsentieren:
    </p>
    <ul>
        <li><code>HEAL</code>: Stellt Lebenspunkte bei einem Ziel oder dem Zaubernden selbst wieder her.</li>
        <li><code>DAMAGE</code>: Fügt einem Ziel Schaden zu.</li>
        <li><code>PROJECTILE</code>: Erzeugt ein Projektil (z. B. einen Pfeil oder Feuerball), das bei Kollision Effekte auslöst.</li>
        <li><code>POTION</code>: Wendet Minecraft-Trankeffekte (Status-Effekte) auf eine Entität an.</li>
        <li><code>SOUND</code>: Spielt einen akustischen Effekt an der Position des Geschehens ab.</li>
        <li><code>XP</code>: Verleiht dem Spieler Erfahrungspunkte.</li>
        <li><code>PARTICLE</code>: Erzeugt visuelle Partikel-Effekte in der Spielwelt.</li>
        <li><code>VELOCITY</code>: Manipuliert die Bewegungsgeschwindigkeit oder stößt Entitäten in eine bestimmte Richtung (Knockback/Leap).</li>
        <li><code>AGGRO</code>: Beeinflusst das Aggressionsverhalten von Mobs (Bedrohungswert).</li>
    </ul>

    <h3>Technische Details</h3>
    <p>
        Die Konstanten in diesem Enum korrespondieren direkt mit den Implementierungen im Paket <code>com.example.rpg.skill.effects</code>. Sie werden in der Konfiguration (<code>SkillEffectConfig</code>) genutzt, um zu bestimmen, welcher Effekt-Handler für einen bestimmten Skill geladen werden soll.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/AggroEffect.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/AggroEffect.java</h2>
    <p>
        Die Klasse <code>AggroEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. 
        Ihr Hauptzweck ist es, die Aufmerksamkeit (Aggro) von Monstern in der Umgebung direkt auf den ausführenden Spieler zu lenken. 
        Dies ist eine klassische "Taunt"-Mechanik (Spott), wie sie häufig von Tank-Klassen in Rollenspielen verwendet wird.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.skill.effects</code></li>
        <li><strong>Interface:</strong> <code>SkillEffect</code></li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code></h4>
    <p>
        Diese Methode führt den Effekt aus. Sie sucht nach allen Entitäten vom Typ <code>Mob</code> innerhalb eines definierten Radius um den Spieler und setzt den Spieler als deren aktuelles Angriffsziel.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>player</code>: Der <code>Player</code> (Bukkit), der die Fertigkeit aktiviert hat.</li>
                <li><code>profile</code>: Das <code>PlayerProfile</code> des Spielers (enthält RPG-spezifische Daten).</li>
                <li><code>params</code>: Eine Map mit Konfigurationsparametern. Unterstützt den Schlüssel <code>"radius"</code> (Standardwert: 8.0).</li>
            </ul>
        </li>
        <li><strong>Logik:</strong>
            <ol>
                <li>Ermittelt den Radius aus den Parametern.</li>
                <li>Sucht nahegelegene Entitäten mittels <code>getNearbyEntities</code>.</li>
                <li>Filtert die Liste, sodass nur Instanzen von <code>Mob</code> verarbeitet werden.</li>
                <li>Ruft <code>setTarget(player)</code> für jeden gefundenen Mob auf.</li>
            </ol>
        </li>
    </ul>

    <h4><code>parseDouble(Object raw)</code></h4>
    <p>
        Eine private Hilfsmethode, die versucht, ein Objekt sicher in einen <code>double</code>-Wert zu konvertieren.
    </p>
    <ul>
        <li><strong>Parameter:</strong> <code>raw</code> - Das zu konvertierende Objekt (meist aus der Parameter-Map).</li>
        <li><strong>Rückgabewert:</strong> Der konvertierte <code>double</code>-Wert oder <code>8.0</code> als Fallback, falls die Konvertierung fehlschlägt (z. B. bei ungültigem Format).</li>
    </ul>

    <h3>Besonderheiten</h3>
    <p>
        Der Effekt nutzt die Bukkit-API (<code>org.bukkit.entity.Mob</code>), um die KI-Ziele der Kreaturen direkt zu beeinflussen. Dies ist besonders nützlich für Gruppen-Dungeons, um Schaden von schwächeren Gruppenmitgliedern abzuwenden.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/DamageEffect.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/DamageEffect.java</h2>
    <p>
        Die Klasse <code>DamageEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. 
        Sie dient dazu, Schaden an Entitäten in der Spielwelt zu verursachen, wenn ein Skill aktiviert wird. Dabei unterstützt sie sowohl Einzelziel-Angriffe als auch Flächenschaden (AoE).
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        <strong>Klasse:</strong> <code>DamageEffect</code><br>
        <strong>Paket:</strong> <code>com.example.rpg.skill.effects</code><br>
        <strong>Interface:</strong> <code>SkillEffect</code>
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code>
            <p>
                Führt den Schadenseffekt basierend auf den übergebenen Parametern aus. Die Methode unterscheidet zwischen zwei Modi:
            </p>
            <ul>
                <li><strong>Flächenschaden (AoE):</strong> Wenn der Parameter <code>radius</code> größer als 0 ist, werden nahegelegene <code>LivingEntity</code>-Objekte (außer Spieler) bis zu einem definierten Limit (<code>maxTargets</code>) beschädigt.</li>
                <li><strong>Einzelziel:</strong> Wenn kein Radius angegeben ist, wird automatisch die am nächsten stehende Entität in einem Standardbereich (3x2x3 Blöcke) gesucht und angegriffen.</li>
            </ul>
            <p><strong>Parameter:</strong></p>
            <ul>
                <li><code>player</code>: Der Spieler, der den Skill auslöst (wird als Schadensquelle registriert).</li>
                <li><code>profile</code>: Das RPG-Profil des Spielers.</li>
                <li><code>params</code>: Eine Map mit Konfigurationswerten:
                    <ul>
                        <li><code>amount</code> (Standard: 4): Die Höhe des verursachten Schadens.</li>
                        <li><code>radius</code> (Standard: 0): Der Radius für Flächenschaden.</li>
                        <li><code>maxTargets</code> (Standard: 1): Die maximale Anzahl an Zielen bei Flächenschaden.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code>parseDouble(Object raw)</code>
            <p>
                Hilfsmethode zur sicheren Konvertierung von Objekten in <code>double</code>-Werte. Gibt <code>0.0</code> zurück, falls die Konvertierung fehlschlägt.
            </p>
        </li>
        <li>
            <code>parseInt(Object raw)</code>
            <p>
                Hilfsmethode zur sicheren Konvertierung von Objekten in <code>int</code>-Werte. Gibt <code>1</code> zurück, falls die Konvertierung fehlschlägt.
            </p>
        </li>
    </ul>

    <h3>Besonderheiten</h3>
    <ul>
        <li><strong>Ziel-Filterung:</strong> Der Effekt ignoriert Instanzen von <code>Player</code>, um versehentliches Friendly Fire durch Skills zu verhindern (beschädigt nur Mobs/NPCs).</li>
        <li><strong>Sortierung:</strong> Bei mehreren potenziellen Zielen werden diese nach ihrer Entfernung zum auslösenden Spieler sortiert, sodass die am nächsten stehenden Ziele zuerst getroffen werden.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/HealEffect.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/HealEffect.java</h2>

    <p>Die Klasse <code>HealEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. Ihr Hauptzweck ist es, die Lebenspunkte (HP) eines Spielers basierend auf definierten Parametern zu regenerieren.</p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class HealEffect implements SkillEffect</code>
    </p>
    <p>
        Diese Klasse stellt die Logik für Heilungsfähigkeiten bereit. Sie stellt sicher, dass die Heilung den maximalen Gesundheitswert des Spielers nicht überschreitet.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code><strong>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</strong></code>
            <p>Führt den Heilungseffekt auf den angegebenen Spieler aus.</p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>player</code>: Das <code>Player</code>-Objekt von Bukkit, das geheilt werden soll.</li>
                        <li><code>profile</code>: Das RPG-Profil des Spielers (wird in dieser Implementierung aktuell nicht direkt für Berechnungen genutzt).</li>
                        <li><code>params</code>: Eine Map mit Konfigurationsparametern. Erwartet wird der Schlüssel <code>"amount"</code> (Standardwert: 4), der die Menge der zu heilenden Lebenspunkte angibt.</li>
                    </ul>
                </li>
                <li><strong>Logik:</strong> Die Methode berechnet die neue Gesundheit, indem sie den Heilwert auf die aktuelle Gesundheit addiert, begrenzt durch das Attribut <code>GENERIC_MAX_HEALTH</code> des Spielers.</li>
            </ul>
        </li>
        <li>
            <code><strong>parseDouble(Object raw)</strong></code>
            <p>Eine private Hilfsmethode, die versucht, ein Objekt sicher in einen <code>double</code>-Wert zu konvertieren.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>raw</code> - Das zu konvertierende Objekt.</li>
                <li><strong>Rückgabewert:</strong> Der konvertierte <code>double</code>-Wert oder <code>0.0</code>, falls die Konvertierung fehlschlägt (z. B. bei einer <code>NumberFormatException</code>).</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>com.example.rpg.model.PlayerProfile</code>: Datenmodell für Spielerstatistiken.</li>
        <li><code>com.example.rpg.skill.SkillEffect</code>: Basis-Interface für alle Skill-Effekte.</li>
        <li><code>org.bukkit.entity.Player</code>: Bukkit-API Repräsentation des Minecraft-Spielers.</li>
        <li><code>org.bukkit.attribute.Attribute</code>: Zugriff auf Spielerattribute wie maximale Gesundheit.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ParticleEffect.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ParticleEffect.java</h2>
    <p>
        Die Klasse <code>ParticleEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. 
        Ihr Zweck ist es, visuelle Partikeleffekte in der Spielwelt an der Position des Spielers zu erzeugen, wenn eine entsprechende Fähigkeit (Skill) aktiviert wird.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class ParticleEffect implements SkillEffect</code>
    </p>
    <p>
        Diese Klasse nutzt die Bukkit-API, um Partikel zu spawnen. Sie ist so konzipiert, dass sie über eine Map von Parametern hochgradig konfigurierbar ist, 
        was eine dynamische Definition von Effekten in Konfigurationsdateien ermöglicht.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code><strong>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</strong></code>
            <p>Führt den Partikeleffekt aus. Die Partikel werden leicht oberhalb der aktuellen Position des Spielers (Y + 1.0) gespawnt.</p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>player</code>: Das <code>Player</code>-Objekt (Bukkit), bei dem der Effekt erscheint.</li>
                <li><code>profile</code>: Das RPG-Profil des Spielers (wird in dieser Implementierung nicht direkt für Berechnungen genutzt).</li>
                <li><code>params</code>: Eine Map mit Konfigurationswerten:
                    <ul>
                        <li><code>type</code> (String): Der Name des Partikel-Typs (Standard: "SPELL").</li>
                        <li><code>count</code> (Integer): Die Anzahl der zu erzeugenden Partikel (Standard: 10).</li>
                        <li><code>speed</code> (Double): Die Bewegungsgeschwindigkeit der Partikel (Standard: 0.01).</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code><strong>parseInt(Object raw)</strong></code>
            <p>Hilfsmethode zur sicheren Konvertierung von Objekten in Ganzzahlen. Gibt bei Fehlern den Standardwert 10 zurück.</p>
        </li>
        <li>
            <code><strong>parseDouble(Object raw)</strong></code>
            <p>Hilfsmethode zur sicheren Konvertierung von Objekten in Gleitkommazahlen. Gibt bei Fehlern den Standardwert 0.01 zurück.</p>
        </li>
    </ul>

    <h3>Besonderheiten</h3>
    <p>
        Die Klasse enthält eine Fehlerbehandlung für den Partikel-Typ: Falls ein in der Konfiguration angegebener Partikel-Name nicht existiert (<code>IllegalArgumentException</code>), 
        fällt das System automatisch auf den Typ <code>Particle.SPELL</code> zurück. Die Partikel werden in einem Bereich von 0.3 x 0.6 x 0.3 Blöcken um den Zielpunkt gestreut.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/PotionStatusEffect.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/PotionStatusEffect.java</h2>
    <p>
        Die Klasse <code>PotionStatusEffect</code> implementiert das Interface <code>SkillEffect</code> und ist dafür verantwortlich, Spielern oder Entitäten in der Umgebung Trankeffekte (Potion Effects) zuzuweisen. Dies ist ein zentraler Bestandteil des RPG-Skillsystems, um Buffs oder Debuffs während der Skill-Aktivierung anzuwenden.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <strong>Name:</strong> <code>PotionStatusEffect</code><br>
        <strong>Zweck:</strong> Erzeugt und appliziert Bukkit-Trankeffekte basierend auf dynamischen Konfigurationsparametern.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code>
            <p>
                Führt den Effekt aus. Die Methode extrahiert die benötigten Werte aus der Parameter-Map und wendet den Effekt entweder direkt auf den ausführenden Spieler oder auf alle lebenden Entitäten in einem definierten Radius an.
            </p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>player</code>: Der Spieler, der den Skill auslöst.</li>
                <li><code>profile</code>: Das RPG-Profil des Spielers (wird in dieser Implementierung für die Logik nicht direkt genutzt, aber vom Interface gefordert).</li>
                <li><code>params</code>: Eine Map mit Konfigurationswerten:
                    <ul>
                        <li><code>type</code> (String): Der Name des Trankeffekts (z. B. "SPEED", "REGENERATION"). Standard: "SPEED".</li>
                        <li><code>duration</code> (Integer): Die Dauer des Effekts in Ticks. Standard: 100.</li>
                        <li><code>amplifier</code> (Integer): Die Stärke des Effekts (0 entspricht Stufe I). Standard: 0.</li>
                        <li><code>radius</code> (Double): Wenn größer als 0, wird der Effekt auf alle Entitäten im Umkreis angewendet. Standard: 0.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code>parseInt(Object raw)</code>
            <p>
                Hilfsmethode zur sicheren Konvertierung von Objekten in Ganzzahlen. Gibt 0 zurück, falls die Konvertierung fehlschlägt.
            </p>
        </li>
        <li>
            <code>parseDouble(Object raw)</code>
            <p>
                Hilfsmethode zur sicheren Konvertierung von Objekten in Gleitkommazahlen. Gibt 0.0 zurück, falls die Konvertierung fehlschlägt.
            </p>
        </li>
    </ul>

    <h3>Logik-Details</h3>
    <p>
        Die Klasse prüft zunächst, ob der angegebene <code>PotionEffectType</code> gültig ist. Falls ein <code>radius</code> definiert wurde, nutzt die Methode die Bukkit-API <code>getNearbyEntities</code>, filtert nach <code>LivingEntity</code> und wendet den Effekt auf alle gefundenen Ziele an. Andernfalls wird der Effekt nur auf den ausführenden Spieler selbst angewendet.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ProjectileEffect.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/ProjectileEffect.java</h2>

    <p>
        Die Klasse <code>ProjectileEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. 
        Ihr Hauptzweck ist es, dem Spieler das Abfeuern von Projektilen als Teil einer Skill-Aktivierung zu ermöglichen.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class ProjectileEffect implements SkillEffect</code>
    </p>
    <p>
        Diese Klasse stellt die Logik bereit, um verschiedene Arten von Projektilen (wie Schneebälle oder Feuerbälle) von der Position des Spielers aus in Blickrichtung zu starten.
    </p>

    <h3>Methoden</h3>
    
    <h4><code>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code></h4>
    <p>
        Führt den Effekt aus, indem ein Projektil basierend auf den übergebenen Parametern instanziiert und abgeschossen wird.
    </p>
    
    <ul>
        <li>
            <strong>Parameter:</strong>
            <ul>
                <li><code>player</code> (Player): Das Bukkit-Player-Objekt, welches das Projektil abschießt.</li>
                <li><code>profile</code> (PlayerProfile): Das RPG-Profil des Spielers (wird in dieser spezifischen Implementierung nicht direkt genutzt, ist aber Teil der Interface-Signatur).</li>
                <li><code>params</code> (Map&lt;String, Object&gt;): Eine Map mit Konfigurationsparametern für den Effekt.</li>
            </ul>
        </li>
        <li>
            <strong>Konfigurationsparameter (in <code>params</code>):</strong>
            <ul>
                <li><code>type</code> (String): Bestimmt den Typ des Projektils. Mögliche Werte sind:
                    <ul>
                        <li><code>"SMALL_FIREBALL"</code>: Schießt einen kleinen Feuerball (SmallFireball).</li>
                        <li><code>"SNOWBALL"</code>: Schießt einen Schneeball (Standardwert).</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <strong>Rückgabewert:</strong> <code>void</code>
        </li>
    </ul>

    <h3>Logik-Details</h3>
    <p>
        Die Methode extrahiert den Wert für <code>type</code> aus der Parameter-Map. Falls kein Typ angegeben ist, wird standardmäßig ein <code>SNOWBALL</code> verwendet. 
        Die Auswahl erfolgt über ein modernes Java-Switch-Statement, das die entsprechende Bukkit-Entity-Klasse an die <code>launchProjectile</code>-Methode des Spielers übergibt.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/SoundEffect.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/SoundEffect.java</h2>
    <p>
        Die Klasse <code>SoundEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. 
        Ihr Hauptzweck besteht darin, akustisches Feedback abzuspielen, wenn eine Fähigkeit (Skill) aktiviert wird. 
        Dies verbessert die Immersion und gibt dem Spieler eine direkte Rückmeldung über den Erfolg einer Aktion.
    </p>

    <h3>Klassenbeschreibung</h3>
    <p>
        <code>public class SoundEffect implements SkillEffect</code>
    </p>
    <p>
        Diese Klasse nutzt die Bukkit-API, um Sounds an der aktuellen Position des Spielers in der Spielwelt zu erzeugen. 
        Sie ist so konzipiert, dass sie über eine Parameter-Map flexibel konfiguriert werden kann.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code><strong>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</strong></code>
            <p>Führt den Sound-Effekt für den angegebenen Spieler aus.</p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>player</code>: Das <code>Player</code>-Objekt von Bukkit, an dessen Position der Sound abgespielt wird.</li>
                        <li><code>profile</code>: Das RPG-Profil des Spielers (wird in dieser Implementierung nicht direkt für die Logik benötigt, aber vom Interface vorgeschrieben).</li>
                        <li><code>params</code>: Eine Map mit Konfigurationsparametern für den Sound:
                            <ul>
                                <li><code>"sound"</code>: Der Name des Bukkit-Sounds (Standard: <code>ENTITY_PLAYER_LEVELUP</code>).</li>
                                <li><code>"volume"</code>: Die Lautstärke des Sounds (Standard: <code>1.0</code>).</li>
                                <li><code>"pitch"</code>: Die Tonhöhe/Geschwindigkeit des Sounds (Standard: <code>1.0</code>).</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>Logik:</strong> Die Methode extrahiert die Werte aus der Map, validiert den Sound-Namen gegen das <code>Sound</code>-Enum von Bukkit und spielt den Sound an der <code>Location</code> des Spielers ab.</li>
            </ul>
        </li>
        <li>
            <code><strong>parseFloat(Object raw)</strong></code>
            <p>Eine private Hilfsmethode zur sicheren Konvertierung von Objekten in Gleitkommazahlen.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>raw</code> - Das zu konvertierende Objekt.</li>
                <li><strong>Rückgabewert:</strong> Ein <code>float</code>-Wert. Falls die Konvertierung fehlschlägt, wird der Standardwert <code>1.0f</code> zurückgegeben.</li>
            </ul>
        </li>
    </ul>

    <h3>Besonderheiten</h3>
    <p>
        Die Klasse enthält eine Fehlerbehandlung (Try-Catch-Block) für den Fall, dass ein ungültiger Sound-Name in der Konfiguration angegeben wurde. 
        In einem solchen Fall fällt das System automatisch auf den Standard-Sound <code>ENTITY_PLAYER_LEVELUP</code> zurück, um Abstürze oder Fehlermeldungen in der Konsole zu vermeiden.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/VelocityEffect.java">
    <h2>VelocityEffect.java</h2>
    <p>
        Die Klasse <code>VelocityEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. 
        Ihr Hauptzweck ist es, die Bewegungsgeschwindigkeit (Velocity) eines Spielers zu manipulieren, um Effekte wie Sprints, Sprünge oder Rückstoß (Knockback) zu realisieren.
    </p>

    <h3>Klassenübersicht</h3>
    <p><strong>Paket:</strong> <code>com.example.rpg.skill.effects</code></p>
    <p><strong>Interfaces:</strong> <code>SkillEffect</code></p>

    <h3>Methoden</h3>
    
    <h4><code>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code></h4>
    <p>
        Wendet den Geschwindigkeitseffekt auf den angegebenen Spieler an. Die Richtung und Stärke der Bewegung werden basierend auf der Blickrichtung des Spielers und den übergebenen Parametern berechnet.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>player</code> (Player): Das Bukkit-Player-Objekt, auf das die Kraft ausgeübt wird.</li>
                <li><code>profile</code> (PlayerProfile): Das RPG-Profil des Spielers (wird in dieser Implementierung nicht direkt genutzt).</li>
                <li><code>params</code> (Map): Ein Mapping von Konfigurationswerten für den Effekt.</li>
            </ul>
        </li>
        <li><strong>Unterstützte Parameter in <code>params</code>:</strong>
            <ul>
                <li><code>forward</code> (Standard: 1.2): Multiplikator für die Vorwärtsbewegung in Blickrichtung.</li>
                <li><code>up</code> (Standard: 0.3): Der vertikale Impuls (Y-Achse).</li>
                <li><code>add</code> (Standard: false): Wenn <code>true</code>, wird die neue Kraft zur aktuellen Geschwindigkeit addiert. Wenn <code>false</code>, wird die Geschwindigkeit des Spielers direkt auf den berechneten Wert gesetzt.</li>
            </ul>
        </li>
    </ul>

    <h4><code>parseDouble(Object raw)</code> (privat)</h4>
    <p>
        Hilfsmethode zur sicheren Konvertierung von Objekten aus der Parameter-Map in <code>double</code>-Werte.
        <ul>
            <li><strong>Rückgabewert:</strong> Der konvertierte Wert oder <code>0.0</code>, falls die Konvertierung fehlschlägt.</li>
        </ul>
    </p>

    <h4><code>parseBoolean(Object raw)</code> (privat)</h4>
    <p>
        Hilfsmethode zur Konvertierung von Objekten aus der Parameter-Map in <code>boolean</code>-Werte.
        <ul>
            <li><strong>Rückgabewert:</strong> Der konvertierte Wahrheitswert.</li>
        </ul>
    </p>

    <h3>Funktionsweise</h3>
    <p>
        Die Methode extrahiert die Blickrichtung des Spielers mittels <code>player.getLocation().getDirection()</code>, multipliziert diese mit dem <code>forward</code>-Faktor und setzt anschließend den <code>up</code>-Wert für die vertikale Komponente. Je nach <code>add</code>-Flag wird dieser Vektor entweder als neue absolute Geschwindigkeit gesetzt oder auf die bestehende Geschwindigkeit des Spielers aufaddiert.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/XpEffect.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/skill/effects/XpEffect.java</h2>

    <p>Die Klasse <code>XpEffect</code> ist eine Implementierung des <code>SkillEffect</code>-Interfaces innerhalb des RPG-Plugins. Ihr primärer Zweck ist es, Spielern Erfahrungspunkte (XP) als Resultat einer Fertigkeitsaktivierung (Skill) gutzuschreiben.</p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.skill.effects</code></li>
        <li><strong>Interface:</strong> <code>SkillEffect</code></li>
    </ul>

    <h3>Methoden</h3>

    <h4><code>apply(Player player, PlayerProfile profile, Map&lt;String, Object&gt; params)</code></h4>
    <p>
        Diese Methode führt den Effekt aus, indem sie die in den Parametern definierte Menge an Erfahrungspunkten dem Spielerprofil hinzufügt.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>player</code> (Player): Die Bukkit-Instanz des Spielers (wird in dieser spezifischen Implementierung nicht direkt genutzt, ist aber Teil der Interface-Signatur).</li>
                <li><code>profile</code> (PlayerProfile): Das RPG-Profil des Spielers, auf dem die Methode <code>addXp</code> aufgerufen wird.</li>
                <li><code>params</code> (Map): Ein Schlüssel-Wert-Speicher für Konfigurationen. Erwartet den Schlüssel <code>"amount"</code>.</li>
            </ul>
        </li>
        <li><strong>Logik:</strong> Extrahiert den Wert für "amount" (Standardwert 0). Wenn der Wert größer als 0 ist, wird er dem Profil gutgeschrieben.</li>
    </ul>

    <h4><code>parseInt(Object raw)</code></h4>
    <p>
        Eine private Hilfsmethode zur sicheren Konvertierung von Objekten in Ganzzahlen.
    </p>
    <ul>
        <li><strong>Parameter:</strong> <code>raw</code> (Object): Der zu konvertierende Wert.</li>
        <li><strong>Rückgabewert:</strong> <code>int</code>: Die konvertierte Zahl oder <code>0</code>, falls die Konvertierung fehlschlägt (z. B. bei ungültigem Format).</li>
    </ul>

    <h3>Konfiguration</h3>
    <p>
        Damit dieser Effekt innerhalb eines Skills funktioniert, muss in der Konfiguration des Skills der Parameter <code>amount</code> definiert sein. Beispiel:
    </p>
    <code>
        params: { "amount": 50 }
    </code>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/AuditLog.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/AuditLog.java</h2>

    <p>
        Die Klasse <code>AuditLog</code> ist eine Hilfskomponente innerhalb des RPG-Plugins, die für die Protokollierung von administrativen Aktionen oder sicherheitsrelevanten Ereignissen zuständig ist. Sie schreibt Log-Einträge in eine dedizierte Datei namens <code>audit.log</code> im Datenverzeichnis des Plugins.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        <strong>Name:</strong> <code>AuditLog</code><br>
        <strong>Paket:</strong> <code>com.example.rpg.util</code><br>
        <strong>Zweck:</strong> Erstellung eines Revisionsprotokolls (Audit Trail) zur Nachverfolgung von Befehlen und Aktionen.
    </p>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>AuditLog(JavaPlugin plugin)</code>: 
            Initialisiert eine neue Instanz des Loggers. 
            <ul>
                <li><code>plugin</code>: Die Instanz des Java-Plugins, um auf das Datenverzeichnis (DataFolder) und den Logger für Fehlermeldungen zuzugreifen.</li>
            </ul>
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public void log(CommandSender sender, String action)</code>
            <p>
                Schreibt einen neuen Eintrag in die Datei <code>audit.log</code>. Jeder Eintrag wird am Ende der Datei angehängt (Append-Modus).
            </p>
            <strong>Parameter:</strong>
            <ul>
                <li><code>sender</code>: Der <code>CommandSender</code> (z. B. ein Spieler oder die Konsole), der die Aktion ausgeführt hat.</li>
                <li><code>action</code>: Eine textuelle Beschreibung der durchgeführten Aktion.</li>
            </ul>
            <strong>Format des Log-Eintrags:</strong>
            <p>
                <code>[Zeitstempel (ISO-8601)] | [Name des Senders] | [Aktion]</code>
            </p>
            <strong>Fehlerbehandlung:</strong>
            <p>
                Sollte ein Schreibfehler (IOException) auftreten, wird eine Warnung über den Standard-Logger des Plugins ausgegeben, um den Administrator über das Scheitern der Protokollierung zu informieren.
            </p>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>java.io.File</code> &amp; <code>java.io.FileWriter</code>: Für die Dateiverwaltung und das Schreiben von Daten.</li>
        <li><code>java.time.Instant</code>: Zur Erzeugung präziser Zeitstempel.</li>
        <li><code>org.bukkit.command.CommandSender</code>: Bukkit-API zur Identifizierung des Akteurs.</li>
        <li><code>org.bukkit.plugin.java.JavaPlugin</code>: Basisklasse des Plugins für Kontextinformationen.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/EloCalculator.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/EloCalculator.java</h2>
    <p>
        Die Klasse <code>EloCalculator</code> ist eine Utility-Klasse, die zur Berechnung von Elo-Bewertungen (Ratings) in einem kompetitiven Umfeld (z. B. PvP-Arena) dient. 
        Sie implementiert das mathematische Standard-Elo-System, um die Spielstärke von Spielern basierend auf Spielergebnissen anzupassen.
    </p>

    <h3>Klasse: EloCalculator</h3>
    <p>
        Diese Klasse ist als <code>final</code> deklariert und besitzt einen privaten Konstruktor, um eine Instanziierung zu verhindern, da sie lediglich statische Hilfsmethoden bereitstellt.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong>calculateNewRating(int rating, int opponentRating, double score, int kFactor)</strong>
            <p>Berechnet die neue Elo-Punktzahl eines Spielers basierend auf seiner aktuellen Wertung, der Wertung des Gegners und dem Ausgang des Spiels.</p>
            
            <strong>Parameter:</strong>
            <ul>
                <li><code>rating</code> (int): Die aktuelle Elo-Punktzahl des Spielers.</li>
                <li><code>opponentRating</code> (int): Die aktuelle Elo-Punktzahl des Gegners.</li>
                <li><code>score</code> (double): Das Ergebnis des Spiels (üblicherweise <code>1.0</code> für einen Sieg, <code>0.5</code> für ein Unentschieden und <code>0.0</code> für eine Niederlage).</li>
                <li><code>kFactor</code> (int): Der K-Faktor, der bestimmt, wie stark sich ein einzelnes Spielergebnis auf die Wertung auswirkt (höhere Werte führen zu schnelleren Anpassungen).</li>
            </ul>

            <strong>Rückgabewert:</strong>
            <ul>
                <li><code>int</code>: Die neue, gerundete Elo-Punktzahl des Spielers.</li>
            </ul>

            <strong>Funktionsweise:</strong>
            <p>
                Die Methode berechnet zunächst die Gewinnerwartung (<code>expected</code>) mittels der Formel: <br>
                <code>1.0 / (1.0 + 10^((GegnerRating - SpielerRating) / 400))</code>. <br>
                Anschließend wird die Differenz zwischen dem tatsächlichen Ergebnis und der Erwartung mit dem K-Faktor multipliziert und zum alten Rating addiert.
            </p>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemBuilder.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemBuilder.java</h2>
    <p>
        Die Klasse <code>ItemBuilder</code> ist eine Hilfsklasse im Fluent-Interface-Design (Builder-Pattern), die dazu dient, <code>ItemStack</code>-Objekte in der Bukkit/Spigot-API effizienter zu erstellen und zu konfigurieren. Sie vereinfacht die Handhabung von Metadaten wie Anzeigenamen und Beschreibungen (Lore).
    </p>

    <h3>Klasse: ItemBuilder</h3>
    <p><strong>Beschreibung:</strong> Ermöglicht die schrittweise Erstellung eines Minecraft-Items.</p>

    <h4>Konstruktoren</h4>
    <ul>
        <li>
            <code>ItemBuilder(Material material)</code>: Initialisiert den Builder mit einem Basismaterial. Erstellt intern ein neues <code>ItemStack</code> und ruft dessen <code>ItemMeta</code> ab.
        </li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>name(Component name)</code>
            <p>Setzt den Anzeigenamen des Items unter Verwendung der Adventure-API (Component).</p>
            <p><strong>Parameter:</strong> <code>name</code> - Der anzuzeigende Name.</p>
            <p><strong>Rückgabewert:</strong> Die aktuelle <code>ItemBuilder</code>-Instanz für Method-Chaining.</p>
        </li>
        <li>
            <code>loreLine(Component line)</code>
            <p>Fügt der Beschreibung (Lore) des Items eine einzelne Zeile hinzu.</p>
            <p><strong>Parameter:</strong> <code>line</code> - Die hinzuzufügende Textzeile.</p>
            <p><strong>Rückgabewert:</strong> Die aktuelle <code>ItemBuilder</code>-Instanz.</p>
        </li>
        <li>
            <code>loreLines(List&lt;Component&gt; lines)</code>
            <p>Fügt der Beschreibung des Items mehrere Zeilen gleichzeitig hinzu.</p>
            <p><strong>Parameter:</strong> <code>lines</code> - Eine Liste von Textkomponenten.</p>
            <p><strong>Rückgabewert:</strong> Die aktuelle <code>ItemBuilder</code>-Instanz.</p>
        </li>
        <li>
            <code>build()</code>
            <p>Schließt die Konfiguration ab, wendet die gesammelten Metadaten (Name und Lore) auf das Item an und gibt das fertige Objekt zurück.</p>
            <p><strong>Rückgabewert:</strong> Das fertig konfigurierte <code>ItemStack</code>-Objekt.</p>
        </li>
    </ul>

    <h4>Interne Felder</h4>
    <ul>
        <li><code>item</code>: Das zugrunde liegende <code>ItemStack</code>-Objekt.</li>
        <li><code>meta</code>: Die <code>ItemMeta</code> des Items, in der Attribute wie der Name gespeichert werden.</li>
        <li><code>lore</code>: Eine interne Liste von <code>Component</code>-Objekten, die die Zeilen der Item-Beschreibung speichert.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemGenerator.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/ItemGenerator.java</h2>
    <p>
        Die Klasse <code>ItemGenerator</code> ist eine Hilfskomponente innerhalb des RPG-Plugins, die für die dynamische Erstellung von Gegenständen (Items) verantwortlich ist. Sie kombiniert Materialien, Seltenheitsgrade und statistische Modifikatoren (Affixe), um individualisierte Spielgegenstände zu generieren.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Die Klasse nutzt das Bukkit-API-Framework und die Adventure-Library für Textformatierungen. Sie speichert Metadaten direkt im <code>PersistentDataContainer</code> des Items, um diese später identifizieren zu können.
    </p>

    <h3>Konstruktor</h3>
    <code>public ItemGenerator(JavaPlugin plugin, com.example.rpg.manager.ItemStatManager itemStatManager)</code>
    <p>
        Initialisiert den Generator und erstellt die notwendigen <code>NamespacedKey</code>-Objekte für die Persistenz von RPG-Daten auf den Items.
    </p>
    <ul>
        <li><strong>plugin:</strong> Die Instanz des JavaPlugins, um NamespacedKeys zu registrieren.</li>
        <li><strong>itemStatManager:</strong> Ein Manager, der für das Zuweisen von Attributen und Affixen zuständig ist.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4>createRpgItem</h4>
    <code>public ItemStack createRpgItem(Material material, Rarity rarity, int minLevel)</code>
    <p>
        Erzeugt ein neues <code>ItemStack</code>-Objekt basierend auf den übergebenen Parametern und wendet RPG-spezifische Metadaten an.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>material</code>: Das Bukkit-Material (z. B. DIAMOND_SWORD), aus dem das Item bestehen soll.</li>
                <li><code>rarity</code>: Der Seltenheitsgrad (Rarity), der die Farbe des Namens und die Qualität beeinflusst.</li>
                <li><code>minLevel</code>: Die Mindeststufe, die ein Spieler benötigt, um diesen Gegenstand zu führen.</li>
            </ul>
        </li>
        <li><strong>Rückgabewert:</strong> Ein fertig konfiguriertes <code>ItemStack</code>-Objekt.</li>
        <li><strong>Funktionsweise:</strong>
            <ol>
                <li>Erstellt das Basis-Item.</li>
                <li>Setzt den Anzeigenamen in der Farbe der Seltenheit.</li>
                <li>Generiert die Lore (Beschreibungstext) mit Seltenheit und Level-Anforderung.</li>
                <li>Speichert Identifikations-Tags (<code>rpg_item</code> und <code>rpg_rarity</code>) in den persistenten Daten des Items.</li>
                <li>Ruft den <code>ItemStatManager</code> auf, um zufällige Affixe/Stats auf das Item anzuwenden.</li>
                <li>Setzt eine zufällige Stapelgröße (derzeit fest auf 1 begrenzt durch <code>1 + random.nextInt(1)</code>).</li>
            </ol>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>com.example.rpg.model.Rarity</code>: Definiert Farben und Namen der Seltenheitsstufen.</li>
        <li><code>com.example.rpg.manager.ItemStatManager</code>: Übernimmt die Logik für die statistische Aufwertung der Items.</li>
        <li><code>net.kyori.adventure.text.Component</code>: Wird für die moderne Textformatierung in Minecraft verwendet.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/PromptManager.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/PromptManager.java</h2>
    <p>
        Die Klasse <code>PromptManager</code> ist eine Hilfskomponente, die dazu dient, interaktive Benutzereingaben über den Chat in Minecraft zu verwalten. Sie ermöglicht es, einen "Zustand" für einen Spieler zu setzen, sodass die nächste Chateingabe des Spielers abgefangen und von einer spezifischen Logik (Callback) verarbeitet wird, anstatt als normale Chat-Nachricht gesendet zu werden.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Die Klasse verwendet eine interne <code>Map</code>, um Spieler-UUIDs mit entsprechenden <code>Consumer&lt;String&gt;</code>-Handlern zu verknüpfen.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public void prompt(Player player, Component message, Consumer&lt;String&gt; handler)</code>
            <p>
                Initiiert eine Eingabeaufforderung für einen Spieler.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>player</code>: Der Spieler, von dem eine Eingabe erwartet wird.</li>
                        <li><code>message</code>: Die Nachricht (Component), die dem Spieler als Aufforderung im Chat angezeigt wird.</li>
                        <li><code>handler</code>: Ein funktionaler Callback, der ausgeführt wird, sobald der Spieler eine Nachricht sendet.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code>public boolean handle(Player player, String message)</code>
            <p>
                Versucht, eine eingehende Nachricht eines Spielers zu verarbeiten, falls für diesen ein aktiver Prompt existiert.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>player</code>: Der Spieler, der die Nachricht gesendet hat.</li>
                        <li><code>message</code>: Der Inhalt der gesendeten Nachricht.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> <code>true</code>, wenn ein Handler gefunden und ausgeführt wurde; <code>false</code>, wenn kein Prompt für diesen Spieler aktiv war.</li>
            </ul>
        </li>
        <li>
            <code>public void cancel(Player player)</code>
            <p>
                Entfernt eine aktive Eingabeaufforderung für den angegebenen Spieler, ohne den Handler auszuführen. Dies ist nützlich, um Timeouts oder manuelle Abbrüche zu realisieren.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>player</code>: Der Spieler, dessen Prompt gelöscht werden soll.</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>

    <h3>Technische Details</h3>
    <p>
        Die Implementierung nutzt <code>java.util.function.Consumer</code> für eine flexible, funktionale Programmierung der Eingabelogik. Durch die Verwendung von <code>UUID</code> als Schlüssel in der Map ist die Zuordnung auch bei Namensänderungen oder Reconnects (innerhalb einer Session) stabil.
    </p>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/Text.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/Text.java</h2>
    <p>
        Die Klasse <code>Text</code> ist eine Utility-Klasse innerhalb des RPG-Plugins, die als Wrapper für die <strong>Kyori Adventure MiniMessage</strong> Bibliothek dient. 
        Sie bietet eine vereinfachte Schnittstelle zur Deserialisierung von Text-Strings in formatierte Minecraft-Komponenten.
    </p>

    <h3>Klassen-Details</h3>
    <ul>
        <li><strong>Paket:</strong> <code>com.example.rpg.util</code></li>
        <li><strong>Modifikatoren:</strong> <code>public final</code> (Die Klasse kann nicht vererbt werden)</li>
        <li><strong>Abhängigkeiten:</strong> <code>net.kyori.adventure.text.Component</code>, <code>net.kyori.adventure.text.minimessage.MiniMessage</code></li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code><strong>public static Component mm(String input)</strong></code>
            <p>
                Diese statische Methode wandelt einen String, der MiniMessage-Tags enthält (z. B. <code>&lt;red&gt;Warnung&lt;/red&gt;</code>), in ein <code>Component</code>-Objekt um.
            </p>
            <ul>
                <li><strong>Parameter:</strong> <code>input</code> (String) - Der zu formatierende Text mit MiniMessage-Syntax.</li>
                <li><strong>Rückgabewert:</strong> <code>Component</code> - Die deserialisierte Adventure-Komponente, die im Spiel angezeigt werden kann.</li>
            </ul>
        </li>
    </ul>

    <h3>Besonderheiten</h3>
    <ul>
        <li><strong>Privater Konstruktor:</strong> Die Klasse verfügt über einen privaten Konstruktor <code>private Text()</code>, um eine Instanziierung der Utility-Klasse zu verhindern.</li>
        <li><strong>Statische Instanz:</strong> Es wird eine einzige, statische Instanz von <code>MiniMessage</code> (<code>MINI</code>) verwendet, um die Performance bei der Textverarbeitung zu optimieren.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/WorldUtils.java">
    <h2>MineLauncher/plugins/RPGPlugin/src/main/java/com/example/rpg/util/WorldUtils.java</h2>
    <p>
        Die Klasse <code>WorldUtils</code> ist eine Utility-Klasse innerhalb des RPG-Plugins, die Hilfsmethoden für die Verwaltung von Minecraft-Welten bereitstellt. Ihr Hauptaugenmerk liegt auf dem sicheren Entladen und physischen Löschen von Welten, was insbesondere für temporäre Instanzen wie Dungeons von Bedeutung ist.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        Die Klasse enthält statische Methoden, um Welten zu manipulieren, ohne dass eine Instanziierung der Klasse erforderlich ist.
    </p>

    <h3>Methoden</h3>
    <ul>
        <li>
            <strong><code>unloadAndDeleteWorld(World world, Location fallback)</code></strong>
            <p>
                Diese Methode entlädt eine angegebene Welt sicher vom Server und löscht anschließend den zugehörigen Ordner vom Dateisystem.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>world</code> (World): Die Bukkit-Welt, die entfernt werden soll.</li>
                        <li><code>fallback</code> (Location): Der Zielort, zu dem Spieler teleportiert werden, die sich zum Zeitpunkt des Entladens in der Welt befinden.</li>
                    </ul>
                </li>
                <li><strong>Funktionsweise:</strong>
                    <ol>
                        <li>Prüft, ob die Welt existiert.</li>
                        <li>Teleportiert alle Spieler in der Welt entweder zum <code>fallback</code>-Ort oder zum Spawn der ersten verfügbaren Welt auf dem Server.</li>
                        <li>Sendet eine Benachrichtigung an die betroffenen Spieler ("Der Dungeon löst sich auf...").</li>
                        <li>Entlädt die Welt über die Bukkit-API (ohne Speichern der Änderungen).</li>
                        <li>Ruft <code>deleteDirectory</code> auf, um die Weltdaten physisch zu löschen.</li>
                    </ol>
                </li>
            </ul>
        </li>
        <li>
            <strong><code>deleteDirectory(File directory)</code></strong>
            <p>
                Eine private Hilfsmethode, die ein Verzeichnis und alle darin enthaltenen Dateien und Unterverzeichnisse rekursiv löscht.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>directory</code> (File): Das zu löschende Verzeichnis.</li>
                    </ul>
                </li>
                <li><strong>Technische Details:</strong> Verwendet <code>Files.walk</code>, um den Verzeichnisbaum zu durchlaufen, sortiert die Pfade in umgekehrter Reihenfolge (damit Dateien vor ihren Elternverzeichnissen gelöscht werden) und löscht jedes Element.</li>
            </ul>
        </li>
    </ul>

    <h3>Abhängigkeiten</h3>
    <ul>
        <li><code>org.bukkit</code>: Nutzung der Bukkit-API für Welt- und Spielermanagement.</li>
        <li><code>java.nio.file</code>: Effiziente Dateisystemoperationen zum Löschen von Weltordnern.</li>
        <li><code>com.example.rpg.util.Text</code>: Zur Formatierung von Chat-Nachrichten mittels MiniMessage.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/WorldCreatorPlugin/README.md">
    <h2>MineLauncher/plugins/WorldCreatorPlugin/README.md</h2>
    <p>
        Diese Datei enthält die Dokumentation und Bedienungsanleitung für das <strong>WorldCreatorPlugin</strong>. Es handelt sich um ein Bukkit/Spigot-Plugin, das Funktionalitäten zur dynamischen Erstellung und Verwaltung von Minecraft-Welten direkt im Spiel bereitstellt.
    </p>

    <h3>Hauptfunktionen</h3>
    <ul>
        <li><strong>Ingame-Menü:</strong> Bietet eine grafische Benutzeroberfläche (GUI), um verschiedene Welttypen auszuwählen.</li>
        <li><strong>Welttypen:</strong> Unterstützt die Erstellung von speziellen Welt-Generatoren wie:
            <ul>
                <li><code>Leere Welt</code> (Void)</li>
                <li><code>Wasserwelt</code></li>
                <li><code>Sky-Inseln</code></li>
                <li>Thematische Biome wie <code>Dschungel</code> und <code>Wüste</code>.</li>
            </ul>
        </li>
        <li><strong>Automatischer Teleport:</strong> Nach der Erstellung einer Welt wird der Spieler sofort an den Zielort teleportiert.</li>
    </ul>

    <h3>Build-Anweisungen</h3>
    <p>
        Das Plugin wird mit Apache Maven kompiliert. Der folgende Befehl erstellt das ausführbare JAR-Archiv:
    </p>
    <pre><code>mvn -f plugins/WorldCreatorPlugin/pom.xml package</code></pre>
    <p>
        Nach erfolgreichem Build befindet sich die Datei im Verzeichnis: <code>plugins/WorldCreatorPlugin/target/</code>.
    </p>

    <h3>Nutzung und Befehle</h3>
    <p>
        Um das Plugin zu verwenden, müssen die folgenden Schritte durchgeführt werden:
    </p>
    <ol>
        <li>Kopieren der JAR-Datei in den <code>plugins/</code> Ordner des Minecraft-Servers.</li>
        <li>Starten oder Neustarten des Servers.</li>
        <li>Verwendung des Hauptbefehls im Spiel:</li>
    </ol>
    <ul>
        <li><code>/worlds</code>: Öffnet das Auswahlmenü für die Welterstellung.</li>
    </ul>

    <h3>Technische Details</h3>
    <p>
        Das Plugin interagiert eng mit den im Projekt enthaltenen Generatoren wie <code>SkyIslandsChunkGenerator</code>, <code>VoidChunkGenerator</code> und <code>WaterChunkGenerator</code>, um die spezifischen Landschaftsformen während des Erstellungsprozesses zu definieren.
    </p>
</section>
<section id="MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/FixedBiomeProvider.java">
    <h2>MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/FixedBiomeProvider.java</h2>

    <p>
        Die Klasse <code>FixedBiomeProvider</code> ist eine spezialisierte Implementierung des <code>BiomeProvider</code> der Bukkit-API. 
        Ihr Hauptzweck besteht darin, eine Welt zu generieren, die konsistent aus nur einem einzigen, vordefinierten Biom besteht, unabhängig von den Koordinaten.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        <code>public final class FixedBiomeProvider extends BiomeProvider</code>
    </p>
    <ul>
        <li><strong>Zweck:</strong> Erzwingt ein statisches Biom für eine gesamte Welt oder einen spezifischen Generator-Durchlauf.</li>
        <li><strong>Verwendung:</strong> Wird typischerweise in benutzerdefinierten Chunk-Generatoren (wie Void- oder Wasser-Welten) eingesetzt, um eine homogene Umgebung zu schaffen.</li>
    </ul>

    <h3>Konstruktoren</h3>
    <ul>
        <li>
            <code>public FixedBiomeProvider(Biome biome)</code>
            <p>Initialisiert den Provider mit dem gewünschten Biom.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>biome</code> - Das <code>Biome</code>-Objekt, das für die gesamte Welt verwendet werden soll.</li>
            </ul>
        </li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>@Override public Biome getBiome(WorldInfo worldInfo, int x, int y, int z)</code>
            <p>Gibt das festgelegte Biom für die angegebenen Koordinaten zurück.</p>
            <ul>
                <li><strong>Parameter:</strong> 
                    <ul>
                        <li><code>worldInfo</code>: Informationen über die Welt.</li>
                        <li><code>x, y, z</code>: Die Koordinaten im 3D-Raum.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> Das im Konstruktor definierte <code>Biome</code>.</li>
            </ul>
        </li>
        <li>
            <code>@Override public List&lt;Biome&gt; getBiomes(WorldInfo worldInfo)</code>
            <p>Liefert eine Liste aller Biome, die in dieser Welt vorkommen können.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> Eine unveränderliche Liste (<code>List.of</code>), die ausschließlich das konfigurierte Biom enthält.</li>
            </ul>
        </li>
    </ul>
</section>
<section id="MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/SkyIslandsChunkGenerator.java">
    <h2>MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/SkyIslandsChunkGenerator.java</h2>
    <p>
        Diese Klasse ist ein spezialisierter <code>ChunkGenerator</code> für Bukkit/Spigot, der eine Welt bestehend aus fliegenden Inseln ("Sky Islands") erzeugt. 
        Sie ist Teil des <code>WorldCreatorPlugin</code> und ermöglicht die Generierung von schwebenden Terrains in einer ansonsten leeren Welt.
    </p>

    <h3>Klasse: SkyIslandsChunkGenerator</h3>
    <p>
        Die Klasse erweitert <code>org.bukkit.generator.ChunkGenerator</code> und implementiert die Logik zur Platzierung von Blöcken innerhalb eines Chunks.
    </p>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code><strong>generateChunkData(World world, Random random, int chunkX, int chunkZ, BiomeGrid biome)</strong></code>
            <p>
                Diese Methode ist das Herzstück der Generierung. Sie berechnet für jeden Chunk, ob und wo eine fliegende Insel platziert wird.
            </p>
            <ul>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>world</code>: Die Welt, für die der Chunk generiert wird.</li>
                        <li><code>random</code>: Eine Zufallsquelle (wird hier zugunsten einer deterministischen Quelle ergänzt).</li>
                        <li><code>chunkX</code>: Die X-Koordinate des Chunks.</li>
                        <li><code>chunkZ</code>: Die Z-Koordinate des Chunks.</li>
                        <li><code>biome</code>: Das BiomeGrid zur Festlegung von Biomen (hier primär für die Blockplatzierung genutzt).</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> <code>ChunkData</code> – Das Objekt, das die Blockdaten des generierten Chunks enthält.</li>
                <li><strong>Logik:</strong>
                    <ul>
                        <li>Es wird eine deterministische Zufallsquelle (<code>seededRandom</code>) basierend auf dem World-Seed und den Chunk-Koordinaten erstellt, um konsistente Ergebnisse beim Neuladen der Welt zu gewährleisten.</li>
                        <li>Mit einer Wahrscheinlichkeit von 35 % (<code>0.35</code>) wird im aktuellen Chunk eine Insel generiert.</li>
                        <li>Die Inseln haben ein zufälliges Zentrum (X/Z innerhalb des Chunks, Y zwischen 90 und 120) und einen Radius zwischen 4 und 9 Blöcken.</li>
                        <li>Die Form der Insel wird mathematisch als Sphäre berechnet.</li>
                        <li><strong>Block-Zuweisung:</strong> Die oberste Schicht der Insel (Radius - 1) wird mit <code>Material.GRASS_BLOCK</code> versehen, während das Innere aus <code>Material.STONE</code> besteht.</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>

    <h3>Besonderheiten</h3>
    <p>
        Die Implementierung nutzt eine einfache Distanzberechnung (Euklidischer Abstand), um kugelförmige Inseln zu erzeugen. Da die Generierung nur innerhalb eines Chunks (16x16 Blöcke) stattfindet und der Radius maximal 9 beträgt, können Inseln an den Chunk-Grenzen abgeschnitten wirken, sofern sie nicht zufällig genau im Zentrum platziert werden.
    </p>
</section>
<section id="MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/VoidChunkGenerator.java">
    <h2>MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/VoidChunkGenerator.java</h2>

    <p>
        Die Klasse <code>VoidChunkGenerator</code> ist eine spezialisierte Implementierung des Bukkit <code>ChunkGenerator</code>. 
        Ihr Hauptzweck besteht darin, eine "Leere Welt" (Void World) zu erzeugen, in der keine Blöcke generiert werden. 
        Dies ist besonders nützlich für Lobbys, Minispiele oder Welten, in denen der Boden manuell oder durch andere Mechanismen (wie Schematics) erstellt wird.
    </p>

    <h3>Klassenübersicht</h3>
    <ul>
        <li><strong>Name:</strong> <code>VoidChunkGenerator</code></li>
        <li><strong>Basisklasse:</strong> <code>org.bukkit.generator.ChunkGenerator</code></li>
        <li><strong>Sichtbarkeit:</strong> <code>public final</code></li>
    </ul>

    <h3>Methoden</h3>
    
    <div class="method-definition">
        <h4><code>generateChunkData(World world, Random random, int chunkX, int chunkZ, BiomeGrid biome)</code></h4>
        <p>
            Diese Methode überschreibt den Standard-Generierungsprozess von Minecraft für einzelne Chunks. 
            Anstatt Geländeformen, Erze oder Strukturen zu berechnen, gibt sie ein leeres Datenobjekt zurück.
        </p>
        <ul>
            <li><strong>Parameter:</strong>
                <ul>
                    <li><code>world</code>: Die Instanz der Welt, für die der Chunk generiert wird.</li>
                    <li><code>random</code>: Ein Zufallszahlengenerator (wird hier ignoriert).</li>
                    <li><code>chunkX</code>: Die X-Koordinate des Chunks.</li>
                    <li><code>chunkZ</code>: Die Z-Koordinate des Chunks.</li>
                    <li><code>biome</code>: Das Biome-Grid zur Festlegung der Biome-Daten (wird hier nicht modifiziert).</li>
                </ul>
            </li>
            <li><strong>Rückgabewert:</strong> <code>ChunkData</code> – Ein neu erstelltes, leeres Chunk-Datenobjekt, das keine Blöcke enthält.</li>
        </ul>
    </div>

    <h3>Besonderheiten</h3>
    <p>
        Da die Methode <code>createChunkData(world)</code> aufgerufen wird, ohne dass danach Blöcke in das Objekt geschrieben werden, resultiert dies in einem vollkommen leeren Chunk. Spieler, die in einer solchen Welt spawnen, würden ohne zusätzliche Plattformen oder Befehle in das Nichts fallen.
    </p>
</section>
<section id="MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WaterChunkGenerator.java">
    <h2>MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WaterChunkGenerator.java</h2>

    <p>
        Die Klasse <code>WaterChunkGenerator</code> ist ein spezialisierter Chunk-Generator für Bukkit/Spigot-Server. 
        Ihr Hauptzweck besteht darin, eine Welt zu generieren, die fast ausschließlich aus Wasser besteht, ähnlich einer endlosen Ozean-Welt.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        <code>public final class WaterChunkGenerator extends ChunkGenerator</code>
    </p>
    <p>
        Diese Klasse erweitert die Basisklasse <code>ChunkGenerator</code> von Bukkit, um die Standard-Weltgenerierung zu überschreiben.
    </p>

    <h3>Konstanten</h3>
    <ul>
        <li><code>SEA_LEVEL</code> (int): Definiert die Höhe des Meeresspiegels. In dieser Implementierung ist der Wert fest auf <strong>62</strong> gesetzt.</li>
    </ul>

    <h3>Methoden</h3>
    
    <h4><code>generateChunkData</code></h4>
    <p>
        Diese Methode ist das Herzstück des Generators und wird aufgerufen, wenn ein neuer Chunk (ein 16x16 Block großer Bereich) erstellt werden muss.
    </p>
    
    <h5>Parameter:</h5>
    <ul>
        <li><code>World world</code>: Die Welt, für die der Chunk generiert wird.</li>
        <li><code>Random random</code>: Ein Zufallszahlengenerator (wird in dieser spezifischen Implementierung nicht genutzt, da das Layout statisch ist).</li>
        <li><code>int chunkX</code>: Die X-Koordinate des Chunks.</li>
        <li><code>int chunkZ</code>: Die Z-Koordinate des Chunks.</li>
        <li><code>BiomeGrid biome</code>: Die Biom-Daten für den Chunk.</li>
    </ul>

    <h5>Rückgabewert:</h5>
    <ul>
        <li><code>ChunkData</code>: Ein Objekt, das die Block-Daten des generierten Chunks enthält.</li>
    </ul>

    <h5>Funktionsweise:</h5>
    <ol>
        <li>Erstellt ein neues <code>ChunkData</code>-Objekt für die angegebene Welt.</li>
        <li>Iteriert über die gesamte Grundfläche des Chunks (16x16 Blöcke).</li>
        <li>Setzt auf der untersten Ebene (Y = 0) einen Block aus <code>Material.BEDROCK</code> (Grundgestein), um ein Durchfallen der Spieler in den Void zu verhindern.</li>
        <li>Füllt alle Ebenen von Y = 1 bis zur Höhe des Meeresspiegels (Y = 62) mit <code>Material.WATER</code> (Wasser) auf.</li>
        <li>Gibt die resultierenden Daten an den Server zurück.</li>
    </ol>
</section>
<section id="MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldCreatorPlugin.java">
    <h2>MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldCreatorPlugin.java</h2>
    <p>
        Die Klasse <code>WorldCreatorPlugin</code> ist die Hauptklasse des WorldCreator-Plugins für Minecraft (Bukkit/Spigot). 
        Sie ermöglicht es Spielern, über ein grafisches Inventar-Menü (GUI) neue Welten mit spezifischen Generatoren oder Biomen zu erstellen und sich direkt dorthin zu teleportieren.
    </p>

    <h3>Klassenübersicht</h3>
    <p>
        <code>public final class WorldCreatorPlugin extends JavaPlugin implements Listener</code>
    </p>
    <ul>
        <li><strong>Erbt von:</strong> <code>JavaPlugin</code> (Standard-Basisklasse für Bukkit-Plugins).</li>
        <li><strong>Implementiert:</strong> <code>Listener</code> (Ermöglicht die Verarbeitung von Events, hier speziell Inventar-Klicks).</li>
    </ul>

    <h3>Methoden</h3>
    <ul>
        <li>
            <code>public void onEnable()</code>
            <p>Initialisiert das Plugin beim Starten des Servers. Hier wird der <code>NamespacedKey</code> für die persistenten Daten erstellt, die Event-Registrierung vorgenommen und die Slot-Belegung für das GUI-Menü definiert.</p>
        </li>
        <li>
            <code>public boolean onCommand(CommandSender sender, Command command, String label, String[] args)</code>
            <p>Verarbeitet Befehle. Wenn ein Spieler den Befehl ausführt, wird das World-Creator-Menü (GUI) geöffnet.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>sender</code> (Der Ausführende), <code>command</code>, <code>label</code>, <code>args</code>.</li>
                <li><strong>Rückgabewert:</strong> <code>boolean</code> (true, wenn der Befehl erfolgreich verarbeitet wurde).</li>
            </ul>
        </li>
        <li>
            <code>public void onInventoryClick(InventoryClickEvent event)</code>
            <p>Ein Event-Handler, der Klicks im Inventar überwacht. Wenn ein Spieler auf ein Item im "World Creator"-Menü klickt, wird die entsprechende Weltgenerierung gestartet.</p>
            <ul>
                <li><strong>Annotation:</strong> <code>@EventHandler</code></li>
            </ul>
        </li>
        <li>
            <code>private Inventory buildMenu()</code>
            <p>Erstellt das grafische Menü (Inventory) mit einer Größe von 27 Slots und füllt es mit den in der <code>slotMap</code> definierten Optionen.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>Inventory</code> (Das fertige GUI-Objekt).</li>
            </ul>
        </li>
        <li>
            <code>private ItemStack createMenuItem(WorldTypeOption option)</code>
            <p>Erzeugt ein Icon für das Menü basierend auf einer <code>WorldTypeOption</code>. Speichert den Typ der Welt in den <code>PersistentDataContainer</code> des Items, um ihn beim Klick identifizieren zu können.</p>
            <ul>
                <li><strong>Parameter:</strong> <code>option</code> (Die Welt-Option).</li>
                <li><strong>Rückgabewert:</strong> <code>ItemStack</code> (Das konfigurierte Item).</li>
            </ul>
        </li>
        <li>
            <code>private void createWorldAndTeleport(Player player, WorldTypeOption option)</code>
            <p>Die Kernlogik zur Welterstellung. Generiert einen eindeutigen Namen basierend auf dem Zeitstempel und konfiguriert den <code>WorldCreator</code> je nach gewählter Option (z.B. Void, Sky Islands oder spezifische Biome).</p>
            <ul>
                <li><strong>Parameter:</strong> <code>player</code> (Der Zielspieler), <code>option</code> (Der gewählte Welttyp).</li>
            </ul>
        </li>
    </ul>

    <h3>Konstanten und Felder</h3>
    <ul>
        <li><code>MENU_TITLE</code>: Der Titel des GUI-Fensters ("World Creator").</li>
        <li><code>NAME_FORMAT</code>: Ein Formatter für Zeitstempel (<code>yyyyMMdd-HHmmss</code>), um eindeutige Weltnamen zu generieren.</li>
        <li><code>worldTypeKey</code>: Ein <code>NamespacedKey</code> zur Identifizierung des Welttyps in Item-Metadaten.</li>
        <li><code>slotMap</code>: Eine Map, die <code>WorldTypeOption</code>-Werten feste Slot-Positionen im Inventar zuweist.</li>
    </ul>
</section>
<section id="MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldTypeOption.java">
    <h2>MineLauncher/plugins/WorldCreatorPlugin/src/main/java/com/example/worldcreator/WorldTypeOption.java</h2>

    <p>
        Die Datei <code>WorldTypeOption.java</code> definiert eine Enumeration (Aufzählung), die verschiedene Welt-Typen für das WorldCreator-Plugin bereitstellt. Diese Optionen dienen dazu, dem Benutzer eine Auswahl an vordefinierten Generierungstypen für neue Welten anzubieten, inklusive Metadaten für die Darstellung in einer Benutzeroberfläche (GUI).
    </p>

    <h3>Klasse: <code>WorldTypeOption</code></h3>
    <p>
        Dieser Enum-Typ verknüpft technische Welt-Kategorien mit lesbaren Namen und repräsentativen Icons aus dem Bukkit-Material-Katalog.
    </p>

    <h4>Enum-Konstanten</h4>
    <ul>
        <li><code>VOID</code>: Repräsentiert eine leere Welt. Anzeigename: "Leere Welt", Icon: <code>Material.GLASS</code>.</li>
        <li><code>WATER</code>: Repräsentiert eine Wasserwelt. Anzeigename: "Wasserwelt", Icon: <code>Material.WATER_BUCKET</code>.</li>
        <li><code>SKY_ISLANDS</code>: Repräsentiert fliegende Inseln. Anzeigename: "Sky Inseln", Icon: <code>Material.ELYTRA</code>.</li>
        <li><code>JUNGLE</code>: Repräsentiert eine Dschungel-Welt. Anzeigename: "Dschungel", Icon: <code>Material.JUNGLE_LOG</code>.</li>
        <li><code>DESERT</code>: Repräsentiert eine Wüsten-Welt. Anzeigename: "Wüste", Icon: <code>Material.SAND</code>.</li>
    </ul>

    <h4>Felder</h4>
    <ul>
        <li><code>displayName</code> (String): Ein benutzerfreundlicher Name für den Welt-Typ.</li>
        <li><code>icon</code> (Material): Ein Minecraft-Material, das als Icon in Menüs verwendet werden kann.</li>
    </ul>

    <h4>Methoden</h4>
    <ul>
        <li>
            <code>getDisplayName()</code>
            <p>Gibt den lesbaren Namen der Welt-Option zurück.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>String</code> - Der Anzeigename.</li>
            </ul>
        </li>
        <li>
            <code>getIcon()</code>
            <p>Gibt das zugeordnete Material-Icon zurück.</p>
            <ul>
                <li><strong>Rückgabewert:</strong> <code>Material</code> - Das Bukkit-Material.</li>
            </ul>
        </li>
    </ul>
</section>
    </main>
</body>
</html>