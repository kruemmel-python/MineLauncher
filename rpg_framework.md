# CodeDump for Project: `rpg_framework.zip`

_Generated on 2025-12-27T11:55:23.558Z_

## File: `behaviors/lvl01_behavior_001.yml`  
- Path: `behaviors/lvl01_behavior_001.yml`  
- Size: 924 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl01_behavior_001:
  name: "&cGegner Lvl 1"
  type: ZOMBIE
  health: 24
  damage: 3
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 26
  lootTable: forest_mobs
  behaviorTree: lvl01_behavior_001

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.16
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 4.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.11
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl01_behavior_031.yml`  
- Path: `behaviors/lvl01_behavior_031.yml`  
- Size: 917 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl01_behavior_031:
  name: "&cGegner Lvl 1"
  type: WITHER_SKELETON
  health: 24
  damage: 3
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 26
  lootTable: forest_mobs
  behaviorTree: lvl01_behavior_031

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.16
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 4.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.11
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl01_behavior_061.yml`  
- Path: `behaviors/lvl01_behavior_061.yml`  
- Size: 924 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl01_behavior_061:
  name: "&cGegner Lvl 1"
  type: WITCH
  health: 24
  damage: 3
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 26
  lootTable: forest_mobs
  behaviorTree: lvl01_behavior_061

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.16
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 4.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.11
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl01_behavior_091.yml`  
- Path: `behaviors/lvl01_behavior_091.yml`  
- Size: 907 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl01_behavior_091:
  name: "&cGegner Lvl 1"
  type: STRAY
  health: 24
  damage: 3
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 26
  lootTable: forest_mobs
  behaviorTree: lvl01_behavior_091

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.16
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 4.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.11
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl01_behavior_121.yml`  
- Path: `behaviors/lvl01_behavior_121.yml`  
- Size: 927 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl01_behavior_121:
  name: "&cGegner Lvl 1"
  type: SKELETON
  health: 24
  damage: 3
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 26
  lootTable: forest_mobs
  behaviorTree: lvl01_behavior_121

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.16
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 4.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.11
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl01_behavior_151.yml`  
- Path: `behaviors/lvl01_behavior_151.yml`  
- Size: 907 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl01_behavior_151:
  name: "&cGegner Lvl 1"
  type: BLAZE
  health: 24
  damage: 3
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 26
  lootTable: forest_mobs
  behaviorTree: lvl01_behavior_151

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.16
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 4.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.11
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl01_behavior_181.yml`  
- Path: `behaviors/lvl01_behavior_181.yml`  
- Size: 927 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl01_behavior_181:
  name: "&cGegner Lvl 1"
  type: PILLAGER
  health: 24
  damage: 3
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 26
  lootTable: forest_mobs
  behaviorTree: lvl01_behavior_181

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.16
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 4.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.11
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl02_behavior_002.yml`  
- Path: `behaviors/lvl02_behavior_002.yml`  
- Size: 913 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl02_behavior_002:
  name: "&cGegner Lvl 2"
  type: SKELETON
  health: 28
  damage: 4
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 32
  lootTable: forest_mobs
  behaviorTree: lvl02_behavior_002

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.17
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 4.7
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.12
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl02_behavior_032.yml`  
- Path: `behaviors/lvl02_behavior_032.yml`  
- Size: 909 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl02_behavior_032:
  name: "&cGegner Lvl 2"
  type: BLAZE
  health: 28
  damage: 4
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 32
  lootTable: forest_mobs
  behaviorTree: lvl02_behavior_032

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.17
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 4.7
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.12
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl02_behavior_062.yml`  
- Path: `behaviors/lvl02_behavior_062.yml`  
- Size: 912 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl02_behavior_062:
  name: "&cGegner Lvl 2"
  type: PILLAGER
  health: 28
  damage: 4
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 32
  lootTable: forest_mobs
  behaviorTree: lvl02_behavior_062

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.17
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 4.7
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.12
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl02_behavior_092.yml`  
- Path: `behaviors/lvl02_behavior_092.yml`  
- Size: 910 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl02_behavior_092:
  name: "&cGegner Lvl 2"
  type: DROWNED
  health: 28
  damage: 4
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 32
  lootTable: forest_mobs
  behaviorTree: lvl02_behavior_092

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.17
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 4.7
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.12
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl02_behavior_122.yml`  
- Path: `behaviors/lvl02_behavior_122.yml`  
- Size: 911 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl02_behavior_122:
  name: "&cGegner Lvl 2"
  type: SPIDER
  health: 28
  damage: 4
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 32
  lootTable: forest_mobs
  behaviorTree: lvl02_behavior_122

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.17
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 4.7
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.12
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl02_behavior_152.yml`  
- Path: `behaviors/lvl02_behavior_152.yml`  
- Size: 914 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl02_behavior_152:
  name: "&cGegner Lvl 2"
  type: MAGMA_CUBE
  health: 28
  damage: 4
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 32
  lootTable: forest_mobs
  behaviorTree: lvl02_behavior_152

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.17
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 4.7
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.12
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl02_behavior_182.yml`  
- Path: `behaviors/lvl02_behavior_182.yml`  
- Size: 913 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl02_behavior_182:
  name: "&cGegner Lvl 2"
  type: VINDICATOR
  health: 28
  damage: 4
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 32
  lootTable: forest_mobs
  behaviorTree: lvl02_behavior_182

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.17
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 4.7
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.12
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl03_behavior_003.yml`  
- Path: `behaviors/lvl03_behavior_003.yml`  
- Size: 916 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl03_behavior_003:
  name: "&cGegner Lvl 3"
  type: SPIDER
  health: 32
  damage: 4
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 38
  lootTable: forest_mobs
  behaviorTree: lvl03_behavior_003

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.18
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 5.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.13
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl03_behavior_033.yml`  
- Path: `behaviors/lvl03_behavior_033.yml`  
- Size: 921 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl03_behavior_033:
  name: "&cGegner Lvl 3"
  type: MAGMA_CUBE
  health: 32
  damage: 4
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 38
  lootTable: forest_mobs
  behaviorTree: lvl03_behavior_033

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.18
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 5.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.13
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl03_behavior_063.yml`  
- Path: `behaviors/lvl03_behavior_063.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl03_behavior_063:
  name: "&cGegner Lvl 3"
  type: VINDICATOR
  health: 32
  damage: 4
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 38
  lootTable: forest_mobs
  behaviorTree: lvl03_behavior_063

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.18
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 5.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.13
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl03_behavior_093.yml`  
- Path: `behaviors/lvl03_behavior_093.yml`  
- Size: 918 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl03_behavior_093:
  name: "&cGegner Lvl 3"
  type: ENDERMAN
  health: 32
  damage: 4
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 38
  lootTable: forest_mobs
  behaviorTree: lvl03_behavior_093

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.18
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 5.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.13
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl03_behavior_123.yml`  
- Path: `behaviors/lvl03_behavior_123.yml`  
- Size: 917 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl03_behavior_123:
  name: "&cGegner Lvl 3"
  type: CREEPER
  health: 32
  damage: 4
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 38
  lootTable: forest_mobs
  behaviorTree: lvl03_behavior_123

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.18
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 5.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.13
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl03_behavior_153.yml`  
- Path: `behaviors/lvl03_behavior_153.yml`  
- Size: 921 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl03_behavior_153:
  name: "&cGegner Lvl 3"
  type: SILVERFISH
  health: 32
  damage: 4
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 38
  lootTable: forest_mobs
  behaviorTree: lvl03_behavior_153

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.18
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 5.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.13
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl03_behavior_183.yml`  
- Path: `behaviors/lvl03_behavior_183.yml`  
- Size: 915 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl03_behavior_183:
  name: "&cGegner Lvl 3"
  type: EVOKER
  health: 32
  damage: 4
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 38
  lootTable: forest_mobs
  behaviorTree: lvl03_behavior_183

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.18
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 5.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.13
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl04_behavior_004.yml`  
- Path: `behaviors/lvl04_behavior_004.yml`  
- Size: 905 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl04_behavior_004:
  name: "&cGegner Lvl 4"
  type: CREEPER
  health: 36
  damage: 5
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 44
  lootTable: forest_mobs
  behaviorTree: lvl04_behavior_004

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.2
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 5.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.15
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl04_behavior_034.yml`  
- Path: `behaviors/lvl04_behavior_034.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl04_behavior_034:
  name: "&cGegner Lvl 4"
  type: SILVERFISH
  health: 36
  damage: 5
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 44
  lootTable: forest_mobs
  behaviorTree: lvl04_behavior_034

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.2
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 5.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.15
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl04_behavior_064.yml`  
- Path: `behaviors/lvl04_behavior_064.yml`  
- Size: 904 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl04_behavior_064:
  name: "&cGegner Lvl 4"
  type: EVOKER
  health: 36
  damage: 5
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 44
  lootTable: forest_mobs
  behaviorTree: lvl04_behavior_064

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.2
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 5.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.15
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl04_behavior_094.yml`  
- Path: `behaviors/lvl04_behavior_094.yml`  
- Size: 914 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl04_behavior_094:
  name: "&cGegner Lvl 4"
  type: SLIME
  health: 36
  damage: 5
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 44
  lootTable: forest_mobs
  behaviorTree: lvl04_behavior_094

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.2
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 5.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.15
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl04_behavior_124.yml`  
- Path: `behaviors/lvl04_behavior_124.yml`  
- Size: 902 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl04_behavior_124:
  name: "&cGegner Lvl 4"
  type: HUSK
  health: 36
  damage: 5
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 44
  lootTable: forest_mobs
  behaviorTree: lvl04_behavior_124

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.2
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 5.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.15
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl04_behavior_154.yml`  
- Path: `behaviors/lvl04_behavior_154.yml`  
- Size: 914 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl04_behavior_154:
  name: "&cGegner Lvl 4"
  type: ZOMBIE
  health: 36
  damage: 5
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 44
  lootTable: forest_mobs
  behaviorTree: lvl04_behavior_154

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.2
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 5.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.15
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl04_behavior_184.yml`  
- Path: `behaviors/lvl04_behavior_184.yml`  
- Size: 914 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl04_behavior_184:
  name: "&cGegner Lvl 4"
  type: WITHER_SKELETON
  health: 36
  damage: 5
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 44
  lootTable: forest_mobs
  behaviorTree: lvl04_behavior_184

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.2
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 5.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.15
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl05_behavior_005.yml`  
- Path: `behaviors/lvl05_behavior_005.yml`  
- Size: 897 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl05_behavior_005:
  name: "&cGegner Lvl 5"
  type: HUSK
  health: 40
  damage: 5
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 50
  lootTable: forest_mobs
  behaviorTree: lvl05_behavior_005

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.21
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 5.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.16
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl05_behavior_035.yml`  
- Path: `behaviors/lvl05_behavior_035.yml`  
- Size: 914 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl05_behavior_035:
  name: "&cGegner Lvl 5"
  type: ZOMBIE
  health: 40
  damage: 5
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 50
  lootTable: forest_mobs
  behaviorTree: lvl05_behavior_035

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.21
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 5.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.16
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl05_behavior_065.yml`  
- Path: `behaviors/lvl05_behavior_065.yml`  
- Size: 908 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl05_behavior_065:
  name: "&cGegner Lvl 5"
  type: WITHER_SKELETON
  health: 40
  damage: 5
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 50
  lootTable: forest_mobs
  behaviorTree: lvl05_behavior_065

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.21
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 5.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.16
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl05_behavior_095.yml`  
- Path: `behaviors/lvl05_behavior_095.yml`  
- Size: 915 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl05_behavior_095:
  name: "&cGegner Lvl 5"
  type: WITCH
  health: 40
  damage: 5
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 50
  lootTable: forest_mobs
  behaviorTree: lvl05_behavior_095

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.21
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 5.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.16
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl05_behavior_125.yml`  
- Path: `behaviors/lvl05_behavior_125.yml`  
- Size: 898 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl05_behavior_125:
  name: "&cGegner Lvl 5"
  type: STRAY
  health: 40
  damage: 5
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 50
  lootTable: forest_mobs
  behaviorTree: lvl05_behavior_125

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.21
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 5.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.16
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl05_behavior_155.yml`  
- Path: `behaviors/lvl05_behavior_155.yml`  
- Size: 916 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl05_behavior_155:
  name: "&cGegner Lvl 5"
  type: SKELETON
  health: 40
  damage: 5
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 50
  lootTable: forest_mobs
  behaviorTree: lvl05_behavior_155

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.21
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 5.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.16
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl05_behavior_185.yml`  
- Path: `behaviors/lvl05_behavior_185.yml`  
- Size: 898 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl05_behavior_185:
  name: "&cGegner Lvl 5"
  type: BLAZE
  health: 40
  damage: 5
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 50
  lootTable: forest_mobs
  behaviorTree: lvl05_behavior_185

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.21
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 5.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.16
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl06_behavior_006.yml`  
- Path: `behaviors/lvl06_behavior_006.yml`  
- Size: 913 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl06_behavior_006:
  name: "&cGegner Lvl 6"
  type: STRAY
  health: 44
  damage: 6
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 56
  lootTable: forest_mobs
  behaviorTree: lvl06_behavior_006

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.22
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 6.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.17
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl06_behavior_036.yml`  
- Path: `behaviors/lvl06_behavior_036.yml`  
- Size: 918 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl06_behavior_036:
  name: "&cGegner Lvl 6"
  type: SKELETON
  health: 44
  damage: 6
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 56
  lootTable: forest_mobs
  behaviorTree: lvl06_behavior_036

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.22
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 6.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.17
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl06_behavior_066.yml`  
- Path: `behaviors/lvl06_behavior_066.yml`  
- Size: 912 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl06_behavior_066:
  name: "&cGegner Lvl 6"
  type: BLAZE
  health: 44
  damage: 6
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 56
  lootTable: forest_mobs
  behaviorTree: lvl06_behavior_066

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.22
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 6.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.17
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl06_behavior_096.yml`  
- Path: `behaviors/lvl06_behavior_096.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl06_behavior_096:
  name: "&cGegner Lvl 6"
  type: PILLAGER
  health: 44
  damage: 6
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 56
  lootTable: forest_mobs
  behaviorTree: lvl06_behavior_096

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.22
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 6.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.17
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl06_behavior_126.yml`  
- Path: `behaviors/lvl06_behavior_126.yml`  
- Size: 914 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl06_behavior_126:
  name: "&cGegner Lvl 6"
  type: DROWNED
  health: 44
  damage: 6
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 56
  lootTable: forest_mobs
  behaviorTree: lvl06_behavior_126

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.22
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 6.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.17
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl06_behavior_156.yml`  
- Path: `behaviors/lvl06_behavior_156.yml`  
- Size: 917 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl06_behavior_156:
  name: "&cGegner Lvl 6"
  type: SPIDER
  health: 44
  damage: 6
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 56
  lootTable: forest_mobs
  behaviorTree: lvl06_behavior_156

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.22
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 6.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.17
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl06_behavior_186.yml`  
- Path: `behaviors/lvl06_behavior_186.yml`  
- Size: 917 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl06_behavior_186:
  name: "&cGegner Lvl 6"
  type: MAGMA_CUBE
  health: 44
  damage: 6
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 56
  lootTable: forest_mobs
  behaviorTree: lvl06_behavior_186

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.22
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 6.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.17
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl07_behavior_007.yml`  
- Path: `behaviors/lvl07_behavior_007.yml`  
- Size: 925 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl07_behavior_007:
  name: "&cGegner Lvl 7"
  type: DROWNED
  health: 48
  damage: 6
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 62
  lootTable: forest_mobs
  behaviorTree: lvl07_behavior_007

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.23
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 6.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.18
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl07_behavior_037.yml`  
- Path: `behaviors/lvl07_behavior_037.yml`  
- Size: 909 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl07_behavior_037:
  name: "&cGegner Lvl 7"
  type: SPIDER
  health: 48
  damage: 6
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 62
  lootTable: forest_mobs
  behaviorTree: lvl07_behavior_037

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.23
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 6.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.18
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl07_behavior_067.yml`  
- Path: `behaviors/lvl07_behavior_067.yml`  
- Size: 929 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl07_behavior_067:
  name: "&cGegner Lvl 7"
  type: MAGMA_CUBE
  health: 48
  damage: 6
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 62
  lootTable: forest_mobs
  behaviorTree: lvl07_behavior_067

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.23
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 6.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.18
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl07_behavior_097.yml`  
- Path: `behaviors/lvl07_behavior_097.yml`  
- Size: 912 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl07_behavior_097:
  name: "&cGegner Lvl 7"
  type: VINDICATOR
  health: 48
  damage: 6
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 62
  lootTable: forest_mobs
  behaviorTree: lvl07_behavior_097

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.23
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 6.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.18
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl07_behavior_127.yml`  
- Path: `behaviors/lvl07_behavior_127.yml`  
- Size: 926 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl07_behavior_127:
  name: "&cGegner Lvl 7"
  type: ENDERMAN
  health: 48
  damage: 6
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 62
  lootTable: forest_mobs
  behaviorTree: lvl07_behavior_127

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.23
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 6.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.18
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl07_behavior_157.yml`  
- Path: `behaviors/lvl07_behavior_157.yml`  
- Size: 910 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl07_behavior_157:
  name: "&cGegner Lvl 7"
  type: CREEPER
  health: 48
  damage: 6
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 62
  lootTable: forest_mobs
  behaviorTree: lvl07_behavior_157

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.23
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 6.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.18
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl07_behavior_187.yml`  
- Path: `behaviors/lvl07_behavior_187.yml`  
- Size: 929 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl07_behavior_187:
  name: "&cGegner Lvl 7"
  type: SILVERFISH
  health: 48
  damage: 6
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 62
  lootTable: forest_mobs
  behaviorTree: lvl07_behavior_187

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.23
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 6.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.18
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl08_behavior_008.yml`  
- Path: `behaviors/lvl08_behavior_008.yml`  
- Size: 911 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl08_behavior_008:
  name: "&cGegner Lvl 8"
  type: ENDERMAN
  health: 52
  damage: 7
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 68
  lootTable: forest_mobs
  behaviorTree: lvl08_behavior_008

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.24
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 6.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.19
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl08_behavior_038.yml`  
- Path: `behaviors/lvl08_behavior_038.yml`  
- Size: 911 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl08_behavior_038:
  name: "&cGegner Lvl 8"
  type: CREEPER
  health: 52
  damage: 7
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 68
  lootTable: forest_mobs
  behaviorTree: lvl08_behavior_038

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.24
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 6.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.19
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl08_behavior_068.yml`  
- Path: `behaviors/lvl08_behavior_068.yml`  
- Size: 915 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl08_behavior_068:
  name: "&cGegner Lvl 8"
  type: SILVERFISH
  health: 52
  damage: 7
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 68
  lootTable: forest_mobs
  behaviorTree: lvl08_behavior_068

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.24
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 6.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.19
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl08_behavior_098.yml`  
- Path: `behaviors/lvl08_behavior_098.yml`  
- Size: 909 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl08_behavior_098:
  name: "&cGegner Lvl 8"
  type: EVOKER
  health: 52
  damage: 7
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 68
  lootTable: forest_mobs
  behaviorTree: lvl08_behavior_098

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.24
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 6.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.19
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl08_behavior_128.yml`  
- Path: `behaviors/lvl08_behavior_128.yml`  
- Size: 909 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl08_behavior_128:
  name: "&cGegner Lvl 8"
  type: SLIME
  health: 52
  damage: 7
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 68
  lootTable: forest_mobs
  behaviorTree: lvl08_behavior_128

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.24
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 6.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.19
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl08_behavior_158.yml`  
- Path: `behaviors/lvl08_behavior_158.yml`  
- Size: 908 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl08_behavior_158:
  name: "&cGegner Lvl 8"
  type: HUSK
  health: 52
  damage: 7
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 68
  lootTable: forest_mobs
  behaviorTree: lvl08_behavior_158

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.24
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 6.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.19
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl08_behavior_188.yml`  
- Path: `behaviors/lvl08_behavior_188.yml`  
- Size: 911 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl08_behavior_188:
  name: "&cGegner Lvl 8"
  type: ZOMBIE
  health: 52
  damage: 7
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 68
  lootTable: forest_mobs
  behaviorTree: lvl08_behavior_188

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.24
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 6.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.19
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl09_behavior_009.yml`  
- Path: `behaviors/lvl09_behavior_009.yml`  
- Size: 915 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl09_behavior_009:
  name: "&cGegner Lvl 9"
  type: SLIME
  health: 56
  damage: 7
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 74
  lootTable: forest_mobs
  behaviorTree: lvl09_behavior_009

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.26
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 7.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.21
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl09_behavior_039.yml`  
- Path: `behaviors/lvl09_behavior_039.yml`  
- Size: 914 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl09_behavior_039:
  name: "&cGegner Lvl 9"
  type: HUSK
  health: 56
  damage: 7
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 74
  lootTable: forest_mobs
  behaviorTree: lvl09_behavior_039

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.26
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 7.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.21
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl09_behavior_069.yml`  
- Path: `behaviors/lvl09_behavior_069.yml`  
- Size: 916 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl09_behavior_069:
  name: "&cGegner Lvl 9"
  type: ZOMBIE
  health: 56
  damage: 7
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 74
  lootTable: forest_mobs
  behaviorTree: lvl09_behavior_069

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.26
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 7.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.21
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl09_behavior_099.yml`  
- Path: `behaviors/lvl09_behavior_099.yml`  
- Size: 925 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl09_behavior_099:
  name: "&cGegner Lvl 9"
  type: WITHER_SKELETON
  health: 56
  damage: 7
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 74
  lootTable: forest_mobs
  behaviorTree: lvl09_behavior_099

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.26
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 7.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.21
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl09_behavior_129.yml`  
- Path: `behaviors/lvl09_behavior_129.yml`  
- Size: 915 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl09_behavior_129:
  name: "&cGegner Lvl 9"
  type: WITCH
  health: 56
  damage: 7
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 74
  lootTable: forest_mobs
  behaviorTree: lvl09_behavior_129

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.26
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 7.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.21
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl09_behavior_159.yml`  
- Path: `behaviors/lvl09_behavior_159.yml`  
- Size: 915 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl09_behavior_159:
  name: "&cGegner Lvl 9"
  type: STRAY
  health: 56
  damage: 7
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 74
  lootTable: forest_mobs
  behaviorTree: lvl09_behavior_159

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.26
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 7.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.21
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl09_behavior_189.yml`  
- Path: `behaviors/lvl09_behavior_189.yml`  
- Size: 917 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl09_behavior_189:
  name: "&cGegner Lvl 9"
  type: SKELETON
  health: 56
  damage: 7
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 74
  lootTable: forest_mobs
  behaviorTree: lvl09_behavior_189

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.26
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 7.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.21
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl10_behavior_010.yml`  
- Path: `behaviors/lvl10_behavior_010.yml`  
- Size: 906 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl10_behavior_010:
  name: "&cGegner Lvl 10"
  type: WITCH
  health: 60
  damage: 8
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 80
  lootTable: forest_mobs
  behaviorTree: lvl10_behavior_010

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.27
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 7.5
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.22
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl10_behavior_040.yml`  
- Path: `behaviors/lvl10_behavior_040.yml`  
- Size: 916 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl10_behavior_040:
  name: "&cGegner Lvl 10"
  type: STRAY
  health: 60
  damage: 8
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 80
  lootTable: forest_mobs
  behaviorTree: lvl10_behavior_040

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.27
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 7.5
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.22
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl10_behavior_070.yml`  
- Path: `behaviors/lvl10_behavior_070.yml`  
- Size: 907 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl10_behavior_070:
  name: "&cGegner Lvl 10"
  type: SKELETON
  health: 60
  damage: 8
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 80
  lootTable: forest_mobs
  behaviorTree: lvl10_behavior_070

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.27
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 7.5
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.22
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl10_behavior_100.yml`  
- Path: `behaviors/lvl10_behavior_100.yml`  
- Size: 916 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl10_behavior_100:
  name: "&cGegner Lvl 10"
  type: BLAZE
  health: 60
  damage: 8
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 80
  lootTable: forest_mobs
  behaviorTree: lvl10_behavior_100

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.27
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 7.5
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.22
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl10_behavior_130.yml`  
- Path: `behaviors/lvl10_behavior_130.yml`  
- Size: 909 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl10_behavior_130:
  name: "&cGegner Lvl 10"
  type: PILLAGER
  health: 60
  damage: 8
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 80
  lootTable: forest_mobs
  behaviorTree: lvl10_behavior_130

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.27
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 7.5
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.22
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl10_behavior_160.yml`  
- Path: `behaviors/lvl10_behavior_160.yml`  
- Size: 918 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl10_behavior_160:
  name: "&cGegner Lvl 10"
  type: DROWNED
  health: 60
  damage: 8
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 80
  lootTable: forest_mobs
  behaviorTree: lvl10_behavior_160

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.27
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 7.5
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.22
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl10_behavior_190.yml`  
- Path: `behaviors/lvl10_behavior_190.yml`  
- Size: 905 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl10_behavior_190:
  name: "&cGegner Lvl 10"
  type: SPIDER
  health: 60
  damage: 8
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 80
  lootTable: forest_mobs
  behaviorTree: lvl10_behavior_190

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.27
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 7.5
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.22
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl11_behavior_011.yml`  
- Path: `behaviors/lvl11_behavior_011.yml`  
- Size: 903 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl11_behavior_011:
  name: "&cGegner Lvl 11"
  type: PILLAGER
  health: 64
  damage: 8
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 86
  lootTable: dungeon_mobs
  behaviorTree: lvl11_behavior_011

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.28
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 7.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.23
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl11_behavior_041.yml`  
- Path: `behaviors/lvl11_behavior_041.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl11_behavior_041:
  name: "&cGegner Lvl 11"
  type: DROWNED
  health: 64
  damage: 8
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 86
  lootTable: dungeon_mobs
  behaviorTree: lvl11_behavior_041

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.28
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 7.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.23
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl11_behavior_071.yml`  
- Path: `behaviors/lvl11_behavior_071.yml`  
- Size: 900 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl11_behavior_071:
  name: "&cGegner Lvl 11"
  type: SPIDER
  health: 64
  damage: 8
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 86
  lootTable: dungeon_mobs
  behaviorTree: lvl11_behavior_071

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.28
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 7.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.23
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl11_behavior_101.yml`  
- Path: `behaviors/lvl11_behavior_101.yml`  
- Size: 921 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl11_behavior_101:
  name: "&cGegner Lvl 11"
  type: MAGMA_CUBE
  health: 64
  damage: 8
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 86
  lootTable: dungeon_mobs
  behaviorTree: lvl11_behavior_101

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.28
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 7.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.23
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl11_behavior_131.yml`  
- Path: `behaviors/lvl11_behavior_131.yml`  
- Size: 905 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl11_behavior_131:
  name: "&cGegner Lvl 11"
  type: VINDICATOR
  health: 64
  damage: 8
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 86
  lootTable: dungeon_mobs
  behaviorTree: lvl11_behavior_131

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.28
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 7.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.23
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl11_behavior_161.yml`  
- Path: `behaviors/lvl11_behavior_161.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl11_behavior_161:
  name: "&cGegner Lvl 11"
  type: ENDERMAN
  health: 64
  damage: 8
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 86
  lootTable: dungeon_mobs
  behaviorTree: lvl11_behavior_161

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.28
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 7.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.23
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl11_behavior_191.yml`  
- Path: `behaviors/lvl11_behavior_191.yml`  
- Size: 902 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl11_behavior_191:
  name: "&cGegner Lvl 11"
  type: CREEPER
  health: 64
  damage: 8
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 86
  lootTable: dungeon_mobs
  behaviorTree: lvl11_behavior_191

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.28
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 7.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.23
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl12_behavior_012.yml`  
- Path: `behaviors/lvl12_behavior_012.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl12_behavior_012:
  name: "&cGegner Lvl 12"
  type: VINDICATOR
  health: 68
  damage: 9
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 92
  lootTable: dungeon_mobs
  behaviorTree: lvl12_behavior_012

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.29
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 8.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.24
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl12_behavior_042.yml`  
- Path: `behaviors/lvl12_behavior_042.yml`  
- Size: 920 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl12_behavior_042:
  name: "&cGegner Lvl 12"
  type: ENDERMAN
  health: 68
  damage: 9
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 92
  lootTable: dungeon_mobs
  behaviorTree: lvl12_behavior_042

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.29
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 8.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.24
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl12_behavior_072.yml`  
- Path: `behaviors/lvl12_behavior_072.yml`  
- Size: 917 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl12_behavior_072:
  name: "&cGegner Lvl 12"
  type: CREEPER
  health: 68
  damage: 9
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 92
  lootTable: dungeon_mobs
  behaviorTree: lvl12_behavior_072

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.29
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 8.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.24
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl12_behavior_102.yml`  
- Path: `behaviors/lvl12_behavior_102.yml`  
- Size: 923 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl12_behavior_102:
  name: "&cGegner Lvl 12"
  type: SILVERFISH
  health: 68
  damage: 9
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 92
  lootTable: dungeon_mobs
  behaviorTree: lvl12_behavior_102

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.29
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 8.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.24
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl12_behavior_132.yml`  
- Path: `behaviors/lvl12_behavior_132.yml`  
- Size: 915 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl12_behavior_132:
  name: "&cGegner Lvl 12"
  type: EVOKER
  health: 68
  damage: 9
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 92
  lootTable: dungeon_mobs
  behaviorTree: lvl12_behavior_132

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.29
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 8.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.24
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl12_behavior_162.yml`  
- Path: `behaviors/lvl12_behavior_162.yml`  
- Size: 917 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl12_behavior_162:
  name: "&cGegner Lvl 12"
  type: SLIME
  health: 68
  damage: 9
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 92
  lootTable: dungeon_mobs
  behaviorTree: lvl12_behavior_162

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.29
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 8.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.24
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl12_behavior_192.yml`  
- Path: `behaviors/lvl12_behavior_192.yml`  
- Size: 914 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl12_behavior_192:
  name: "&cGegner Lvl 12"
  type: HUSK
  health: 68
  damage: 9
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 92
  lootTable: dungeon_mobs
  behaviorTree: lvl12_behavior_192

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.29
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 8.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.24
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl13_behavior_013.yml`  
- Path: `behaviors/lvl13_behavior_013.yml`  
- Size: 926 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl13_behavior_013:
  name: "&cGegner Lvl 13"
  type: EVOKER
  health: 72
  damage: 9
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 98
  lootTable: dungeon_mobs
  behaviorTree: lvl13_behavior_013

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.3
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 8.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.25
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl13_behavior_043.yml`  
- Path: `behaviors/lvl13_behavior_043.yml`  
- Size: 907 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl13_behavior_043:
  name: "&cGegner Lvl 13"
  type: SLIME
  health: 72
  damage: 9
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 98
  lootTable: dungeon_mobs
  behaviorTree: lvl13_behavior_043

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.3
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 8.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.25
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl13_behavior_073.yml`  
- Path: `behaviors/lvl13_behavior_073.yml`  
- Size: 924 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl13_behavior_073:
  name: "&cGegner Lvl 13"
  type: HUSK
  health: 72
  damage: 9
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 98
  lootTable: dungeon_mobs
  behaviorTree: lvl13_behavior_073

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.3
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 8.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.25
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl13_behavior_103.yml`  
- Path: `behaviors/lvl13_behavior_103.yml`  
- Size: 910 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl13_behavior_103:
  name: "&cGegner Lvl 13"
  type: ZOMBIE
  health: 72
  damage: 9
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 98
  lootTable: dungeon_mobs
  behaviorTree: lvl13_behavior_103

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.3
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 8.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.25
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl13_behavior_133.yml`  
- Path: `behaviors/lvl13_behavior_133.yml`  
- Size: 934 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl13_behavior_133:
  name: "&cGegner Lvl 13"
  type: WITHER_SKELETON
  health: 72
  damage: 9
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 98
  lootTable: dungeon_mobs
  behaviorTree: lvl13_behavior_133

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.3
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 8.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.25
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl13_behavior_163.yml`  
- Path: `behaviors/lvl13_behavior_163.yml`  
- Size: 908 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl13_behavior_163:
  name: "&cGegner Lvl 13"
  type: WITCH
  health: 72
  damage: 9
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 98
  lootTable: dungeon_mobs
  behaviorTree: lvl13_behavior_163

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.3
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 8.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.25
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl13_behavior_193.yml`  
- Path: `behaviors/lvl13_behavior_193.yml`  
- Size: 925 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl13_behavior_193:
  name: "&cGegner Lvl 13"
  type: STRAY
  health: 72
  damage: 9
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 98
  lootTable: dungeon_mobs
  behaviorTree: lvl13_behavior_193

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.3
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 8.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.25
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl14_behavior_014.yml`  
- Path: `behaviors/lvl14_behavior_014.yml`  
- Size: 923 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl14_behavior_014:
  name: "&cGegner Lvl 14"
  type: WITHER_SKELETON
  health: 76
  damage: 10
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 104
  lootTable: dungeon_mobs
  behaviorTree: lvl14_behavior_014

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.31
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 8.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.26
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl14_behavior_044.yml`  
- Path: `behaviors/lvl14_behavior_044.yml`  
- Size: 913 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl14_behavior_044:
  name: "&cGegner Lvl 14"
  type: WITCH
  health: 76
  damage: 10
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 104
  lootTable: dungeon_mobs
  behaviorTree: lvl14_behavior_044

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.31
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 8.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.26
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl14_behavior_074.yml`  
- Path: `behaviors/lvl14_behavior_074.yml`  
- Size: 913 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl14_behavior_074:
  name: "&cGegner Lvl 14"
  type: STRAY
  health: 76
  damage: 10
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 104
  lootTable: dungeon_mobs
  behaviorTree: lvl14_behavior_074

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.31
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 8.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.26
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl14_behavior_104.yml`  
- Path: `behaviors/lvl14_behavior_104.yml`  
- Size: 916 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl14_behavior_104:
  name: "&cGegner Lvl 14"
  type: SKELETON
  health: 76
  damage: 10
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 104
  lootTable: dungeon_mobs
  behaviorTree: lvl14_behavior_104

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.31
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 8.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.26
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl14_behavior_134.yml`  
- Path: `behaviors/lvl14_behavior_134.yml`  
- Size: 913 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl14_behavior_134:
  name: "&cGegner Lvl 14"
  type: BLAZE
  health: 76
  damage: 10
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 104
  lootTable: dungeon_mobs
  behaviorTree: lvl14_behavior_134

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.31
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 8.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.26
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl14_behavior_164.yml`  
- Path: `behaviors/lvl14_behavior_164.yml`  
- Size: 916 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl14_behavior_164:
  name: "&cGegner Lvl 14"
  type: PILLAGER
  health: 76
  damage: 10
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 104
  lootTable: dungeon_mobs
  behaviorTree: lvl14_behavior_164

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.31
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 8.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.26
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl14_behavior_194.yml`  
- Path: `behaviors/lvl14_behavior_194.yml`  
- Size: 915 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl14_behavior_194:
  name: "&cGegner Lvl 14"
  type: DROWNED
  health: 76
  damage: 10
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 104
  lootTable: dungeon_mobs
  behaviorTree: lvl14_behavior_194

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.31
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 8.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.26
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl15_behavior_015.yml`  
- Path: `behaviors/lvl15_behavior_015.yml`  
- Size: 918 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl15_behavior_015:
  name: "&cGegner Lvl 15"
  type: BLAZE
  health: 80
  damage: 10
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 110
  lootTable: dungeon_mobs
  behaviorTree: lvl15_behavior_015

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.32
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 9.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.27
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl15_behavior_045.yml`  
- Path: `behaviors/lvl15_behavior_045.yml`  
- Size: 923 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl15_behavior_045:
  name: "&cGegner Lvl 15"
  type: PILLAGER
  health: 80
  damage: 10
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 110
  lootTable: dungeon_mobs
  behaviorTree: lvl15_behavior_045

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.32
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 9.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.27
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl15_behavior_075.yml`  
- Path: `behaviors/lvl15_behavior_075.yml`  
- Size: 921 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl15_behavior_075:
  name: "&cGegner Lvl 15"
  type: DROWNED
  health: 80
  damage: 10
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 110
  lootTable: dungeon_mobs
  behaviorTree: lvl15_behavior_075

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.32
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 9.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.27
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl15_behavior_105.yml`  
- Path: `behaviors/lvl15_behavior_105.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl15_behavior_105:
  name: "&cGegner Lvl 15"
  type: SPIDER
  health: 80
  damage: 10
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 110
  lootTable: dungeon_mobs
  behaviorTree: lvl15_behavior_105

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.32
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 9.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.27
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl15_behavior_135.yml`  
- Path: `behaviors/lvl15_behavior_135.yml`  
- Size: 924 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl15_behavior_135:
  name: "&cGegner Lvl 15"
  type: MAGMA_CUBE
  health: 80
  damage: 10
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 110
  lootTable: dungeon_mobs
  behaviorTree: lvl15_behavior_135

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.32
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 9.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.27
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl15_behavior_165.yml`  
- Path: `behaviors/lvl15_behavior_165.yml`  
- Size: 925 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl15_behavior_165:
  name: "&cGegner Lvl 15"
  type: VINDICATOR
  health: 80
  damage: 10
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 110
  lootTable: dungeon_mobs
  behaviorTree: lvl15_behavior_165

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.32
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 9.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.27
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl15_behavior_195.yml`  
- Path: `behaviors/lvl15_behavior_195.yml`  
- Size: 922 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl15_behavior_195:
  name: "&cGegner Lvl 15"
  type: ENDERMAN
  health: 80
  damage: 10
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 110
  lootTable: dungeon_mobs
  behaviorTree: lvl15_behavior_195

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.32
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 9.2
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.27
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl16_behavior_016.yml`  
- Path: `behaviors/lvl16_behavior_016.yml`  
- Size: 913 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl16_behavior_016:
  name: "&cGegner Lvl 16"
  type: MAGMA_CUBE
  health: 84
  damage: 11
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 116
  lootTable: dungeon_mobs
  behaviorTree: lvl16_behavior_016

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.34
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 9.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.29
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl16_behavior_046.yml`  
- Path: `behaviors/lvl16_behavior_046.yml`  
- Size: 924 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl16_behavior_046:
  name: "&cGegner Lvl 16"
  type: VINDICATOR
  health: 84
  damage: 11
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 116
  lootTable: dungeon_mobs
  behaviorTree: lvl16_behavior_046

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.34
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 9.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.29
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl16_behavior_076.yml`  
- Path: `behaviors/lvl16_behavior_076.yml`  
- Size: 912 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl16_behavior_076:
  name: "&cGegner Lvl 16"
  type: ENDERMAN
  health: 84
  damage: 11
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 116
  lootTable: dungeon_mobs
  behaviorTree: lvl16_behavior_076

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.34
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 9.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.29
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl16_behavior_106.yml`  
- Path: `behaviors/lvl16_behavior_106.yml`  
- Size: 920 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl16_behavior_106:
  name: "&cGegner Lvl 16"
  type: CREEPER
  health: 84
  damage: 11
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 116
  lootTable: dungeon_mobs
  behaviorTree: lvl16_behavior_106

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.34
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 9.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.29
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl16_behavior_136.yml`  
- Path: `behaviors/lvl16_behavior_136.yml`  
- Size: 913 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl16_behavior_136:
  name: "&cGegner Lvl 16"
  type: SILVERFISH
  health: 84
  damage: 11
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 116
  lootTable: dungeon_mobs
  behaviorTree: lvl16_behavior_136

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.34
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 9.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.29
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl16_behavior_166.yml`  
- Path: `behaviors/lvl16_behavior_166.yml`  
- Size: 920 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl16_behavior_166:
  name: "&cGegner Lvl 16"
  type: EVOKER
  health: 84
  damage: 11
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 116
  lootTable: dungeon_mobs
  behaviorTree: lvl16_behavior_166

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.34
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 9.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.29
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl16_behavior_196.yml`  
- Path: `behaviors/lvl16_behavior_196.yml`  
- Size: 908 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl16_behavior_196:
  name: "&cGegner Lvl 16"
  type: SLIME
  health: 84
  damage: 11
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 116
  lootTable: dungeon_mobs
  behaviorTree: lvl16_behavior_196

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.34
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 9.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.29
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl17_behavior_017.yml`  
- Path: `behaviors/lvl17_behavior_017.yml`  
- Size: 906 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl17_behavior_017:
  name: "&cGegner Lvl 17"
  type: SILVERFISH
  health: 88
  damage: 11
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 122
  lootTable: dungeon_mobs
  behaviorTree: lvl17_behavior_017

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.35
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 9.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.3
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl17_behavior_047.yml`  
- Path: `behaviors/lvl17_behavior_047.yml`  
- Size: 918 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl17_behavior_047:
  name: "&cGegner Lvl 17"
  type: EVOKER
  health: 88
  damage: 11
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 122
  lootTable: dungeon_mobs
  behaviorTree: lvl17_behavior_047

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.35
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 9.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.3
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl17_behavior_077.yml`  
- Path: `behaviors/lvl17_behavior_077.yml`  
- Size: 900 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl17_behavior_077:
  name: "&cGegner Lvl 17"
  type: SLIME
  health: 88
  damage: 11
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 122
  lootTable: dungeon_mobs
  behaviorTree: lvl17_behavior_077

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.35
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 9.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.3
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl17_behavior_107.yml`  
- Path: `behaviors/lvl17_behavior_107.yml`  
- Size: 917 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl17_behavior_107:
  name: "&cGegner Lvl 17"
  type: HUSK
  health: 88
  damage: 11
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 122
  lootTable: dungeon_mobs
  behaviorTree: lvl17_behavior_107

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.35
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 9.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.3
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl17_behavior_137.yml`  
- Path: `behaviors/lvl17_behavior_137.yml`  
- Size: 902 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl17_behavior_137:
  name: "&cGegner Lvl 17"
  type: ZOMBIE
  health: 88
  damage: 11
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 122
  lootTable: dungeon_mobs
  behaviorTree: lvl17_behavior_137

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.35
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 9.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.3
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl17_behavior_167.yml`  
- Path: `behaviors/lvl17_behavior_167.yml`  
- Size: 927 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl17_behavior_167:
  name: "&cGegner Lvl 17"
  type: WITHER_SKELETON
  health: 88
  damage: 11
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 122
  lootTable: dungeon_mobs
  behaviorTree: lvl17_behavior_167

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.35
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 9.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.3
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl17_behavior_197.yml`  
- Path: `behaviors/lvl17_behavior_197.yml`  
- Size: 900 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl17_behavior_197:
  name: "&cGegner Lvl 17"
  type: WITCH
  health: 88
  damage: 11
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 122
  lootTable: dungeon_mobs
  behaviorTree: lvl17_behavior_197

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.35
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 9.9
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.3
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl18_behavior_018.yml`  
- Path: `behaviors/lvl18_behavior_018.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl18_behavior_018:
  name: "&cGegner Lvl 18"
  type: ZOMBIE
  health: 92
  damage: 12
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 128
  lootTable: dungeon_mobs
  behaviorTree: lvl18_behavior_018

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.36
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 10.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.31
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl18_behavior_048.yml`  
- Path: `behaviors/lvl18_behavior_048.yml`  
- Size: 931 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl18_behavior_048:
  name: "&cGegner Lvl 18"
  type: WITHER_SKELETON
  health: 92
  damage: 12
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 128
  lootTable: dungeon_mobs
  behaviorTree: lvl18_behavior_048

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.36
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 10.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.31
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl18_behavior_078.yml`  
- Path: `behaviors/lvl18_behavior_078.yml`  
- Size: 916 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl18_behavior_078:
  name: "&cGegner Lvl 18"
  type: WITCH
  health: 92
  damage: 12
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 128
  lootTable: dungeon_mobs
  behaviorTree: lvl18_behavior_078

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.36
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 10.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.31
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl18_behavior_108.yml`  
- Path: `behaviors/lvl18_behavior_108.yml`  
- Size: 921 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl18_behavior_108:
  name: "&cGegner Lvl 18"
  type: STRAY
  health: 92
  damage: 12
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 128
  lootTable: dungeon_mobs
  behaviorTree: lvl18_behavior_108

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.36
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 10.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.31
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl18_behavior_138.yml`  
- Path: `behaviors/lvl18_behavior_138.yml`  
- Size: 921 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl18_behavior_138:
  name: "&cGegner Lvl 18"
  type: SKELETON
  health: 92
  damage: 12
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 128
  lootTable: dungeon_mobs
  behaviorTree: lvl18_behavior_138

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.36
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 10.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.31
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl18_behavior_168.yml`  
- Path: `behaviors/lvl18_behavior_168.yml`  
- Size: 920 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl18_behavior_168:
  name: "&cGegner Lvl 18"
  type: BLAZE
  health: 92
  damage: 12
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 128
  lootTable: dungeon_mobs
  behaviorTree: lvl18_behavior_168

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.36
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 10.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.31
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl18_behavior_198.yml`  
- Path: `behaviors/lvl18_behavior_198.yml`  
- Size: 920 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl18_behavior_198:
  name: "&cGegner Lvl 18"
  type: PILLAGER
  health: 92
  damage: 12
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 128
  lootTable: dungeon_mobs
  behaviorTree: lvl18_behavior_198

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.36
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 10.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.31
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl19_behavior_019.yml`  
- Path: `behaviors/lvl19_behavior_019.yml`  
- Size: 932 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl19_behavior_019:
  name: "&cGegner Lvl 19"
  type: SKELETON
  health: 96
  damage: 12
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 134
  lootTable: dungeon_mobs
  behaviorTree: lvl19_behavior_019

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.37
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 10.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.32
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl19_behavior_049.yml`  
- Path: `behaviors/lvl19_behavior_049.yml`  
- Size: 912 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl19_behavior_049:
  name: "&cGegner Lvl 19"
  type: BLAZE
  health: 96
  damage: 12
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 134
  lootTable: dungeon_mobs
  behaviorTree: lvl19_behavior_049

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.37
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 10.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.32
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl19_behavior_079.yml`  
- Path: `behaviors/lvl19_behavior_079.yml`  
- Size: 932 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl19_behavior_079:
  name: "&cGegner Lvl 19"
  type: PILLAGER
  health: 96
  damage: 12
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 134
  lootTable: dungeon_mobs
  behaviorTree: lvl19_behavior_079

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.37
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 10.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.32
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl19_behavior_109.yml`  
- Path: `behaviors/lvl19_behavior_109.yml`  
- Size: 914 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl19_behavior_109:
  name: "&cGegner Lvl 19"
  type: DROWNED
  health: 96
  damage: 12
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 134
  lootTable: dungeon_mobs
  behaviorTree: lvl19_behavior_109

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.37
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 10.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.32
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl19_behavior_139.yml`  
- Path: `behaviors/lvl19_behavior_139.yml`  
- Size: 930 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl19_behavior_139:
  name: "&cGegner Lvl 19"
  type: SPIDER
  health: 96
  damage: 12
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 134
  lootTable: dungeon_mobs
  behaviorTree: lvl19_behavior_139

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.37
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 10.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.32
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl19_behavior_169.yml`  
- Path: `behaviors/lvl19_behavior_169.yml`  
- Size: 917 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl19_behavior_169:
  name: "&cGegner Lvl 19"
  type: MAGMA_CUBE
  health: 96
  damage: 12
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 134
  lootTable: dungeon_mobs
  behaviorTree: lvl19_behavior_169

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.37
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 10.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.32
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl19_behavior_199.yml`  
- Path: `behaviors/lvl19_behavior_199.yml`  
- Size: 934 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl19_behavior_199:
  name: "&cGegner Lvl 19"
  type: VINDICATOR
  health: 96
  damage: 12
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 134
  lootTable: dungeon_mobs
  behaviorTree: lvl19_behavior_199

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.37
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 10.6
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.32
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl20_behavior_020.yml`  
- Path: `behaviors/lvl20_behavior_020.yml`  
- Size: 916 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl20_behavior_020:
  name: "&cGegner Lvl 20"
  type: SPIDER
  health: 100
  damage: 13
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 140
  lootTable: dungeon_mobs
  behaviorTree: lvl20_behavior_020

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.38
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 11.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.33
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl20_behavior_050.yml`  
- Path: `behaviors/lvl20_behavior_050.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl20_behavior_050:
  name: "&cGegner Lvl 20"
  type: MAGMA_CUBE
  health: 100
  damage: 13
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 140
  lootTable: dungeon_mobs
  behaviorTree: lvl20_behavior_050

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.38
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 11.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.33
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl20_behavior_080.yml`  
- Path: `behaviors/lvl20_behavior_080.yml`  
- Size: 921 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl20_behavior_080:
  name: "&cGegner Lvl 20"
  type: VINDICATOR
  health: 100
  damage: 13
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 140
  lootTable: dungeon_mobs
  behaviorTree: lvl20_behavior_080

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.38
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 11.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.33
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl20_behavior_110.yml`  
- Path: `behaviors/lvl20_behavior_110.yml`  
- Size: 918 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl20_behavior_110:
  name: "&cGegner Lvl 20"
  type: ENDERMAN
  health: 100
  damage: 13
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 140
  lootTable: dungeon_mobs
  behaviorTree: lvl20_behavior_110

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.38
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 11.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.33
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl20_behavior_140.yml`  
- Path: `behaviors/lvl20_behavior_140.yml`  
- Size: 916 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl20_behavior_140:
  name: "&cGegner Lvl 20"
  type: CREEPER
  health: 100
  damage: 13
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 140
  lootTable: dungeon_mobs
  behaviorTree: lvl20_behavior_140

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.38
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 11.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.33
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl20_behavior_170.yml`  
- Path: `behaviors/lvl20_behavior_170.yml`  
- Size: 920 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl20_behavior_170:
  name: "&cGegner Lvl 20"
  type: SILVERFISH
  health: 100
  damage: 13
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 140
  lootTable: dungeon_mobs
  behaviorTree: lvl20_behavior_170

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.38
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 11.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.33
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl20_behavior_200.yml`  
- Path: `behaviors/lvl20_behavior_200.yml`  
- Size: 917 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl20_behavior_200:
  name: "&cGegner Lvl 20"
  type: EVOKER
  health: 100
  damage: 13
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 140
  lootTable: dungeon_mobs
  behaviorTree: lvl20_behavior_200

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.38
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 11.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.33
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl21_behavior_021.yml`  
- Path: `behaviors/lvl21_behavior_021.yml`  
- Size: 920 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl21_behavior_021:
  name: "&cGegner Lvl 21"
  type: CREEPER
  health: 104
  damage: 13
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 146
  lootTable: elite_mobs
  behaviorTree: lvl21_behavior_021

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.39
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 11.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.34
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl21_behavior_051.yml`  
- Path: `behaviors/lvl21_behavior_051.yml`  
- Size: 924 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl21_behavior_051:
  name: "&cGegner Lvl 21"
  type: SILVERFISH
  health: 104
  damage: 13
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 146
  lootTable: elite_mobs
  behaviorTree: lvl21_behavior_051

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.39
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 11.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.34
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl21_behavior_081.yml`  
- Path: `behaviors/lvl21_behavior_081.yml`  
- Size: 920 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl21_behavior_081:
  name: "&cGegner Lvl 21"
  type: EVOKER
  health: 104
  damage: 13
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 146
  lootTable: elite_mobs
  behaviorTree: lvl21_behavior_081

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.39
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 11.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.34
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl21_behavior_111.yml`  
- Path: `behaviors/lvl21_behavior_111.yml`  
- Size: 920 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl21_behavior_111:
  name: "&cGegner Lvl 21"
  type: SLIME
  health: 104
  damage: 13
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 146
  lootTable: elite_mobs
  behaviorTree: lvl21_behavior_111

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.39
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 11.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.34
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl21_behavior_141.yml`  
- Path: `behaviors/lvl21_behavior_141.yml`  
- Size: 917 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl21_behavior_141:
  name: "&cGegner Lvl 21"
  type: HUSK
  health: 104
  damage: 13
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 146
  lootTable: elite_mobs
  behaviorTree: lvl21_behavior_141

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.39
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 11.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.34
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl21_behavior_171.yml`  
- Path: `behaviors/lvl21_behavior_171.yml`  
- Size: 920 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl21_behavior_171:
  name: "&cGegner Lvl 21"
  type: ZOMBIE
  health: 104
  damage: 13
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 146
  lootTable: elite_mobs
  behaviorTree: lvl21_behavior_171

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.39
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 11.3
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.34
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl22_behavior_022.yml`  
- Path: `behaviors/lvl22_behavior_022.yml`  
- Size: 907 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl22_behavior_022:
  name: "&cGegner Lvl 22"
  type: HUSK
  health: 108
  damage: 14
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 152
  lootTable: elite_mobs
  behaviorTree: lvl22_behavior_022

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.41
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 11.7
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.36
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl22_behavior_052.yml`  
- Path: `behaviors/lvl22_behavior_052.yml`  
- Size: 920 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl22_behavior_052:
  name: "&cGegner Lvl 22"
  type: ZOMBIE
  health: 108
  damage: 14
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 152
  lootTable: elite_mobs
  behaviorTree: lvl22_behavior_052

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.41
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 11.7
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.36
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl22_behavior_082.yml`  
- Path: `behaviors/lvl22_behavior_082.yml`  
- Size: 918 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl22_behavior_082:
  name: "&cGegner Lvl 22"
  type: WITHER_SKELETON
  health: 108
  damage: 14
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 152
  lootTable: elite_mobs
  behaviorTree: lvl22_behavior_082

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.41
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 11.7
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.36
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl22_behavior_112.yml`  
- Path: `behaviors/lvl22_behavior_112.yml`  
- Size: 918 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl22_behavior_112:
  name: "&cGegner Lvl 22"
  type: WITCH
  health: 108
  damage: 14
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 152
  lootTable: elite_mobs
  behaviorTree: lvl22_behavior_112

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.41
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 11.7
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.36
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl22_behavior_142.yml`  
- Path: `behaviors/lvl22_behavior_142.yml`  
- Size: 909 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl22_behavior_142:
  name: "&cGegner Lvl 22"
  type: STRAY
  health: 108
  damage: 14
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 152
  lootTable: elite_mobs
  behaviorTree: lvl22_behavior_142

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.41
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 11.7
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.36
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl22_behavior_172.yml`  
- Path: `behaviors/lvl22_behavior_172.yml`  
- Size: 922 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl22_behavior_172:
  name: "&cGegner Lvl 22"
  type: SKELETON
  health: 108
  damage: 14
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 152
  lootTable: elite_mobs
  behaviorTree: lvl22_behavior_172

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.41
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 11.7
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.36
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl23_behavior_023.yml`  
- Path: `behaviors/lvl23_behavior_023.yml`  
- Size: 902 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl23_behavior_023:
  name: "&cGegner Lvl 23"
  type: STRAY
  health: 112
  damage: 14
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 158
  lootTable: elite_mobs
  behaviorTree: lvl23_behavior_023

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.42
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 12.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.37
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl23_behavior_053.yml`  
- Path: `behaviors/lvl23_behavior_053.yml`  
- Size: 922 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl23_behavior_053:
  name: "&cGegner Lvl 23"
  type: SKELETON
  health: 112
  damage: 14
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 158
  lootTable: elite_mobs
  behaviorTree: lvl23_behavior_053

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.42
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 12.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.37
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl23_behavior_083.yml`  
- Path: `behaviors/lvl23_behavior_083.yml`  
- Size: 902 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl23_behavior_083:
  name: "&cGegner Lvl 23"
  type: BLAZE
  health: 112
  damage: 14
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 158
  lootTable: elite_mobs
  behaviorTree: lvl23_behavior_083

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.42
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 12.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.37
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl23_behavior_113.yml`  
- Path: `behaviors/lvl23_behavior_113.yml`  
- Size: 920 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl23_behavior_113:
  name: "&cGegner Lvl 23"
  type: PILLAGER
  health: 112
  damage: 14
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 158
  lootTable: elite_mobs
  behaviorTree: lvl23_behavior_113

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.42
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 12.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.37
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl23_behavior_143.yml`  
- Path: `behaviors/lvl23_behavior_143.yml`  
- Size: 904 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl23_behavior_143:
  name: "&cGegner Lvl 23"
  type: DROWNED
  health: 112
  damage: 14
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 158
  lootTable: elite_mobs
  behaviorTree: lvl23_behavior_143

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.42
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 12.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.37
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl23_behavior_173.yml`  
- Path: `behaviors/lvl23_behavior_173.yml`  
- Size: 920 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl23_behavior_173:
  name: "&cGegner Lvl 23"
  type: SPIDER
  health: 112
  damage: 14
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 158
  lootTable: elite_mobs
  behaviorTree: lvl23_behavior_173

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.42
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 12.0
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.37
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl24_behavior_024.yml`  
- Path: `behaviors/lvl24_behavior_024.yml`  
- Size: 918 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl24_behavior_024:
  name: "&cGegner Lvl 24"
  type: DROWNED
  health: 116
  damage: 15
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 164
  lootTable: elite_mobs
  behaviorTree: lvl24_behavior_024

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.43
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 12.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.38
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl24_behavior_054.yml`  
- Path: `behaviors/lvl24_behavior_054.yml`  
- Size: 921 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl24_behavior_054:
  name: "&cGegner Lvl 24"
  type: SPIDER
  health: 116
  damage: 15
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 164
  lootTable: elite_mobs
  behaviorTree: lvl24_behavior_054

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.43
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 12.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.38
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl24_behavior_084.yml`  
- Path: `behaviors/lvl24_behavior_084.yml`  
- Size: 921 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl24_behavior_084:
  name: "&cGegner Lvl 24"
  type: MAGMA_CUBE
  health: 116
  damage: 15
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 164
  lootTable: elite_mobs
  behaviorTree: lvl24_behavior_084

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.43
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 12.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.38
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl24_behavior_114.yml`  
- Path: `behaviors/lvl24_behavior_114.yml`  
- Size: 925 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl24_behavior_114:
  name: "&cGegner Lvl 24"
  type: VINDICATOR
  health: 116
  damage: 15
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 164
  lootTable: elite_mobs
  behaviorTree: lvl24_behavior_114

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.43
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 12.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.38
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl24_behavior_144.yml`  
- Path: `behaviors/lvl24_behavior_144.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl24_behavior_144:
  name: "&cGegner Lvl 24"
  type: ENDERMAN
  health: 116
  damage: 15
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 164
  lootTable: elite_mobs
  behaviorTree: lvl24_behavior_144

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.43
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 12.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.38
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl24_behavior_174.yml`  
- Path: `behaviors/lvl24_behavior_174.yml`  
- Size: 922 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl24_behavior_174:
  name: "&cGegner Lvl 24"
  type: CREEPER
  health: 116
  damage: 15
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 164
  lootTable: elite_mobs
  behaviorTree: lvl24_behavior_174

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.43
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 12.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.38
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl25_behavior_025.yml`  
- Path: `behaviors/lvl25_behavior_025.yml`  
- Size: 931 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl25_behavior_025:
  name: "&cGegner Lvl 25"
  type: ENDERMAN
  health: 120
  damage: 15
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 170
  lootTable: elite_mobs
  behaviorTree: lvl25_behavior_025

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.44
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 12.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.39
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl25_behavior_055.yml`  
- Path: `behaviors/lvl25_behavior_055.yml`  
- Size: 913 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl25_behavior_055:
  name: "&cGegner Lvl 25"
  type: CREEPER
  health: 120
  damage: 15
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 170
  lootTable: elite_mobs
  behaviorTree: lvl25_behavior_055

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.44
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 12.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.39
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl25_behavior_085.yml`  
- Path: `behaviors/lvl25_behavior_085.yml`  
- Size: 932 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl25_behavior_085:
  name: "&cGegner Lvl 25"
  type: SILVERFISH
  health: 120
  damage: 15
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 170
  lootTable: elite_mobs
  behaviorTree: lvl25_behavior_085

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.44
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 12.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.39
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl25_behavior_115.yml`  
- Path: `behaviors/lvl25_behavior_115.yml`  
- Size: 913 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl25_behavior_115:
  name: "&cGegner Lvl 25"
  type: EVOKER
  health: 120
  damage: 15
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 170
  lootTable: elite_mobs
  behaviorTree: lvl25_behavior_115

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.44
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 12.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.39
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl25_behavior_145.yml`  
- Path: `behaviors/lvl25_behavior_145.yml`  
- Size: 928 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl25_behavior_145:
  name: "&cGegner Lvl 25"
  type: SLIME
  health: 120
  damage: 15
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - divine_blessing
    - frost_bolt
  skillIntervalSeconds: 7
  xp: 170
  lootTable: elite_mobs
  behaviorTree: lvl25_behavior_145

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.44
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 12.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.39
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl25_behavior_175.yml`  
- Path: `behaviors/lvl25_behavior_175.yml`  
- Size: 909 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl25_behavior_175:
  name: "&cGegner Lvl 25"
  type: HUSK
  health: 120
  damage: 15
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - execute
    - fortify
  skillIntervalSeconds: 7
  xp: 170
  lootTable: elite_mobs
  behaviorTree: lvl25_behavior_175

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.44
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 12.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 5
        child:
          type: cast_skill
          skill: divine_blessing
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.39
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl26_behavior_026.yml`  
- Path: `behaviors/lvl26_behavior_026.yml`  
- Size: 913 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl26_behavior_026:
  name: "&cGegner Lvl 26"
  type: SLIME
  health: 124
  damage: 16
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 176
  lootTable: elite_mobs
  behaviorTree: lvl26_behavior_026

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.45
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 13.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.4
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl26_behavior_056.yml`  
- Path: `behaviors/lvl26_behavior_056.yml`  
- Size: 910 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl26_behavior_056:
  name: "&cGegner Lvl 26"
  type: HUSK
  health: 124
  damage: 16
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 176
  lootTable: elite_mobs
  behaviorTree: lvl26_behavior_056

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.45
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 13.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.4
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl26_behavior_086.yml`  
- Path: `behaviors/lvl26_behavior_086.yml`  
- Size: 913 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl26_behavior_086:
  name: "&cGegner Lvl 26"
  type: ZOMBIE
  health: 124
  damage: 16
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 176
  lootTable: elite_mobs
  behaviorTree: lvl26_behavior_086

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.45
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 13.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.4
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl26_behavior_116.yml`  
- Path: `behaviors/lvl26_behavior_116.yml`  
- Size: 922 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl26_behavior_116:
  name: "&cGegner Lvl 26"
  type: WITHER_SKELETON
  health: 124
  damage: 16
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 176
  lootTable: elite_mobs
  behaviorTree: lvl26_behavior_116

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.45
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 13.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.4
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl26_behavior_146.yml`  
- Path: `behaviors/lvl26_behavior_146.yml`  
- Size: 913 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl26_behavior_146:
  name: "&cGegner Lvl 26"
  type: WITCH
  health: 124
  damage: 16
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - frost_bolt
    - execute
  skillIntervalSeconds: 8
  xp: 176
  lootTable: elite_mobs
  behaviorTree: lvl26_behavior_146

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.45
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 13.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.4
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl26_behavior_176.yml`  
- Path: `behaviors/lvl26_behavior_176.yml`  
- Size: 911 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl26_behavior_176:
  name: "&cGegner Lvl 26"
  type: STRAY
  health: 124
  damage: 16
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - fortify
    - divine_blessing
  skillIntervalSeconds: 8
  xp: 176
  lootTable: elite_mobs
  behaviorTree: lvl26_behavior_176

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.45
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 13.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 6
        child:
          type: cast_skill
          skill: frost_bolt
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.4
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl27_behavior_027.yml`  
- Path: `behaviors/lvl27_behavior_027.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl27_behavior_027:
  name: "&cGegner Lvl 27"
  type: WITCH
  health: 128
  damage: 16
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 182
  lootTable: elite_mobs
  behaviorTree: lvl27_behavior_027

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.46
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 13.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.41
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl27_behavior_057.yml`  
- Path: `behaviors/lvl27_behavior_057.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl27_behavior_057:
  name: "&cGegner Lvl 27"
  type: STRAY
  health: 128
  damage: 16
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 182
  lootTable: elite_mobs
  behaviorTree: lvl27_behavior_057

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.46
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 13.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.41
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl27_behavior_087.yml`  
- Path: `behaviors/lvl27_behavior_087.yml`  
- Size: 922 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl27_behavior_087:
  name: "&cGegner Lvl 27"
  type: SKELETON
  health: 128
  damage: 16
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 182
  lootTable: elite_mobs
  behaviorTree: lvl27_behavior_087

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.46
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 13.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.41
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl27_behavior_117.yml`  
- Path: `behaviors/lvl27_behavior_117.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl27_behavior_117:
  name: "&cGegner Lvl 27"
  type: BLAZE
  health: 128
  damage: 16
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 182
  lootTable: elite_mobs
  behaviorTree: lvl27_behavior_117

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.46
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 13.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.41
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl27_behavior_147.yml`  
- Path: `behaviors/lvl27_behavior_147.yml`  
- Size: 921 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl27_behavior_147:
  name: "&cGegner Lvl 27"
  type: PILLAGER
  health: 128
  damage: 16
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - power_strike
    - heal_pulse
  skillIntervalSeconds: 9
  xp: 182
  lootTable: elite_mobs
  behaviorTree: lvl27_behavior_147

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.46
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 13.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.41
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl27_behavior_177.yml`  
- Path: `behaviors/lvl27_behavior_177.yml`  
- Size: 922 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl27_behavior_177:
  name: "&cGegner Lvl 27"
  type: DROWNED
  health: 128
  damage: 16
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - heal_pulse
    - power_strike
  skillIntervalSeconds: 9
  xp: 182
  lootTable: elite_mobs
  behaviorTree: lvl27_behavior_177

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.46
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 13.4
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 7
        child:
          type: cast_skill
          skill: power_strike
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.41
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl28_behavior_028.yml`  
- Path: `behaviors/lvl28_behavior_028.yml`  
- Size: 910 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl28_behavior_028:
  name: "&cGegner Lvl 28"
  type: PILLAGER
  health: 132
  damage: 17
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 188
  lootTable: elite_mobs
  behaviorTree: lvl28_behavior_028

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.48
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 13.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.43
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl28_behavior_058.yml`  
- Path: `behaviors/lvl28_behavior_058.yml`  
- Size: 921 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl28_behavior_058:
  name: "&cGegner Lvl 28"
  type: DROWNED
  health: 132
  damage: 17
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 188
  lootTable: elite_mobs
  behaviorTree: lvl28_behavior_058

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.48
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 13.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.43
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl28_behavior_088.yml`  
- Path: `behaviors/lvl28_behavior_088.yml`  
- Size: 910 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl28_behavior_088:
  name: "&cGegner Lvl 28"
  type: SPIDER
  health: 132
  damage: 17
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 188
  lootTable: elite_mobs
  behaviorTree: lvl28_behavior_088

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.48
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 13.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.43
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl28_behavior_118.yml`  
- Path: `behaviors/lvl28_behavior_118.yml`  
- Size: 924 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl28_behavior_118:
  name: "&cGegner Lvl 28"
  type: MAGMA_CUBE
  health: 132
  damage: 17
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 188
  lootTable: elite_mobs
  behaviorTree: lvl28_behavior_118

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.48
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 13.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.43
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl28_behavior_148.yml`  
- Path: `behaviors/lvl28_behavior_148.yml`  
- Size: 912 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl28_behavior_148:
  name: "&cGegner Lvl 28"
  type: VINDICATOR
  health: 132
  damage: 17
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - execute
    - frost_bolt
  skillIntervalSeconds: 10
  xp: 188
  lootTable: elite_mobs
  behaviorTree: lvl28_behavior_148

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.48
      - type: cast_skill
        skill: execute
      - type: heal_self
        amount: 13.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.43
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl28_behavior_178.yml`  
- Path: `behaviors/lvl28_behavior_178.yml`  
- Size: 922 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl28_behavior_178:
  name: "&cGegner Lvl 28"
  type: ENDERMAN
  health: 132
  damage: 17
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - divine_blessing
    - fortify
  skillIntervalSeconds: 10
  xp: 188
  lootTable: elite_mobs
  behaviorTree: lvl28_behavior_178

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.48
      - type: cast_skill
        skill: divine_blessing
      - type: heal_self
        amount: 13.8
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 8
        child:
          type: cast_skill
          skill: execute
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.43
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl29_behavior_029.yml`  
- Path: `behaviors/lvl29_behavior_029.yml`  
- Size: 906 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl29_behavior_029:
  name: "&cGegner Lvl 29"
  type: VINDICATOR
  health: 136
  damage: 17
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 194
  lootTable: elite_mobs
  behaviorTree: lvl29_behavior_029

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.49
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 14.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.44
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl29_behavior_059.yml`  
- Path: `behaviors/lvl29_behavior_059.yml`  
- Size: 921 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl29_behavior_059:
  name: "&cGegner Lvl 29"
  type: ENDERMAN
  health: 136
  damage: 17
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 194
  lootTable: elite_mobs
  behaviorTree: lvl29_behavior_059

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.49
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 14.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.44
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl29_behavior_089.yml`  
- Path: `behaviors/lvl29_behavior_089.yml`  
- Size: 904 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl29_behavior_089:
  name: "&cGegner Lvl 29"
  type: CREEPER
  health: 136
  damage: 17
  mainHand: GOLDEN_AXE
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 194
  lootTable: elite_mobs
  behaviorTree: lvl29_behavior_089

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.49
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 14.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.44
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl29_behavior_119.yml`  
- Path: `behaviors/lvl29_behavior_119.yml`  
- Size: 923 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl29_behavior_119:
  name: "&cGegner Lvl 29"
  type: SILVERFISH
  health: 136
  damage: 17
  mainHand: DIAMOND_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 194
  lootTable: elite_mobs
  behaviorTree: lvl29_behavior_119

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.49
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 14.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 6
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.44
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl29_behavior_149.yml`  
- Path: `behaviors/lvl29_behavior_149.yml`  
- Size: 903 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl29_behavior_149:
  name: "&cGegner Lvl 29"
  type: EVOKER
  health: 136
  damage: 17
  mainHand: IRON_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - fortify
    - execute
  skillIntervalSeconds: 11
  xp: 194
  lootTable: elite_mobs
  behaviorTree: lvl29_behavior_149

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.49
      - type: cast_skill
        skill: fortify
      - type: heal_self
        amount: 14.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.44
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl29_behavior_179.yml`  
- Path: `behaviors/lvl29_behavior_179.yml`  
- Size: 918 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl29_behavior_179:
  name: "&cGegner Lvl 29"
  type: SLIME
  health: 136
  damage: 17
  mainHand: WOODEN_SWORD
  helmet: GOLDEN_HELMET
  skills:
    - frost_bolt
    - divine_blessing
  skillIntervalSeconds: 11
  xp: 194
  lootTable: elite_mobs
  behaviorTree: lvl29_behavior_179

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.49
      - type: cast_skill
        skill: frost_bolt
      - type: heal_self
        amount: 14.1
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 9
        child:
          type: cast_skill
          skill: fortify
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.44
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl30_behavior_030.yml`  
- Path: `behaviors/lvl30_behavior_030.yml`  
- Size: 917 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl30_behavior_030:
  name: "&cGegner Lvl 30"
  type: EVOKER
  health: 140
  damage: 18
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 200
  lootTable: elite_mobs
  behaviorTree: lvl30_behavior_030

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.5
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 14.5
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 10
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.45
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl30_behavior_060.yml`  
- Path: `behaviors/lvl30_behavior_060.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl30_behavior_060:
  name: "&cGegner Lvl 30"
  type: SLIME
  health: 140
  damage: 18
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 200
  lootTable: elite_mobs
  behaviorTree: lvl30_behavior_060

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.5
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 14.5
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 14
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.45
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl30_behavior_090.yml`  
- Path: `behaviors/lvl30_behavior_090.yml`  
- Size: 914 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl30_behavior_090:
  name: "&cGegner Lvl 30"
  type: HUSK
  health: 140
  damage: 18
  mainHand: WOODEN_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 200
  lootTable: elite_mobs
  behaviorTree: lvl30_behavior_090

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.5
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 14.5
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 18
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.45
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl30_behavior_120.yml`  
- Path: `behaviors/lvl30_behavior_120.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl30_behavior_120:
  name: "&cGegner Lvl 30"
  type: ZOMBIE
  health: 140
  damage: 18
  mainHand: GOLDEN_AXE
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 200
  lootTable: elite_mobs
  behaviorTree: lvl30_behavior_120

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.5
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 14.5
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 8
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.45
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl30_behavior_150.yml`  
- Path: `behaviors/lvl30_behavior_150.yml`  
- Size: 926 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl30_behavior_150:
  name: "&cGegner Lvl 30"
  type: WITHER_SKELETON
  health: 140
  damage: 18
  mainHand: DIAMOND_SWORD
  helmet: LEATHER_HELMET
  skills:
    - heal_pulse
    - heal_pulse
  skillIntervalSeconds: 6
  xp: 200
  lootTable: elite_mobs
  behaviorTree: lvl30_behavior_150

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.5
      - type: cast_skill
        skill: heal_pulse
      - type: heal_self
        amount: 14.5
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 12
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.45
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `behaviors/lvl30_behavior_180.yml`  
- Path: `behaviors/lvl30_behavior_180.yml`  
- Size: 919 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
lvl30_behavior_180:
  name: "&cGegner Lvl 30"
  type: WITCH
  health: 140
  damage: 18
  mainHand: IRON_SWORD
  helmet: LEATHER_HELMET
  skills:
    - power_strike
    - power_strike
  skillIntervalSeconds: 6
  xp: 200
  lootTable: elite_mobs
  behaviorTree: lvl30_behavior_180

type: selector
children:
  - type: sequence
    children:
      - type: health_below
        threshold: 0.5
      - type: cast_skill
        skill: power_strike
      - type: heal_self
        amount: 14.5
      - type: flee
  - type: sequence
    children:
      - type: target_distance_above
        distance: 16
      - type: cooldown
        cooldownSeconds: 4
        child:
          type: cast_skill
          skill: heal_pulse
  - type: sequence
    children:
      - type: inverter
        child:
          type: health_below
          threshold: 0.45
      - type: walk_to_target
      - type: melee_attack
  - type: melee_attack

```

## File: `pom.xml`  
- Path: `pom.xml`  
- Size: 3608 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>rpg-plugin</artifactId>
    <version>1.0.0</version>
    <name>MineLauncherRPG</name>

    <properties>
        <java.version>17</java.version>
        <paper.version>1.20.4-R0.1-SNAPSHOT</paper.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <repositories>
        <repository>
            <id>papermc</id>
            <url>https://repo.papermc.io/repository/maven-public/</url>
        </repository>
    </repositories>

    <dependencies>
        <dependency>
            <groupId>io.papermc.paper</groupId>
            <artifactId>paper-api</artifactId>
            <version>${paper.version}</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
            <version>5.1.0</version>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <version>42.7.2</version>
        </dependency>
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>2.11.0</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <release>${java.version}</release>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.5.2</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <createDependencyReducedPom>false</createDependencyReducedPom>
                            <shadedArtifactAttached>false</shadedArtifactAttached>
                            <outputFile>${project.build.directory}/${project.artifactId}-${project.version}.jar</outputFile>
                            <filters>
                                <filter>
                                    <artifact>*:*</artifact>
                                    <excludes>
                                        <exclude>META-INF/*.SF</exclude>
                                        <exclude>META-INF/*.DSA</exclude>
                                        <exclude>META-INF/*.RSA</exclude>
                                        <exclude>module-info.class</exclude>
                                        <exclude>META-INF/versions/**</exclude>
                                    </excludes>
                                </filter>
                            </filters>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>

```

## File: `src/main/java/com/example/rpg/behavior/BehaviorContext.java`  
- Path: `src/main/java/com/example/rpg/behavior/BehaviorContext.java`  
- Size: 1165 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.MobDefinition;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;

public class BehaviorContext {
    private final RPGPlugin plugin;
    private final LivingEntity mob;
    private final MobDefinition definition;
    private Player target;
    private final Map<String, Long> cooldowns = new HashMap<>();

    public BehaviorContext(RPGPlugin plugin, LivingEntity mob, MobDefinition definition) {
        this.plugin = plugin;
        this.mob = mob;
        this.definition = definition;
    }

    public RPGPlugin plugin() {
        return plugin;
    }

    public LivingEntity mob() {
        return mob;
    }

    public MobDefinition definition() {
        return definition;
    }

    public Player target() {
        return target;
    }

    public void setTarget(Player target) {
        this.target = target;
    }

    public Map<String, Long> cooldowns() {
        return cooldowns;
    }

    public UUID mobId() {
        return mob.getUniqueId();
    }
}

```

## File: `src/main/java/com/example/rpg/behavior/BehaviorNode.java`  
- Path: `src/main/java/com/example/rpg/behavior/BehaviorNode.java`  
- Size: 399 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

import java.util.UUID;

public abstract class BehaviorNode {
    private final String id;

    protected BehaviorNode(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public abstract BehaviorStatus tick(BehaviorContext context);

    protected String key(UUID entityId) {
        return id + ":" + entityId;
    }
}

```

## File: `src/main/java/com/example/rpg/behavior/BehaviorStatus.java`  
- Path: `src/main/java/com/example/rpg/behavior/BehaviorStatus.java`  
- Size: 104 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

public enum BehaviorStatus {
    SUCCESS,
    FAILURE,
    RUNNING
}

```

## File: `src/main/java/com/example/rpg/behavior/CastSkillNode.java`  
- Path: `src/main/java/com/example/rpg/behavior/CastSkillNode.java`  
- Size: 633 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

import org.bukkit.entity.Player;

public class CastSkillNode extends BehaviorNode {
    private final String skillId;

    public CastSkillNode(String id, String skillId) {
        super(id);
        this.skillId = skillId;
    }

    @Override
    public BehaviorStatus tick(BehaviorContext context) {
        Player target = context.target();
        if (target == null) {
            return BehaviorStatus.FAILURE;
        }
        boolean success = context.plugin().useMobSkill(context.mob(), target, skillId);
        return success ? BehaviorStatus.SUCCESS : BehaviorStatus.FAILURE;
    }
}

```

## File: `src/main/java/com/example/rpg/behavior/CompositeNode.java`  
- Path: `src/main/java/com/example/rpg/behavior/CompositeNode.java`  
- Size: 357 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

import java.util.ArrayList;
import java.util.List;

public abstract class CompositeNode extends BehaviorNode {
    private final List<BehaviorNode> children = new ArrayList<>();

    protected CompositeNode(String id) {
        super(id);
    }

    public List<BehaviorNode> children() {
        return children;
    }
}

```

## File: `src/main/java/com/example/rpg/behavior/CooldownNode.java`  
- Path: `src/main/java/com/example/rpg/behavior/CooldownNode.java`  
- Size: 853 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

public class CooldownNode extends BehaviorNode {
    private final BehaviorNode child;
    private final long cooldownMillis;

    public CooldownNode(String id, BehaviorNode child, long cooldownMillis) {
        super(id);
        this.child = child;
        this.cooldownMillis = cooldownMillis;
    }

    @Override
    public BehaviorStatus tick(BehaviorContext context) {
        long now = System.currentTimeMillis();
        String key = key(context.mobId());
        Long last = context.cooldowns().get(key);
        if (last != null && now - last < cooldownMillis) {
            return BehaviorStatus.FAILURE;
        }
        BehaviorStatus status = child.tick(context);
        if (status == BehaviorStatus.SUCCESS) {
            context.cooldowns().put(key, now);
        }
        return status;
    }
}

```

## File: `src/main/java/com/example/rpg/behavior/FleeNode.java`  
- Path: `src/main/java/com/example/rpg/behavior/FleeNode.java`  
- Size: 850 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.util.Vector;

public class FleeNode extends BehaviorNode {
    public FleeNode(String id) {
        super(id);
    }

    @Override
    public BehaviorStatus tick(BehaviorContext context) {
        Player target = context.target();
        if (target == null) {
            return BehaviorStatus.FAILURE;
        }
        Location mobLoc = context.mob().getLocation();
        Location targetLoc = target.getLocation();
        Vector direction = mobLoc.toVector().subtract(targetLoc.toVector());
        if (direction.lengthSquared() == 0) {
            return BehaviorStatus.FAILURE;
        }
        direction.normalize().multiply(0.35);
        context.mob().setVelocity(direction);
        return BehaviorStatus.RUNNING;
    }
}

```

## File: `src/main/java/com/example/rpg/behavior/HealSelfNode.java`  
- Path: `src/main/java/com/example/rpg/behavior/HealSelfNode.java`  
- Size: 534 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

public class HealSelfNode extends BehaviorNode {
    private final double amount;

    public HealSelfNode(String id, double amount) {
        super(id);
        this.amount = amount;
    }

    @Override
    public BehaviorStatus tick(BehaviorContext context) {
        double maxHealth = Math.max(1, context.definition().health());
        double next = Math.min(maxHealth, context.mob().getHealth() + amount);
        context.mob().setHealth(next);
        return BehaviorStatus.SUCCESS;
    }
}

```

## File: `src/main/java/com/example/rpg/behavior/HealthBelowNode.java`  
- Path: `src/main/java/com/example/rpg/behavior/HealthBelowNode.java`  
- Size: 547 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

public class HealthBelowNode extends BehaviorNode {
    private final double threshold;

    public HealthBelowNode(String id, double threshold) {
        super(id);
        this.threshold = threshold;
    }

    @Override
    public BehaviorStatus tick(BehaviorContext context) {
        double maxHealth = Math.max(1, context.definition().health());
        double current = context.mob().getHealth();
        return (current / maxHealth) < threshold ? BehaviorStatus.SUCCESS : BehaviorStatus.FAILURE;
    }
}

```

## File: `src/main/java/com/example/rpg/behavior/InverterNode.java`  
- Path: `src/main/java/com/example/rpg/behavior/InverterNode.java`  
- Size: 567 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

public class InverterNode extends BehaviorNode {
    private final BehaviorNode child;

    public InverterNode(String id, BehaviorNode child) {
        super(id);
        this.child = child;
    }

    @Override
    public BehaviorStatus tick(BehaviorContext context) {
        BehaviorStatus status = child.tick(context);
        return switch (status) {
            case SUCCESS -> BehaviorStatus.FAILURE;
            case FAILURE -> BehaviorStatus.SUCCESS;
            case RUNNING -> BehaviorStatus.RUNNING;
        };
    }
}

```

## File: `src/main/java/com/example/rpg/behavior/MeleeAttackNode.java`  
- Path: `src/main/java/com/example/rpg/behavior/MeleeAttackNode.java`  
- Size: 638 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

import org.bukkit.entity.Player;

public class MeleeAttackNode extends BehaviorNode {
    public MeleeAttackNode(String id) {
        super(id);
    }

    @Override
    public BehaviorStatus tick(BehaviorContext context) {
        Player target = context.target();
        if (target == null) {
            return BehaviorStatus.FAILURE;
        }
        if (target.getLocation().distanceSquared(context.mob().getLocation()) > 9) {
            return BehaviorStatus.FAILURE;
        }
        target.damage(context.definition().damage(), context.mob());
        return BehaviorStatus.SUCCESS;
    }
}

```

## File: `src/main/java/com/example/rpg/behavior/SelectorNode.java`  
- Path: `src/main/java/com/example/rpg/behavior/SelectorNode.java`  
- Size: 515 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

public class SelectorNode extends CompositeNode {
    public SelectorNode(String id) {
        super(id);
    }

    @Override
    public BehaviorStatus tick(BehaviorContext context) {
        for (BehaviorNode child : children()) {
            BehaviorStatus status = child.tick(context);
            if (status == BehaviorStatus.SUCCESS || status == BehaviorStatus.RUNNING) {
                return status;
            }
        }
        return BehaviorStatus.FAILURE;
    }
}

```

## File: `src/main/java/com/example/rpg/behavior/SequenceNode.java`  
- Path: `src/main/java/com/example/rpg/behavior/SequenceNode.java`  
- Size: 608 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

public class SequenceNode extends CompositeNode {
    public SequenceNode(String id) {
        super(id);
    }

    @Override
    public BehaviorStatus tick(BehaviorContext context) {
        for (BehaviorNode child : children()) {
            BehaviorStatus status = child.tick(context);
            if (status == BehaviorStatus.FAILURE) {
                return BehaviorStatus.FAILURE;
            }
            if (status == BehaviorStatus.RUNNING) {
                return BehaviorStatus.RUNNING;
            }
        }
        return BehaviorStatus.SUCCESS;
    }
}

```

## File: `src/main/java/com/example/rpg/behavior/TargetDistanceAboveNode.java`  
- Path: `src/main/java/com/example/rpg/behavior/TargetDistanceAboveNode.java`  
- Size: 659 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

import org.bukkit.entity.Player;

public class TargetDistanceAboveNode extends BehaviorNode {
    private final double distance;

    public TargetDistanceAboveNode(String id, double distance) {
        super(id);
        this.distance = distance;
    }

    @Override
    public BehaviorStatus tick(BehaviorContext context) {
        Player target = context.target();
        if (target == null) {
            return BehaviorStatus.FAILURE;
        }
        double dist = target.getLocation().distance(context.mob().getLocation());
        return dist > distance ? BehaviorStatus.SUCCESS : BehaviorStatus.FAILURE;
    }
}

```

## File: `src/main/java/com/example/rpg/behavior/WalkToTargetNode.java`  
- Path: `src/main/java/com/example/rpg/behavior/WalkToTargetNode.java`  
- Size: 647 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.behavior;

import org.bukkit.entity.Mob;
import org.bukkit.entity.Player;

public class WalkToTargetNode extends BehaviorNode {
    public WalkToTargetNode(String id) {
        super(id);
    }

    @Override
    public BehaviorStatus tick(BehaviorContext context) {
        Player target = context.target();
        if (target == null) {
            return BehaviorStatus.FAILURE;
        }
        if (context.mob() instanceof Mob mob) {
            mob.setTarget(target);
            mob.getPathfinder().moveTo(target);
            return BehaviorStatus.RUNNING;
        }
        return BehaviorStatus.FAILURE;
    }
}

```

## File: `src/main/java/com/example/rpg/command/AuctionCommand.java`  
- Path: `src/main/java/com/example/rpg/command/AuctionCommand.java`  
- Size: 4726 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.command;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.AuctionListing;
import com.example.rpg.util.Text;
import java.util.UUID;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;

public class AuctionCommand implements CommandExecutor {
    private final RPGPlugin plugin;

    public AuctionCommand(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player player)) {
            sender.sendMessage("Nur Spieler.");
            return true;
        }
        if (args.length < 1) {
            player.sendMessage(Text.mm("<gray>/auction <list|sell|buy>"));
            return true;
        }
        switch (args[0].toLowerCase()) {
            case "list" -> listAuctions(player);
            case "sell" -> sellAuction(player, args);
            case "buy" -> buyAuction(player, args);
            default -> player.sendMessage(Text.mm("<gray>/auction <list|sell|buy>"));
        }
        return true;
    }

    private void listAuctions(Player player) {
        if (plugin.auctionHouseManager().listings().isEmpty()) {
            player.sendMessage(Text.mm("<yellow>Keine Auktionen verfgbar."));
            return;
        }
        player.sendMessage(Text.mm("<gold>Auktionen:"));
        for (AuctionListing listing : plugin.auctionHouseManager().listings().values()) {
            player.sendMessage(Text.mm("<gray>" + listing.id() + " - <gold>" + listing.price() + "</gold> Gold"));
        }
    }

    private void sellAuction(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/auction sell <price>"));
            return;
        }
        int price;
        try {
            price = Integer.parseInt(args[1]);
        } catch (NumberFormatException e) {
            player.sendMessage(Text.mm("<red>Preis ungltig."));
            return;
        }
        if (price <= 0) {
            player.sendMessage(Text.mm("<red>Preis muss > 0 sein."));
            return;
        }
        ItemStack item = player.getInventory().getItemInMainHand();
        if (item == null || item.getType().isAir()) {
            player.sendMessage(Text.mm("<red>Halte ein Item in der Hand."));
            return;
        }
        String data = plugin.auctionHouseManager().serializeItem(item);
        if (data == null) {
            player.sendMessage(Text.mm("<red>Item konnte nicht gespeichert werden."));
            return;
        }
        String id = UUID.randomUUID().toString().substring(0, 8);
        AuctionListing listing = new AuctionListing(id);
        listing.setSeller(player.getUniqueId());
        listing.setPrice(price);
        listing.setItemData(data);
        plugin.auctionHouseManager().addListing(listing);
        player.getInventory().setItemInMainHand(null);
        player.sendMessage(Text.mm("<green>Auktion erstellt: " + id));
    }

    private void buyAuction(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/auction buy <id>"));
            return;
        }
        String id = args[1];
        AuctionListing listing = plugin.auctionHouseManager().getListing(id);
        if (listing == null) {
            player.sendMessage(Text.mm("<red>Auktion nicht gefunden."));
            return;
        }
        var buyerProfile = plugin.playerDataManager().getProfile(player);
        if (buyerProfile.gold() < listing.price()) {
            player.sendMessage(Text.mm("<red>Nicht genug Gold."));
            return;
        }
        ItemStack item = plugin.auctionHouseManager().deserializeItem(listing.itemData());
        if (item == null) {
            player.sendMessage(Text.mm("<red>Item nicht verfgbar."));
            return;
        }
        buyerProfile.setGold(buyerProfile.gold() - listing.price());
        player.getInventory().addItem(item);
        if (listing.seller() != null) {
            var seller = plugin.getServer().getPlayer(listing.seller());
            if (seller != null) {
                var sellerProfile = plugin.playerDataManager().getProfile(seller);
                sellerProfile.setGold(sellerProfile.gold() + listing.price());
                seller.sendMessage(Text.mm("<green>Dein Item wurde verkauft fr " + listing.price() + " Gold."));
            }
        }
        plugin.auctionHouseManager().removeListing(id);
        player.sendMessage(Text.mm("<green>Item gekauft."));
    }
}

```

## File: `src/main/java/com/example/rpg/command/BehaviorCommand.java`  
- Path: `src/main/java/com/example/rpg/command/BehaviorCommand.java`  
- Size: 982 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.command;

import com.example.rpg.RPGPlugin;
import com.example.rpg.util.Text;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

public class BehaviorCommand implements CommandExecutor {
    private final RPGPlugin plugin;

    public BehaviorCommand(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player player)) {
            sender.sendMessage("Nur Spieler.");
            return true;
        }
        if (args.length < 2 || !"edit".equalsIgnoreCase(args[0])) {
            player.sendMessage(Text.mm("<gray>/behavior edit <tree>"));
            return true;
        }
        String treeName = args[1];
        plugin.behaviorTreeEditorGui().open(player, treeName);
        return true;
    }
}

```

## File: `src/main/java/com/example/rpg/command/DungeonCommand.java`  
- Path: `src/main/java/com/example/rpg/command/DungeonCommand.java`  
- Size: 4189 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.command;

import com.example.rpg.RPGPlugin;
import com.example.rpg.util.Text;
import org.bukkit.Location;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

public class DungeonCommand implements CommandExecutor {
    private final RPGPlugin plugin;

    public DungeonCommand(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player player)) {
            sender.sendMessage("Nur Spieler.");
            return true;
        }
        if (args.length < 1) {
            player.sendMessage(Text.mm("<gray>/dungeon <enter|leave|generate|queue|role|leavequeue>"));
            return true;
        }
        switch (args[0].toLowerCase()) {
            case "enter" -> enterDungeon(player);
            case "leave" -> leaveDungeon(player);
            case "generate" -> generateDungeon(player, args);
            case "queue" -> queueDungeon(player, args);
            case "leavequeue" -> plugin.dungeonManager().leaveQueue(player);
            case "role" -> setRole(player, args);
            default -> player.sendMessage(Text.mm("<gray>/dungeon <enter|leave|generate|queue|role|leavequeue>"));
        }
        return true;
    }

    private void enterDungeon(Player player) {
        Location spawn = plugin.dungeonManager().getEntrance();
        if (spawn == null) {
            player.sendMessage(Text.mm("<red>Dungeon nicht konfiguriert."));
            return;
        }
        if (!plugin.dungeonManager().hasFactionAccess(player, "default")) {
            player.sendMessage(Text.mm("<red>Dein Ruf reicht nicht aus."));
            return;
        }
        plugin.dungeonManager().enterDungeon(player);
        player.sendMessage(Text.mm("<green>Dungeon betreten."));
    }

    private void leaveDungeon(Player player) {
        plugin.dungeonManager().leaveDungeon(player);
        player.sendMessage(Text.mm("<yellow>Dungeon verlassen."));
    }

    private void generateDungeon(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/dungeon generate <theme>"));
            return;
        }
        String theme = args[1];
        var party = plugin.partyManager().getParty(player.getUniqueId());
        java.util.List<Player> members = new java.util.ArrayList<>();
        if (party.isPresent()) {
            for (java.util.UUID memberId : party.get().members()) {
                Player member = player.getServer().getPlayer(memberId);
                if (member != null) {
                    members.add(member);
                }
            }
            Player leader = player.getServer().getPlayer(party.get().leader());
            if (leader != null && !members.contains(leader)) {
                members.add(leader);
            }
        } else {
            members.add(player);
        }
        if (!plugin.dungeonManager().hasFactionAccess(player, theme)) {
            player.sendMessage(Text.mm("<red>Dein Ruf reicht nicht aus."));
            return;
        }
        plugin.dungeonManager().generateDungeon(player, theme, members);
    }

    private void queueDungeon(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/dungeon queue <theme>"));
            return;
        }
        plugin.dungeonManager().joinQueue(player, args[1]);
    }

    private void setRole(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/dungeon role <tank|heal|dps>"));
            return;
        }
        String role = args[1].toUpperCase();
        if (!role.equals("TANK") && !role.equals("HEAL") && !role.equals("DPS")) {
            player.sendMessage(Text.mm("<red>Rolle ungltig."));
            return;
        }
        var profile = plugin.playerDataManager().getProfile(player);
        profile.setDungeonRole(role);
        player.sendMessage(Text.mm("<green>Rolle gesetzt: " + role));
    }
}

```

## File: `src/main/java/com/example/rpg/command/GuildCommand.java`  
- Path: `src/main/java/com/example/rpg/command/GuildCommand.java`  
- Size: 18338 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.command;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.Guild;
import com.example.rpg.model.GuildMemberRole;
import com.example.rpg.model.GuildQuest;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.util.Text;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

public class GuildCommand implements CommandExecutor {
    private final RPGPlugin plugin;

    public GuildCommand(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player player)) {
            sender.sendMessage("Nur Spieler.");
            return true;
        }
        if (label.equalsIgnoreCase("g")) {
            if (args.length == 0) {
                player.sendMessage(Text.mm("<gray>/g <message>"));
                return true;
            }
            String message = join(args, 0);
            guildChat(player, new String[] {"chat", message});
            return true;
        }
        if (args.length == 0) {
            player.sendMessage(Text.mm("<gray>/guild <create|invite|accept|leave|disband|info|chat|bank|quest|hall>"));
            return true;
        }
        switch (args[0].toLowerCase()) {
            case "create" -> createGuild(player, args);
            case "invite" -> invitePlayer(player, args);
            case "accept" -> acceptInvite(player);
            case "leave" -> leaveGuild(player);
            case "disband" -> disbandGuild(player);
            case "info" -> guildInfo(player);
            case "chat" -> guildChat(player, args);
            case "bank" -> bankCommand(player, args);
            case "quest" -> questCommand(player, args);
            case "hall" -> hallCommand(player, args);
            default -> player.sendMessage(Text.mm("<gray>/guild <create|invite|accept|leave|disband|info|chat|bank|quest|hall>"));
        }
        return true;
    }

    private void createGuild(Player player, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/guild create <id> <name>"));
            return;
        }
        if (plugin.guildManager().isMember(player.getUniqueId())) {
            player.sendMessage(Text.mm("<red>Du bist bereits in einer Gilde."));
            return;
        }
        String id = args[1].toLowerCase();
        String name = join(args, 2);
        if (plugin.guildManager().guildById(id).isPresent()) {
            player.sendMessage(Text.mm("<red>Gilden-ID existiert bereits."));
            return;
        }
        plugin.guildManager().createGuild(id, name, player);
        player.sendMessage(Text.mm("<green>Gilde erstellt: " + name));
    }

    private void invitePlayer(Player player, String[] args) {
        Optional<Guild> guildOpt = plugin.guildManager().guildFor(player.getUniqueId());
        if (guildOpt.isEmpty()) {
            player.sendMessage(Text.mm("<red>Du bist in keiner Gilde."));
            return;
        }
        Guild guild = guildOpt.get();
        if (!isOfficerOrLeader(guild, player.getUniqueId())) {
            player.sendMessage(Text.mm("<red>Keine Rechte, um einzuladen."));
            return;
        }
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/guild invite <player>"));
            return;
        }
        Player target = player.getServer().getPlayer(args[1]);
        if (target == null) {
            player.sendMessage(Text.mm("<red>Spieler nicht online."));
            return;
        }
        if (plugin.guildManager().isMember(target.getUniqueId())) {
            player.sendMessage(Text.mm("<red>Spieler ist bereits in einer Gilde."));
            return;
        }
        plugin.guildManager().invite(target.getUniqueId(), guild.id());
        player.sendMessage(Text.mm("<green>Einladung gesendet."));
        target.sendMessage(Text.mm("<yellow>Gildeneinladung von " + guild.name() + ". /guild accept"));
    }

    private void acceptInvite(Player player) {
        if (plugin.guildManager().isMember(player.getUniqueId())) {
            player.sendMessage(Text.mm("<red>Du bist bereits in einer Gilde."));
            return;
        }
        Optional<Guild> guild = plugin.guildManager().acceptInvite(player.getUniqueId());
        if (guild.isEmpty()) {
            player.sendMessage(Text.mm("<red>Keine Einladung gefunden."));
            return;
        }
        player.sendMessage(Text.mm("<green>Du bist der Gilde beigetreten."));
    }

    private void leaveGuild(Player player) {
        if (!plugin.guildManager().isMember(player.getUniqueId())) {
            player.sendMessage(Text.mm("<red>Du bist in keiner Gilde."));
            return;
        }
        plugin.guildManager().leaveGuild(player.getUniqueId());
        player.sendMessage(Text.mm("<yellow>Gilde verlassen."));
    }

    private void disbandGuild(Player player) {
        Optional<Guild> guildOpt = plugin.guildManager().guildFor(player.getUniqueId());
        if (guildOpt.isEmpty()) {
            player.sendMessage(Text.mm("<red>Du bist in keiner Gilde."));
            return;
        }
        Guild guild = guildOpt.get();
        if (!guild.leader().equals(player.getUniqueId())) {
            player.sendMessage(Text.mm("<red>Nur der Gildenleiter kann auflsen."));
            return;
        }
        plugin.guildManager().disbandGuild(guild);
        player.sendMessage(Text.mm("<yellow>Gilde aufgelst."));
    }

    private void guildInfo(Player player) {
        Optional<Guild> guildOpt = plugin.guildManager().guildFor(player.getUniqueId());
        if (guildOpt.isEmpty()) {
            player.sendMessage(Text.mm("<red>Du bist in keiner Gilde."));
            return;
        }
        Guild guild = guildOpt.get();
        String members = guild.members().keySet().stream()
            .map(uuid -> {
                Player online = player.getServer().getPlayer(uuid);
                return online != null ? online.getName() : uuid.toString().substring(0, 8);
            })
            .collect(Collectors.joining(", "));
        player.sendMessage(Text.mm("<gold>Gilde: <white>" + guild.name()));
        player.sendMessage(Text.mm("<gray>Mitglieder: <white>" + members));
        player.sendMessage(Text.mm("<gray>Gildenbank: <gold>" + guild.bankGold() + "</gold> Gold"));
    }

    private void guildChat(Player player, String[] args) {
        Optional<Guild> guildOpt = plugin.guildManager().guildFor(player.getUniqueId());
        if (guildOpt.isEmpty()) {
            player.sendMessage(Text.mm("<red>Du bist in keiner Gilde."));
            return;
        }
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/guild chat <message>"));
            return;
        }
        Guild guild = guildOpt.get();
        String message = join(args, 1);
        for (UUID member : guild.members().keySet()) {
            Player target = player.getServer().getPlayer(member);
            if (target != null) {
                target.sendMessage(Text.mm("<aqua>[Gilde] <white>" + player.getName() + ": " + message));
            }
        }
    }

    private void bankCommand(Player player, String[] args) {
        Optional<Guild> guildOpt = plugin.guildManager().guildFor(player.getUniqueId());
        if (guildOpt.isEmpty()) {
            player.sendMessage(Text.mm("<red>Du bist in keiner Gilde."));
            return;
        }
        Guild guild = guildOpt.get();
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/guild bank <balance|deposit|withdraw>"));
            return;
        }
        switch (args[1].toLowerCase()) {
            case "balance" -> player.sendMessage(Text.mm("<gold>Gildenbank: " + guild.bankGold() + " Gold"));
            case "deposit" -> depositGuild(player, guild, args);
            case "withdraw" -> withdrawGuild(player, guild, args);
            default -> player.sendMessage(Text.mm("<gray>/guild bank <balance|deposit|withdraw>"));
        }
    }

    private void depositGuild(Player player, Guild guild, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/guild bank deposit <amount>"));
            return;
        }
        Integer amount = parseAmount(player, args[2]);
        if (amount == null) {
            return;
        }
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        if (profile.gold() < amount) {
            player.sendMessage(Text.mm("<red>Nicht genug Gold."));
            return;
        }
        profile.setGold(profile.gold() - amount);
        plugin.guildManager().deposit(guild, amount);
        player.sendMessage(Text.mm("<green>" + amount + " Gold eingezahlt."));
    }

    private void withdrawGuild(Player player, Guild guild, String[] args) {
        if (!isOfficerOrLeader(guild, player.getUniqueId())) {
            player.sendMessage(Text.mm("<red>Keine Rechte zum Abheben."));
            return;
        }
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/guild bank withdraw <amount>"));
            return;
        }
        Integer amount = parseAmount(player, args[2]);
        if (amount == null) {
            return;
        }
        if (!plugin.guildManager().withdraw(guild, amount)) {
            player.sendMessage(Text.mm("<red>Gildenbank hat nicht genug Gold."));
            return;
        }
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        profile.setGold(profile.gold() + amount);
        player.sendMessage(Text.mm("<green>" + amount + " Gold abgehoben."));
    }

    private void questCommand(Player player, String[] args) {
        Optional<Guild> guildOpt = plugin.guildManager().guildFor(player.getUniqueId());
        if (guildOpt.isEmpty()) {
            player.sendMessage(Text.mm("<red>Du bist in keiner Gilde."));
            return;
        }
        Guild guild = guildOpt.get();
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/guild quest <list|create|progress|complete>"));
            return;
        }
        switch (args[1].toLowerCase()) {
            case "list" -> listQuests(player, guild);
            case "create" -> createQuest(player, guild, args);
            case "progress" -> progressQuest(player, guild, args);
            case "complete" -> completeQuest(player, guild, args);
            default -> player.sendMessage(Text.mm("<gray>/guild quest <list|create|progress|complete>"));
        }
    }

    private void listQuests(Player player, Guild guild) {
        if (guild.quests().isEmpty()) {
            player.sendMessage(Text.mm("<yellow>Keine Gilden-Quests verfgbar."));
            return;
        }
        player.sendMessage(Text.mm("<gold>Gilden-Quests:</gold>"));
        for (GuildQuest quest : guild.quests().values()) {
            String status = quest.completed() ? "<green>abgeschlossen" : "<yellow>" + quest.progress() + "/" + quest.goal();
            player.sendMessage(Text.mm("<gray>" + quest.id() + " - <white>" + quest.name() + " <gray>(" + status + "<gray>)"));
        }
    }

    private void createQuest(Player player, Guild guild, String[] args) {
        if (!isOfficerOrLeader(guild, player.getUniqueId())) {
            player.sendMessage(Text.mm("<red>Keine Rechte, um Quests zu erstellen."));
            return;
        }
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/guild quest create <id> <goal> <name>"));
            return;
        }
        String id = args[2].toLowerCase();
        Integer goal = parseAmount(player, args[3]);
        if (goal == null) {
            return;
        }
        if (guild.quests().containsKey(id)) {
            player.sendMessage(Text.mm("<red>Quest-ID existiert bereits."));
            return;
        }
        String name = args.length > 4 ? join(args, 4) : id;
        GuildQuest quest = new GuildQuest(id);
        quest.setName(name);
        quest.setDescription("Gildenquest");
        quest.setGoal(goal);
        quest.setProgress(0);
        quest.setCompleted(false);
        guild.quests().put(id, quest);
        plugin.guildManager().saveAll();
        player.sendMessage(Text.mm("<green>Gilden-Quest erstellt."));
    }

    private void progressQuest(Player player, Guild guild, String[] args) {
        if (!isOfficerOrLeader(guild, player.getUniqueId())) {
            player.sendMessage(Text.mm("<red>Keine Rechte, um Fortschritt zu setzen."));
            return;
        }
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/guild quest progress <id> <amount>"));
            return;
        }
        GuildQuest quest = guild.quests().get(args[2]);
        if (quest == null) {
            player.sendMessage(Text.mm("<red>Quest nicht gefunden."));
            return;
        }
        Integer amount = parseAmount(player, args[3]);
        if (amount == null) {
            return;
        }
        quest.setProgress(quest.progress() + amount);
        if (quest.progress() >= quest.goal()) {
            quest.setCompleted(true);
        }
        plugin.guildManager().saveAll();
        player.sendMessage(Text.mm("<green>Quest-Fortschritt aktualisiert."));
    }

    private void completeQuest(Player player, Guild guild, String[] args) {
        if (!isOfficerOrLeader(guild, player.getUniqueId())) {
            player.sendMessage(Text.mm("<red>Keine Rechte, um Quests abzuschlieen."));
            return;
        }
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/guild quest complete <id>"));
            return;
        }
        GuildQuest quest = guild.quests().get(args[2]);
        if (quest == null) {
            player.sendMessage(Text.mm("<red>Quest nicht gefunden."));
            return;
        }
        quest.setCompleted(true);
        plugin.guildManager().saveAll();
        player.sendMessage(Text.mm("<green>Quest abgeschlossen."));
    }

    private void hallCommand(Player player, String[] args) {
        Optional<Guild> guildOpt = plugin.guildManager().guildFor(player.getUniqueId());
        if (guildOpt.isEmpty()) {
            player.sendMessage(Text.mm("<red>Du bist in keiner Gilde."));
            return;
        }
        Guild guild = guildOpt.get();
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/guild hall <set|go|upgrade>"));
            return;
        }
        switch (args[1].toLowerCase()) {
            case "set" -> {
                if (!guild.leader().equals(player.getUniqueId())) {
                    player.sendMessage(Text.mm("<red>Nur der Leader kann die Halle setzen."));
                    return;
                }
                var loc = player.getLocation();
                guild.setHall(loc.getWorld().getName(), loc.getX(), loc.getY(), loc.getZ());
                plugin.guildManager().saveAll();
                player.sendMessage(Text.mm("<green>Gildenhalle gesetzt."));
            }
            case "go" -> {
                var hall = plugin.guildManager().hallLocation(guild);
                if (hall == null) {
                    player.sendMessage(Text.mm("<red>Keine Gildenhalle gesetzt."));
                    return;
                }
                if (guild.hallUpgrades().getOrDefault("teleport", 0) < 1) {
                    player.sendMessage(Text.mm("<red>Teleport-Upgrade erforderlich."));
                    return;
                }
                player.teleport(hall);
                player.sendMessage(Text.mm("<green>Zur Gildenhalle teleportiert."));
            }
            case "upgrade" -> upgradeHall(player, guild, args);
            default -> player.sendMessage(Text.mm("<gray>/guild hall <set|go|upgrade>"));
        }
    }

    private void upgradeHall(Player player, Guild guild, String[] args) {
        if (!isOfficerOrLeader(guild, player.getUniqueId())) {
            player.sendMessage(Text.mm("<red>Keine Rechte fr Upgrades."));
            return;
        }
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/guild hall upgrade <craft|teleport|buff>"));
            return;
        }
        String type = args[2].toLowerCase();
        int current = guild.hallUpgrades().getOrDefault(type, 0);
        int cost = switch (type) {
            case "craft" -> 500 + (current * 300);
            case "teleport" -> 800 + (current * 400);
            case "buff" -> 1000 + (current * 500);
            default -> -1;
        };
        if (cost < 0) {
            player.sendMessage(Text.mm("<red>Unbekanntes Upgrade."));
            return;
        }
        if (guild.bankGold() < cost) {
            player.sendMessage(Text.mm("<red>Nicht genug Gold in der Gildenbank. Bentigt: " + cost));
            return;
        }
        guild.setBankGold(guild.bankGold() - cost);
        guild.hallUpgrades().put(type, current + 1);
        plugin.guildManager().saveAll();
        player.sendMessage(Text.mm("<green>Upgrade verbessert: " + type + " (Stufe " + (current + 1) + ")"));
    }

    private boolean isOfficerOrLeader(Guild guild, UUID member) {
        GuildMemberRole role = guild.members().get(member);
        return role == GuildMemberRole.LEADER || role == GuildMemberRole.OFFICER;
    }

    private Integer parseAmount(Player player, String input) {
        int amount;
        try {
            amount = Integer.parseInt(input);
        } catch (NumberFormatException e) {
            player.sendMessage(Text.mm("<red>Betrag ungltig."));
            return null;
        }
        if (amount <= 0) {
            player.sendMessage(Text.mm("<red>Betrag muss > 0 sein."));
            return null;
        }
        return amount;
    }

    private String join(String[] args, int start) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i < args.length; i++) {
            if (i > start) {
                builder.append(" ");
            }
            builder.append(args[i]);
        }
        return builder.toString();
    }
}

```

## File: `src/main/java/com/example/rpg/command/LootChatCommand.java`  
- Path: `src/main/java/com/example/rpg/command/LootChatCommand.java`  
- Size: 902 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.command;

import com.example.rpg.RPGPlugin;
import com.example.rpg.util.Text;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;

public class LootChatCommand implements CommandExecutor {
    private final RPGPlugin plugin;

    public LootChatCommand(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        boolean current = plugin.getConfig().getBoolean("lootchat.enabled", true);
        boolean next = args.length == 1 ? Boolean.parseBoolean(args[0]) : !current;
        plugin.getConfig().set("lootchat.enabled", next);
        plugin.saveConfig();
        sender.sendMessage(Text.mm(next ? "<green>Lootchat aktiviert." : "<red>Lootchat deaktiviert."));
        return true;
    }
}

```

## File: `src/main/java/com/example/rpg/command/PartyCommand.java`  
- Path: `src/main/java/com/example/rpg/command/PartyCommand.java`  
- Size: 4553 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.command;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.Party;
import com.example.rpg.util.Text;
import java.util.UUID;
import org.bukkit.Bukkit;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

public class PartyCommand implements CommandExecutor {
    private final RPGPlugin plugin;

    public PartyCommand(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player player)) {
            sender.sendMessage("Nur Spieler.");
            return true;
        }
        if (args.length == 0) {
            player.sendMessage(Text.mm("<gray>/party <create|invite|join|leave|chat>"));
            return true;
        }
        switch (args[0].toLowerCase()) {
            case "create" -> createParty(player);
            case "invite" -> invitePlayer(player, args);
            case "join" -> joinParty(player, args);
            case "leave" -> leaveParty(player);
            case "chat" -> partyChat(player, args);
            default -> player.sendMessage(Text.mm("<gray>/party <create|invite|join|leave|chat>"));
        }
        return true;
    }

    private void createParty(Player player) {
        if (plugin.partyManager().getParty(player.getUniqueId()).isPresent()) {
            player.sendMessage(Text.mm("<yellow>Du bist bereits in einer Party."));
            return;
        }
        plugin.partyManager().createParty(player.getUniqueId());
        player.sendMessage(Text.mm("<green>Party erstellt."));
    }

    private void invitePlayer(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/party invite <player>"));
            return;
        }
        Player target = Bukkit.getPlayer(args[1]);
        if (target == null) {
            player.sendMessage(Text.mm("<red>Spieler nicht online."));
            return;
        }
        plugin.partyManager().getParty(player.getUniqueId()).ifPresentOrElse(party -> {
            target.sendMessage(Text.mm("<yellow>Party Einladung von " + player.getName() + ". Benutze /party join " + player.getName()));
        }, () -> player.sendMessage(Text.mm("<red>Du hast keine Party.")));
    }

    private void joinParty(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/party join <leader>"));
            return;
        }
        Player leader = Bukkit.getPlayer(args[1]);
        if (leader == null) {
            player.sendMessage(Text.mm("<red>Leader nicht online."));
            return;
        }
        plugin.partyManager().getParty(leader.getUniqueId()).ifPresentOrElse(party -> {
            if (plugin.partyManager().getParty(player.getUniqueId()).isPresent()) {
                player.sendMessage(Text.mm("<yellow>Du bist bereits in einer Party."));
                return;
            }
            plugin.partyManager().addMember(party, player.getUniqueId());
            leader.sendMessage(Text.mm("<green>" + player.getName() + " ist beigetreten."));
            player.sendMessage(Text.mm("<green>Du bist der Party beigetreten."));
        }, () -> player.sendMessage(Text.mm("<red>Party nicht gefunden.")));
    }

    private void leaveParty(Player player) {
        UUID uuid = player.getUniqueId();
        if (plugin.partyManager().getParty(uuid).isEmpty()) {
            player.sendMessage(Text.mm("<yellow>Du bist in keiner Party."));
            return;
        }
        plugin.partyManager().removeMember(uuid);
        player.sendMessage(Text.mm("<green>Party verlassen."));
    }

    private void partyChat(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/party chat <message>"));
            return;
        }
        plugin.partyManager().getParty(player.getUniqueId()).ifPresentOrElse(party -> {
            String message = String.join(" ", java.util.Arrays.copyOfRange(args, 1, args.length));
            for (UUID member : party.members()) {
                Player target = Bukkit.getPlayer(member);
                if (target != null) {
                    target.sendMessage(Text.mm("<aqua>[Party] " + player.getName() + ": <white>" + message));
                }
            }
        }, () -> player.sendMessage(Text.mm("<yellow>Du bist in keiner Party.")));
    }
}

```

## File: `src/main/java/com/example/rpg/command/PvpCommand.java`  
- Path: `src/main/java/com/example/rpg/command/PvpCommand.java`  
- Size: 2134 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.command;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.util.Text;
import java.util.List;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

public class PvpCommand implements CommandExecutor {
    private final RPGPlugin plugin;

    public PvpCommand(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player player)) {
            sender.sendMessage("Nur Spieler.");
            return true;
        }
        if (args.length < 1) {
            player.sendMessage(Text.mm("<gray>/pvp <join|top|season>"));
            return true;
        }
        switch (args[0].toLowerCase()) {
            case "join" -> plugin.arenaManager().joinQueue(player);
            case "top" -> showTop(player);
            case "season" -> showSeason(player);
            default -> player.sendMessage(Text.mm("<gray>/pvp <join|top|season>"));
        }
        return true;
    }

    private void showTop(Player player) {
        List<PlayerProfile> profiles = plugin.arenaManager().topPlayers(10);
        player.sendMessage(Text.mm("<gold>PvP Rangliste:"));
        int index = 1;
        for (PlayerProfile profile : profiles) {
            String name = plugin.getServer().getOfflinePlayer(profile.uuid()).getName();
            if (name == null) {
                name = profile.uuid().toString().substring(0, 8);
            }
            player.sendMessage(Text.mm("<gray>" + index++ + ". <white>" + name
                + " <gold>(" + profile.elo() + ")"));
        }
    }

    private void showSeason(Player player) {
        var season = plugin.pvpSeasonManager().currentSeason();
        if (season == null) {
            player.sendMessage(Text.mm("<yellow>Keine aktive Saison."));
            return;
        }
        player.sendMessage(Text.mm("<gold>PvP-Saison:</gold> " + season.name()));
    }
}

```

## File: `src/main/java/com/example/rpg/command/RPGAdminCommand.java`  
- Path: `src/main/java/com/example/rpg/command/RPGAdminCommand.java`  
- Size: 44937 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.command;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.LootEntry;
import com.example.rpg.model.LootTable;
import com.example.rpg.model.Npc;
import com.example.rpg.model.NpcRole;
import com.example.rpg.model.Quest;
import com.example.rpg.model.QuestStep;
import com.example.rpg.model.QuestStepType;
import com.example.rpg.model.Rarity;
import com.example.rpg.model.Skill;
import com.example.rpg.model.SkillCategory;
import com.example.rpg.model.SkillType;
import com.example.rpg.model.Zone;
import com.example.rpg.skill.SkillEffectConfig;
import com.example.rpg.skill.SkillEffectType;
import com.example.rpg.util.ItemBuilder;
import com.example.rpg.util.Text;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.UUID;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.persistence.PersistentDataType;

public class RPGAdminCommand implements CommandExecutor {
    private final RPGPlugin plugin;

    public RPGAdminCommand(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player player)) {
            sender.sendMessage("Nur Spieler.");
            return true;
        }
        if (!plugin.permissionService().has(player, "rpg.admin")) {
            player.sendMessage(Text.mm("<red>Keine Rechte."));
            return true;
        }
        if (args.length == 0) {
            plugin.guiManager().openAdminMenu(player);
            return true;
        }
        switch (args[0].toLowerCase()) {
            case "wand" -> giveWand(player);
            case "zone" -> handleZone(player, args);
            case "npc" -> handleNpc(player, args);
            case "quest" -> handleQuest(player, args);
            case "loot" -> handleLoot(player, args);
            case "skill" -> handleSkill(player, args);
            case "mob" -> handleMob(player, args);
            case "spawner" -> handleSpawner(player, args);
            case "build" -> handleBuild(player, args);
            case "perms" -> handlePerms(player, args);
            case "event" -> handleEvent(player, args);
            case "pvp" -> handlePvp(player, args);
            case "node" -> handleNode(player, args);
            default -> player.sendMessage(Text.mm("<gray>/rpgadmin <wand|zone|npc|quest|loot|skill|mob|spawner|build|perms|event|pvp|node>"));
        }
        return true;
    }

    private void handlePerms(Player player, String[] args) {
        if (!plugin.permissionService().has(player, "rpg.admin.perms")) {
            player.sendMessage(Text.mm("<red>Keine Rechte."));
            return;
        }
        if (args.length < 2 || "gui".equalsIgnoreCase(args[1])) {
            plugin.guiManager().openPermissionsMain(player);
            return;
        }
        switch (args[1].toLowerCase()) {
            case "role" -> handlePermRole(player, args);
            case "user" -> handlePermUser(player, args);
            default -> player.sendMessage(Text.mm("<gray>/rpgadmin perms <gui|role|user>"));
        }
    }

    private void handlePermRole(Player player, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/rpgadmin perms role <create|delete|parent|node|rename>"));
            return;
        }
        switch (args[2].toLowerCase()) {
            case "create" -> {
                if (args.length < 5) {
                    player.sendMessage(Text.mm("<gray>/rpgadmin perms role create <key> <displayName>"));
                    return;
                }
                String key = args[3];
                String displayName = String.join(" ", java.util.Arrays.copyOfRange(args, 4, args.length));
                plugin.permissionService().createRole(player, key, displayName);
                player.sendMessage(Text.mm("<green>Rolle erstellt."));
            }
            case "delete" -> {
                if (args.length < 4) {
                    player.sendMessage(Text.mm("<gray>/rpgadmin perms role delete <key>"));
                    return;
                }
                plugin.permissionService().deleteRole(player, args[3]);
                player.sendMessage(Text.mm("<green>Rolle gelscht."));
            }
            case "rename" -> {
                if (args.length < 5) {
                    player.sendMessage(Text.mm("<gray>/rpgadmin perms role rename <key> <displayName>"));
                    return;
                }
                String key = args[3];
                String displayName = String.join(" ", java.util.Arrays.copyOfRange(args, 4, args.length));
                plugin.permissionService().renameRole(player, key, displayName);
                player.sendMessage(Text.mm("<green>Rolle umbenannt."));
            }
            case "parent" -> handlePermParents(player, args);
            case "node" -> handlePermNodes(player, args);
            default -> player.sendMessage(Text.mm("<gray>/rpgadmin perms role <create|delete|parent|node|rename>"));
        }
    }

    private void handlePermParents(Player player, String[] args) {
        if (args.length < 6) {
            player.sendMessage(Text.mm("<gray>/rpgadmin perms role parent <add|remove> <role> <parent>"));
            return;
        }
        String action = args[3].toLowerCase();
        String role = args[4];
        String parent = args[5];
        if ("add".equals(action)) {
            boolean added = plugin.permissionService().addParent(player, role, parent);
            player.sendMessage(Text.mm(added ? "<green>Parent hinzugefgt." : "<red>Parent nicht hinzugefgt."));
            return;
        }
        if ("remove".equals(action)) {
            plugin.permissionService().removeParent(player, role, parent);
            player.sendMessage(Text.mm("<green>Parent entfernt."));
            return;
        }
        player.sendMessage(Text.mm("<gray>/rpgadmin perms role parent <add|remove> <role> <parent>"));
    }

    private void handlePermNodes(Player player, String[] args) {
        if (args.length < 6) {
            player.sendMessage(Text.mm("<gray>/rpgadmin perms role node <role> <node> <allow|deny|inherit>"));
            return;
        }
        String role = args[3];
        String node = args[4];
        String decisionRaw = args.length > 5 ? args[5] : "inherit";
        com.example.rpg.permissions.PermissionDecision decision = switch (decisionRaw.toLowerCase()) {
            case "allow" -> com.example.rpg.permissions.PermissionDecision.ALLOW;
            case "deny" -> com.example.rpg.permissions.PermissionDecision.DENY;
            default -> com.example.rpg.permissions.PermissionDecision.INHERIT;
        };
        plugin.permissionService().setRoleNode(player, role, node, decision);
        player.sendMessage(Text.mm("<green>Node gesetzt."));
    }

    private void handlePermUser(Player player, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/rpgadmin perms user <setprimary|add|remove|info> ..."));
            return;
        }
        String action = args[2].toLowerCase();
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/rpgadmin perms user <setprimary|add|remove|info> <player> [role/node]"));
            return;
        }
        org.bukkit.OfflinePlayer target = plugin.getServer().getOfflinePlayer(args[3]);
        UUID targetId = target.getUniqueId();
        switch (action) {
            case "setprimary" -> {
                if (args.length < 5) {
                    player.sendMessage(Text.mm("<gray>/rpgadmin perms user setprimary <player> <role>"));
                    return;
                }
                plugin.permissionService().assignPrimary(player, targetId, args[4]);
                player.sendMessage(Text.mm("<green>Primary Rolle gesetzt."));
            }
            case "add" -> {
                if (args.length < 5) {
                    player.sendMessage(Text.mm("<gray>/rpgadmin perms user add <player> <role>"));
                    return;
                }
                plugin.permissionService().addRole(player, targetId, args[4]);
                player.sendMessage(Text.mm("<green>Rolle hinzugefgt."));
            }
            case "remove" -> {
                if (args.length < 5) {
                    player.sendMessage(Text.mm("<gray>/rpgadmin perms user remove <player> <role>"));
                    return;
                }
                plugin.permissionService().removeRole(player, targetId, args[4]);
                player.sendMessage(Text.mm("<green>Rolle entfernt."));
            }
            case "info" -> {
                if (args.length < 5) {
                    player.sendMessage(Text.mm("<gray>/rpgadmin perms user info <player> <node>"));
                    return;
                }
                var explain = plugin.permissionService().explain(targetId, args[4]);
                player.sendMessage(Text.mm("<yellow>Ergebnis: " + (explain.allowed() ? "ALLOW" : "DENY")));
                if (explain.winningRole() != null) {
                    player.sendMessage(Text.mm("<gray>Role: " + explain.winningRole() + " Node: " + explain.winningNode()));
                }
            }
            default -> player.sendMessage(Text.mm("<gray>/rpgadmin perms user <setprimary|add|remove|info> ..."));
        }
    }

    private void giveWand(Player player) {
        ItemStack wand = new ItemBuilder(Material.STICK)
            .name(Text.mm("<yellow>Editor Wand"))
            .loreLine(Text.mm("<gray>Links: Pos1, Rechts: Pos2"))
            .build();
        var meta = wand.getItemMeta();
        meta.getPersistentDataContainer().set(plugin.wandKey(), PersistentDataType.BYTE, (byte) 1);
        wand.setItemMeta(meta);
        player.getInventory().addItem(wand);
        player.sendMessage(Text.mm("<green>Editor Wand erhalten."));
    }

    private void handleZone(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpgadmin zone <create|setlevel|setmod>"));
            return;
        }
        switch (args[1].toLowerCase()) {
            case "create" -> createZone(player, args);
            case "setlevel" -> setZoneLevel(player, args);
            case "setmod" -> setZoneModifiers(player, args);
            default -> player.sendMessage(Text.mm("<gray>/rpgadmin zone <create|setlevel|setmod>"));
        }
    }

    private void createZone(Player player, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/rpgadmin zone create <id>"));
            return;
        }
        Location pos1 = readPosition(player, "pos1");
        Location pos2 = readPosition(player, "pos2");
        if (pos1 == null || pos2 == null) {
            player.sendMessage(Text.mm("<red>Setze Pos1/Pos2 mit der Wand."));
            return;
        }
        String id = args[2];
        Zone zone = new Zone(id);
        zone.setName(id);
        zone.setWorld(pos1.getWorld().getName());
        zone.setBounds(pos1, pos2);
        plugin.zoneManager().zones().put(id, zone);
        plugin.zoneManager().saveZone(zone);
        plugin.auditLog().log(player, "Zone erstellt: " + id);
        player.sendMessage(Text.mm("<green>Zone erstellt: " + id));
    }

    private void setZoneLevel(Player player, String[] args) {
        if (args.length < 5) {
            player.sendMessage(Text.mm("<gray>/rpgadmin zone setlevel <id> <min> <max>"));
            return;
        }
        Zone zone = plugin.zoneManager().getZone(args[2]);
        if (zone == null) {
            player.sendMessage(Text.mm("<red>Zone nicht gefunden."));
            return;
        }
        Integer min = parseInt(args[3]);
        Integer max = parseInt(args[4]);
        if (min == null || max == null || min < 1 || max < min) {
            player.sendMessage(Text.mm("<red>Ungltiger Levelbereich. Beispiel: <white>/rpgadmin zone setlevel <id> 1 30</white>"));
            return;
        }
        zone.setMinLevel(min);
        zone.setMaxLevel(max);
        plugin.zoneManager().saveZone(zone);
        plugin.auditLog().log(player, "Zone Level gesetzt: " + zone.id());
        player.sendMessage(Text.mm("<green>Zone Level aktualisiert."));
    }

    private void setZoneModifiers(Player player, String[] args) {
        if (args.length < 5) {
            player.sendMessage(Text.mm("<gray>/rpgadmin zone setmod <id> <slow> <damage>"));
            return;
        }
        Zone zone = plugin.zoneManager().getZone(args[2]);
        if (zone == null) {
            player.sendMessage(Text.mm("<red>Zone nicht gefunden."));
            return;
        }
        Double slow = parseDouble(args[3]);
        Double dmg = parseDouble(args[4]);
        if (slow == null || dmg == null || slow <= 0.0 || dmg <= 0.0) {
            player.sendMessage(Text.mm("<red>Ungltige Werte. Beispiel: <white>/rpgadmin zone setmod <id> 0.8 1.2</white>"));
            return;
        }
        zone.setSlowMultiplier(slow);
        zone.setDamageMultiplier(dmg);
        plugin.zoneManager().saveZone(zone);
        plugin.auditLog().log(player, "Zone Modifikatoren gesetzt: " + zone.id());
        player.sendMessage(Text.mm("<green>Zone Modifikatoren aktualisiert."));
    }

    private void handleNpc(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpgadmin npc <create|dialog|linkquest|linkshop|faction|rank>"));
            return;
        }
        switch (args[1].toLowerCase()) {
            case "create" -> createNpc(player, args);
            case "dialog" -> setNpcDialog(player, args);
            case "linkquest" -> linkNpcQuest(player, args);
            case "linkshop" -> linkNpcShop(player, args);
            case "faction" -> setNpcFaction(player, args);
            case "rank" -> setNpcRank(player, args);
            default -> player.sendMessage(Text.mm("<gray>/rpgadmin npc <create|dialog|linkquest|linkshop|faction|rank>"));
        }
    }

    private void handleBuild(Player player, String[] args) {
        if (args.length < 2) {
            plugin.guiManager().openBuildingCategories(player);
            return;
        }
        if ("gui".equalsIgnoreCase(args[1])) {
            plugin.guiManager().openBuildingCategories(player);
            return;
        }
        if ("undo".equalsIgnoreCase(args[1])) {
            plugin.buildingManager().undoLast(player);
            return;
        }
        if ("move".equalsIgnoreCase(args[1])) {
            plugin.guiManager().openSchematicMoveGui(player);
            return;
        }
        plugin.buildingManager().beginPlacement(player, args[1], com.example.rpg.schematic.Transform.Rotation.NONE);
    }

    private void createNpc(Player player, String[] args) {
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/rpgadmin npc create <id> <role> [shopId]"));
            return;
        }
        String id = args[2];
        Optional<NpcRole> roleOpt = parseEnum(NpcRole.class, args[3]);
        if (roleOpt.isEmpty()) {
            player.sendMessage(Text.mm("<red>Unbekannte Rolle. Erlaubt: <white>" + java.util.Arrays.toString(NpcRole.values())));
            return;
        }
        NpcRole role = roleOpt.get();
        Npc npc = new Npc(id);
        npc.setName(id);
        npc.setRole(role);
        npc.setLocation(player.getLocation());
        npc.setDialog(List.of("Hallo!", "Ich habe eine Aufgabe fr dich."));
        if (role == NpcRole.VENDOR && args.length >= 5) {
            npc.setShopId(args[4]);
        }
        plugin.npcManager().npcs().put(id, npc);
        plugin.npcManager().spawnNpc(npc);
        plugin.npcManager().saveNpc(npc);
        plugin.auditLog().log(player, "NPC erstellt: " + id);
        player.sendMessage(Text.mm("<green>NPC erstellt: " + id));
    }

    private void setNpcDialog(Player player, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/rpgadmin npc dialog <id>"));
            return;
        }
        String id = args[2];
        Npc npc = plugin.npcManager().getNpc(id);
        if (npc == null) {
            player.sendMessage(Text.mm("<red>NPC nicht gefunden."));
            return;
        }
        plugin.promptManager().prompt(player, Text.mm("<yellow>Dialogzeile eingeben:"), input -> {
            npc.setDialog(List.of(input));
            plugin.npcManager().saveNpc(npc);
            plugin.auditLog().log(player, "NPC Dialog gesetzt: " + id);
            player.sendMessage(Text.mm("<green>Dialog gespeichert."));
        });
    }

    private void linkNpcQuest(Player player, String[] args) {
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/rpgadmin npc linkquest <npcId> <questId>"));
            return;
        }
        String npcId = args[2];
        String questId = args[3];
        Npc npc = plugin.npcManager().getNpc(npcId);
        if (npc == null) {
            player.sendMessage(Text.mm("<red>NPC nicht gefunden."));
            return;
        }
        Quest quest = plugin.questManager().getQuest(questId);
        if (quest == null) {
            player.sendMessage(Text.mm("<red>Quest nicht gefunden."));
            return;
        }
        npc.setQuestLink(questId);
        plugin.npcManager().saveNpc(npc);
        plugin.auditLog().log(player, "NPC Quest verlinkt: " + npcId + " -> " + questId);
        player.sendMessage(Text.mm("<green>NPC verlinkt mit Quest: " + quest.name()));
    }

    private void linkNpcShop(Player player, String[] args) {
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/rpgadmin npc linkshop <npcId> <shopId>"));
            return;
        }
        String npcId = args[2];
        String shopId = args[3];
        Npc npc = plugin.npcManager().getNpc(npcId);
        if (npc == null) {
            player.sendMessage(Text.mm("<red>NPC nicht gefunden."));
            return;
        }
        if (plugin.shopManager().getShop(shopId) == null) {
            player.sendMessage(Text.mm("<red>Shop nicht gefunden."));
            return;
        }
        npc.setShopId(shopId);
        plugin.npcManager().saveNpc(npc);
        plugin.auditLog().log(player, "NPC Shop verlinkt: " + npcId + " -> " + shopId);
        player.sendMessage(Text.mm("<green>NPC verlinkt mit Shop: " + shopId));
    }

    private void setNpcFaction(Player player, String[] args) {
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/rpgadmin npc faction <npcId> <factionId>"));
            return;
        }
        Npc npc = plugin.npcManager().getNpc(args[2]);
        if (npc == null) {
            player.sendMessage(Text.mm("<red>NPC nicht gefunden."));
            return;
        }
        if (plugin.factionManager().getFaction(args[3]) == null) {
            player.sendMessage(Text.mm("<red>Fraktion nicht gefunden."));
            return;
        }
        npc.setFactionId(args[3]);
        plugin.npcManager().saveNpc(npc);
        plugin.auditLog().log(player, "NPC Fraktion gesetzt: " + npc.id());
        player.sendMessage(Text.mm("<green>NPC Fraktion gesetzt."));
    }

    private void setNpcRank(Player player, String[] args) {
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/rpgadmin npc rank <npcId> <rankId>"));
            return;
        }
        Npc npc = plugin.npcManager().getNpc(args[2]);
        if (npc == null) {
            player.sendMessage(Text.mm("<red>NPC nicht gefunden."));
            return;
        }
        npc.setRequiredRankId(args[3]);
        plugin.npcManager().saveNpc(npc);
        plugin.auditLog().log(player, "NPC Rang gesetzt: " + npc.id());
        player.sendMessage(Text.mm("<green>NPC Rang gesetzt."));
    }

    private void handleEvent(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpgadmin event <create|addstep|start|stop|reward|unlock>"));
            return;
        }
        switch (args[1].toLowerCase()) {
            case "create" -> createEvent(player, args);
            case "addstep" -> addEventStep(player, args);
            case "start" -> startEvent(player, args);
            case "stop" -> stopEvent(player, args);
            case "reward" -> setEventReward(player, args);
            case "unlock" -> addEventUnlock(player, args);
            default -> player.sendMessage(Text.mm("<gray>/rpgadmin event <create|addstep|start|stop|reward|unlock>"));
        }
    }

    private void createEvent(Player player, String[] args) {
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/rpgadmin event create <id> <zoneId> <name>"));
            return;
        }
        String id = args[2];
        String zoneId = args[3];
        if (plugin.zoneManager().getZone(zoneId) == null) {
            player.sendMessage(Text.mm("<red>Zone nicht gefunden."));
            return;
        }
        String name = args.length > 4 ? String.join(" ", java.util.Arrays.copyOfRange(args, 4, args.length)) : id;
        com.example.rpg.model.WorldEvent event = new com.example.rpg.model.WorldEvent(id);
        event.setName(name);
        event.setZoneId(zoneId);
        event.setActive(false);
        plugin.worldEventManager().events().put(id, event);
        plugin.worldEventManager().saveEvent(event);
        player.sendMessage(Text.mm("<green>Event erstellt: " + name));
    }

    private void addEventStep(Player player, String[] args) {
        if (args.length < 6) {
            player.sendMessage(Text.mm("<gray>/rpgadmin event addstep <id> <type> <target> <amount>"));
            return;
        }
        com.example.rpg.model.WorldEvent event = plugin.worldEventManager().getEvent(args[2]);
        if (event == null) {
            player.sendMessage(Text.mm("<red>Event nicht gefunden."));
            return;
        }
        Optional<QuestStepType> typeOpt = parseEnum(QuestStepType.class, args[3]);
        if (typeOpt.isEmpty()) {
            player.sendMessage(Text.mm("<red>Unbekannter Step-Typ."));
            return;
        }
        Integer amount = parseInt(args[5]);
        if (amount == null || amount < 1) {
            player.sendMessage(Text.mm("<red>Amount ungltig."));
            return;
        }
        event.steps().add(new QuestStep(typeOpt.get(), args[4], amount));
        plugin.worldEventManager().saveEvent(event);
        player.sendMessage(Text.mm("<green>Event-Step hinzugefgt."));
    }

    private void startEvent(Player player, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/rpgadmin event start <id>"));
            return;
        }
        plugin.worldEventManager().startEvent(args[2]);
        player.sendMessage(Text.mm("<green>Event gestartet."));
    }

    private void stopEvent(Player player, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/rpgadmin event stop <id>"));
            return;
        }
        plugin.worldEventManager().stopEvent(args[2]);
        player.sendMessage(Text.mm("<yellow>Event gestoppt."));
    }

    private void setEventReward(Player player, String[] args) {
        if (args.length < 5) {
            player.sendMessage(Text.mm("<gray>/rpgadmin event reward <id> <xp> <gold>"));
            return;
        }
        com.example.rpg.model.WorldEvent event = plugin.worldEventManager().getEvent(args[2]);
        if (event == null) {
            player.sendMessage(Text.mm("<red>Event nicht gefunden."));
            return;
        }
        Integer xp = parseInt(args[3]);
        Integer gold = parseInt(args[4]);
        if (xp == null || gold == null) {
            player.sendMessage(Text.mm("<red>Ungltige Werte."));
            return;
        }
        event.setRewardXp(xp);
        event.setRewardGold(gold);
        plugin.worldEventManager().saveEvent(event);
        player.sendMessage(Text.mm("<green>Belohnung gesetzt."));
    }

    private void addEventUnlock(Player player, String[] args) {
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/rpgadmin event unlock <id> <questId>"));
            return;
        }
        com.example.rpg.model.WorldEvent event = plugin.worldEventManager().getEvent(args[2]);
        if (event == null) {
            player.sendMessage(Text.mm("<red>Event nicht gefunden."));
            return;
        }
        if (plugin.questManager().getQuest(args[3]) == null) {
            player.sendMessage(Text.mm("<red>Quest nicht gefunden."));
            return;
        }
        event.unlockQuests().add(args[3]);
        plugin.worldEventManager().saveEvent(event);
        player.sendMessage(Text.mm("<green>Quest freigeschaltet."));
    }

    private void handlePvp(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpgadmin pvp <seasonstart|seasonend>"));
            return;
        }
        switch (args[1].toLowerCase()) {
            case "seasonstart" -> startSeason(player, args);
            case "seasonend" -> endSeason(player);
            default -> player.sendMessage(Text.mm("<gray>/rpgadmin pvp <seasonstart|seasonend>"));
        }
    }

    private void handleNode(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpgadmin node <create>"));
            return;
        }
        if (!"create".equalsIgnoreCase(args[1])) {
            player.sendMessage(Text.mm("<gray>/rpgadmin node create <profession> <material> <respawnSeconds> <xp>"));
            return;
        }
        if (args.length < 6) {
            player.sendMessage(Text.mm("<gray>/rpgadmin node create <profession> <material> <respawnSeconds> <xp>"));
            return;
        }
        String profession = args[2].toLowerCase();
        String materialName = args[3].toUpperCase();
        Integer respawn = parseInt(args[4]);
        Integer xp = parseInt(args[5]);
        if (respawn == null || xp == null) {
            player.sendMessage(Text.mm("<red>Ungltige Werte."));
            return;
        }
        Material material = Material.matchMaterial(materialName);
        if (material == null) {
            player.sendMessage(Text.mm("<red>Material nicht gefunden."));
            return;
        }
        plugin.resourceNodeManager().createNode(player, profession, material, respawn, xp);
        player.sendMessage(Text.mm("<green>Ressourcen-Node erstellt."));
    }

    private void startSeason(Player player, String[] args) {
        if (args.length < 5) {
            player.sendMessage(Text.mm("<gray>/rpgadmin pvp seasonstart <id> <name> <days>"));
            return;
        }
        String id = args[2];
        String name = args[3];
        Integer days = parseInt(args[4]);
        if (days == null || days < 1) {
            player.sendMessage(Text.mm("<red>Tage ungltig."));
            return;
        }
        long endTimestamp = System.currentTimeMillis() + (days * 24L * 60L * 60L * 1000L);
        plugin.pvpSeasonManager().startSeason(id, name, endTimestamp);
        player.sendMessage(Text.mm("<green>Season gestartet."));
    }

    private void endSeason(Player player) {
        plugin.pvpSeasonManager().endSeason();
        player.sendMessage(Text.mm("<yellow>Season beendet."));
    }

    private void handleQuest(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpgadmin quest <create|addstep|reload>"));
            return;
        }
        switch (args[1].toLowerCase()) {
            case "create" -> createQuest(player, args);
            case "addstep" -> addQuestStep(player, args);
            case "reload" -> reloadQuests(player);
            default -> player.sendMessage(Text.mm("<gray>/rpgadmin quest <create|addstep|reload>"));
        }
    }

    private void reloadQuests(Player player) {
        plugin.questManager().reload();
        player.sendMessage(Text.mm("<green>Quests neu geladen.</green>"));
    }

    private void createQuest(Player player, String[] args) {
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/rpgadmin quest create <id> <name>"));
            return;
        }
        String id = args[2];
        String name = args[3];
        Quest quest = new Quest(id);
        quest.setName(name);
        quest.setDescription("Neue Quest");
        quest.setRepeatable(false);
        quest.setMinLevel(1);
        quest.setSteps(new java.util.ArrayList<>());
        plugin.questManager().quests().put(id, quest);
        plugin.questManager().saveQuest(quest);
        plugin.auditLog().log(player, "Quest erstellt: " + id);
        player.sendMessage(Text.mm("<green>Quest erstellt: " + id));
    }

    private void addQuestStep(Player player, String[] args) {
        if (args.length < 6) {
            player.sendMessage(Text.mm("<gray>/rpgadmin quest addstep <id> <type> <target> <amount>"));
            return;
        }
        Quest quest = plugin.questManager().getQuest(args[2]);
        if (quest == null) {
            player.sendMessage(Text.mm("<red>Quest nicht gefunden."));
            return;
        }
        Optional<QuestStepType> typeOpt = parseEnum(QuestStepType.class, args[3]);
        if (typeOpt.isEmpty()) {
            player.sendMessage(Text.mm("<red>Unbekannter Step-Typ. Erlaubt: <white>" + java.util.Arrays.toString(QuestStepType.values())));
            return;
        }
        QuestStepType type = typeOpt.get();
        String target = args[4];
        Integer amount = parseInt(args[5]);
        if (amount == null || amount < 1) {
            player.sendMessage(Text.mm("<red>Amount muss >= 1 sein.</red>"));
            return;
        }
        quest.steps().add(new QuestStep(type, target, amount));
        plugin.questManager().saveQuest(quest);
        plugin.auditLog().log(player, "Quest Step hinzugefgt: " + quest.id());
        player.sendMessage(Text.mm("<green>Quest Step hinzugefgt."));
    }

    private void handleLoot(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpgadmin loot <create|addentry>"));
            return;
        }
        switch (args[1].toLowerCase()) {
            case "create" -> createLoot(player, args);
            case "addentry" -> addLootEntry(player, args);
            default -> player.sendMessage(Text.mm("<gray>/rpgadmin loot <create|addentry>"));
        }
    }

    private void createLoot(Player player, String[] args) {
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/rpgadmin loot create <id> <appliesTo>"));
            return;
        }
        String id = args[2];
        String appliesTo = args[3];
        LootTable table = new LootTable(id);
        table.setAppliesTo(appliesTo);
        plugin.lootManager().tables().put(id, table);
        plugin.lootManager().saveTable(table);
        plugin.auditLog().log(player, "Loot Table erstellt: " + id);
        player.sendMessage(Text.mm("<green>Loot Table erstellt."));
    }

    private void addLootEntry(Player player, String[] args) {
        if (args.length < 8) {
            player.sendMessage(Text.mm("<gray>/rpgadmin loot addentry <id> <material> <chance> <min> <max> <rarity>"));
            return;
        }
        LootTable table = plugin.lootManager().getTable(args[2]);
        if (table == null) {
            player.sendMessage(Text.mm("<red>Loot Table nicht gefunden."));
            return;
        }
        String material = args[3];
        Material mat = Material.matchMaterial(material.toUpperCase(Locale.ROOT));
        if (mat == null) {
            player.sendMessage(Text.mm("<red>Unbekanntes Material: <white>" + material + "</white>"));
            return;
        }
        Double chance = parseDouble(args[4]);
        Integer min = parseInt(args[5]);
        Integer max = parseInt(args[6]);
        Optional<Rarity> rarityOpt = parseEnum(Rarity.class, args[7]);
        if (chance == null || min == null || max == null || rarityOpt.isEmpty()) {
            player.sendMessage(Text.mm("<red>Ungltige Parameter. Beispiel: <white>/rpgadmin loot addentry <id> IRON_NUGGET 0.5 1 3 COMMON</white>"));
            return;
        }
        if (chance < 0.0 || chance > 1.0 || min < 1 || max < min) {
            player.sendMessage(Text.mm("<red>Chance 0..1 und min/max gltig setzen.</red>"));
            return;
        }
        Rarity rarity = rarityOpt.get();
        table.entries().add(new LootEntry(mat.name(), chance, min, max, rarity));
        plugin.lootManager().saveTable(table);
        plugin.auditLog().log(player, "Loot Entry hinzugefgt: " + table.id());
        player.sendMessage(Text.mm("<green>Loot Entry hinzugefgt."));
    }

    private void handleSkill(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpgadmin skill <create|set|addeffect>"));
            return;
        }
        switch (args[1].toLowerCase()) {
            case "create" -> createSkill(player, args);
            case "set" -> setSkillValue(player, args);
            case "addeffect" -> addSkillEffect(player, args);
            default -> player.sendMessage(Text.mm("<gray>/rpgadmin skill <create|set|addeffect>"));
        }
    }

    private void handleMob(Player player, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/rpgadmin mob spawn <mobId>"));
            return;
        }
        if (!args[1].equalsIgnoreCase("spawn")) {
            player.sendMessage(Text.mm("<gray>/rpgadmin mob spawn <mobId>"));
            return;
        }
        String mobId = args[2];
        var mobDef = plugin.mobManager().getMob(mobId);
        if (mobDef == null) {
            player.sendMessage(Text.mm("<red>Mob nicht gefunden."));
            return;
        }
        var world = player.getWorld();
        org.bukkit.entity.EntityType type;
        try {
            type = org.bukkit.entity.EntityType.valueOf(mobDef.type().toUpperCase(Locale.ROOT));
        } catch (IllegalArgumentException e) {
            player.sendMessage(Text.mm("<red>Ungltiger Mob-Typ.</red>"));
            return;
        }
        var entity = world.spawnEntity(player.getLocation(), type);
        if (entity instanceof org.bukkit.entity.LivingEntity living) {
            plugin.customMobListener().applyDefinition(living, mobDef);
            plugin.mobManager().saveMob(mobDef);
            plugin.auditLog().log(player, "Mob gespawnt: " + mobId);
            player.sendMessage(Text.mm("<green>Mob gespawnt: " + mobId));
        } else {
            entity.remove();
            player.sendMessage(Text.mm("<red>Mob-Typ ist kein LivingEntity."));
        }
    }

    private void handleSpawner(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpgadmin spawner <create|addmob|setlimit>"));
            return;
        }
        switch (args[1].toLowerCase()) {
            case "create" -> createSpawner(player, args);
            case "addmob" -> addSpawnerMob(player, args);
            case "setlimit" -> setSpawnerLimit(player, args);
            default -> player.sendMessage(Text.mm("<gray>/rpgadmin spawner <create|addmob|setlimit>"));
        }
    }

    private void createSpawner(Player player, String[] args) {
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/rpgadmin spawner create <id> <zoneId>"));
            return;
        }
        String id = args[2];
        String zoneId = args[3];
        if (plugin.zoneManager().getZone(zoneId) == null) {
            player.sendMessage(Text.mm("<red>Zone nicht gefunden."));
            return;
        }
        var spawner = new com.example.rpg.model.Spawner(id);
        spawner.setZoneId(zoneId);
        spawner.setMaxMobs(6);
        spawner.setSpawnInterval(200);
        plugin.spawnerManager().spawners().put(id, spawner);
        plugin.spawnerManager().saveSpawner(spawner);
        plugin.auditLog().log(player, "Spawner erstellt: " + id);
        player.sendMessage(Text.mm("<green>Spawner erstellt: " + id));
    }

    private void addSpawnerMob(Player player, String[] args) {
        if (args.length < 5) {
            player.sendMessage(Text.mm("<gray>/rpgadmin spawner addmob <id> <mobId> <chance>"));
            return;
        }
        var spawner = plugin.spawnerManager().getSpawner(args[2]);
        if (spawner == null) {
            player.sendMessage(Text.mm("<red>Spawner nicht gefunden."));
            return;
        }
        String mobId = args[3];
        if (plugin.mobManager().getMob(mobId) == null) {
            player.sendMessage(Text.mm("<red>Mob nicht gefunden."));
            return;
        }
        Double chance = parseDouble(args[4]);
        if (chance == null || chance <= 0) {
            player.sendMessage(Text.mm("<red>Chance ungltig.</red>"));
            return;
        }
        spawner.mobs().put(mobId, chance);
        plugin.spawnerManager().saveSpawner(spawner);
        plugin.auditLog().log(player, "Spawner Mob hinzugefgt: " + spawner.id());
        player.sendMessage(Text.mm("<green>Spawner Mob hinzugefgt."));
    }

    private void setSpawnerLimit(Player player, String[] args) {
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/rpgadmin spawner setlimit <id> <amount>"));
            return;
        }
        var spawner = plugin.spawnerManager().getSpawner(args[2]);
        if (spawner == null) {
            player.sendMessage(Text.mm("<red>Spawner nicht gefunden."));
            return;
        }
        Integer limit = parseInt(args[3]);
        if (limit == null || limit < 0) {
            player.sendMessage(Text.mm("<red>Limit ungltig.</red>"));
            return;
        }
        spawner.setMaxMobs(limit);
        plugin.spawnerManager().saveSpawner(spawner);
        plugin.auditLog().log(player, "Spawner Limit gesetzt: " + spawner.id());
        player.sendMessage(Text.mm("<green>Spawner Limit aktualisiert."));
    }

    private void createSkill(Player player, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/rpgadmin skill create <id>"));
            return;
        }
        String id = args[2].toLowerCase(Locale.ROOT);
        Skill skill = new Skill(id);
        skill.setName(id);
        skill.setType(SkillType.ACTIVE);
        skill.setCategory(SkillCategory.ATTACK);
        skill.setCooldown(10);
        skill.setManaCost(10);
        skill.setEffects(new java.util.ArrayList<>());
        plugin.skillManager().skills().put(id, skill);
        plugin.skillManager().saveSkill(skill);
        plugin.auditLog().log(player, "Skill erstellt: " + id);
        player.sendMessage(Text.mm("<green>Skill erstellt: " + id));
    }

    private void setSkillValue(Player player, String[] args) {
        if (args.length < 5) {
            player.sendMessage(Text.mm("<gray>/rpgadmin skill set <id> <cooldown|mana|category|type|name|requires> <value>"));
            return;
        }
        Skill skill = plugin.skillManager().getSkill(args[2]);
        if (skill == null) {
            player.sendMessage(Text.mm("<red>Skill nicht gefunden."));
            return;
        }
        String field = args[3].toLowerCase(Locale.ROOT);
        String value = args[4];
        switch (field) {
            case "cooldown" -> {
                Integer cd = parseInt(value);
                if (cd == null || cd < 0) {
                    player.sendMessage(Text.mm("<red>Cooldown ungltig.</red>"));
                    return;
                }
                skill.setCooldown(cd);
            }
            case "mana" -> {
                Integer mana = parseInt(value);
                if (mana == null || mana < 0) {
                    player.sendMessage(Text.mm("<red>Mana ungltig.</red>"));
                    return;
                }
                skill.setManaCost(mana);
            }
            case "category" -> {
                Optional<SkillCategory> category = parseEnum(SkillCategory.class, value);
                if (category.isEmpty()) {
                    player.sendMessage(Text.mm("<red>Unbekannte Kategorie.</red>"));
                    return;
                }
                skill.setCategory(category.get());
            }
            case "type" -> {
                Optional<SkillType> type = parseEnum(SkillType.class, value);
                if (type.isEmpty()) {
                    player.sendMessage(Text.mm("<red>Unbekannter Typ.</red>"));
                    return;
                }
                skill.setType(type.get());
            }
            case "name" -> skill.setName(value);
            case "requires" -> skill.setRequiredSkill(value.equalsIgnoreCase("none") ? null : value);
            default -> {
                player.sendMessage(Text.mm("<red>Unbekanntes Feld.</red>"));
                return;
            }
        }
        plugin.skillManager().saveSkill(skill);
        plugin.auditLog().log(player, "Skill gesetzt: " + skill.id() + " " + field + "=" + value);
        player.sendMessage(Text.mm("<green>Skill aktualisiert."));
    }

    private void addSkillEffect(Player player, String[] args) {
        if (args.length < 4) {
            player.sendMessage(Text.mm("<gray>/rpgadmin skill addeffect <id> <effectType> <param:value>..."));
            return;
        }
        Skill skill = plugin.skillManager().getSkill(args[2]);
        if (skill == null) {
            player.sendMessage(Text.mm("<red>Skill nicht gefunden."));
            return;
        }
        Optional<SkillEffectType> typeOpt = parseEnum(SkillEffectType.class, args[3]);
        if (typeOpt.isEmpty()) {
            player.sendMessage(Text.mm("<red>Unbekannter Effekt-Typ. Erlaubt: <white>"
                + java.util.Arrays.toString(SkillEffectType.values())));
            return;
        }
        java.util.Map<String, Object> params = new java.util.HashMap<>();
        for (int i = 4; i < args.length; i++) {
            String token = args[i];
            if (!token.contains(":")) {
                continue;
            }
            String[] parts = token.split(":", 2);
            params.put(parts[0], parseParamValue(parts[1]));
        }
        skill.effects().add(new SkillEffectConfig(typeOpt.get(), params));
        plugin.skillManager().saveSkill(skill);
        plugin.auditLog().log(player, "Skill Effekt hinzugefgt: " + skill.id() + " " + typeOpt.get());
        player.sendMessage(Text.mm("<green>Effekt hinzugefgt."));
    }

    private Location readPosition(Player player, String key) {
        NamespacedKey namespacedKey = new NamespacedKey(plugin, key);
        String value = player.getPersistentDataContainer().get(namespacedKey, PersistentDataType.STRING);
        if (value == null) {
            return null;
        }
        String[] parts = value.split(",");
        if (parts.length < 4) {
            return null;
        }
        return new Location(player.getServer().getWorld(parts[0]),
            Double.parseDouble(parts[1]), Double.parseDouble(parts[2]), Double.parseDouble(parts[3]));
    }

    // -----------------------
    // Parsing-Helper (crash-sicher)
    // -----------------------
    private static Integer parseInt(String raw) {
        try {
            return Integer.parseInt(raw);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    private static Double parseDouble(String raw) {
        try {
            return Double.parseDouble(raw);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    private static <E extends Enum<E>> Optional<E> parseEnum(Class<E> type, String raw) {
        if (raw == null) {
            return Optional.empty();
        }
        String key = raw.trim().toUpperCase(Locale.ROOT);
        try {
            return Optional.of(Enum.valueOf(type, key));
        } catch (IllegalArgumentException e) {
            return Optional.empty();
        }
    }

    private static Object parseParamValue(String raw) {
        try {
            if (raw.contains(".")) {
                return Double.parseDouble(raw);
            }
            return Integer.parseInt(raw);
        } catch (NumberFormatException e) {
            return raw;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/command/RPGCommand.java`  
- Path: `src/main/java/com/example/rpg/command/RPGCommand.java`  
- Size: 21287 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.command;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.ClassDefinition;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.model.Skill;
import com.example.rpg.util.Text;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

public class RPGCommand implements CommandExecutor {
    private final RPGPlugin plugin;

    public RPGCommand(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player player)) {
            sender.sendMessage("Nur Spieler.");
            return true;
        }
        if (args.length == 0) {
            plugin.guiManager().openPlayerMenu(player);
            return true;
        }
        switch (args[0].toLowerCase()) {
            case "skill" -> handleSkill(player, args);
            case "quest" -> handleQuest(player, args);
            case "respec" -> handleRespec(player);
            case "class" -> handleClass(player, args);
            case "bind" -> handleBind(player, args);
            case "money" -> handleMoney(player);
            case "pay" -> handlePay(player, args);
            case "profession" -> handleProfession(player, args);
            case "skilltree" -> plugin.skillTreeGui().open(player);
            case "enchant" -> plugin.guiManager().openEnchanting(player, null);
            case "combatlog" -> handleCombatLog(player, args);
            case "event" -> handleEvent(player, args);
            case "order" -> handleOrder(player, args);
            case "home" -> handleHome(player, args);
            case "faction" -> handleFaction(player);
            default -> player.sendMessage(Text.mm("<gray>/rpg <skill|quest|respec|class|bind|money|pay|profession|skilltree|enchant|combatlog|event|order|home|faction>"));
        }
        return true;
    }

    private void handleSkill(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpg skill <id>"));
            return;
        }
        String skillId = args[1].toLowerCase();
        plugin.useSkill(player, skillId);
    }

    private void handleQuest(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpg quest <accept|abandon|list>"));
            return;
        }
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        switch (args[1].toLowerCase()) {
            case "list" -> plugin.guiManager().openQuestList(player);
            case "abandon" -> {
                if (args.length < 3) {
                    player.sendMessage(Text.mm("<gray>/rpg quest abandon <id>"));
                    return;
                }
                String questId = args[2];
                profile.activeQuests().remove(questId);
                player.sendMessage(Text.mm("<yellow>Quest abgebrochen: " + questId));
            }
            case "complete" -> {
                if (args.length < 3) {
                    player.sendMessage(Text.mm("<gray>/rpg quest complete <id>"));
                    return;
                }
                String questId = args[2];
                var quest = plugin.questManager().getQuest(questId);
                var progress = profile.activeQuests().get(questId);
                if (quest == null || progress == null) {
                    player.sendMessage(Text.mm("<red>Quest nicht aktiv."));
                    return;
                }
                if (!plugin.completeQuestIfReady(player, quest, progress)) {
                    player.sendMessage(Text.mm("<yellow>Quest noch nicht abgeschlossen."));
                }
            }
            default -> player.sendMessage(Text.mm("<gray>/rpg quest <list|abandon|complete>"));
        }
    }

    private void handleRespec(Player player) {
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        profile.learnedSkills().clear();
        profile.setSkillPoints(profile.level() * 2);
        profile.stats().replaceAll((stat, value) -> 5);
        profile.applyAttributes(player, plugin.itemStatManager(), plugin.classManager());
        player.sendMessage(Text.mm("<green>Respec durchgefhrt. Skillpunkte zurckgesetzt."));
    }

    private void handleClass(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpg class <list|choose>"));
            return;
        }
        if (args[1].equalsIgnoreCase("list")) {
            player.sendMessage(Text.mm("<yellow>Klassen: " + plugin.classManager().classes().keySet()));
            return;
        }
        if (args[1].equalsIgnoreCase("choose")) {
            if (args.length < 3) {
                player.sendMessage(Text.mm("<gray>/rpg class choose <id>"));
                return;
            }
            String id = args[2];
            ClassDefinition definition = plugin.classManager().getClass(id);
            if (definition == null) {
                player.sendMessage(Text.mm("<red>Unbekannte Klasse."));
                return;
            }
            PlayerProfile profile = plugin.playerDataManager().getProfile(player);
            profile.setClassId(id);
            for (String skill : definition.startSkills()) {
                profile.learnedSkills().put(skill, 1);
            }
            profile.applyAttributes(player, plugin.itemStatManager(), plugin.classManager());
            player.sendMessage(Text.mm("<green>Klasse gewhlt: " + definition.name()));
            return;
        }
        player.sendMessage(Text.mm("<gray>/rpg class <list|choose>"));
    }

    private void handleBind(Player player, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/rpg bind <slot 1-9> <skillId>"));
            return;
        }
        Integer slot;
        try {
            slot = Integer.parseInt(args[1]);
        } catch (NumberFormatException e) {
            player.sendMessage(Text.mm("<red>Slot muss 1-9 sein."));
            return;
        }
        if (slot < 1 || slot > 9) {
            player.sendMessage(Text.mm("<red>Slot muss 1-9 sein."));
            return;
        }
        String skillId = args[2].toLowerCase();
        Skill skill = plugin.skillManager().getSkill(skillId);
        if (skill == null) {
            player.sendMessage(Text.mm("<red>Unbekannter Skill."));
            return;
        }
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        if (!profile.learnedSkills().containsKey(skillId)) {
            player.sendMessage(Text.mm("<red>Skill nicht gelernt."));
            return;
        }
        plugin.skillHotbarManager().bindSkill(profile, slot, skillId);
        player.sendMessage(Text.mm("<green>Skill gebunden: Slot " + slot + " -> " + skill.name()));
    }

    private void handleMoney(Player player) {
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        player.sendMessage(Text.mm("<gold>Gold: <white>" + profile.gold()));
    }

    private void handlePay(Player player, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/rpg pay <player> <amount>"));
            return;
        }
        Player target = player.getServer().getPlayer(args[1]);
        if (target == null) {
            player.sendMessage(Text.mm("<red>Spieler nicht online."));
            return;
        }
        Integer amount;
        try {
            amount = Integer.parseInt(args[2]);
        } catch (NumberFormatException e) {
            player.sendMessage(Text.mm("<red>Betrag ungltig."));
            return;
        }
        if (amount <= 0) {
            player.sendMessage(Text.mm("<red>Betrag muss > 0 sein."));
            return;
        }
        PlayerProfile senderProfile = plugin.playerDataManager().getProfile(player);
        PlayerProfile targetProfile = plugin.playerDataManager().getProfile(target);
        if (senderProfile.gold() < amount) {
            player.sendMessage(Text.mm("<red>Nicht genug Gold."));
            return;
        }
        senderProfile.setGold(senderProfile.gold() - amount);
        targetProfile.setGold(targetProfile.gold() + amount);
        player.sendMessage(Text.mm("<green>Du hast <gold>" + amount + "</gold> Gold an " + target.getName() + " gesendet."));
        target.sendMessage(Text.mm("<green>Du hast <gold>" + amount + "</gold> Gold von " + player.getName() + " erhalten."));
    }

    private void handleProfession(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpg profession <list|set>"));
            return;
        }
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        switch (args[1].toLowerCase()) {
            case "list" -> {
                if (profile.professions().isEmpty()) {
                    player.sendMessage(Text.mm("<yellow>Keine Berufe freigeschaltet."));
                    return;
                }
                String summary = profile.professions().entrySet().stream()
                    .filter(entry -> entry.getKey().endsWith("_level"))
                    .map(entry -> entry.getKey().replace("_level", "") + ": " + entry.getValue())
                    .collect(java.util.stream.Collectors.joining(", "));
                player.sendMessage(Text.mm("<gold>Berufe: <white>" + summary));
            }
            case "set" -> {
                if (args.length < 4) {
                    player.sendMessage(Text.mm("<gray>/rpg profession set <name> <level>"));
                    return;
                }
                Integer level;
                try {
                    level = Integer.parseInt(args[3]);
                } catch (NumberFormatException e) {
                    player.sendMessage(Text.mm("<red>Level ungltig."));
                    return;
                }
                plugin.professionManager().setLevel(profile, args[2].toLowerCase(), level);
                player.sendMessage(Text.mm("<green>Beruf gesetzt."));
            }
            default -> player.sendMessage(Text.mm("<gray>/rpg profession <list|set>"));
        }
    }

    private void handleCombatLog(Player player, String[] args) {
        if (args.length < 2) {
            boolean enabled = plugin.toggleCombatLog(player.getUniqueId());
            player.sendMessage(Text.mm(enabled ? "<green>Kampflog aktiviert." : "<red>Kampflog deaktiviert."));
            return;
        }
        String value = args[1].toLowerCase();
        if ("on".equals(value) || "true".equals(value)) {
            plugin.setCombatLog(player.getUniqueId(), true);
            player.sendMessage(Text.mm("<green>Kampflog aktiviert."));
            return;
        }
        if ("off".equals(value) || "false".equals(value)) {
            plugin.setCombatLog(player.getUniqueId(), false);
            player.sendMessage(Text.mm("<red>Kampflog deaktiviert."));
            return;
        }
        player.sendMessage(Text.mm("<gray>/rpg combatlog <on|off>"));
    }

    private void handleEvent(Player player, String[] args) {
        if (args.length < 2 || "list".equalsIgnoreCase(args[1])) {
            player.sendMessage(Text.mm("<gold>Aktive Events:"));
            boolean any = false;
            for (var event : plugin.worldEventManager().events().values()) {
                if (!event.active()) {
                    continue;
                }
                any = true;
                String zone = event.zoneId() != null ? event.zoneId() : "global";
                player.sendMessage(Text.mm("<gray>- <white>" + event.name() + " <gray>(Zone: " + zone + ")"));
            }
            if (!any) {
                player.sendMessage(Text.mm("<yellow>Keine aktiven Events."));
            }
            return;
        }
        if ("status".equalsIgnoreCase(args[1]) && args.length >= 3) {
            var event = plugin.worldEventManager().getEvent(args[2]);
            if (event == null) {
                player.sendMessage(Text.mm("<red>Event nicht gefunden."));
                return;
            }
            player.sendMessage(Text.mm("<gold>Event: <white>" + event.name()));
            for (int i = 0; i < event.steps().size(); i++) {
                var step = event.steps().get(i);
                int current = event.progress().getOrDefault(i, 0);
                player.sendMessage(Text.mm("<gray>Step " + (i + 1) + ": " + step.type()
                    + " " + step.target() + " <white>" + current + "/" + step.amount()));
            }
            return;
        }
        player.sendMessage(Text.mm("<gray>/rpg event <list|status <id>>"));
    }

    private void handleOrder(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpg order <list|create|fulfill>"));
            return;
        }
        switch (args[1].toLowerCase()) {
            case "list" -> {
                if (plugin.craftingOrderManager().orders().isEmpty()) {
                    player.sendMessage(Text.mm("<yellow>Keine Auftrge."));
                    return;
                }
                player.sendMessage(Text.mm("<gold>Crafting-Auftrge:"));
                for (var order : plugin.craftingOrderManager().orders().values()) {
                    player.sendMessage(Text.mm("<gray>" + order.id() + ": <white>" + order.amount() + "x "
                        + order.material() + " <gold>(" + order.rewardGold() + " Gold)"));
                }
            }
            case "create" -> createOrder(player, args);
            case "fulfill" -> fulfillOrder(player, args);
            default -> player.sendMessage(Text.mm("<gray>/rpg order <list|create|fulfill>"));
        }
    }

    private void createOrder(Player player, String[] args) {
        if (args.length < 5) {
            player.sendMessage(Text.mm("<gray>/rpg order create <material> <amount> <reward>"));
            return;
        }
        String material = args[2].toUpperCase();
        if (org.bukkit.Material.matchMaterial(material) == null) {
            player.sendMessage(Text.mm("<red>Material ungltig."));
            return;
        }
        Integer amount = parseAmount(player, args[3]);
        Integer reward = parseAmount(player, args[4]);
        if (amount == null || reward == null) {
            return;
        }
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        if (profile.gold() < reward) {
            player.sendMessage(Text.mm("<red>Nicht genug Gold."));
            return;
        }
        String id = "order_" + (plugin.craftingOrderManager().orders().size() + 1);
        var order = new com.example.rpg.model.CraftingOrder(id);
        order.setRequester(player.getUniqueId());
        order.setMaterial(material);
        order.setAmount(amount);
        order.setRewardGold(reward);
        plugin.craftingOrderManager().orders().put(id, order);
        plugin.craftingOrderManager().saveOrder(order);
        profile.setGold(profile.gold() - reward);
        player.sendMessage(Text.mm("<green>Auftrag erstellt: " + id));
    }

    private void fulfillOrder(Player player, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/rpg order fulfill <id>"));
            return;
        }
        var order = plugin.craftingOrderManager().getOrder(args[2]);
        if (order == null) {
            player.sendMessage(Text.mm("<red>Auftrag nicht gefunden."));
            return;
        }
        org.bukkit.Material material = org.bukkit.Material.matchMaterial(order.material());
        if (material == null) {
            player.sendMessage(Text.mm("<red>Ungltiges Material."));
            return;
        }
        int total = countMaterial(player, material);
        if (total < order.amount()) {
            player.sendMessage(Text.mm("<red>Nicht genug Materialien."));
            return;
        }
        removeMaterial(player, material, order.amount());
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        profile.setGold(profile.gold() + order.rewardGold());
        plugin.craftingOrderManager().removeOrder(order.id());
        player.sendMessage(Text.mm("<green>Auftrag erfllt! +" + order.rewardGold() + " Gold."));
    }

    private void handleHome(Player player, String[] args) {
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/rpg home <set|go|upgrade>"));
            return;
        }
        switch (args[1].toLowerCase()) {
            case "set" -> {
                var loc = player.getLocation();
                profile.setHome(loc.getWorld().getName(), loc.getX(), loc.getY(), loc.getZ());
                player.sendMessage(Text.mm("<green>Home gesetzt."));
            }
            case "go" -> {
                if (profile.homeWorld() == null) {
                    player.sendMessage(Text.mm("<red>Kein Home gesetzt."));
                    return;
                }
                var world = player.getServer().getWorld(profile.homeWorld());
                if (world == null) {
                    player.sendMessage(Text.mm("<red>Home-Welt nicht verfgbar."));
                    return;
                }
                player.teleport(new org.bukkit.Location(world, profile.homeX(), profile.homeY(), profile.homeZ()));
                player.sendMessage(Text.mm("<green>Teleportiert."));
            }
            case "upgrade" -> upgradeHome(player, args);
            default -> player.sendMessage(Text.mm("<gray>/rpg home <set|go|upgrade>"));
        }
    }

    private void upgradeHome(Player player, String[] args) {
        if (args.length < 3) {
            player.sendMessage(Text.mm("<gray>/rpg home upgrade <craft|teleport|buff>"));
            return;
        }
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        String type = args[2].toLowerCase();
        int current = profile.housingUpgrades().getOrDefault(type, 0);
        int cost = switch (type) {
            case "craft" -> 200 + (current * 150);
            case "teleport" -> 300 + (current * 200);
            case "buff" -> 400 + (current * 250);
            default -> -1;
        };
        if (cost < 0) {
            player.sendMessage(Text.mm("<red>Unbekanntes Upgrade."));
            return;
        }
        if (profile.gold() < cost) {
            player.sendMessage(Text.mm("<red>Nicht genug Gold. Bentigt: " + cost));
            return;
        }
        profile.setGold(profile.gold() - cost);
        profile.housingUpgrades().put(type, current + 1);
        player.sendMessage(Text.mm("<green>Upgrade verbessert: " + type + " (Stufe " + (current + 1) + ")"));
    }

    private void handleFaction(Player player) {
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        if (profile.factionRep().isEmpty()) {
            player.sendMessage(Text.mm("<yellow>Keine Fraktionswerte."));
            return;
        }
        player.sendMessage(Text.mm("<gold>Fraktionsruf:"));
        for (var entry : profile.factionRep().entrySet()) {
            var faction = plugin.factionManager().getFaction(entry.getKey());
            String name = faction != null ? faction.name() : entry.getKey();
            player.sendMessage(Text.mm("<gray>" + name + ": <white>" + entry.getValue()));
        }
    }

    private Integer parseAmount(Player player, String input) {
        int amount;
        try {
            amount = Integer.parseInt(input);
        } catch (NumberFormatException e) {
            player.sendMessage(Text.mm("<red>Betrag ungltig."));
            return null;
        }
        if (amount <= 0) {
            player.sendMessage(Text.mm("<red>Betrag muss > 0 sein."));
            return null;
        }
        return amount;
    }

    private int countMaterial(Player player, org.bukkit.Material material) {
        int total = 0;
        for (var stack : player.getInventory().getContents()) {
            if (stack != null && stack.getType() == material) {
                total += stack.getAmount();
            }
        }
        return total;
    }

    private void removeMaterial(Player player, org.bukkit.Material material, int amount) {
        int remaining = amount;
        var contents = player.getInventory().getContents();
        for (int i = 0; i < contents.length; i++) {
            var stack = contents[i];
            if (stack == null || stack.getType() != material) {
                continue;
            }
            int take = Math.min(remaining, stack.getAmount());
            stack.setAmount(stack.getAmount() - take);
            if (stack.getAmount() <= 0) {
                contents[i] = null;
            }
            remaining -= take;
            if (remaining <= 0) {
                break;
            }
        }
        player.getInventory().setContents(contents);
    }
}

```

## File: `src/main/java/com/example/rpg/command/TradeCommand.java`  
- Path: `src/main/java/com/example/rpg/command/TradeCommand.java`  
- Size: 6032 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.command;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.TradeRequest;
import com.example.rpg.util.Text;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

public class TradeCommand implements CommandExecutor {
    private final RPGPlugin plugin;

    public TradeCommand(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player player)) {
            sender.sendMessage("Nur Spieler.");
            return true;
        }
        if (args.length < 1) {
            player.sendMessage(Text.mm("<gray>/trade <request|accept|offer|requestgold|ready|cancel>"));
            return true;
        }
        switch (args[0].toLowerCase()) {
            case "request" -> requestTrade(player, args);
            case "accept" -> acceptTrade(player);
            case "offer" -> offerGold(player, args);
            case "requestgold" -> requestGold(player, args);
            case "ready" -> readyTrade(player);
            case "cancel" -> cancelTrade(player);
            default -> player.sendMessage(Text.mm("<gray>/trade <request|accept|offer|requestgold|ready|cancel>"));
        }
        return true;
    }

    private void requestTrade(Player player, String[] args) {
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/trade request <player>"));
            return;
        }
        Player target = player.getServer().getPlayer(args[1]);
        if (target == null) {
            player.sendMessage(Text.mm("<red>Spieler nicht online."));
            return;
        }
        plugin.tradeManager().requestTrade(player.getUniqueId(), target.getUniqueId());
        player.sendMessage(Text.mm("<green>Handel angefragt."));
        target.sendMessage(Text.mm("<yellow>Handelsanfrage von " + player.getName() + ". /trade accept"));
    }

    private void acceptTrade(Player player) {
        TradeRequest request = plugin.tradeManager().getRequest(player.getUniqueId());
        if (request == null) {
            player.sendMessage(Text.mm("<red>Keine Anfrage."));
            return;
        }
        player.sendMessage(Text.mm("<green>Handel akzeptiert. Beide Seiten knnen Gold setzen."));
    }

    private void offerGold(Player player, String[] args) {
        TradeRequest request = plugin.tradeManager().getRequest(player.getUniqueId());
        if (request == null) {
            player.sendMessage(Text.mm("<red>Kein Handel aktiv."));
            return;
        }
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/trade offer <gold>"));
            return;
        }
        int amount;
        try {
            amount = Integer.parseInt(args[1]);
        } catch (NumberFormatException e) {
            player.sendMessage(Text.mm("<red>Betrag ungltig."));
            return;
        }
        request.setGoldOffer(amount);
        player.sendMessage(Text.mm("<green>Du bietest " + amount + " Gold."));
    }

    private void requestGold(Player player, String[] args) {
        TradeRequest request = plugin.tradeManager().getRequest(player.getUniqueId());
        if (request == null) {
            player.sendMessage(Text.mm("<red>Kein Handel aktiv."));
            return;
        }
        if (args.length < 2) {
            player.sendMessage(Text.mm("<gray>/trade requestgold <gold>"));
            return;
        }
        int amount;
        try {
            amount = Integer.parseInt(args[1]);
        } catch (NumberFormatException e) {
            player.sendMessage(Text.mm("<red>Betrag ungltig."));
            return;
        }
        request.setGoldRequest(amount);
        player.sendMessage(Text.mm("<green>Du verlangst " + amount + " Gold."));
    }

    private void readyTrade(Player player) {
        TradeRequest request = plugin.tradeManager().getRequest(player.getUniqueId());
        if (request == null) {
            player.sendMessage(Text.mm("<red>Kein Handel aktiv."));
            return;
        }
        if (request.requester().equals(player.getUniqueId())) {
            request.setRequesterReady(true);
        } else {
            request.setTargetReady(true);
        }
        if (request.requesterReady() && request.targetReady()) {
            completeTrade(request);
        } else {
            player.sendMessage(Text.mm("<green>Bereit gesetzt. Warte auf den Handelspartner."));
        }
    }

    private void completeTrade(TradeRequest request) {
        Player requester = plugin.getServer().getPlayer(request.requester());
        Player target = plugin.getServer().getPlayer(request.target());
        if (requester == null || target == null) {
            return;
        }
        var requesterProfile = plugin.playerDataManager().getProfile(requester);
        var targetProfile = plugin.playerDataManager().getProfile(target);
        if (requesterProfile.gold() < request.goldOffer() || targetProfile.gold() < request.goldRequest()) {
            requester.sendMessage(Text.mm("<red>Handel fehlgeschlagen: nicht genug Gold."));
            target.sendMessage(Text.mm("<red>Handel fehlgeschlagen: nicht genug Gold."));
            plugin.tradeManager().clear(request.requester());
            return;
        }
        requesterProfile.setGold(requesterProfile.gold() - request.goldOffer() + request.goldRequest());
        targetProfile.setGold(targetProfile.gold() - request.goldRequest() + request.goldOffer());
        requester.sendMessage(Text.mm("<green>Handel abgeschlossen."));
        target.sendMessage(Text.mm("<green>Handel abgeschlossen."));
        plugin.tradeManager().clear(request.requester());
    }

    private void cancelTrade(Player player) {
        plugin.tradeManager().clear(player.getUniqueId());
        player.sendMessage(Text.mm("<yellow>Handel abgebrochen."));
    }
}

```

## File: `src/main/java/com/example/rpg/command/VoiceChatCommand.java`  
- Path: `src/main/java/com/example/rpg/command/VoiceChatCommand.java`  
- Size: 1216 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.command;

import com.example.rpg.RPGPlugin;
import com.example.rpg.util.Text;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

public class VoiceChatCommand implements CommandExecutor {
    private final RPGPlugin plugin;

    public VoiceChatCommand(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player player)) {
            sender.sendMessage("Nur Spieler.");
            return true;
        }
        if (args.length < 1) {
            player.sendMessage(Text.mm("<gray>/voicechat <party|guild|leave>"));
            return true;
        }
        switch (args[0].toLowerCase()) {
            case "party" -> plugin.voiceChatManager().joinParty(player);
            case "guild" -> plugin.voiceChatManager().joinGuild(player);
            case "leave" -> plugin.voiceChatManager().leave(player);
            default -> player.sendMessage(Text.mm("<gray>/voicechat <party|guild|leave>"));
        }
        return true;
    }
}

```

## File: `src/main/java/com/example/rpg/db/DatabaseService.java`  
- Path: `src/main/java/com/example/rpg/db/DatabaseService.java`  
- Size: 7744 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.db;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.plugin.java.JavaPlugin;

public class DatabaseService {
    private final JavaPlugin plugin;
    private HikariDataSource dataSource;
    private final ExecutorService executor;
    private final String jdbcUrl;
    private final String databaseName;
    private final String username;
    private final String password;

    public DatabaseService(JavaPlugin plugin) {
        this.plugin = plugin;
        FileConfiguration config = plugin.getConfig();
        String host = config.getString("database.host", "localhost");
        int port = config.getInt("database.port", 5432);
        String database = config.getString("database.name", "rpg");
        this.databaseName = database;
        this.username = config.getString("database.user", "rpg");
        this.password = config.getString("database.password", "minecraft");
        int poolSize = config.getInt("database.poolSize", 10);

        this.jdbcUrl = "jdbc:postgresql://" + host + ":" + port + "/" + database;

        try {
            Class.forName("org.postgresql.Driver");
        } catch (ClassNotFoundException e) {
            plugin.getLogger().severe("PostgreSQL JDBC driver not found.");
        }

        HikariConfig hikariConfig = new HikariConfig();
        hikariConfig.setJdbcUrl(jdbcUrl);
        hikariConfig.setDriverClassName("org.postgresql.Driver");
        hikariConfig.setUsername(this.username);
        hikariConfig.setPassword(this.password);
        hikariConfig.setMaximumPoolSize(poolSize);
        hikariConfig.setPoolName("MineLauncherRPG");
        hikariConfig.setAutoCommit(true);
        this.dataSource = createDataSource(hikariConfig);
        this.executor = Executors.newFixedThreadPool(Math.max(2, poolSize));
    }

    public Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }

    public ExecutorService executor() {
        return executor;
    }

    public void initTables() {
        if (dataSource == null) {
            plugin.getLogger().severe("Database not available. Skipping table initialization.");
            return;
        }
        String playersTable = """
            CREATE TABLE IF NOT EXISTS rpg_players (
                uuid UUID PRIMARY KEY,
                level INT,
                xp INT,
                skill_points INT,
                mana INT,
                max_mana INT,
                class_id TEXT,
                gold INT,
                guild_id TEXT,
                elo INT,
                dungeon_role TEXT,
                home_world TEXT,
                home_x DOUBLE PRECISION,
                home_y DOUBLE PRECISION,
                home_z DOUBLE PRECISION,
                professions JSONB,
                stats JSONB,
                learned_skills JSONB,
                active_quests JSONB,
                completed_quests JSONB,
                faction_rep JSONB,
                skill_cooldowns JSONB,
                skill_bindings JSONB,
                housing_upgrades JSONB,
                cosmetics JSONB,
                title TEXT
            )
            """;
        String skillsTable = """
            CREATE TABLE IF NOT EXISTS rpg_skills (
                player_uuid UUID PRIMARY KEY,
                data JSONB
            )
            """;
        String playersAlter = """
            ALTER TABLE rpg_players
                ADD COLUMN IF NOT EXISTS dungeon_role TEXT,
                ADD COLUMN IF NOT EXISTS home_world TEXT,
                ADD COLUMN IF NOT EXISTS home_x DOUBLE PRECISION,
                ADD COLUMN IF NOT EXISTS home_y DOUBLE PRECISION,
                ADD COLUMN IF NOT EXISTS home_z DOUBLE PRECISION,
                ADD COLUMN IF NOT EXISTS housing_upgrades JSONB DEFAULT '{}'::jsonb,
                ADD COLUMN IF NOT EXISTS cosmetics JSONB DEFAULT '[]'::jsonb,
                ADD COLUMN IF NOT EXISTS title TEXT
            """;
        String questsTable = """
            CREATE TABLE IF NOT EXISTS rpg_quests (
                player_uuid UUID PRIMARY KEY,
                data JSONB
            )
            """;
        String rolesTable = """
            CREATE TABLE IF NOT EXISTS rpg_roles (
                role_key TEXT PRIMARY KEY,
                display_name TEXT NOT NULL,
                parents JSONB NOT NULL DEFAULT '[]',
                nodes JSONB NOT NULL DEFAULT '{}'
            )
            """;
        String playerRolesTable = """
            CREATE TABLE IF NOT EXISTS rpg_player_roles (
                player_uuid UUID PRIMARY KEY,
                primary_role TEXT,
                extra_roles JSONB NOT NULL DEFAULT '[]'
            )
            """;
        String auditTable = """
            CREATE TABLE IF NOT EXISTS rpg_audit_log (
                id BIGSERIAL PRIMARY KEY,
                ts TIMESTAMPTZ NOT NULL DEFAULT now(),
                actor_uuid UUID,
                actor_name TEXT,
                action TEXT NOT NULL,
                target TEXT NOT NULL,
                before JSONB,
                after JSONB
            )
            """;
        try (Connection connection = getConnection(); Statement statement = connection.createStatement()) {
            statement.execute(playersTable);
            statement.execute(skillsTable);
            statement.execute(questsTable);
            statement.execute(rolesTable);
            statement.execute(playerRolesTable);
            statement.execute(auditTable);
            statement.execute(playersAlter);
        } catch (SQLException e) {
            plugin.getLogger().severe("Failed to init database tables: " + e.getMessage());
        }
    }

    public void shutdown() {
        executor.shutdown();
        if (dataSource != null) {
            dataSource.close();
        }
    }

    private HikariDataSource createDataSource(HikariConfig hikariConfig) {
        try {
            return new HikariDataSource(hikariConfig);
        } catch (RuntimeException ex) {
            if (ex.getMessage() != null && ex.getMessage().contains("existiert nicht")) {
                plugin.getLogger().warning("Database not found. Attempting to create '" + databaseName + "'.");
                if (createDatabase()) {
                    return new HikariDataSource(hikariConfig);
                }
            }
            plugin.getLogger().severe("Failed to initialize database: " + ex.getMessage());
            return null;
        }
    }

    private boolean createDatabase() {
        String adminUrl = jdbcUrl.replace("/" + databaseName, "/postgres");
        try (Connection connection = java.sql.DriverManager.getConnection(adminUrl, username, password);
             java.sql.PreparedStatement exists = connection.prepareStatement(
                 "SELECT 1 FROM pg_database WHERE datname = ?")) {
            exists.setString(1, databaseName);
            try (java.sql.ResultSet resultSet = exists.executeQuery()) {
                if (resultSet.next()) {
                    return true;
                }
            }
            try (java.sql.Statement statement = connection.createStatement()) {
                statement.execute("CREATE DATABASE \"" + databaseName + "\"");
                return true;
            }
        } catch (SQLException e) {
            plugin.getLogger().severe("Failed to create database: " + e.getMessage());
            return false;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/db/PlayerDao.java`  
- Path: `src/main/java/com/example/rpg/db/PlayerDao.java`  
- Size: 298 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.db;

import com.example.rpg.model.PlayerProfile;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

public interface PlayerDao {
    CompletableFuture<Void> savePlayer(PlayerProfile profile);
    CompletableFuture<PlayerProfile> loadPlayer(UUID uuid);
}

```

## File: `src/main/java/com/example/rpg/db/SqlPlayerDao.java`  
- Path: `src/main/java/com/example/rpg/db/SqlPlayerDao.java`  
- Size: 12139 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.db;

import com.example.rpg.model.PlayerProfile;
import com.example.rpg.model.QuestProgress;
import com.example.rpg.model.RPGStat;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

public class SqlPlayerDao implements PlayerDao {
    private final DatabaseService databaseService;
    private final Gson gson = new Gson();
    private final Type mapStringInt = new TypeToken<Map<String, Integer>>() {}.getType();
    private final Type mapStringLong = new TypeToken<Map<String, Long>>() {}.getType();
    private final Type mapIntString = new TypeToken<Map<Integer, String>>() {}.getType();
    private final Type listString = new TypeToken<List<String>>() {}.getType();
    private final Type mapStringObject = new TypeToken<Map<String, Object>>() {}.getType();

    public SqlPlayerDao(DatabaseService databaseService) {
        this.databaseService = databaseService;
    }

    @Override
    public CompletableFuture<Void> savePlayer(PlayerProfile profile) {
        return CompletableFuture.supplyAsync(() -> {
            String sql = """
                INSERT INTO rpg_players (uuid, level, xp, skill_points, mana, max_mana, class_id, gold, guild_id, elo,
                    dungeon_role, home_world, home_x, home_y, home_z,
                    professions, stats, learned_skills, active_quests, completed_quests, faction_rep, skill_cooldowns, skill_bindings,
                    housing_upgrades, cosmetics, title)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?::jsonb, ?::jsonb, ?::jsonb, ?::jsonb, ?::jsonb, ?::jsonb, ?::jsonb, ?::jsonb, ?::jsonb, ?::jsonb, ?)
                ON CONFLICT (uuid) DO UPDATE SET
                    level = EXCLUDED.level,
                    xp = EXCLUDED.xp,
                    skill_points = EXCLUDED.skill_points,
                    mana = EXCLUDED.mana,
                    max_mana = EXCLUDED.max_mana,
                    class_id = EXCLUDED.class_id,
                    gold = EXCLUDED.gold,
                    guild_id = EXCLUDED.guild_id,
                    elo = EXCLUDED.elo,
                    dungeon_role = EXCLUDED.dungeon_role,
                    home_world = EXCLUDED.home_world,
                    home_x = EXCLUDED.home_x,
                    home_y = EXCLUDED.home_y,
                    home_z = EXCLUDED.home_z,
                    professions = EXCLUDED.professions,
                    stats = EXCLUDED.stats,
                    learned_skills = EXCLUDED.learned_skills,
                    active_quests = EXCLUDED.active_quests,
                    completed_quests = EXCLUDED.completed_quests,
                    faction_rep = EXCLUDED.faction_rep,
                    skill_cooldowns = EXCLUDED.skill_cooldowns,
                    skill_bindings = EXCLUDED.skill_bindings,
                    housing_upgrades = EXCLUDED.housing_upgrades,
                    cosmetics = EXCLUDED.cosmetics,
                    title = EXCLUDED.title
                """;
            try (Connection connection = databaseService.getConnection();
                 PreparedStatement statement = connection.prepareStatement(sql)) {
                statement.setObject(1, profile.uuid());
                statement.setInt(2, profile.level());
                statement.setInt(3, profile.xp());
                statement.setInt(4, profile.skillPoints());
                statement.setInt(5, profile.mana());
                statement.setInt(6, profile.maxMana());
                statement.setString(7, profile.classId());
                statement.setInt(8, profile.gold());
                statement.setString(9, profile.guildId());
                statement.setInt(10, profile.elo());
                statement.setString(11, profile.dungeonRole());
                statement.setString(12, profile.homeWorld());
                statement.setObject(13, profile.homeWorld() != null ? profile.homeX() : null);
                statement.setObject(14, profile.homeWorld() != null ? profile.homeY() : null);
                statement.setObject(15, profile.homeWorld() != null ? profile.homeZ() : null);
                statement.setString(16, gson.toJson(profile.professions()));
                statement.setString(17, gson.toJson(statsToMap(profile.stats())));
                statement.setString(18, gson.toJson(profile.learnedSkills()));
                statement.setString(19, gson.toJson(questsToMap(profile.activeQuests())));
                statement.setString(20, gson.toJson(profile.completedQuests().stream().toList()));
                statement.setString(21, gson.toJson(profile.factionRep()));
                statement.setString(22, gson.toJson(profile.skillCooldowns()));
                statement.setString(23, gson.toJson(profile.skillBindings()));
                statement.setString(24, gson.toJson(profile.housingUpgrades()));
                statement.setString(25, gson.toJson(profile.cosmetics().stream().toList()));
                statement.setString(26, profile.title());
                statement.executeUpdate();
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
            return null;
        }, databaseService.executor());
    }

    @Override
    public CompletableFuture<PlayerProfile> loadPlayer(UUID uuid) {
        return CompletableFuture.supplyAsync(() -> {
            String sql = "SELECT * FROM rpg_players WHERE uuid = ?";
            try (Connection connection = databaseService.getConnection();
                 PreparedStatement statement = connection.prepareStatement(sql)) {
                statement.setObject(1, uuid);
                try (ResultSet resultSet = statement.executeQuery()) {
                    if (!resultSet.next()) {
                        return null;
                    }
                    PlayerProfile profile = new PlayerProfile(uuid);
                    profile.setLevel(resultSet.getInt("level"));
                    profile.setXp(resultSet.getInt("xp"));
                    profile.setSkillPoints(resultSet.getInt("skill_points"));
                    profile.setMana(resultSet.getInt("mana"));
                    profile.setMaxMana(resultSet.getInt("max_mana"));
                    profile.setClassId(resultSet.getString("class_id"));
                    profile.setGold(resultSet.getInt("gold"));
                    profile.setGuildId(resultSet.getString("guild_id"));
                    profile.setElo(resultSet.getInt("elo"));
                    String role = resultSet.getString("dungeon_role");
                    profile.setDungeonRole(role != null ? role : "DPS");
                    String homeWorld = resultSet.getString("home_world");
                    if (homeWorld != null) {
                        profile.setHome(homeWorld,
                            resultSet.getDouble("home_x"),
                            resultSet.getDouble("home_y"),
                            resultSet.getDouble("home_z"));
                    }
                    applyMap(resultSet.getString("professions"), profile.professions(), mapStringInt);
                    Map<String, Integer> stats = fromJson(resultSet.getString("stats"), mapStringInt);
                    if (stats != null) {
                        for (Map.Entry<String, Integer> entry : stats.entrySet()) {
                            try {
                                profile.stats().put(RPGStat.valueOf(entry.getKey()), entry.getValue());
                            } catch (IllegalArgumentException ignored) {
                            }
                        }
                    }
                    applyMap(resultSet.getString("learned_skills"), profile.learnedSkills(), mapStringInt);
                    loadQuests(resultSet.getString("active_quests"), profile);
                    Set<String> completed = fromJson(resultSet.getString("completed_quests"),
                        new TypeToken<Set<String>>() {}.getType());
                    if (completed != null) {
                        profile.completedQuests().addAll(completed);
                    }
                    applyMap(resultSet.getString("faction_rep"), profile.factionRep(), mapStringInt);
                    applyMap(resultSet.getString("skill_cooldowns"), profile.skillCooldowns(), mapStringLong);
                    Map<Integer, String> bindings = fromJson(resultSet.getString("skill_bindings"), mapIntString);
                    if (bindings != null) {
                        profile.skillBindings().putAll(bindings);
                    }
                    applyMap(resultSet.getString("housing_upgrades"), profile.housingUpgrades(), mapStringInt);
                    List<String> cosmetics = fromJson(resultSet.getString("cosmetics"), listString);
                    if (cosmetics != null) {
                        profile.cosmetics().addAll(cosmetics);
                    }
                    profile.setTitle(resultSet.getString("title"));
                    return profile;
                }
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        }, databaseService.executor());
    }

    private Map<String, Integer> statsToMap(Map<RPGStat, Integer> stats) {
        Map<String, Integer> mapped = new HashMap<>();
        for (Map.Entry<RPGStat, Integer> entry : stats.entrySet()) {
            mapped.put(entry.getKey().name(), entry.getValue());
        }
        return mapped;
    }

    private Map<String, Object> questsToMap(Map<String, QuestProgress> quests) {
        Map<String, Object> data = new HashMap<>();
        for (QuestProgress progress : quests.values()) {
            Map<String, Object> quest = new HashMap<>();
            Map<String, Integer> steps = new HashMap<>();
            for (Map.Entry<Integer, Integer> entry : progress.stepProgress().entrySet()) {
                steps.put(String.valueOf(entry.getKey()), entry.getValue());
            }
            quest.put("steps", steps);
            quest.put("completed", progress.completed());
            data.put(progress.questId(), quest);
        }
        return data;
    }

    private void loadQuests(String json, PlayerProfile profile) {
        Map<String, Object> data = fromJson(json, mapStringObject);
        if (data == null) {
            return;
        }
        for (Map.Entry<String, Object> entry : data.entrySet()) {
            QuestProgress progress = new QuestProgress(entry.getKey());
            if (entry.getValue() instanceof Map<?, ?> map) {
                Object stepsObj = map.get("steps");
                if (stepsObj instanceof Map<?, ?> steps) {
                    for (Map.Entry<?, ?> stepEntry : steps.entrySet()) {
                        try {
                            int step = Integer.parseInt(String.valueOf(stepEntry.getKey()));
                            int value = Integer.parseInt(String.valueOf(stepEntry.getValue()));
                            progress.incrementStep(step, value);
                        } catch (NumberFormatException ignored) {
                        }
                    }
                }
                Object completed = map.get("completed");
                if (completed instanceof Boolean done) {
                    progress.setCompleted(done);
                }
            }
            profile.activeQuests().put(entry.getKey(), progress);
        }
    }

    private <T> void applyMap(String json, Map<String, T> target, Type type) {
        Map<String, T> data = fromJson(json, type);
        if (data != null) {
            target.putAll(data);
        }
    }

    private <T> T fromJson(String json, Type type) {
        if (json == null || json.isBlank()) {
            return null;
        }
        return gson.fromJson(json, type);
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/DungeonGenerator.java`  
- Path: `src/main/java/com/example/rpg/dungeon/DungeonGenerator.java`  
- Size: 14829 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.MobDefinition;
import com.example.rpg.model.Spawner;
import com.example.rpg.dungeon.wfc.Pattern;
import com.example.rpg.dungeon.wfc.WfcGenerator;
import com.example.rpg.dungeon.layout.DungeonBuilder;
import com.example.rpg.dungeon.layout.DungeonPlan;
import com.example.rpg.dungeon.layout.DungeonPlanner;
import com.example.rpg.dungeon.layout.DungeonSettings;
import com.example.rpg.util.Text;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.function.Consumer;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.WorldCreator;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.entity.TextDisplay;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.util.BoundingBox;

public class DungeonGenerator {
    private final RPGPlugin plugin;
    private final Random random = new Random();
    private final WfcGenerator wfcGenerator;

    public DungeonGenerator(RPGPlugin plugin) {
        this.plugin = plugin;
        this.wfcGenerator = new WfcGenerator(plugin);
    }

    public DungeonInstance generate(String theme, List<Player> party, java.util.Set<java.util.UUID> participants, double scale) {
        String worldName = "dungeon_" + System.currentTimeMillis();
        World world = plugin.getServer().createWorld(new WorldCreator(worldName));
        int baseY = plugin.getConfig().getInt("dungeon.fixedBaseY", 150);
        int wallHeight = plugin.getConfig().getInt("dungeon.wfc.boundaryHeight", 10);
        DungeonSettings settings = loadSettings();
        int grid = (int) Math.ceil(Math.sqrt(settings.roomCount()));
        int maxSize = Math.max(settings.roomMaxSizeX(), settings.roomMaxSizeZ()) + 4;
        int width = grid * maxSize;
        int depth = grid * maxSize;
        BoundingBox bounds = new BoundingBox(0, baseY, 0, width, baseY + 6, depth);
        createGlassBoundary(world, bounds, wallHeight);
        DungeonPlan plan = planDungeon(bounds, settings);
        if (plan != null) {
            new DungeonBuilder(plugin, random).build(world, plan, settings);
            Location start = plan.startRoom().center(world);
            Location bossRoom = plan.bossRoom().center(world);
            spawnSigns(start, bossRoom, theme);
            return new DungeonInstance(world, start, bossRoom, participants, scale);
        }
        return new DungeonInstance(world, new Location(world, 0, baseY + 2, 0), new Location(world, 0, baseY + 2, 0),
            participants, scale);
    }

    public void generateWfc(String theme, List<Player> party, java.util.Set<java.util.UUID> participants, double scale,
                            Consumer<DungeonInstance> callback) {
        String worldName = "dungeon_" + System.currentTimeMillis();
        World world = plugin.getServer().createWorld(new WorldCreator(worldName));
        int width = plugin.getConfig().getInt("dungeon.wfc.width", 10);
        int height = plugin.getConfig().getInt("dungeon.wfc.height", 3);
        int depth = plugin.getConfig().getInt("dungeon.wfc.depth", 10);
        int originY = plugin.getConfig().getInt("dungeon.wfc.originY", 150);
        int wallHeight = plugin.getConfig().getInt("dungeon.wfc.boundaryHeight", 10);
        wfcGenerator.generate(theme, width, height, depth).thenAccept(patterns -> {
            new BukkitRunnable() {
                @Override
                public void run() {
                    if (patterns == null) {
                        return;
                    }
                    Location start = new Location(world, 1, originY + 2, 1);
                    Location bossRoom = buildFromPatterns(world, patterns, originY);
                    int cellSize = 2;
                    int maxX = (width - 1) * cellSize + 2;
                    int maxZ = (depth - 1) * cellSize + 2;
                    int maxY = originY + (height - 1) * cellSize + 6;
                    BoundingBox area = new BoundingBox(0, originY, 0, maxX, maxY, maxZ);
                    createGlassBoundary(world, area, wallHeight);
                    DungeonSettings settings = loadSettings();
                    DungeonPlan plan = planDungeon(area, settings);
                    if (plan != null) {
                        new DungeonBuilder(plugin, random).build(world, plan, settings);
                        start = plan.startRoom().center(world);
                        bossRoom = plan.bossRoom().center(world);
                        spawnSigns(start, bossRoom, theme);
                    }
                    DungeonInstance instance = new DungeonInstance(world, start, bossRoom, participants, scale);
                    callback.accept(instance);
                }
            }.runTask(plugin);
        });
    }

    private Location buildFromPatterns(World world, Pattern[][][] patterns, int originY) {
        Location start = null;
        Location farthest = null;
        double bestDistance = 0;
        int cellSize = 2;
        for (int x = 0; x < patterns.length; x++) {
            for (int y = 0; y < patterns[x].length; y++) {
                for (int z = 0; z < patterns[x][y].length; z++) {
                    Pattern pattern = patterns[x][y][z];
                    if (pattern == null) {
                        continue;
                    }
                    int baseX = x * cellSize;
                    int baseY = originY + y * cellSize;
                    int baseZ = z * cellSize;
                    placePattern(world, pattern, baseX, baseY, baseZ);
                    if ("FLOOR".equals(pattern.socketDown())) {
                        Location center = new Location(world, baseX + 0.5, baseY + 1, baseZ + 0.5);
                        if (start == null) {
                            start = center;
                        }
                        double distance = start != null ? start.distanceSquared(center) : 0;
                        if (distance > bestDistance) {
                            bestDistance = distance;
                            farthest = center;
                        }
                    }
                }
            }
        }
        if (farthest == null) {
            farthest = new Location(world, 1, originY + 2, 1);
        }
        return farthest;
    }

    private void placePattern(World world, Pattern pattern, int baseX, int baseY, int baseZ) {
        Material[] blocks = pattern.blocks();
        int index = 0;
        for (int x = 0; x < 2; x++) {
            for (int y = 0; y < 2; y++) {
                for (int z = 0; z < 2; z++) {
                    Material material = blocks[index++];
                    world.getBlockAt(baseX + x, baseY + y, baseZ + z).setType(material, false);
                }
            }
        }
    }

    private void carveRoom(World world, int startX, int startY, int startZ, int size, Material material) {
        for (int x = startX; x < startX + size; x++) {
            for (int z = startZ; z < startZ + size; z++) {
                world.getBlockAt(x, startY, z).setType(material);
                for (int y = 1; y <= 4; y++) {
                    world.getBlockAt(x, startY + y, z).setType(Material.AIR);
                }
            }
        }
        for (int x = startX; x < startX + size; x++) {
            for (int z = startZ; z < startZ + size; z++) {
                if (x == startX || x == startX + size - 1 || z == startZ || z == startZ + size - 1) {
                    world.getBlockAt(x, startY + 5, z).setType(material);
                }
            }
        }
    }

    private void carveCorridor(World world, int startX, int startY, int startZ, Material material) {
        for (int i = 0; i < 3; i++) {
            world.getBlockAt(startX + i, startY, startZ).setType(material);
            for (int y = 1; y <= 3; y++) {
                world.getBlockAt(startX + i, startY + y, startZ).setType(Material.AIR);
            }
        }
    }

    private void spawnSpawners(List<Location> roomCenters, String theme) {
        String spawnerId = theme + "_spawner";
        Spawner spawner = plugin.spawnerManager().getSpawner(spawnerId);
        for (int i = 1; i < roomCenters.size() - 1; i++) {
            Location location = roomCenters.get(i);
            if (spawner == null) {
                spawnFallbackMob(location);
                continue;
            }
            if (spawner.mobs().isEmpty()) {
                spawnFallbackMob(location);
                continue;
            }
            String mobId = spawner.mobs().keySet().iterator().next();
            MobDefinition mob = plugin.mobManager().getMob(mobId);
            if (mob == null) {
                spawnFallbackMob(location);
                continue;
            }
            var entity = location.getWorld().spawnEntity(location, EntityType.valueOf(mob.type().toUpperCase()));
            if (entity instanceof org.bukkit.entity.LivingEntity living) {
                plugin.customMobListener().applyDefinition(living, mob);
            }
        }
    }

    private void spawnFallbackMob(Location location) {
        location.getWorld().spawnEntity(location, EntityType.ZOMBIE);
    }

    private void spawnBoss(Location bossRoom) {
        MobDefinition boss = plugin.mobManager().getMob("boss_zombie");
        if (boss == null) {
            return;
        }
        var entity = bossRoom.getWorld().spawnEntity(bossRoom, EntityType.valueOf(boss.type().toUpperCase()));
        if (entity instanceof org.bukkit.entity.LivingEntity living) {
            plugin.customMobListener().applyDefinition(living, boss);
            TextDisplay display = bossRoom.getWorld().spawn(bossRoom.clone().add(0, 2, 0), TextDisplay.class);
            Component bossName = LegacyComponentSerializer.legacySection().deserialize(boss.name());
            display.text(Component.text("Boss: ").append(bossName));
        }
    }

    private void spawnSigns(Location start, Location bossRoom, String theme) {
        TextDisplay startSign = start.getWorld().spawn(start.clone().add(0, 2, 0), TextDisplay.class);
        startSign.text(Text.mm("<gold>Dungeon: " + theme));
        TextDisplay bossSign = bossRoom.getWorld().spawn(bossRoom.clone().add(0, 2, 0), TextDisplay.class);
        bossSign.text(Text.mm("<red>Boss-Raum"));
    }

    private DungeonSettings loadSettings() {
        var config = plugin.getConfig();
        List<Integer> roomMin = config.getIntegerList("dungeon.roomMinSize");
        List<Integer> roomMax = config.getIntegerList("dungeon.roomMaxSize");
        if (roomMin.size() < 2) {
            roomMin = List.of(7, 7);
        }
        if (roomMax.size() < 2) {
            roomMax = List.of(13, 13);
        }
        Material wall = materialOrDefault(config.getString("dungeon.wallBlock", "STONE_BRICKS"), Material.STONE_BRICKS);
        Material floor = materialOrDefault(config.getString("dungeon.floorBlock", "DEEPSLATE_TILES"), Material.DEEPSLATE_TILES);
        Material door = materialOrDefault(config.getString("dungeon.door", "OAK_DOOR"), Material.OAK_DOOR);
        Material light = materialOrDefault(config.getString("dungeon.light", "SOUL_LANTERN"), Material.SOUL_LANTERN);
        List<Integer> perCombatRoom = config.getIntegerList("dungeon.mobs.perCombatRoom");
        List<Integer> lootPerRoom = config.getIntegerList("dungeon.loot.chestsPerLootRoom");
        return new DungeonSettings(
            config.getInt("dungeon.roomCount", 12),
            roomMin,
            roomMax,
            config.getInt("dungeon.corridorWidth", 3),
            wall,
            floor,
            door,
            light,
            config.getBoolean("dungeon.water.enabled", true),
            config.getDouble("dungeon.water.canalChance", 0.25),
            config.getDouble("dungeon.water.floodRoomChance", 0.05),
            config.getBoolean("dungeon.mobs.enabled", true),
            perCombatRoom.isEmpty()
                ? 2
                : perCombatRoom.get(0),
            perCombatRoom.size() > 1
                ? perCombatRoom.get(1)
                : 5,
            config.getDouble("dungeon.mobs.eliteChance", 0.15),
            config.getBoolean("dungeon.mobs.bossEnabled", true),
            config.getBoolean("dungeon.loot.enabled", true),
            lootPerRoom.isEmpty()
                ? 1
                : lootPerRoom.get(0),
            lootPerRoom.size() > 1
                ? lootPerRoom.get(1)
                : 3,
            config.getString("dungeon.loot.table", "wcf_dungeon_default"),
            config.getBoolean("dungeon.debug.enabled", false)
        );
    }

    private Material materialOrDefault(String name, Material fallback) {
        Material material = Material.matchMaterial(name);
        return material != null ? material : fallback;
    }

    private DungeonPlan planDungeon(BoundingBox bounds, DungeonSettings settings) {
        long seed = plugin.getConfig().getLong("dungeon.seed", System.currentTimeMillis());
        for (int attempt = 0; attempt < 5; attempt++) {
            DungeonPlanner planner = new DungeonPlanner(new Random(seed + attempt));
            DungeonPlan plan = planner.plan(seed + attempt, bounds, settings);
            if (plan != null) {
                return plan;
            }
        }
        return null;
    }

    private void createGlassBoundary(World world, BoundingBox area, int wallHeight) {
        int minX = (int) Math.floor(area.getMinX()) - 1;
        int minZ = (int) Math.floor(area.getMinZ()) - 1;
        int maxX = (int) Math.ceil(area.getMaxX()) + 1;
        int maxZ = (int) Math.ceil(area.getMaxZ()) + 1;
        int floorY = (int) Math.floor(area.getMinY()) - 1;

        for (int x = minX; x <= maxX; x++) {
            for (int z = minZ; z <= maxZ; z++) {
                world.getBlockAt(x, floorY, z).setType(Material.BLACK_STAINED_GLASS, false);
            }
        }

        int wallTop = floorY + wallHeight;
        for (int x = minX; x <= maxX; x++) {
            for (int z = minZ; z <= maxZ; z++) {
                if (x != minX && x != maxX && z != minZ && z != maxZ) {
                    continue;
                }
                for (int y = floorY + 1; y <= wallTop; y++) {
                    world.getBlockAt(x, y, z).setType(Material.GLASS, false);
                }
            }
        }

        int roofY = wallTop + 1;
        for (int x = minX; x <= maxX; x++) {
            for (int z = minZ; z <= maxZ; z++) {
                world.getBlockAt(x, roofY, z).setType(Material.GLASS, false);
            }
        }
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/DungeonInstance.java`  
- Path: `src/main/java/com/example/rpg/dungeon/DungeonInstance.java`  
- Size: 1133 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon;

import org.bukkit.Location;
import org.bukkit.World;

public class DungeonInstance {
    private final World world;
    private final Location start;
    private final Location bossRoom;
    private final java.util.Set<java.util.UUID> participants;
    private final double scale;
    private boolean noDeath = true;

    public DungeonInstance(World world, Location start, Location bossRoom, java.util.Set<java.util.UUID> participants, double scale) {
        this.world = world;
        this.start = start;
        this.bossRoom = bossRoom;
        this.participants = participants;
        this.scale = scale;
    }

    public World world() {
        return world;
    }

    public Location start() {
        return start;
    }

    public Location bossRoom() {
        return bossRoom;
    }

    public java.util.Set<java.util.UUID> participants() {
        return participants;
    }

    public double scale() {
        return scale;
    }

    public boolean noDeath() {
        return noDeath;
    }

    public void setNoDeath(boolean noDeath) {
        this.noDeath = noDeath;
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/BlockBuffer.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/BlockBuffer.java`  
- Size: 956 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import java.util.HashMap;
import java.util.Map;
import org.bukkit.Material;
import org.bukkit.World;

public class BlockBuffer {
    private final Map<Long, Material> buffer = new HashMap<>();

    public void set(int x, int y, int z, Material material) {
        buffer.put(toKey(x, y, z), material);
    }

    public void flush(World world) {
        for (Map.Entry<Long, Material> entry : buffer.entrySet()) {
            long key = entry.getKey();
            int x = (int) (key >> 42);
            int y = (int) (key >> 21) & 0x1FFFFF;
            int z = (int) (key & 0x1FFFFF);
            world.getBlockAt(x, y, z).setType(entry.getValue(), false);
        }
        buffer.clear();
    }

    private long toKey(int x, int y, int z) {
        long lx = ((long) x & 0x1FFFFF) << 42;
        long ly = ((long) y & 0x1FFFFF) << 21;
        long lz = (long) z & 0x1FFFFF;
        return lx | ly | lz;
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/Corridor.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/Corridor.java`  
- Size: 268 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import java.util.ArrayList;
import java.util.List;
import org.bukkit.util.Vector;

public class Corridor {
    private final List<Vector> path = new ArrayList<>();

    public List<Vector> path() {
        return path;
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/CorridorRouter.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/CorridorRouter.java`  
- Size: 6264 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.Random;
import org.bukkit.Location;
import org.bukkit.util.BoundingBox;
import org.bukkit.util.Vector;

public class CorridorRouter {
    private final Random random;

    public CorridorRouter(Random random) {
        this.random = random;
    }

    public List<Corridor> routeCorridors(BoundingBox bounds, List<Room> rooms, List<RoomEdge> edges) {
        List<Corridor> corridors = new ArrayList<>();
        for (RoomEdge edge : edges) {
            Location doorA = chooseDoor(edge.a(), edge.b());
            Location doorB = chooseDoor(edge.b(), edge.a());
            edge.a().doorPoints().add(doorA);
            edge.b().doorPoints().add(doorB);
            Corridor corridor = new Corridor();
            List<Vector> path = findPath(bounds, rooms, doorA, doorB);
            corridor.path().addAll(path);
            corridors.add(corridor);
        }
        return corridors;
    }

    private Location chooseDoor(Room from, Room to) {
        BoundingBox box = from.bounds();
        double centerX = (box.getMinX() + box.getMaxX()) / 2.0;
        double centerZ = (box.getMinZ() + box.getMaxZ()) / 2.0;
        double dx = to.bounds().getCenterX() - centerX;
        double dz = to.bounds().getCenterZ() - centerZ;
        double x;
        double z;
        if (Math.abs(dx) > Math.abs(dz)) {
            x = dx > 0 ? box.getMaxX() : box.getMinX();
            z = centerZ;
        } else {
            x = centerX;
            z = dz > 0 ? box.getMaxZ() : box.getMinZ();
        }
        return new Location(null, Math.round(x), box.getMinY() + 1, Math.round(z));
    }

    private List<Vector> findPath(BoundingBox bounds, List<Room> rooms, Location start, Location goal) {
        Point startPoint = new Point(start.getBlockX(), start.getBlockZ());
        Point goalPoint = new Point(goal.getBlockX(), goal.getBlockZ());
        PriorityQueue<Node> open = new PriorityQueue<>(Comparator.comparingDouble(n -> n.f));
        Map<Point, Node> all = new HashMap<>();
        Set<Point> closed = new HashSet<>();
        Node startNode = new Node(startPoint, null, 0, heuristic(startPoint, goalPoint));
        open.add(startNode);
        all.put(startPoint, startNode);
        int minX = (int) bounds.getMinX();
        int maxX = (int) bounds.getMaxX();
        int minZ = (int) bounds.getMinZ();
        int maxZ = (int) bounds.getMaxZ();
        while (!open.isEmpty()) {
            Node current = open.poll();
            if (current.point.equals(goalPoint)) {
                return reconstruct(current);
            }
            closed.add(current.point);
            for (int[] dir : new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}) {
                int nx = current.point.x + dir[0];
                int nz = current.point.z + dir[1];
                if (nx < minX || nx > maxX || nz < minZ || nz > maxZ) {
                    continue;
                }
                Point next = new Point(nx, nz);
                if (closed.contains(next)) {
                    continue;
                }
                if (isBlocked(rooms, next, startPoint, goalPoint)) {
                    continue;
                }
                double cost = current.g + 1;
                Node existing = all.get(next);
                if (existing == null || cost < existing.g) {
                    Node node = new Node(next, current, cost, heuristic(next, goalPoint));
                    all.put(next, node);
                    open.add(node);
                }
            }
        }
        return fallbackManhattan(startPoint, goalPoint);
    }

    private boolean isBlocked(List<Room> rooms, Point point, Point start, Point goal) {
        if (point.equals(start) || point.equals(goal)) {
            return false;
        }
        for (Room room : rooms) {
            BoundingBox box = room.bounds();
            if (point.x > box.getMinX() && point.x < box.getMaxX()
                && point.z > box.getMinZ() && point.z < box.getMaxZ()) {
                return true;
            }
        }
        return false;
    }

    private List<Vector> fallbackManhattan(Point start, Point goal) {
        List<Vector> path = new ArrayList<>();
        int x = start.x;
        int z = start.z;
        while (x != goal.x) {
            x += Integer.signum(goal.x - x);
            path.add(new Vector(x, 0, z));
        }
        while (z != goal.z) {
            z += Integer.signum(goal.z - z);
            path.add(new Vector(x, 0, z));
        }
        return path;
    }

    private List<Vector> reconstruct(Node node) {
        List<Vector> path = new ArrayList<>();
        Node current = node;
        while (current.parent != null) {
            path.add(new Vector(current.point.x, 0, current.point.z));
            current = current.parent;
        }
        java.util.Collections.reverse(path);
        return path;
    }

    private double heuristic(Point a, Point b) {
        return Math.abs(a.x - b.x) + Math.abs(a.z - b.z);
    }

    public record RoomEdge(Room a, Room b) {
    }

    private static class Point {
        private final int x;
        private final int z;

        private Point(int x, int z) {
            this.x = x;
            this.z = z;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof Point point)) {
                return false;
            }
            return point.x == x && point.z == z;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, z);
        }
    }

    private static class Node {
        private final Point point;
        private final Node parent;
        private final double g;
        private final double h;
        private final double f;

        private Node(Point point, Node parent, double g, double h) {
            this.point = point;
            this.parent = parent;
            this.g = g;
            this.h = h;
            this.f = g + h;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/DungeonBuilder.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/DungeonBuilder.java`  
- Size: 5268 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import com.example.rpg.RPGPlugin;
import java.util.Random;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.util.BoundingBox;
import org.bukkit.util.Vector;

public class DungeonBuilder {
    private final RPGPlugin plugin;
    private final Random random;
    private final DungeonDecorator decorator;
    private final SpawnPlacer spawnPlacer;
    private final LootPlacer lootPlacer;

    public DungeonBuilder(RPGPlugin plugin, Random random) {
        this.plugin = plugin;
        this.random = random;
        this.decorator = new DungeonDecorator();
        this.spawnPlacer = new SpawnPlacer(plugin, random);
        this.lootPlacer = new LootPlacer(random);
    }

    public void build(World world, DungeonPlan plan, DungeonSettings settings) {
        BlockBuffer buffer = new BlockBuffer();
        for (Room room : plan.rooms()) {
            carveRoom(buffer, room, settings);
            decorator.decorateRoom(world, buffer, room, settings, random);
        }
        for (Corridor corridor : plan.corridors()) {
            carveCorridor(buffer, corridor, plan.bounds(), settings);
        }
        applyDoors(buffer, plan, settings);
        applyWater(buffer, plan, settings);
        buffer.flush(world);
        for (Room room : plan.rooms()) {
            spawnPlacer.spawnRoomMobs(room, settings, world);
            lootPlacer.placeLoot(room, settings, world);
        }
    }

    private void carveRoom(BlockBuffer buffer, Room room, DungeonSettings settings) {
        BoundingBox box = room.bounds();
        int minX = (int) box.getMinX();
        int maxX = (int) box.getMaxX();
        int minZ = (int) box.getMinZ();
        int maxZ = (int) box.getMaxZ();
        int baseY = (int) box.getMinY();
        int height = 5;
        for (int x = minX; x <= maxX; x++) {
            for (int z = minZ; z <= maxZ; z++) {
                buffer.set(x, baseY, z, settings.floorBlock());
                for (int y = 1; y <= height; y++) {
                    Material material = (x == minX || x == maxX || z == minZ || z == maxZ)
                        ? settings.wallBlock()
                        : Material.AIR;
                    buffer.set(x, baseY + y, z, material);
                }
            }
        }
    }

    private void carveCorridor(BlockBuffer buffer, Corridor corridor, BoundingBox bounds, DungeonSettings settings) {
        int width = settings.corridorWidth();
        int baseY = (int) bounds.getMinY();
        int height = 4;
        for (Vector step : corridor.path()) {
            int centerX = step.getBlockX();
            int centerZ = step.getBlockZ();
            for (int dx = -width / 2; dx <= width / 2; dx++) {
                for (int dz = -width / 2; dz <= width / 2; dz++) {
                    int x = centerX + dx;
                    int z = centerZ + dz;
                    buffer.set(x, baseY, z, settings.floorBlock());
                    for (int y = 1; y <= height; y++) {
                        buffer.set(x, baseY + y, z, Material.AIR);
                    }
                }
            }
        }
    }

    private void applyDoors(BlockBuffer buffer, DungeonPlan plan, DungeonSettings settings) {
        Material doorMaterial = settings.doorBlock();
        for (Room room : plan.rooms()) {
            for (Location door : room.doorPoints()) {
                int x = door.getBlockX();
                int y = door.getBlockY();
                int z = door.getBlockZ();
                buffer.set(x, y, z, settings.floorBlock());
                buffer.set(x, y + 1, z, doorMaterial);
                buffer.set(x, y + 2, z, doorMaterial);
            }
        }
    }

    private void applyWater(BlockBuffer buffer, DungeonPlan plan, DungeonSettings settings) {
        if (!settings.waterEnabled()) {
            return;
        }
        if (settings.canalChance() > 0) {
            for (Corridor corridor : plan.corridors()) {
                if (random.nextDouble() > settings.canalChance()) {
                    continue;
                }
                for (Vector step : corridor.path()) {
                    int x = step.getBlockX();
                    int z = step.getBlockZ();
                    int y = (int) plan.bounds().getMinY() + 1;
                    buffer.set(x + settings.corridorWidth(), y, z, Material.WATER);
                }
            }
        }
        for (Room room : plan.rooms()) {
            if (random.nextDouble() > settings.floodRoomChance()) {
                continue;
            }
            BoundingBox box = room.bounds();
            int minX = (int) box.getMinX() + 1;
            int maxX = (int) box.getMaxX() - 1;
            int minZ = (int) box.getMinZ() + 1;
            int maxZ = (int) box.getMaxZ() - 1;
            int y = (int) box.getMinY() + 1;
            for (int x = minX; x <= maxX; x++) {
                buffer.set(x, y, minZ, Material.WATER);
                buffer.set(x, y, maxZ, Material.WATER);
            }
            for (int z = minZ; z <= maxZ; z++) {
                buffer.set(minX, y, z, Material.WATER);
                buffer.set(maxX, y, z, Material.WATER);
            }
        }
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/DungeonDecorator.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/DungeonDecorator.java`  
- Size: 2432 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import java.util.Random;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.util.BoundingBox;

public class DungeonDecorator {
    public void decorateRoom(World world, BlockBuffer buffer, Room room, DungeonSettings settings, Random random) {
        BoundingBox box = room.bounds();
        int minX = (int) box.getMinX() + 1;
        int maxX = (int) box.getMaxX() - 1;
        int minZ = (int) box.getMinZ() + 1;
        int maxZ = (int) box.getMaxZ() - 1;
        int floorY = (int) box.getMinY();
        Material floorMaterial = settings.floorBlock();
        if (settings.debugEnabled()) {
            floorMaterial = debugFloor(room.type());
        }
        for (int x = minX; x <= maxX; x++) {
            for (int z = minZ; z <= maxZ; z++) {
                buffer.set(x, floorY, z, floorMaterial);
                if (!settings.debugEnabled() && random.nextDouble() < 0.08) {
                    buffer.set(x, floorY, z, Material.CRACKED_STONE_BRICKS);
                }
            }
        }
        placeLights(buffer, settings, floorY + 2, minX, maxX, minZ, maxZ);
        if (room.type() == RoomType.ELITE || room.type() == RoomType.BOSS) {
            placePillars(buffer, settings, floorY + 1, minX, maxX, minZ, maxZ);
        }
    }

    private void placeLights(BlockBuffer buffer, DungeonSettings settings, int y, int minX, int maxX, int minZ, int maxZ) {
        buffer.set(minX, y, minZ, settings.lightBlock());
        buffer.set(maxX, y, minZ, settings.lightBlock());
        buffer.set(minX, y, maxZ, settings.lightBlock());
        buffer.set(maxX, y, maxZ, settings.lightBlock());
    }

    private void placePillars(BlockBuffer buffer, DungeonSettings settings, int y, int minX, int maxX, int minZ, int maxZ) {
        int midX = (minX + maxX) / 2;
        int midZ = (minZ + maxZ) / 2;
        for (int dy = 0; dy < 3; dy++) {
            buffer.set(midX, y + dy, midZ, settings.wallBlock());
        }
    }

    private Material debugFloor(RoomType type) {
        return switch (type) {
            case START -> Material.GREEN_WOOL;
            case BOSS -> Material.RED_WOOL;
            case EXIT -> Material.BLUE_WOOL;
            case LOOT -> Material.YELLOW_WOOL;
            case ELITE -> Material.PURPLE_WOOL;
            case PUZZLE -> Material.ORANGE_WOOL;
            case COMBAT -> Material.GRAY_WOOL;
        };
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/DungeonGraph.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/DungeonGraph.java`  
- Size: 511 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DungeonGraph {
    private final Map<Room, List<Room>> adjacency = new HashMap<>();

    public void addEdge(Room a, Room b) {
        adjacency.computeIfAbsent(a, key -> new ArrayList<>()).add(b);
        adjacency.computeIfAbsent(b, key -> new ArrayList<>()).add(a);
    }

    public Map<Room, List<Room>> adjacency() {
        return adjacency;
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/DungeonPlan.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/DungeonPlan.java`  
- Size: 1500 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import java.util.List;
import org.bukkit.util.BoundingBox;

public class DungeonPlan {
    private final long seed;
    private final BoundingBox bounds;
    private final List<Room> rooms;
    private final List<Corridor> corridors;
    private final DungeonGraph graph;
    private final Room startRoom;
    private final Room bossRoom;
    private final Room exitRoom;

    public DungeonPlan(long seed,
                       BoundingBox bounds,
                       List<Room> rooms,
                       List<Corridor> corridors,
                       DungeonGraph graph,
                       Room startRoom,
                       Room bossRoom,
                       Room exitRoom) {
        this.seed = seed;
        this.bounds = bounds;
        this.rooms = rooms;
        this.corridors = corridors;
        this.graph = graph;
        this.startRoom = startRoom;
        this.bossRoom = bossRoom;
        this.exitRoom = exitRoom;
    }

    public long seed() {
        return seed;
    }

    public BoundingBox bounds() {
        return bounds;
    }

    public List<Room> rooms() {
        return rooms;
    }

    public List<Corridor> corridors() {
        return corridors;
    }

    public DungeonGraph graph() {
        return graph;
    }

    public Room startRoom() {
        return startRoom;
    }

    public Room bossRoom() {
        return bossRoom;
    }

    public Room exitRoom() {
        return exitRoom;
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/DungeonPlanner.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/DungeonPlanner.java`  
- Size: 4221 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import com.example.rpg.dungeon.layout.CorridorRouter.RoomEdge;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import org.bukkit.util.BoundingBox;

public class DungeonPlanner {
    private final Random random;
    private final RoomPlacer roomPlacer;
    private final CorridorRouter corridorRouter;
    private final DungeonValidator validator;

    public DungeonPlanner(Random random) {
        this.random = random;
        this.roomPlacer = new RoomPlacer(random);
        this.corridorRouter = new CorridorRouter(random);
        this.validator = new DungeonValidator();
    }

    public DungeonPlan plan(long seed, BoundingBox bounds, DungeonSettings settings) {
        List<Room> rooms = roomPlacer.placeRooms(bounds, settings);
        if (rooms.size() < 3) {
            return null;
        }
        assignRoomTypes(rooms, settings);
        List<RoomEdge> edges = buildEdges(rooms);
        List<Corridor> corridors = corridorRouter.routeCorridors(bounds, rooms, edges);
        DungeonGraph graph = new DungeonGraph();
        for (RoomEdge edge : edges) {
            graph.addEdge(edge.a(), edge.b());
        }
        Room start = rooms.stream().filter(room -> room.type() == RoomType.START).findFirst().orElse(rooms.get(0));
        Room boss = rooms.stream().filter(room -> room.type() == RoomType.BOSS).findFirst().orElse(rooms.get(rooms.size() - 1));
        Room exit = rooms.stream().filter(room -> room.type() == RoomType.EXIT).findFirst().orElse(rooms.get(rooms.size() - 2));
        DungeonPlan plan = new DungeonPlan(seed, bounds, rooms, corridors, graph, start, boss, exit);
        if (!validator.validate(plan)) {
            return null;
        }
        return plan;
    }

    private void assignRoomTypes(List<Room> rooms, DungeonSettings settings) {
        rooms.sort(Comparator.comparingDouble(room -> room.bounds().getMinX()));
        Room start = rooms.get(0);
        Room boss = rooms.get(rooms.size() - 1);
        Room exit = rooms.get(rooms.size() - 2);
        start.setType(RoomType.START);
        boss.setType(RoomType.BOSS);
        exit.setType(RoomType.EXIT);
        for (int i = 1; i < rooms.size() - 2; i++) {
            Room room = rooms.get(i);
            if (settings.lootEnabled() && random.nextDouble() < 0.2) {
                room.setType(RoomType.LOOT);
            } else if (settings.eliteChance() > 0 && random.nextDouble() < settings.eliteChance()) {
                room.setType(RoomType.ELITE);
            } else {
                room.setType(RoomType.COMBAT);
            }
        }
    }

    private List<RoomEdge> buildEdges(List<Room> rooms) {
        List<RoomEdge> edges = new ArrayList<>();
        List<RoomEdge> allEdges = new ArrayList<>();
        for (int i = 0; i < rooms.size(); i++) {
            for (int j = i + 1; j < rooms.size(); j++) {
                allEdges.add(new RoomEdge(rooms.get(i), rooms.get(j)));
            }
        }
        allEdges.sort(Comparator.comparingDouble(edge -> centerDistanceSquared(edge.a(), edge.b())));
        Set<Room> connected = new HashSet<>();
        if (!rooms.isEmpty()) {
            connected.add(rooms.get(0));
        }
        for (RoomEdge edge : allEdges) {
            if (connected.contains(edge.a()) && connected.contains(edge.b())) {
                continue;
            }
            edges.add(edge);
            connected.add(edge.a());
            connected.add(edge.b());
            if (connected.size() == rooms.size()) {
                break;
            }
        }
        int extraLoops = Math.min(2, allEdges.size());
        for (int i = 0; i < extraLoops; i++) {
            RoomEdge edge = allEdges.get(random.nextInt(allEdges.size()));
            if (!edges.contains(edge)) {
                edges.add(edge);
            }
        }
        return edges;
    }

    private double centerDistanceSquared(Room a, Room b) {
        double dx = a.bounds().getCenterX() - b.bounds().getCenterX();
        double dz = a.bounds().getCenterZ() - b.bounds().getCenterZ();
        return dx * dx + dz * dz;
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/DungeonSettings.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/DungeonSettings.java`  
- Size: 4414 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import java.util.List;
import org.bukkit.Material;

public class DungeonSettings {
    private final int roomCount;
    private final int roomMinSizeX;
    private final int roomMinSizeZ;
    private final int roomMaxSizeX;
    private final int roomMaxSizeZ;
    private final int corridorWidth;
    private final Material wallBlock;
    private final Material floorBlock;
    private final Material doorBlock;
    private final Material lightBlock;
    private final boolean waterEnabled;
    private final double canalChance;
    private final double floodRoomChance;
    private final boolean mobsEnabled;
    private final int mobsMin;
    private final int mobsMax;
    private final double eliteChance;
    private final boolean bossEnabled;
    private final boolean lootEnabled;
    private final int lootMin;
    private final int lootMax;
    private final String lootTable;
    private final boolean debugEnabled;

    public DungeonSettings(int roomCount,
                           List<Integer> roomMinSize,
                           List<Integer> roomMaxSize,
                           int corridorWidth,
                           Material wallBlock,
                           Material floorBlock,
                           Material doorBlock,
                           Material lightBlock,
                           boolean waterEnabled,
                           double canalChance,
                           double floodRoomChance,
                           boolean mobsEnabled,
                           int mobsMin,
                           int mobsMax,
                           double eliteChance,
                           boolean bossEnabled,
                           boolean lootEnabled,
                           int lootMin,
                           int lootMax,
                           String lootTable,
                           boolean debugEnabled) {
        this.roomCount = roomCount;
        this.roomMinSizeX = roomMinSize.get(0);
        this.roomMinSizeZ = roomMinSize.get(1);
        this.roomMaxSizeX = roomMaxSize.get(0);
        this.roomMaxSizeZ = roomMaxSize.get(1);
        this.corridorWidth = corridorWidth;
        this.wallBlock = wallBlock;
        this.floorBlock = floorBlock;
        this.doorBlock = doorBlock;
        this.lightBlock = lightBlock;
        this.waterEnabled = waterEnabled;
        this.canalChance = canalChance;
        this.floodRoomChance = floodRoomChance;
        this.mobsEnabled = mobsEnabled;
        this.mobsMin = mobsMin;
        this.mobsMax = mobsMax;
        this.eliteChance = eliteChance;
        this.bossEnabled = bossEnabled;
        this.lootEnabled = lootEnabled;
        this.lootMin = lootMin;
        this.lootMax = lootMax;
        this.lootTable = lootTable;
        this.debugEnabled = debugEnabled;
    }

    public int roomCount() {
        return roomCount;
    }

    public int roomMinSizeX() {
        return roomMinSizeX;
    }

    public int roomMinSizeZ() {
        return roomMinSizeZ;
    }

    public int roomMaxSizeX() {
        return roomMaxSizeX;
    }

    public int roomMaxSizeZ() {
        return roomMaxSizeZ;
    }

    public int corridorWidth() {
        return corridorWidth;
    }

    public Material wallBlock() {
        return wallBlock;
    }

    public Material floorBlock() {
        return floorBlock;
    }

    public Material doorBlock() {
        return doorBlock;
    }

    public Material lightBlock() {
        return lightBlock;
    }

    public boolean waterEnabled() {
        return waterEnabled;
    }

    public double canalChance() {
        return canalChance;
    }

    public double floodRoomChance() {
        return floodRoomChance;
    }

    public boolean mobsEnabled() {
        return mobsEnabled;
    }

    public int mobsMin() {
        return mobsMin;
    }

    public int mobsMax() {
        return mobsMax;
    }

    public double eliteChance() {
        return eliteChance;
    }

    public boolean bossEnabled() {
        return bossEnabled;
    }

    public boolean lootEnabled() {
        return lootEnabled;
    }

    public int lootMin() {
        return lootMin;
    }

    public int lootMax() {
        return lootMax;
    }

    public String lootTable() {
        return lootTable;
    }

    public boolean debugEnabled() {
        return debugEnabled;
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/DungeonValidator.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/DungeonValidator.java`  
- Size: 1333 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import java.util.ArrayDeque;
import java.util.HashSet;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

public class DungeonValidator {
    public boolean validate(DungeonPlan plan) {
        if (plan.rooms().isEmpty()) {
            return false;
        }
        if (!isReachable(plan.graph().adjacency(), plan.startRoom(), plan.bossRoom())) {
            return false;
        }
        if (!isReachable(plan.graph().adjacency(), plan.bossRoom(), plan.exitRoom())) {
            return false;
        }
        return true;
    }

    private boolean isReachable(Map<Room, java.util.List<Room>> graph, Room start, Room target) {
        if (start == null || target == null) {
            return false;
        }
        Queue<Room> queue = new ArrayDeque<>();
        Set<Room> visited = new HashSet<>();
        queue.add(start);
        visited.add(start);
        while (!queue.isEmpty()) {
            Room room = queue.poll();
            if (room.equals(target)) {
                return true;
            }
            for (Room neighbor : graph.getOrDefault(room, java.util.Collections.emptyList())) {
                if (visited.add(neighbor)) {
                    queue.add(neighbor);
                }
            }
        }
        return false;
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/LootPlacer.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/LootPlacer.java`  
- Size: 2136 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import java.util.Random;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.Bukkit;
import org.bukkit.block.BlockState;
import org.bukkit.loot.Lootable;
import org.bukkit.loot.LootTable;
import org.bukkit.util.BoundingBox;

public class LootPlacer {
    private final Random random;

    public LootPlacer(Random random) {
        this.random = random;
    }

    public void placeLoot(Room room, DungeonSettings settings, org.bukkit.World world) {
        if (!settings.lootEnabled() || room.type() != RoomType.LOOT) {
            return;
        }
        int count = nextBetween(settings.lootMin(), settings.lootMax());
        for (int i = 0; i < count; i++) {
            Location location = randomPoint(room, world);
            world.getBlockAt(location).setType(Material.CHEST, false);
            BlockState state = world.getBlockAt(location).getState();
            if (state instanceof Lootable lootable) {
                LootTable table = lookupTable(settings.lootTable(), world);
                if (table != null) {
                    lootable.setLootTable(table);
                    state.update();
                }
            }
        }
    }

    private LootTable lookupTable(String tableKey, org.bukkit.World world) {
        if (tableKey == null || tableKey.isBlank()) {
            return null;
        }
        NamespacedKey key = NamespacedKey.fromString(tableKey);
        if (key == null) {
            key = NamespacedKey.minecraft(tableKey);
        }
        return Bukkit.getLootTable(key);
    }

    private Location randomPoint(Room room, org.bukkit.World world) {
        BoundingBox box = room.bounds();
        int x = nextBetween((int) box.getMinX() + 1, (int) box.getMaxX() - 1);
        int z = nextBetween((int) box.getMinZ() + 1, (int) box.getMaxZ() - 1);
        return new Location(world, x, box.getMinY() + 1, z);
    }

    private int nextBetween(int min, int max) {
        if (max <= min) {
            return min;
        }
        return random.nextInt(max - min + 1) + min;
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/Room.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/Room.java`  
- Size: 1186 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import java.util.ArrayList;
import java.util.List;
import org.bukkit.Location;
import org.bukkit.util.BoundingBox;

public class Room {
    private final int id;
    private final BoundingBox bounds;
    private RoomType type;
    private final List<Location> doorPoints = new ArrayList<>();
    private final List<Location> spawnPoints = new ArrayList<>();

    public Room(int id, BoundingBox bounds, RoomType type) {
        this.id = id;
        this.bounds = bounds;
        this.type = type;
    }

    public int id() {
        return id;
    }

    public BoundingBox bounds() {
        return bounds;
    }

    public RoomType type() {
        return type;
    }

    public void setType(RoomType type) {
        this.type = type;
    }

    public List<Location> doorPoints() {
        return doorPoints;
    }

    public List<Location> spawnPoints() {
        return spawnPoints;
    }

    public Location center(org.bukkit.World world) {
        return new Location(world,
            (bounds.getMinX() + bounds.getMaxX()) / 2.0,
            bounds.getMinY() + 1,
            (bounds.getMinZ() + bounds.getMaxZ()) / 2.0);
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/RoomPlacer.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/RoomPlacer.java`  
- Size: 2275 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import org.bukkit.util.BoundingBox;

public class RoomPlacer {
    private final Random random;

    public RoomPlacer(Random random) {
        this.random = random;
    }

    public List<Room> placeRooms(BoundingBox bounds, DungeonSettings settings) {
        List<Room> rooms = new ArrayList<>();
        int attempts = settings.roomCount() * 15;
        int padding = 2;
        int id = 0;
        while (rooms.size() < settings.roomCount() && attempts-- > 0) {
            int width = nextBetween(settings.roomMinSizeX(), settings.roomMaxSizeX());
            int depth = nextBetween(settings.roomMinSizeZ(), settings.roomMaxSizeZ());
            int minX = (int) bounds.getMinX() + padding;
            int maxX = (int) bounds.getMaxX() - padding - width;
            int minZ = (int) bounds.getMinZ() + padding;
            int maxZ = (int) bounds.getMaxZ() - padding - depth;
            if (maxX <= minX || maxZ <= minZ) {
                break;
            }
            int x1 = nextBetween(minX, maxX);
            int z1 = nextBetween(minZ, maxZ);
            int y1 = (int) bounds.getMinY();
            BoundingBox candidate = new BoundingBox(x1, y1, z1, x1 + width, y1 + 5, z1 + depth);
            if (isOverlapping(candidate, rooms, padding)) {
                continue;
            }
            Room room = new Room(id++, candidate, RoomType.COMBAT);
            rooms.add(room);
        }
        return rooms;
    }

    private boolean isOverlapping(BoundingBox candidate, List<Room> rooms, int padding) {
        BoundingBox padded = new BoundingBox(
            candidate.getMinX() - padding,
            candidate.getMinY(),
            candidate.getMinZ() - padding,
            candidate.getMaxX() + padding,
            candidate.getMaxY(),
            candidate.getMaxZ() + padding
        );
        for (Room room : rooms) {
            if (padded.overlaps(room.bounds())) {
                return true;
            }
        }
        return false;
    }

    private int nextBetween(int min, int max) {
        if (max <= min) {
            return min;
        }
        return random.nextInt(max - min + 1) + min;
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/RoomType.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/RoomType.java`  
- Size: 141 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

public enum RoomType {
    START,
    COMBAT,
    LOOT,
    ELITE,
    BOSS,
    EXIT,
    PUZZLE
}

```

## File: `src/main/java/com/example/rpg/dungeon/layout/SpawnPlacer.java`  
- Path: `src/main/java/com/example/rpg/dungeon/layout/SpawnPlacer.java`  
- Size: 2350 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.layout;

import com.example.rpg.RPGPlugin;
import java.util.Random;
import org.bukkit.Location;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.LivingEntity;
import org.bukkit.util.BoundingBox;

public class SpawnPlacer {
    private final RPGPlugin plugin;
    private final Random random;

    public SpawnPlacer(RPGPlugin plugin, Random random) {
        this.plugin = plugin;
        this.random = random;
    }

    public void spawnRoomMobs(Room room, DungeonSettings settings, org.bukkit.World world) {
        if (!settings.mobsEnabled()) {
            return;
        }
        if (room.type() == RoomType.START || room.type() == RoomType.EXIT || room.type() == RoomType.LOOT) {
            return;
        }
        int count = nextBetween(settings.mobsMin(), settings.mobsMax());
        for (int i = 0; i < count; i++) {
            Location spawn = randomPoint(room, world);
            if (room.type() == RoomType.BOSS) {
                if (!settings.bossEnabled()) {
                    return;
                }
                var boss = plugin.mobManager().getMob("boss_zombie");
                if (boss != null) {
                    var entity = spawn.getWorld().spawnEntity(spawn, EntityType.valueOf(boss.type().toUpperCase()));
                    if (entity instanceof LivingEntity living) {
                        plugin.customMobListener().applyDefinition(living, boss);
                    }
                    return;
                }
                world.spawnEntity(spawn, EntityType.ZOMBIE);
                return;
            }
            if (room.type() == RoomType.ELITE) {
                world.spawnEntity(spawn, EntityType.HUSK);
            } else {
                world.spawnEntity(spawn, EntityType.ZOMBIE);
            }
        }
    }

    private Location randomPoint(Room room, org.bukkit.World world) {
        BoundingBox box = room.bounds();
        int x = nextBetween((int) box.getMinX() + 1, (int) box.getMaxX() - 1);
        int z = nextBetween((int) box.getMinZ() + 1, (int) box.getMaxZ() - 1);
        return new Location(world, x + 0.5, box.getMinY() + 1, z + 0.5);
    }

    private int nextBetween(int min, int max) {
        if (max <= min) {
            return min;
        }
        return random.nextInt(max - min + 1) + min;
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/wfc/Direction.java`  
- Path: `src/main/java/com/example/rpg/dungeon/wfc/Direction.java`  
- Size: 393 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.wfc;

public enum Direction {
    UP,
    DOWN,
    NORTH,
    SOUTH,
    EAST,
    WEST;

    public Direction opposite() {
        return switch (this) {
            case UP -> DOWN;
            case DOWN -> UP;
            case NORTH -> SOUTH;
            case SOUTH -> NORTH;
            case EAST -> WEST;
            case WEST -> EAST;
        };
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/wfc/Pattern.java`  
- Path: `src/main/java/com/example/rpg/dungeon/wfc/Pattern.java`  
- Size: 950 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.wfc;

import java.util.EnumMap;
import java.util.Map;
import org.bukkit.Material;

public class Pattern {
    private final String id;
    private final Material[] blocks;
    private final Map<Direction, String> sockets = new EnumMap<>(Direction.class);
    private final double weight;

    public Pattern(String id, Material[] blocks, double weight) {
        this.id = id;
        this.blocks = blocks;
        this.weight = weight;
    }

    public String id() {
        return id;
    }

    public Material[] blocks() {
        return blocks;
    }

    public double weight() {
        return weight;
    }

    public void setSocket(Direction direction, String socket) {
        sockets.put(direction, socket);
    }

    public String socket(Direction direction) {
        return sockets.getOrDefault(direction, "AIR");
    }

    public String socketDown() {
        return socket(Direction.DOWN);
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/wfc/PatternLoader.java`  
- Path: `src/main/java/com/example/rpg/dungeon/wfc/PatternLoader.java`  
- Size: 6059 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.wfc;

import java.util.ArrayList;
import java.util.List;
import org.bukkit.Material;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.plugin.java.JavaPlugin;

public class PatternLoader {
    private final JavaPlugin plugin;

    public PatternLoader(JavaPlugin plugin) {
        this.plugin = plugin;
    }

    public List<Pattern> loadPatterns(String themeName) {
        List<Pattern> patterns = new ArrayList<>();
        ThemeMaterials materials = resolveTheme(themeName);

        Pattern air = new Pattern("air", fill(Material.AIR), 1.0);
        for (Direction direction : Direction.values()) {
            air.setSocket(direction, "AIR");
        }
        patterns.add(air);

        Pattern floor = new Pattern("floor", floorBlocks(materials.floor()), 1.5);
        floor.setSocket(Direction.DOWN, "FLOOR");
        floor.setSocket(Direction.UP, "AIR");
        floor.setSocket(Direction.NORTH, "AIR");
        floor.setSocket(Direction.SOUTH, "AIR");
        floor.setSocket(Direction.EAST, "AIR");
        floor.setSocket(Direction.WEST, "AIR");
        patterns.add(floor);

        Pattern wallNorth = new Pattern("wall_north", wallBlocks(Direction.NORTH, materials.wall()), 1.0);
        wallNorth.setSocket(Direction.DOWN, "FLOOR");
        wallNorth.setSocket(Direction.UP, "AIR");
        wallNorth.setSocket(Direction.NORTH, "WALL");
        wallNorth.setSocket(Direction.SOUTH, "AIR");
        wallNorth.setSocket(Direction.EAST, "AIR");
        wallNorth.setSocket(Direction.WEST, "AIR");
        patterns.add(wallNorth);
        Pattern wallEast = rotateY(wallNorth, "wall_east");
        Pattern wallSouth = rotateY(wallEast, "wall_south");
        Pattern wallWest = rotateY(wallSouth, "wall_west");
        patterns.add(wallEast);
        patterns.add(wallSouth);
        patterns.add(wallWest);

        Pattern corridor = new Pattern("corridor_ns", corridorBlocks(materials.corridor()), 1.2);
        corridor.setSocket(Direction.DOWN, "FLOOR");
        corridor.setSocket(Direction.UP, "AIR");
        corridor.setSocket(Direction.NORTH, "OPEN");
        corridor.setSocket(Direction.SOUTH, "OPEN");
        corridor.setSocket(Direction.EAST, "WALL");
        corridor.setSocket(Direction.WEST, "WALL");
        patterns.add(corridor);
        patterns.add(rotateY(corridor, "corridor_ew"));

        return patterns;
    }

    private Material[] fill(Material material) {
        Material[] blocks = new Material[8];
        for (int i = 0; i < blocks.length; i++) {
            blocks[i] = material;
        }
        return blocks;
    }

    private Material[] floorBlocks(Material floorMaterial) {
        Material[] blocks = new Material[8];
        int index = 0;
        for (int x = 0; x < 2; x++) {
            for (int y = 0; y < 2; y++) {
                for (int z = 0; z < 2; z++) {
                    blocks[index++] = y == 0 ? floorMaterial : Material.AIR;
                }
            }
        }
        return blocks;
    }

    private Material[] wallBlocks(Direction direction, Material wallMaterial) {
        Material[] blocks = floorBlocks(wallMaterial);
        int index = 0;
        for (int x = 0; x < 2; x++) {
            for (int y = 0; y < 2; y++) {
                for (int z = 0; z < 2; z++) {
                    if (y == 1 && isWallCell(direction, x, z)) {
                        blocks[index] = wallMaterial;
                    }
                    index++;
                }
            }
        }
        return blocks;
    }

    private boolean isWallCell(Direction direction, int x, int z) {
        return switch (direction) {
            case NORTH -> z == 0;
            case SOUTH -> z == 1;
            case EAST -> x == 1;
            case WEST -> x == 0;
            default -> false;
        };
    }

    private Material[] corridorBlocks(Material corridorMaterial) {
        return floorBlocks(corridorMaterial);
    }

    private Pattern rotateY(Pattern base, String newId) {
        Material[] rotated = new Material[8];
        int index = 0;
        for (int x = 0; x < 2; x++) {
            for (int y = 0; y < 2; y++) {
                for (int z = 0; z < 2; z++) {
                    int rx = z;
                    int rz = 1 - x;
                    int targetIndex = rx * 4 + y * 2 + rz;
                    rotated[targetIndex] = base.blocks()[index++];
                }
            }
        }
        Pattern rotatedPattern = new Pattern(newId, rotated, base.weight());
        rotatedPattern.setSocket(Direction.UP, base.socket(Direction.UP));
        rotatedPattern.setSocket(Direction.DOWN, base.socket(Direction.DOWN));
        rotatedPattern.setSocket(Direction.NORTH, base.socket(Direction.WEST));
        rotatedPattern.setSocket(Direction.EAST, base.socket(Direction.NORTH));
        rotatedPattern.setSocket(Direction.SOUTH, base.socket(Direction.EAST));
        rotatedPattern.setSocket(Direction.WEST, base.socket(Direction.SOUTH));
        return rotatedPattern;
    }

    private ThemeMaterials resolveTheme(String themeName) {
        String key = themeName != null ? themeName.toLowerCase() : "crypt";
        ConfigurationSection section = plugin.getConfig().getConfigurationSection("dungeon.themes." + key);
        Material floor = readMaterial(section, "floor_material", Material.STONE_BRICKS);
        Material wall = readMaterial(section, "wall_material", Material.COBBLESTONE);
        Material corridor = readMaterial(section, "corridor_material", Material.COBBLESTONE);
        return new ThemeMaterials(floor, wall, corridor);
    }

    private Material readMaterial(ConfigurationSection section, String path, Material fallback) {
        if (section == null) {
            return fallback;
        }
        String raw = section.getString(path, fallback.name());
        Material material = Material.matchMaterial(raw);
        return material != null ? material : fallback;
    }

    private record ThemeMaterials(Material floor, Material wall, Material corridor) {}
}

```

## File: `src/main/java/com/example/rpg/dungeon/wfc/WaveGrid.java`  
- Path: `src/main/java/com/example/rpg/dungeon/wfc/WaveGrid.java`  
- Size: 1347 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.wfc;

import java.util.ArrayList;
import java.util.List;

public class WaveGrid {
    private final List<Pattern>[][][] possibilities;
    private final boolean[][][] collapsed;

    @SuppressWarnings("unchecked")
    public WaveGrid(int width, int height, int depth, List<Pattern> initial) {
        possibilities = new List[width][height][depth];
        collapsed = new boolean[width][height][depth];
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                for (int z = 0; z < depth; z++) {
                    possibilities[x][y][z] = new ArrayList<>(initial);
                }
            }
        }
    }

    public List<Pattern> possibilities(int x, int y, int z) {
        return possibilities[x][y][z];
    }

    public void setPossibilities(int x, int y, int z, List<Pattern> list) {
        possibilities[x][y][z] = list;
    }

    public boolean collapsed(int x, int y, int z) {
        return collapsed[x][y][z];
    }

    public void setCollapsed(int x, int y, int z, boolean value) {
        collapsed[x][y][z] = value;
    }

    public int width() {
        return possibilities.length;
    }

    public int height() {
        return possibilities[0].length;
    }

    public int depth() {
        return possibilities[0][0].length;
    }
}

```

## File: `src/main/java/com/example/rpg/dungeon/wfc/WfcGenerator.java`  
- Path: `src/main/java/com/example/rpg/dungeon/wfc/WfcGenerator.java`  
- Size: 6089 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.dungeon.wfc;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.Random;
import java.util.concurrent.CompletableFuture;
import org.bukkit.plugin.java.JavaPlugin;

public class WfcGenerator {
    private final PatternLoader patternLoader;
    private final Random random = new Random();

    public WfcGenerator(JavaPlugin plugin) {
        this.patternLoader = new PatternLoader(plugin);
    }

    public CompletableFuture<Pattern[][][]> generate(String themeName, int width, int height, int depth) {
        return CompletableFuture.supplyAsync(() -> {
            List<Pattern> patterns = patternLoader.loadPatterns(themeName);
            for (int attempt = 0; attempt < 5; attempt++) {
                Pattern[][][] result = runAttempt(width, height, depth, patterns);
                if (result != null) {
                    return result;
                }
            }
            return null;
        });
    }

    private Pattern[][][] runAttempt(int width, int height, int depth, List<Pattern> patterns) {
        WaveGrid grid = new WaveGrid(width, height, depth, patterns);
        while (true) {
            int[] cell = findLowestEntropyCell(grid);
            if (cell == null) {
                break;
            }
            int x = cell[0];
            int y = cell[1];
            int z = cell[2];
            Pattern chosen = pickWeighted(grid.possibilities(x, y, z));
            grid.setPossibilities(x, y, z, List.of(chosen));
            grid.setCollapsed(x, y, z, true);
            if (!propagate(grid, x, y, z)) {
                return null;
            }
        }
        Pattern[][][] patternsResult = new Pattern[width][height][depth];
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                for (int z = 0; z < depth; z++) {
                    List<Pattern> options = grid.possibilities(x, y, z);
                    patternsResult[x][y][z] = options.isEmpty() ? null : options.get(0);
                }
            }
        }
        return patternsResult;
    }

    private int[] findLowestEntropyCell(WaveGrid grid) {
        int bestX = -1;
        int bestY = -1;
        int bestZ = -1;
        int bestEntropy = Integer.MAX_VALUE;
        for (int x = 0; x < grid.width(); x++) {
            for (int y = 0; y < grid.height(); y++) {
                for (int z = 0; z < grid.depth(); z++) {
                    if (grid.collapsed(x, y, z)) {
                        continue;
                    }
                    int size = grid.possibilities(x, y, z).size();
                    if (size == 0) {
                        return new int[] {x, y, z};
                    }
                    if (size < bestEntropy) {
                        bestEntropy = size;
                        bestX = x;
                        bestY = y;
                        bestZ = z;
                    }
                }
            }
        }
        if (bestX == -1) {
            return null;
        }
        return new int[] {bestX, bestY, bestZ};
    }

    private Pattern pickWeighted(List<Pattern> options) {
        double total = options.stream().mapToDouble(Pattern::weight).sum();
        double roll = random.nextDouble() * total;
        double current = 0;
        for (Pattern pattern : options) {
            current += pattern.weight();
            if (roll <= current) {
                return pattern;
            }
        }
        return options.get(0);
    }

    private boolean propagate(WaveGrid grid, int startX, int startY, int startZ) {
        Queue<int[]> queue = new ArrayDeque<>();
        queue.add(new int[] {startX, startY, startZ});
        while (!queue.isEmpty()) {
            int[] cell = queue.poll();
            int x = cell[0];
            int y = cell[1];
            int z = cell[2];
            for (Direction direction : Direction.values()) {
                int nx = x + offsetX(direction);
                int ny = y + offsetY(direction);
                int nz = z + offsetZ(direction);
                if (!inside(grid, nx, ny, nz)) {
                    continue;
                }
                List<Pattern> neighborOptions = grid.possibilities(nx, ny, nz);
                List<Pattern> filtered = new ArrayList<>();
                for (Pattern option : neighborOptions) {
                    if (compatible(grid.possibilities(x, y, z), option, direction)) {
                        filtered.add(option);
                    }
                }
                if (filtered.isEmpty()) {
                    return false;
                }
                if (filtered.size() != neighborOptions.size()) {
                    grid.setPossibilities(nx, ny, nz, filtered);
                    queue.add(new int[] {nx, ny, nz});
                }
            }
        }
        return true;
    }

    private boolean compatible(List<Pattern> sourceOptions, Pattern neighbor, Direction direction) {
        for (Pattern source : sourceOptions) {
            String socketA = source.socket(direction);
            String socketB = neighbor.socket(direction.opposite());
            if (socketA.equals(socketB)) {
                return true;
            }
        }
        return false;
    }

    private boolean inside(WaveGrid grid, int x, int y, int z) {
        return x >= 0 && x < grid.width()
            && y >= 0 && y < grid.height()
            && z >= 0 && z < grid.depth();
    }

    private int offsetX(Direction direction) {
        return switch (direction) {
            case EAST -> 1;
            case WEST -> -1;
            default -> 0;
        };
    }

    private int offsetY(Direction direction) {
        return switch (direction) {
            case UP -> 1;
            case DOWN -> -1;
            default -> 0;
        };
    }

    private int offsetZ(Direction direction) {
        return switch (direction) {
            case SOUTH -> 1;
            case NORTH -> -1;
            default -> 0;
        };
    }
}

```

## File: `src/main/java/com/example/rpg/gui/BehaviorTreeEditorGui.java`  
- Path: `src/main/java/com/example/rpg/gui/BehaviorTreeEditorGui.java`  
- Size: 1785 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.gui;

import com.example.rpg.RPGPlugin;
import com.example.rpg.util.ItemBuilder;
import com.example.rpg.util.Text;
import net.kyori.adventure.text.Component;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;

public class BehaviorTreeEditorGui {
    private final RPGPlugin plugin;

    public BehaviorTreeEditorGui(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    public void open(Player player, String treeName) {
        Inventory inventory = Bukkit.createInventory(new GuiHolders.BehaviorTreeEditorHolder(treeName), 27,
            Component.text("Behavior Editor: " + treeName));

        inventory.setItem(10, new ItemBuilder(Material.TOTEM_OF_UNDYING)
            .name(Text.mm("<gold>Notfall-Heilung"))
            .loreLine(Text.mm("<gray>health_below + shield_wall + heal_self"))
            .loreLine(Text.mm("<yellow>Klick, um Parameter einzugeben"))
            .build());

        inventory.setItem(12, new ItemBuilder(Material.BLAZE_ROD)
            .name(Text.mm("<red>Fernkampf-Phase"))
            .loreLine(Text.mm("<gray>target_distance_above + cast_skill"))
            .loreLine(Text.mm("<yellow>Klick, um Parameter einzugeben"))
            .build());

        inventory.setItem(14, new ItemBuilder(Material.IRON_SWORD)
            .name(Text.mm("<green>Nahkampf"))
            .loreLine(Text.mm("<gray>melee_attack"))
            .loreLine(Text.mm("<yellow>Klick, um hinzuzufgen"))
            .build());

        inventory.setItem(16, new ItemBuilder(Material.BARRIER)
            .name(Text.mm("<red>Zurcksetzen"))
            .loreLine(Text.mm("<gray>Leert den Baum"))
            .build());

        player.openInventory(inventory);
    }
}

```

## File: `src/main/java/com/example/rpg/gui/GuiHolders.java`  
- Path: `src/main/java/com/example/rpg/gui/GuiHolders.java`  
- Size: 11055 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.gui;

import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.InventoryHolder;
import org.jetbrains.annotations.NotNull;

/**
 * Robuste Identifikation von GUIs:
 * Nicht ber Inventory-Titel (anfllig fr Farbe/Locale),
 * sondern ber InventoryHolder-Typen.
 */
public final class GuiHolders {
    private GuiHolders() {}

    public static final class PlayerMenuHolder implements InventoryHolder {
        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class AdminMenuHolder implements InventoryHolder {
        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class ZoneEditorHolder implements InventoryHolder {
        private final int page;

        public ZoneEditorHolder(int page) {
            this.page = page;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class NpcEditorHolder implements InventoryHolder {
        private final int page;

        public NpcEditorHolder(int page) {
            this.page = page;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class QuestEditorHolder implements InventoryHolder {
        private final int page;

        public QuestEditorHolder(int page) {
            this.page = page;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class LootEditorHolder implements InventoryHolder {
        private final int page;

        public LootEditorHolder(int page) {
            this.page = page;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class SkillAdminHolder implements InventoryHolder {
        private final int page;

        public SkillAdminHolder(int page) {
            this.page = page;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class ClassAdminHolder implements InventoryHolder {
        private final int page;

        public ClassAdminHolder(int page) {
            this.page = page;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class QuestListHolder implements InventoryHolder {
        private final int page;

        public QuestListHolder(int page) {
            this.page = page;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class QuestLogHolder implements InventoryHolder {
        private final int page;

        public QuestLogHolder(int page) {
            this.page = page;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class QuestDetailHolder implements InventoryHolder {
        private final String questId;
        private final boolean active;
        private final int page;

        public QuestDetailHolder(String questId, boolean active, int page) {
            this.questId = questId;
            this.active = active;
            this.page = page;
        }

        public String questId() {
            return questId;
        }

        public boolean active() {
            return active;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class SkillListHolder implements InventoryHolder {
        private final int page;

        public SkillListHolder(int page) {
            this.page = page;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class SkillTreeHolder implements InventoryHolder {
        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class BuildingCategoryHolder implements InventoryHolder {
        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class BuildingListHolder implements InventoryHolder {
        private final String category;
        private final int page;

        public BuildingListHolder(String category, int page) {
            this.category = category;
            this.page = page;
        }

        public String category() {
            return category;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class BehaviorTreeEditorHolder implements InventoryHolder {
        private final String treeName;

        public BehaviorTreeEditorHolder(String treeName) {
            this.treeName = treeName;
        }

        public String treeName() {
            return treeName;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class ShopHolder implements InventoryHolder {
        private final String shopId;

        public ShopHolder(String shopId) {
            this.shopId = shopId;
        }

        public String shopId() {
            return shopId;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class SchematicMoveHolder implements InventoryHolder {
        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class PermissionsMainHolder implements InventoryHolder {
        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class RoleListHolder implements InventoryHolder {
        private final int page;

        public RoleListHolder(int page) {
            this.page = page;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class RoleDetailHolder implements InventoryHolder {
        private final String roleKey;

        public RoleDetailHolder(String roleKey) {
            this.roleKey = roleKey;
        }

        public String roleKey() {
            return roleKey;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class RoleNodesHolder implements InventoryHolder {
        private final String roleKey;
        private final int page;

        public RoleNodesHolder(String roleKey, int page) {
            this.roleKey = roleKey;
            this.page = page;
        }

        public String roleKey() {
            return roleKey;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class RoleParentsHolder implements InventoryHolder {
        private final String roleKey;

        public RoleParentsHolder(String roleKey) {
            this.roleKey = roleKey;
        }

        public String roleKey() {
            return roleKey;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class PlayerListHolder implements InventoryHolder {
        private final int page;

        public PlayerListHolder(int page) {
            this.page = page;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class PlayerRoleHolder implements InventoryHolder {
        private final java.util.UUID targetId;

        public PlayerRoleHolder(java.util.UUID targetId) {
            this.targetId = targetId;
        }

        public java.util.UUID targetId() {
            return targetId;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class PermissionAuditHolder implements InventoryHolder {
        private final int page;

        public PermissionAuditHolder(int page) {
            this.page = page;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }

    public static final class EnchantingHolder implements InventoryHolder {
        private final String recipeId;
        private final int page;

        public EnchantingHolder(String recipeId, int page) {
            this.recipeId = recipeId;
            this.page = page;
        }

        public String recipeId() {
            return recipeId;
        }

        public int page() {
            return page;
        }

        @Override
        public @NotNull Inventory getInventory() {
            throw new UnsupportedOperationException();
        }
    }
}

```

## File: `src/main/java/com/example/rpg/gui/GuiManager.java`  
- Path: `src/main/java/com/example/rpg/gui/GuiManager.java`  
- Size: 57040 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.gui;

import com.example.rpg.manager.ClassManager;
import com.example.rpg.manager.FactionManager;
import com.example.rpg.manager.PlayerDataManager;
import com.example.rpg.manager.QuestManager;
import com.example.rpg.manager.WorldEventManager;
import com.example.rpg.manager.BuildingManager;
import com.example.rpg.manager.SkillManager;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.model.Quest;
import com.example.rpg.model.QuestProgress;
import com.example.rpg.model.QuestStep;
import com.example.rpg.model.Rarity;
import com.example.rpg.model.ShopDefinition;
import com.example.rpg.model.ShopItem;
import com.example.rpg.model.BuildingCategory;
import com.example.rpg.model.BuildingDefinition;
import com.example.rpg.model.ClassDefinition;
import com.example.rpg.model.LootTable;
import com.example.rpg.model.Npc;
import com.example.rpg.model.Skill;
import com.example.rpg.util.ItemGenerator;
import com.example.rpg.util.ItemBuilder;
import com.example.rpg.util.Text;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import net.kyori.adventure.text.Component;
import org.bukkit.NamespacedKey;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataType;

public class GuiManager {
    private final PlayerDataManager playerDataManager;
    private final QuestManager questManager;
    private final WorldEventManager worldEventManager;
    private final SkillManager skillManager;
    private final ClassManager classManager;
    private final FactionManager factionManager;
    private final BuildingManager buildingManager;
    private final com.example.rpg.permissions.PermissionService permissionService;
    private final com.example.rpg.manager.EnchantManager enchantManager;
    private final com.example.rpg.manager.ItemStatManager itemStatManager;
    private final ItemGenerator itemGenerator;
    private final NamespacedKey questKey;
    private final NamespacedKey skillKey;
    private final NamespacedKey buildingKey;
    private final NamespacedKey buildingCategoryKey;
    private final NamespacedKey zoneKey;
    private final NamespacedKey npcKey;
    private final NamespacedKey npcTemplateKey;
    private final NamespacedKey lootKey;
    private final NamespacedKey classKey;
    private final NamespacedKey permRoleKey;
    private final NamespacedKey permPlayerKey;
    private final NamespacedKey permNodeKey;
    private final NamespacedKey permActionKey;
    private final NamespacedKey enchantRecipeKey;

    public GuiManager(PlayerDataManager playerDataManager, QuestManager questManager, WorldEventManager worldEventManager,
                      SkillManager skillManager, ClassManager classManager, FactionManager factionManager,
                      BuildingManager buildingManager, com.example.rpg.permissions.PermissionService permissionService,
                      com.example.rpg.manager.EnchantManager enchantManager, com.example.rpg.manager.ItemStatManager itemStatManager,
                      ItemGenerator itemGenerator,
                      NamespacedKey questKey, NamespacedKey skillKey, NamespacedKey buildingKey, NamespacedKey buildingCategoryKey,
                      NamespacedKey zoneKey, NamespacedKey npcKey, NamespacedKey npcTemplateKey, NamespacedKey lootKey, NamespacedKey classKey,
                      NamespacedKey permRoleKey, NamespacedKey permPlayerKey, NamespacedKey permNodeKey, NamespacedKey permActionKey,
                      NamespacedKey enchantRecipeKey) {
        this.playerDataManager = playerDataManager;
        this.questManager = questManager;
        this.worldEventManager = worldEventManager;
        this.skillManager = skillManager;
        this.classManager = classManager;
        this.factionManager = factionManager;
        this.buildingManager = buildingManager;
        this.permissionService = permissionService;
        this.enchantManager = enchantManager;
        this.itemStatManager = itemStatManager;
        this.itemGenerator = itemGenerator;
        this.questKey = questKey;
        this.skillKey = skillKey;
        this.buildingKey = buildingKey;
        this.buildingCategoryKey = buildingCategoryKey;
        this.zoneKey = zoneKey;
        this.npcKey = npcKey;
        this.npcTemplateKey = npcTemplateKey;
        this.lootKey = lootKey;
        this.classKey = classKey;
        this.permRoleKey = permRoleKey;
        this.permPlayerKey = permPlayerKey;
        this.permNodeKey = permNodeKey;
        this.permActionKey = permActionKey;
        this.enchantRecipeKey = enchantRecipeKey;
    }

    public void openPlayerMenu(Player player) {
        Inventory inv = Bukkit.createInventory(new GuiHolders.PlayerMenuHolder(), 27, Component.text("RPG Men"));
        PlayerProfile profile = playerDataManager.getProfile(player);

        Map<com.example.rpg.model.RPGStat, Integer> totalStats = profile.totalStats(player, itemStatManager, classManager);
        inv.setItem(10, new ItemBuilder(Material.PLAYER_HEAD)
            .name(Text.mm("<gold>Charakter"))
            .loreLine(Text.mm("<gray>Level: <white>" + profile.level()))
            .loreLine(Text.mm("<gray>XP: <white>" + profile.xp() + "/" + profile.xpNeeded()))
            .loreLine(Text.mm("<gray>Klasse: <white>" + resolveClassName(profile.classId())))
            .loreLine(Text.mm("<gray>Gelernte Skills: <white>" + profile.learnedSkills().size()))
            .loreLine(Text.mm("<gray>Skillpunkte: <white>" + profile.skillPoints()))
            .loreLine(Text.mm("<gray>Strke: <white>" + totalStats.getOrDefault(com.example.rpg.model.RPGStat.STRENGTH, 0)))
            .loreLine(Text.mm("<gray>Geschick: <white>" + totalStats.getOrDefault(com.example.rpg.model.RPGStat.DEXTERITY, 0)))
            .loreLine(Text.mm("<gray>Konstitution: <white>" + totalStats.getOrDefault(com.example.rpg.model.RPGStat.CONSTITUTION, 0)))
            .loreLine(Text.mm("<gray>Intelligenz: <white>" + totalStats.getOrDefault(com.example.rpg.model.RPGStat.INTELLIGENCE, 0)))
            .build());

        inv.setItem(12, new ItemBuilder(Material.NETHER_STAR)
            .name(Text.mm("<aqua>Skills"))
            .loreLine(Text.mm("<gray>Skillpunkte: <white>" + profile.skillPoints()))
            .build());

        inv.setItem(14, new ItemBuilder(Material.WRITABLE_BOOK)
            .name(Text.mm("<green>Quest-Log"))
            .loreLine(Text.mm("<gray>Aktiv: <white>" + profile.activeQuests().size()))
            .loreLine(Text.mm("<gray>Details zu angenommenen Quests"))
            .build());

        inv.setItem(15, new ItemBuilder(Material.BOOK)
            .name(Text.mm("<yellow>Quest-Angebote"))
            .loreLine(Text.mm("<gray>Neue Quests ansehen"))
            .build());

        inv.setItem(16, new ItemBuilder(Material.EMERALD)
            .name(Text.mm("<yellow>Fraktionen"))
            .loreLine(Text.mm("<gray>Ruf verwalten"))
            .loreLine(Text.mm("<gray>Aktiv: <white>" + profile.factionRep().size() + "/" + factionManager.factions().size()))
            .build());

        player.openInventory(inv);
    }

    public void openAdminMenu(Player player) {
        Inventory inv = Bukkit.createInventory(new GuiHolders.AdminMenuHolder(), 27, Component.text("RPG Admin"));
        inv.setItem(10, new ItemBuilder(Material.COMPASS)
            .name(Text.mm("<gold>Zonen-Editor"))
            .loreLine(Text.mm("<gray>Regionen verwalten"))
            .build());
        inv.setItem(11, new ItemBuilder(Material.VILLAGER_SPAWN_EGG)
            .name(Text.mm("<green>NPC-Editor"))
            .loreLine(Text.mm("<gray>NPCs platzieren"))
            .build());
        inv.setItem(12, new ItemBuilder(Material.WRITABLE_BOOK)
            .name(Text.mm("<aqua>Quest-Editor"))
            .loreLine(Text.mm("<gray>Quests erstellen"))
            .build());
        inv.setItem(13, new ItemBuilder(Material.CHEST)
            .name(Text.mm("<yellow>Loot-Tabellen"))
            .loreLine(Text.mm("<gray>Loot konfigurieren"))
            .build());
        inv.setItem(14, new ItemBuilder(Material.BLAZE_POWDER)
            .name(Text.mm("<light_purple>Skills & Klassen"))
            .loreLine(Text.mm("<gray>Skills verwalten"))
            .build());
        inv.setItem(15, new ItemBuilder(Material.REDSTONE)
            .name(Text.mm("<red>Debug Overlay"))
            .loreLine(Text.mm("<gray>Region/Quest Debug"))
            .build());
        inv.setItem(16, new ItemBuilder(Material.BRICKS)
            .name(Text.mm("<gold>Bau-Manager"))
            .loreLine(Text.mm("<gray>Gebude platzieren"))
            .build());
        inv.setItem(17, new ItemBuilder(Material.NAME_TAG)
            .name(Text.mm("<aqua>Permissions"))
            .loreLine(Text.mm("<gray>Rollen & Rechte verwalten"))
            .build());
        player.openInventory(inv);
    }

    public void openZoneEditor(Player player) {
        openZoneEditor(player, 0);
    }

    public void openZoneEditor(Player player, int page) {
        var zones = new java.util.ArrayList<>(com.example.rpg.RPGPlugin.getPlugin(com.example.rpg.RPGPlugin.class)
            .zoneManager().zones().values());
        zones.sort(java.util.Comparator.comparing(com.example.rpg.model.Zone::id));
        int pageSize = 45;
        int maxPage = zones.isEmpty() ? 0 : (zones.size() - 1) / pageSize;
        int safePage = Math.min(Math.max(page, 0), maxPage);
        Inventory inv = Bukkit.createInventory(new GuiHolders.ZoneEditorHolder(safePage), 54, Component.text("Zonen-Editor"));
        int slot = 0;
        int startIndex = safePage * pageSize;
        for (int i = startIndex; i < zones.size() && slot < pageSize; i++) {
            var zone = zones.get(i);
            ItemStack item = new ItemBuilder(Material.MAP)
                .name(Text.mm("<gold>" + zone.name()))
                .loreLine(Text.mm("<gray>ID: <white>" + zone.id()))
                .loreLine(Text.mm("<gray>World: <white>" + zone.world()))
                .loreLine(Text.mm("<gray>Level: <white>" + zone.minLevel() + "-" + zone.maxLevel()))
                .loreLine(Text.mm("<gray>Mod: <white>" + zone.slowMultiplier() + " / " + zone.damageMultiplier()))
                .loreLine(Text.mm("<yellow>Klick: bearbeiten"))
                .loreLine(Text.mm("<red>Rechtsklick: lschen"))
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(zoneKey, PersistentDataType.STRING, zone.id());
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(45, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Vorherige Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        inv.setItem(49, new ItemBuilder(Material.EMERALD_BLOCK)
            .name(Text.mm("<green>Zone erstellen"))
            .loreLine(Text.mm("<gray>Nutze die Wand (Pos1/Pos2)"))
            .build());
        inv.setItem(50, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Seite " + (safePage + 1) + "/" + (maxPage + 1)))
            .build());
        inv.setItem(53, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Nchste Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        player.openInventory(inv);
    }

    public void openNpcEditor(Player player) {
        openNpcEditor(player, 0);
    }

    public void openNpcEditor(Player player, int page) {
        var npcs = new java.util.ArrayList<>(com.example.rpg.RPGPlugin.getPlugin(com.example.rpg.RPGPlugin.class)
            .npcManager().npcs().values());
        npcs.sort(java.util.Comparator.comparing(Npc::id));
        int pageSize = 36;
        int maxPage = npcs.isEmpty() ? 0 : (npcs.size() - 1) / pageSize;
        int safePage = Math.min(Math.max(page, 0), maxPage);
        Inventory inv = Bukkit.createInventory(new GuiHolders.NpcEditorHolder(safePage), 54, Component.text("NPC-Editor"));
        int slot = 0;
        int startIndex = safePage * pageSize;
        for (int i = startIndex; i < npcs.size() && slot < pageSize; i++) {
            var npc = npcs.get(i);
            ItemStack item = new ItemBuilder(Material.VILLAGER_SPAWN_EGG)
                .name(Text.mm("<green>" + npc.name()))
                .loreLine(Text.mm("<gray>ID: <white>" + npc.id()))
                .loreLine(Text.mm("<gray>Rolle: <white>" + npc.role()))
                .loreLine(Text.mm("<gray>Quest: <white>" + (npc.questLink() != null ? npc.questLink() : "-")))
                .loreLine(Text.mm("<gray>Shop: <white>" + (npc.shopId() != null ? npc.shopId() : "-")))
                .loreLine(Text.mm("<yellow>Klick: bearbeiten"))
                .loreLine(Text.mm("<red>Rechtsklick: lschen"))
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(npcKey, PersistentDataType.STRING, npc.id());
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(36, buildNpcTemplate(Material.WRITABLE_BOOK, "<gold>Questgiver",
            com.example.rpg.model.NpcRole.QUESTGIVER, "<gray>Quest-NPC erstellen"));
        inv.setItem(37, buildNpcTemplate(Material.CHEST, "<yellow>Shop (shops.yml)",
            com.example.rpg.model.NpcRole.VENDOR, "<gray>Shop-ID wird abgefragt"));
        inv.setItem(38, buildNpcTemplate(Material.IRON_SWORD, "<red>Waffenhndler",
            com.example.rpg.model.NpcRole.WEAPON_VENDOR, "<gray>Alle Waffen kaufen/verkaufen"));
        inv.setItem(39, buildNpcTemplate(Material.DIAMOND_CHESTPLATE, "<blue>Rstungshndler",
            com.example.rpg.model.NpcRole.ARMOR_VENDOR, "<gray>Alle Rstungen kaufen/verkaufen"));
        inv.setItem(40, buildNpcTemplate(Material.APPLE, "<green>Gegenstandshndler",
            com.example.rpg.model.NpcRole.ITEM_VENDOR, "<gray>Items & Verbrauchsgter"));
        inv.setItem(41, buildNpcTemplate(Material.EMERALD, "<aqua>Rohstoffhndler",
            com.example.rpg.model.NpcRole.RESOURCE_VENDOR, "<gray>Erze & Rohstoffe"));
        inv.setItem(45, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Vorherige Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        inv.setItem(49, new ItemBuilder(Material.EMERALD_BLOCK)
            .name(Text.mm("<green>NPC erstellen"))
            .loreLine(Text.mm("<gray>Erstellt an deiner Position"))
            .build());
        inv.setItem(50, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Seite " + (safePage + 1) + "/" + (maxPage + 1)))
            .build());
        inv.setItem(53, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Nchste Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        player.openInventory(inv);
    }

    private ItemStack buildNpcTemplate(Material material, String name, com.example.rpg.model.NpcRole role, String lore) {
        ItemStack item = new ItemBuilder(material)
            .name(Text.mm(name))
            .loreLine(Text.mm(lore))
            .loreLine(Text.mm("<yellow>Klick: Vorlage nutzen"))
            .build();
        ItemMeta meta = item.getItemMeta();
        meta.getPersistentDataContainer().set(npcTemplateKey, PersistentDataType.STRING, role.name());
        item.setItemMeta(meta);
        return item;
    }

    public void openQuestEditor(Player player) {
        openQuestEditor(player, 0);
    }

    public void openQuestEditor(Player player, int page) {
        var quests = new java.util.ArrayList<>(questManager.quests().values());
        quests.sort(java.util.Comparator.comparing(Quest::id));
        int pageSize = 45;
        int maxPage = quests.isEmpty() ? 0 : (quests.size() - 1) / pageSize;
        int safePage = Math.min(Math.max(page, 0), maxPage);
        Inventory inv = Bukkit.createInventory(new GuiHolders.QuestEditorHolder(safePage), 54, Component.text("Quest-Editor"));
        int slot = 0;
        int startIndex = safePage * pageSize;
        for (int i = startIndex; i < quests.size() && slot < pageSize; i++) {
            Quest quest = quests.get(i);
            ItemStack item = new ItemBuilder(Material.BOOK)
                .name(Text.mm("<aqua>" + quest.name()))
                .loreLine(Text.mm("<gray>ID: <white>" + quest.id()))
                .loreLine(Text.mm("<gray>Level: <white>" + quest.minLevel()))
                .loreLine(Text.mm("<gray>Repeatable: <white>" + quest.repeatable()))
                .loreLine(Text.mm("<yellow>Klick: bearbeiten"))
                .loreLine(Text.mm("<red>Rechtsklick: lschen"))
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(questKey, PersistentDataType.STRING, quest.id());
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(45, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Vorherige Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        inv.setItem(49, new ItemBuilder(Material.EMERALD_BLOCK)
            .name(Text.mm("<green>Quest erstellen"))
            .build());
        inv.setItem(50, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Seite " + (safePage + 1) + "/" + (maxPage + 1)))
            .build());
        inv.setItem(53, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Nchste Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        player.openInventory(inv);
    }

    public void openLootEditor(Player player) {
        openLootEditor(player, 0);
    }

    public void openLootEditor(Player player, int page) {
        var tables = new java.util.ArrayList<>(com.example.rpg.RPGPlugin.getPlugin(com.example.rpg.RPGPlugin.class)
            .lootManager().tables().values());
        tables.sort(java.util.Comparator.comparing(LootTable::id));
        int pageSize = 45;
        int maxPage = tables.isEmpty() ? 0 : (tables.size() - 1) / pageSize;
        int safePage = Math.min(Math.max(page, 0), maxPage);
        Inventory inv = Bukkit.createInventory(new GuiHolders.LootEditorHolder(safePage), 54, Component.text("Loot-Tabellen"));
        int slot = 0;
        int startIndex = safePage * pageSize;
        for (int i = startIndex; i < tables.size() && slot < pageSize; i++) {
            var table = tables.get(i);
            ItemStack item = new ItemBuilder(Material.CHEST)
                .name(Text.mm("<yellow>" + table.id()))
                .loreLine(Text.mm("<gray>Applies: <white>" + table.appliesTo()))
                .loreLine(Text.mm("<gray>Entries: <white>" + table.entries().size()))
                .loreLine(Text.mm("<yellow>Klick: bearbeiten"))
                .loreLine(Text.mm("<red>Rechtsklick: lschen"))
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(lootKey, PersistentDataType.STRING, table.id());
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(45, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Vorherige Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        inv.setItem(49, new ItemBuilder(Material.EMERALD_BLOCK)
            .name(Text.mm("<green>Loot-Tabelle erstellen"))
            .build());
        inv.setItem(50, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Seite " + (safePage + 1) + "/" + (maxPage + 1)))
            .build());
        inv.setItem(53, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Nchste Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        player.openInventory(inv);
    }

    public void openSkillAdmin(Player player) {
        openSkillAdmin(player, 0);
    }

    public void openSkillAdmin(Player player, int page) {
        var skills = new java.util.ArrayList<>(skillManager.skills().values());
        skills.sort(java.util.Comparator.comparing(Skill::id));
        int pageSize = 45;
        int maxPage = skills.isEmpty() ? 0 : (skills.size() - 1) / pageSize;
        int safePage = Math.min(Math.max(page, 0), maxPage);
        Inventory inv = Bukkit.createInventory(new GuiHolders.SkillAdminHolder(safePage), 54, Component.text("Skills verwalten"));
        int slot = 0;
        int startIndex = safePage * pageSize;
        for (int i = startIndex; i < skills.size() && slot < pageSize; i++) {
            var skill = skills.get(i);
            ItemStack item = new ItemBuilder(Material.ENCHANTED_BOOK)
                .name(Text.mm("<light_purple>" + skill.name()))
                .loreLine(Text.mm("<gray>ID: <white>" + skill.id()))
                .loreLine(Text.mm("<gray>Typ: <white>" + skill.type()))
                .loreLine(Text.mm("<gray>Kategorie: <white>" + skill.category()))
                .loreLine(Text.mm("<yellow>Klick: bearbeiten"))
                .loreLine(Text.mm("<red>Rechtsklick: lschen"))
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(skillKey, PersistentDataType.STRING, skill.id());
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(45, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Vorherige Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        inv.setItem(48, new ItemBuilder(Material.WRITABLE_BOOK)
            .name(Text.mm("<aqua>Klassen verwalten"))
            .loreLine(Text.mm("<yellow>Klick: ffnen"))
            .build());
        inv.setItem(49, new ItemBuilder(Material.EMERALD_BLOCK)
            .name(Text.mm("<green>Skill erstellen"))
            .build());
        inv.setItem(50, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Seite " + (safePage + 1) + "/" + (maxPage + 1)))
            .build());
        inv.setItem(53, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Nchste Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        player.openInventory(inv);
    }

    public void openClassAdmin(Player player) {
        openClassAdmin(player, 0);
    }

    public void openClassAdmin(Player player, int page) {
        var classes = new java.util.ArrayList<>(classManager.classes().values());
        classes.sort(java.util.Comparator.comparing(ClassDefinition::id));
        int pageSize = 45;
        int maxPage = classes.isEmpty() ? 0 : (classes.size() - 1) / pageSize;
        int safePage = Math.min(Math.max(page, 0), maxPage);
        Inventory inv = Bukkit.createInventory(new GuiHolders.ClassAdminHolder(safePage), 54, Component.text("Klassen verwalten"));
        int slot = 0;
        int startIndex = safePage * pageSize;
        for (int i = startIndex; i < classes.size() && slot < pageSize; i++) {
            var definition = classes.get(i);
            ItemStack item = new ItemBuilder(Material.BOOKSHELF)
                .name(Text.mm("<gold>" + definition.name()))
                .loreLine(Text.mm("<gray>ID: <white>" + definition.id()))
                .loreLine(Text.mm("<gray>Startskills: <white>" + String.join(", ", definition.startSkills())))
                .loreLine(Text.mm("<yellow>Klick: bearbeiten"))
                .loreLine(Text.mm("<red>Rechtsklick: lschen"))
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(classKey, PersistentDataType.STRING, definition.id());
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(45, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Vorherige Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        inv.setItem(49, new ItemBuilder(Material.EMERALD_BLOCK)
            .name(Text.mm("<green>Klasse erstellen"))
            .build());
        inv.setItem(50, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Seite " + (safePage + 1) + "/" + (maxPage + 1)))
            .build());
        inv.setItem(53, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Nchste Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        player.openInventory(inv);
    }

    public void openBuildingCategories(Player player) {
        Inventory inv = Bukkit.createInventory(new GuiHolders.BuildingCategoryHolder(), 27, Component.text("Gebude Kategorien"));
        int slot = 10;
        for (BuildingCategory category : BuildingCategory.values()) {
            ItemStack item = new ItemBuilder(Material.BOOKSHELF)
                .name(Text.mm("<yellow>" + category.displayName()))
                .loreLine(Text.mm("<gray>Kategorie ffnen"))
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(buildingCategoryKey, PersistentDataType.STRING, category.name());
            item.setItemMeta(meta);
            inv.setItem(slot, item);
            slot += 2;
        }
        ItemStack single = new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Einzel-Schema"))
            .loreLine(Text.mm("<gray>Nur ein Schema platzieren"))
            .build();
        ItemMeta singleMeta = single.getItemMeta();
        singleMeta.getPersistentDataContainer().set(buildingCategoryKey, PersistentDataType.STRING, "SINGLE");
        single.setItemMeta(singleMeta);
        inv.setItem(22, single);
        player.openInventory(inv);
    }

    public void openBuildingList(Player player, BuildingCategory category) {
        openBuildingList(player, category, 0);
    }

    public void openBuildingList(Player player, BuildingCategory category, int page) {
        var buildings = new java.util.ArrayList<>(buildingManager.byCategory().getOrDefault(category, List.of()));
        buildings.sort(java.util.Comparator.comparing(BuildingDefinition::id));
        int pageSize = 45;
        int maxPage = buildings.isEmpty() ? 0 : (buildings.size() - 1) / pageSize;
        int safePage = Math.min(Math.max(page, 0), maxPage);
        Inventory inv = Bukkit.createInventory(new GuiHolders.BuildingListHolder(category.name(), safePage), 54,
            Component.text(category.displayName()));
        int slot = 0;
        int startIndex = safePage * pageSize;
        for (int i = startIndex; i < buildings.size() && slot < pageSize; i++) {
            BuildingDefinition building = buildings.get(i);
            ItemStack item = new ItemBuilder(Material.OAK_DOOR)
                .name(Text.mm("<green>" + building.name()))
                .loreLine(Text.mm("<gray>ID: <white>" + building.id()))
                .loreLine(Text.mm("<yellow>Klick: platzieren"))
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(buildingKey, PersistentDataType.STRING, building.id());
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(45, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Vorherige Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        inv.setItem(50, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Seite " + (safePage + 1) + "/" + (maxPage + 1)))
            .build());
        inv.setItem(53, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Nchste Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        player.openInventory(inv);
    }

    public void openQuestList(Player player) {
        openQuestList(player, 0);
    }

    public void openQuestList(Player player, int page) {
        var quests = questManager.quests().values().stream()
            .filter(quest -> quest.requiredEvent() == null || worldEventManager.isCompleted(quest.requiredEvent()))
            .sorted(java.util.Comparator.comparing(Quest::id))
            .toList();
        int pageSize = 18;
        int maxPage = quests.isEmpty() ? 0 : (quests.size() - 1) / pageSize;
        int safePage = Math.min(Math.max(page, 0), maxPage);
        Inventory inv = Bukkit.createInventory(new GuiHolders.QuestListHolder(safePage), 27, Component.text("Quests"));
        int slot = 0;
        int startIndex = safePage * pageSize;
        for (int i = startIndex; i < quests.size() && slot < pageSize; i++) {
            Quest quest = quests.get(i);
            List<Component> lore = new ArrayList<>();
            lore.add(Text.mm("<gray>" + quest.description()));
            lore.add(Text.mm("<gray>Min Level: <white>" + quest.minLevel()));
            lore.addAll(questStepLore(quest, null));
            lore.add(Text.mm("<yellow>Klick: Details"));
            ItemStack item = new ItemBuilder(Material.BOOK)
                .name(Text.mm("<green>" + quest.name()))
                .loreLines(lore)
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(questKey, PersistentDataType.STRING, quest.id());
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(18, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Vorherige Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        inv.setItem(22, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Seite " + (safePage + 1) + "/" + (maxPage + 1)))
            .build());
        inv.setItem(26, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Nchste Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        player.openInventory(inv);
    }

    public void openQuestLog(Player player) {
        openQuestLog(player, 0);
    }

    public void openQuestLog(Player player, int page) {
        PlayerProfile profile = playerDataManager.getProfile(player);
        var activeIds = new java.util.ArrayList<>(profile.activeQuests().keySet());
        activeIds.sort(String::compareToIgnoreCase);
        int pageSize = 45;
        int maxPage = activeIds.isEmpty() ? 0 : (activeIds.size() - 1) / pageSize;
        int safePage = Math.min(Math.max(page, 0), maxPage);
        Inventory inv = Bukkit.createInventory(new GuiHolders.QuestLogHolder(safePage), 54, Component.text("Quest-Log"));
        int slot = 0;
        int startIndex = safePage * pageSize;
        for (int i = startIndex; i < activeIds.size() && slot < pageSize; i++) {
            String questId = activeIds.get(i);
            Quest quest = questManager.getQuest(questId);
            QuestProgress progress = profile.activeQuests().get(questId);
            if (quest == null) {
                continue;
            }
            List<Component> lore = new ArrayList<>();
            lore.add(Text.mm("<gray>" + quest.description()));
            lore.addAll(questStepLore(quest, progress));
            lore.add(Text.mm("<yellow>Klick: Details"));
            ItemStack item = new ItemBuilder(Material.WRITABLE_BOOK)
                .name(Text.mm("<aqua>" + quest.name()))
                .loreLines(lore)
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(questKey, PersistentDataType.STRING, quest.id());
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(45, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Vorherige Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        inv.setItem(49, new ItemBuilder(Material.BOOK)
            .name(Text.mm("<yellow>Quest-Angebote"))
            .loreLine(Text.mm("<gray>Neue Quests ansehen"))
            .build());
        inv.setItem(50, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Seite " + (safePage + 1) + "/" + (maxPage + 1)))
            .build());
        inv.setItem(53, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Nchste Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        player.openInventory(inv);
    }

    public void openQuestDetails(Player player, String questId, boolean active, int page) {
        Quest quest = questManager.getQuest(questId);
        if (quest == null) {
            player.sendMessage(Text.mm("<red>Quest nicht gefunden."));
            return;
        }
        Inventory inv = Bukkit.createInventory(new GuiHolders.QuestDetailHolder(quest.id(), active, page), 27,
            Component.text("Quest: " + quest.name()));
        PlayerProfile profile = playerDataManager.getProfile(player);
        QuestProgress progress = active ? profile.activeQuests().get(quest.id()) : null;
        List<Component> lore = new ArrayList<>();
        lore.add(Text.mm("<gray>" + quest.description()));
        lore.add(Text.mm("<gray>Min Level: <white>" + quest.minLevel()));
        if (quest.repeatable()) {
            lore.add(Text.mm("<yellow>Wiederholbar"));
        }
        lore.addAll(questStepLore(quest, progress));
        ItemStack info = new ItemBuilder(Material.BOOK)
            .name(Text.mm("<green>" + quest.name()))
            .loreLines(lore)
            .build();
        inv.setItem(13, info);
        if (active) {
            inv.setItem(22, new ItemBuilder(Material.LIME_DYE)
                .name(Text.mm("<green>Aktive Quest"))
                .loreLine(Text.mm("<gray>Diese Quest luft bereits."))
                .build());
        } else {
            inv.setItem(22, new ItemBuilder(Material.ANVIL)
                .name(Text.mm("<green>Quest annehmen"))
                .loreLine(Text.mm("<gray>Klicke, um die Quest zu starten"))
                .build());
        }
        inv.setItem(26, new ItemBuilder(Material.ARROW).name(Text.mm("<yellow>Zurck")).build());
        player.openInventory(inv);
    }

    private List<Component> questStepLore(Quest quest, QuestProgress progress) {
        List<Component> lore = new ArrayList<>();
        int index = 0;
        for (QuestStep step : quest.steps()) {
            int current = progress != null ? progress.getStepProgress(index) : 0;
            String line = step.type() + " " + step.target();
            if (step.amount() > 0) {
                line += " (" + current + "/" + step.amount() + ")";
            }
            lore.add(Text.mm("<gray> <white>" + line));
            index++;
        }
        if (quest.steps().isEmpty()) {
            lore.add(Text.mm("<gray> <white>Keine Aufgaben definiert"));
        }
        return lore;
    }

    public void openSkillList(Player player) {
        openSkillList(player, 0);
    }

    public void openSkillList(Player player, int page) {
        var skills = new java.util.ArrayList<>(skillManager.skills().values());
        skills.sort(java.util.Comparator.comparing(Skill::id));
        int pageSize = 18;
        int maxPage = skills.isEmpty() ? 0 : (skills.size() - 1) / pageSize;
        int safePage = Math.min(Math.max(page, 0), maxPage);
        Inventory inv = Bukkit.createInventory(new GuiHolders.SkillListHolder(safePage), 27, Component.text("Skills"));
        PlayerProfile profile = playerDataManager.getProfile(player);
        int slot = 0;
        int startIndex = safePage * pageSize;
        for (int i = startIndex; i < skills.size() && slot < pageSize; i++) {
            var skill = skills.get(i);
            String id = skill.id();
            List<Component> lore = new ArrayList<>();
            lore.add(Text.mm("<gray>Kategorie: <white>" + skill.category()));
            lore.add(Text.mm("<gray>Typ: <white>" + skill.type()));
            lore.add(Text.mm("<gray>Cooldown: <white>" + skill.cooldown() + "s"));
            lore.add(Text.mm("<gray>Mana: <white>" + skill.manaCost()));
            lore.add(Text.mm("<gray>Rang: <white>" + profile.learnedSkills().getOrDefault(id, 0)));
            if (skill.requiredSkill() != null) {
                lore.add(Text.mm("<gray>Voraussetzung: <white>" + skill.requiredSkill()));
            }
            if (!skill.effects().isEmpty()) {
                for (var effect : skill.effects()) {
                    lore.add(Text.mm("<gray>Effekt: <white>" + effect.describe()));
                }
            }
            lore.add(Text.mm("<yellow>Klick: Skill lernen"));
            ItemStack item = new ItemBuilder(Material.ENCHANTED_BOOK)
                .name(Text.mm("<aqua>" + skill.name()))
                .loreLines(lore)
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(skillKey, PersistentDataType.STRING, id);
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(18, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Vorherige Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        inv.setItem(22, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Seite " + (safePage + 1) + "/" + (maxPage + 1)))
            .build());
        inv.setItem(26, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Nchste Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        player.openInventory(inv);
    }

    public void openSchematicMoveGui(Player player) {
        Inventory inv = Bukkit.createInventory(new GuiHolders.SchematicMoveHolder(), 27, Component.text("Schematic verschieben"));
        inv.setItem(11, new ItemBuilder(Material.ARROW).name(Text.mm("<yellow>Links")).build());
        inv.setItem(15, new ItemBuilder(Material.ARROW).name(Text.mm("<yellow>Rechts")).build());
        inv.setItem(13, new ItemBuilder(Material.FEATHER).name(Text.mm("<yellow>Hoch")).build());
        inv.setItem(22, new ItemBuilder(Material.ANVIL).name(Text.mm("<yellow>Runter")).build());
        inv.setItem(26, new ItemBuilder(Material.BARRIER).name(Text.mm("<red>Fertig")).build());
        player.openInventory(inv);
    }

    public void openEnchanting(Player player, String selectedRecipeId) {
        openEnchanting(player, selectedRecipeId, 0);
    }

    public void openEnchanting(Player player, String selectedRecipeId, int page) {
        ItemStack target = player.getInventory().getItemInMainHand();
        List<com.example.rpg.model.EnchantmentRecipe> available = enchantManager.availableRecipes(player, target);
        if (available.isEmpty()) {
            player.sendMessage(Text.mm("<red>Keine Verzauberungen verfgbar."));
        }
        String recipeId = selectedRecipeId;
        if (recipeId == null && !available.isEmpty()) {
            recipeId = available.get(0).id();
        }
        int pageSize = 9;
        int maxPage = available.isEmpty() ? 0 : (available.size() - 1) / pageSize;
        int safePage = Math.min(Math.max(page, 0), maxPage);
        Inventory inv = Bukkit.createInventory(new GuiHolders.EnchantingHolder(recipeId, safePage), 27,
            Component.text("Verzauberungen"));
        ItemStack displayTarget = target == null ? null : target.clone();
        if (displayTarget != null) {
            displayTarget.setAmount(1);
            inv.setItem(10, displayTarget);
        } else {
            inv.setItem(10, new ItemBuilder(Material.BARRIER).name(Text.mm("<red>Kein Ziel-Item")).build());
        }
        int startIndex = safePage * pageSize;
        for (int i = 0; i < pageSize && startIndex + i < available.size(); i++) {
            var recipe = available.get(startIndex + i);
            ItemBuilder builder = new ItemBuilder(Material.ENCHANTED_BOOK)
                .name(Text.mm("<yellow>" + recipe.id()))
                .loreLine(Text.mm("<gray>Typ: <white>" + recipe.type()))
                .loreLine(Text.mm("<gray>Ziel: <white>" + recipe.targetSlot()));
            if (recipe.statToImprove() != null) {
                builder.loreLine(Text.mm("<gray>Stat: <white>" + recipe.statToImprove()));
            }
            if (recipe.costGold() > 0) {
                builder.loreLine(Text.mm("<gold>Kosten: " + recipe.costGold() + " Gold"));
            }
            if (recipe.costMaterial() != null && recipe.costAmount() > 0) {
                builder.loreLine(Text.mm("<gray>Material: <white>" + recipe.costMaterial() + " x" + recipe.costAmount()));
            }
            ItemStack item = builder.build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(enchantRecipeKey, PersistentDataType.STRING, recipe.id());
            item.setItemMeta(meta);
            inv.setItem(i, item);
        }
        com.example.rpg.model.EnchantmentRecipe selected = recipeId != null ? enchantManager.recipes().get(recipeId) : null;
        if (selected != null) {
            if (selected.costMaterial() != null) {
                inv.setItem(14, new ItemBuilder(selected.costMaterial())
                    .name(Text.mm("<yellow>Material: <white>" + selected.costMaterial()))
                    .loreLine(Text.mm("<gray>Menge: <white>" + selected.costAmount()))
                    .build());
            } else {
                inv.setItem(14, new ItemBuilder(Material.GRAY_STAINED_GLASS_PANE).name(Text.mm("<gray>Kein Material")).build());
            }
            inv.setItem(15, new ItemBuilder(Material.GOLD_INGOT)
                .name(Text.mm("<gold>Goldkosten"))
                .loreLine(Text.mm("<gray>Bentigt: <white>" + selected.costGold()))
                .build());
            inv.setItem(22, new ItemBuilder(Material.ANVIL).name(Text.mm("<green>Verzaubern")).build());
        } else {
            inv.setItem(22, new ItemBuilder(Material.BARRIER).name(Text.mm("<red>Kein Rezept ausgewhlt")).build());
        }
        inv.setItem(18, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Vorherige Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        inv.setItem(24, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Seite " + (safePage + 1) + "/" + (maxPage + 1)))
            .build());
        inv.setItem(25, new ItemBuilder(Material.BARRIER).name(Text.mm("<red>Schlieen")).build());
        inv.setItem(26, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Nchste Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        player.openInventory(inv);
    }

    public void openPermissionsMain(Player player) {
        Inventory inv = Bukkit.createInventory(new GuiHolders.PermissionsMainHolder(), 27, Component.text("Permissions"));
        inv.setItem(11, new ItemBuilder(Material.BOOK)
            .name(Text.mm("<yellow>Rollen"))
            .loreLine(Text.mm("<gray>Rollen verwalten"))
            .build());
        inv.setItem(13, new ItemBuilder(Material.PLAYER_HEAD)
            .name(Text.mm("<green>Spieler"))
            .loreLine(Text.mm("<gray>Rollen zuweisen"))
            .build());
        inv.setItem(15, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<light_purple>Audit Log"))
            .loreLine(Text.mm("<gray>Letzte nderungen"))
            .build());
        player.openInventory(inv);
    }

    public void openRoleList(Player player, int page) {
        Inventory inv = Bukkit.createInventory(new GuiHolders.RoleListHolder(page), 54, Component.text("Rollen"));
        int start = page * 45;
        int slot = 0;
        List<com.example.rpg.permissions.Role> roles = new ArrayList<>(permissionService.roles().values());
        roles.sort(java.util.Comparator.comparing(com.example.rpg.permissions.Role::key));
        for (int i = start; i < roles.size() && slot < 45; i++) {
            var role = roles.get(i);
            ItemStack item = new ItemBuilder(Material.BOOK)
                .name(Text.mm("<yellow>" + role.displayName()))
                .loreLine(Text.mm("<gray>Key: <white>" + role.key()))
                .loreLine(Text.mm("<gray>Nodes: <white>" + role.nodes().size()))
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(permRoleKey, PersistentDataType.STRING, role.key());
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(45, new ItemBuilder(Material.ARROW).name(Text.mm("<yellow>Zurck")).build());
        inv.setItem(53, new ItemBuilder(Material.ANVIL).name(Text.mm("<green>Neue Rolle")).build());
        player.openInventory(inv);
    }

    public void openRoleDetails(Player player, String roleKey) {
        var role = permissionService.roles().get(roleKey);
        if (role == null) {
            player.sendMessage(Text.mm("<red>Rolle nicht gefunden."));
            return;
        }
        Inventory inv = Bukkit.createInventory(new GuiHolders.RoleDetailHolder(roleKey), 27, Component.text("Rolle: " + role.displayName()));
        inv.setItem(11, new ItemBuilder(Material.NAME_TAG).name(Text.mm("<yellow>Eltern"))
            .loreLine(Text.mm("<gray>Vererbung verwalten")).build());
        inv.setItem(13, new ItemBuilder(Material.WRITABLE_BOOK).name(Text.mm("<yellow>Nodes"))
            .loreLine(Text.mm("<gray>Rechte verwalten")).build());
        inv.setItem(15, new ItemBuilder(Material.ANVIL).name(Text.mm("<yellow>Umbenennen"))
            .loreLine(Text.mm("<gray>Display-Name ndern")).build());
        inv.setItem(26, new ItemBuilder(Material.BARRIER).name(Text.mm("<red>Lschen")).build());
        player.openInventory(inv);
    }

    public void openRoleNodes(Player player, String roleKey, int page) {
        var role = permissionService.roles().get(roleKey);
        if (role == null) {
            player.sendMessage(Text.mm("<red>Rolle nicht gefunden."));
            return;
        }
        Inventory inv = Bukkit.createInventory(new GuiHolders.RoleNodesHolder(roleKey, page), 54, Component.text("Nodes: " + role.displayName()));
        List<String> nodes = new ArrayList<>(role.nodes().keySet());
        nodes.sort(String::compareToIgnoreCase);
        int start = page * 45;
        int slot = 0;
        for (int i = start; i < nodes.size() && slot < 45; i++) {
            String node = nodes.get(i);
            var decision = role.nodes().get(node);
            ItemStack item = new ItemBuilder(Material.PAPER)
                .name(Text.mm("<yellow>" + node))
                .loreLine(Text.mm("<gray>Status: <white>" + decision))
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(permRoleKey, PersistentDataType.STRING, roleKey);
            meta.getPersistentDataContainer().set(permNodeKey, PersistentDataType.STRING, node);
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(45, new ItemBuilder(Material.ARROW).name(Text.mm("<yellow>Zurck")).build());
        inv.setItem(53, new ItemBuilder(Material.ANVIL).name(Text.mm("<green>Node hinzufgen")).build());
        player.openInventory(inv);
    }

    public void openRoleParents(Player player, String roleKey) {
        var role = permissionService.roles().get(roleKey);
        if (role == null) {
            player.sendMessage(Text.mm("<red>Rolle nicht gefunden."));
            return;
        }
        Inventory inv = Bukkit.createInventory(new GuiHolders.RoleParentsHolder(roleKey), 54, Component.text("Eltern: " + role.displayName()));
        int slot = 0;
        for (var entry : permissionService.roles().values()) {
            if (slot >= 45) {
                break;
            }
            boolean active = role.parents().contains(entry.key());
            ItemStack item = new ItemBuilder(active ? Material.EMERALD_BLOCK : Material.GRAY_STAINED_GLASS_PANE)
                .name(Text.mm("<yellow>" + entry.displayName()))
                .loreLine(Text.mm(active ? "<green>Aktiv" : "<gray>Inaktiv"))
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(permRoleKey, PersistentDataType.STRING, roleKey);
            meta.getPersistentDataContainer().set(permNodeKey, PersistentDataType.STRING, entry.key());
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(45, new ItemBuilder(Material.ARROW).name(Text.mm("<yellow>Zurck")).build());
        player.openInventory(inv);
    }

    public void openPlayerList(Player player) {
        openPlayerList(player, 0);
    }

    public void openPlayerList(Player player, int page) {
        var players = new java.util.ArrayList<>(Bukkit.getOnlinePlayers());
        players.sort(java.util.Comparator.comparing(Player::getName, String.CASE_INSENSITIVE_ORDER));
        int pageSize = 45;
        int maxPage = players.isEmpty() ? 0 : (players.size() - 1) / pageSize;
        int safePage = Math.min(Math.max(page, 0), maxPage);
        Inventory inv = Bukkit.createInventory(new GuiHolders.PlayerListHolder(safePage), 54, Component.text("Spieler Rollen"));
        int slot = 0;
        int startIndex = safePage * pageSize;
        for (int i = startIndex; i < players.size() && slot < pageSize; i++) {
            Player online = players.get(i);
            ItemStack item = new ItemBuilder(Material.PLAYER_HEAD)
                .name(Text.mm("<yellow>" + online.getName()))
                .loreLine(Text.mm("<gray>UUID: <white>" + online.getUniqueId()))
                .build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(permPlayerKey, PersistentDataType.STRING, online.getUniqueId().toString());
            item.setItemMeta(meta);
            inv.setItem(slot++, item);
        }
        inv.setItem(45, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Vorherige Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        inv.setItem(47, new ItemBuilder(Material.ARROW).name(Text.mm("<yellow>Zurck")).build());
        inv.setItem(49, new ItemBuilder(Material.ANVIL).name(Text.mm("<green>Spieler suchen")).build());
        inv.setItem(50, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Seite " + (safePage + 1) + "/" + (maxPage + 1)))
            .build());
        inv.setItem(53, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Nchste Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        player.openInventory(inv);
    }

    public void openPlayerRoles(Player player, java.util.UUID targetId) {
        var roles = permissionService.getPlayerRoles(targetId);
        String name = Bukkit.getOfflinePlayer(targetId).getName();
        Inventory inv = Bukkit.createInventory(new GuiHolders.PlayerRoleHolder(targetId), 27,
            Component.text("Rollen: " + (name != null ? name : targetId.toString())));
        String primaryRole = roles.primaryRole() != null ? roles.primaryRole() : "Keine";
        inv.setItem(10, new ItemBuilder(Material.BOOK).name(Text.mm("<yellow>Primary: <white>" + primaryRole)).build());
        inv.setItem(12, new ItemBuilder(Material.ANVIL).name(Text.mm("<green>Primary setzen")).build());
        inv.setItem(14, new ItemBuilder(Material.EMERALD).name(Text.mm("<green>Rolle hinzufgen")).build());
        inv.setItem(16, new ItemBuilder(Material.BARRIER).name(Text.mm("<red>Rolle entfernen")).build());
        inv.setItem(22, new ItemBuilder(Material.PAPER).name(Text.mm("<yellow>Node prfen")).build());
        player.openInventory(inv);
    }

    public void openAuditLog(Player player) {
        openAuditLog(player, 0);
    }

    public void openAuditLog(Player player, int page) {
        List<String> entries = permissionService.auditLog().recent(200);
        int pageSize = 45;
        int maxPage = entries.isEmpty() ? 0 : (entries.size() - 1) / pageSize;
        int safePage = Math.min(Math.max(page, 0), maxPage);
        Inventory inv = Bukkit.createInventory(new GuiHolders.PermissionAuditHolder(safePage), 54,
            Component.text("Audit Log"));
        int slot = 0;
        int startIndex = safePage * pageSize;
        for (int i = startIndex; i < entries.size() && slot < pageSize; i++) {
            String line = entries.get(i);
            inv.setItem(slot++, new ItemBuilder(Material.PAPER).name(Text.mm("<gray>" + line)).build());
        }
        inv.setItem(45, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Vorherige Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        inv.setItem(49, new ItemBuilder(Material.ARROW).name(Text.mm("<yellow>Zurck")).build());
        inv.setItem(50, new ItemBuilder(Material.PAPER)
            .name(Text.mm("<gold>Seite " + (safePage + 1) + "/" + (maxPage + 1)))
            .build());
        inv.setItem(53, new ItemBuilder(Material.ARROW)
            .name(Text.mm("<yellow>Nchste Seite"))
            .loreLine(Text.mm("<gray>Seite " + (safePage + 1) + " von " + (maxPage + 1)))
            .build());
        player.openInventory(inv);
    }

    public void openShop(Player player, ShopDefinition shop) {
        int maxSlot = shop.items().values().stream().mapToInt(ShopItem::slot).max().orElse(0);
        int size = maxSlot >= 27 ? 54 : 27;
        Inventory inv = Bukkit.createInventory(new GuiHolders.ShopHolder(shop.id()), size, Component.text(shop.title()));
        for (ShopItem item : shop.items().values()) {
            Material material = Material.matchMaterial(item.material());
            if (material == null) {
                continue;
            }
            ItemStack displayItem;
            if (item.rpgItem()) {
                Rarity rarity = parseRarity(item.rarity());
                displayItem = itemGenerator.createRpgItem(material, rarity, Math.max(1, item.minLevel()));
            } else {
                ItemBuilder builder = new ItemBuilder(material);
                if (item.name() != null && !item.name().isBlank()) {
                    builder.name(net.kyori.adventure.text.Component.text(
                        org.bukkit.ChatColor.translateAlternateColorCodes('&', item.name())));
                }
                displayItem = builder.build();
            }
            ItemMeta meta = displayItem.getItemMeta();
            if (meta != null) {
                List<Component> lore = meta.lore() != null ? new ArrayList<>(meta.lore()) : new ArrayList<>();
                if (item.buyPrice() > 0) {
                    lore.add(Text.mm("<gray>Kaufen: <gold>" + item.buyPrice() + " Gold"));
                }
                if (item.sellPrice() > 0) {
                    lore.add(Text.mm("<gray>Verkaufen: <gold>" + item.sellPrice() + " Gold"));
                }
                meta.lore(lore);
                displayItem.setItemMeta(meta);
            }
            inv.setItem(item.slot(), displayItem);
        }
        player.openInventory(inv);
    }

    private String resolveClassName(String classId) {
        if (classId == null) {
            return "Keine";
        }
        var definition = classManager.getClass(classId);
        return definition != null ? definition.name() : classId;
    }

    private Rarity parseRarity(String raw) {
        if (raw == null) {
            return Rarity.COMMON;
        }
        try {
            return Rarity.valueOf(raw.toUpperCase(Locale.ROOT));
        } catch (IllegalArgumentException e) {
            return Rarity.COMMON;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/gui/SkillTreeGui.java`  
- Path: `src/main/java/com/example/rpg/gui/SkillTreeGui.java`  
- Size: 4169 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.gui;

import com.example.rpg.RPGPlugin;
import com.example.rpg.manager.SkillTreeManager;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.model.Skill;
import com.example.rpg.util.ItemBuilder;
import com.example.rpg.util.Text;
import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.Map;
import net.kyori.adventure.text.Component;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataType;

public class SkillTreeGui {
    private final RPGPlugin plugin;

    public SkillTreeGui(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    public void open(Player player) {
        Inventory inv = Bukkit.createInventory(new GuiHolders.SkillTreeHolder(), 54, Component.text("Skillbaum"));
        SkillTreeManager treeManager = plugin.skillTreeManager();
        treeManager.rebuild();
        Map<String, Integer> slots = layout(treeManager);
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        for (Map.Entry<String, Integer> entry : slots.entrySet()) {
            Skill skill = plugin.skillManager().getSkill(entry.getKey());
            if (skill == null) {
                continue;
            }
            boolean learned = profile.learnedSkills().containsKey(skill.id());
            boolean unlocked = skill.requiredSkill() == null
                || profile.learnedSkills().containsKey(skill.requiredSkill());
            Material material = learned ? Material.ENCHANTED_BOOK : unlocked ? Material.BOOK : Material.BARRIER;
            ItemBuilder builder = new ItemBuilder(material)
                .name(Text.mm(learned ? "<green>" + skill.name() : unlocked ? "<yellow>" + skill.name() : "<red>" + skill.name()))
                .loreLine(Text.mm("<gray>Mana: <white>" + skill.manaCost()))
                .loreLine(Text.mm("<gray>Cooldown: <white>" + skill.cooldown() + "s"))
                .loreLine(Text.mm("<gray>Voraussetzung: <white>" + (skill.requiredSkill() == null ? "Keine" : skill.requiredSkill())));
            if (learned) {
                builder.loreLine(Text.mm("<green>Bereits gelernt"));
            } else if (unlocked) {
                builder.loreLine(Text.mm("<yellow>Klick zum Lernen"));
            } else {
                builder.loreLine(Text.mm("<red>Gesperrt"));
            }
            ItemStack item = builder.build();
            ItemMeta meta = item.getItemMeta();
            meta.getPersistentDataContainer().set(plugin.skillKey(), PersistentDataType.STRING, skill.id());
            item.setItemMeta(meta);
            inv.setItem(entry.getValue(), item);
        }
        for (int slot : slots.values()) {
            int linkSlot = slot + 1;
            if (linkSlot < inv.getSize() && inv.getItem(linkSlot) == null) {
                inv.setItem(linkSlot, new ItemBuilder(Material.GRAY_STAINED_GLASS_PANE).name(Component.text(" ")).build());
            }
        }
        player.openInventory(inv);
    }

    private Map<String, Integer> layout(SkillTreeManager treeManager) {
        Map<String, Integer> slots = new HashMap<>();
        int[] depthIndex = new int[6];
        ArrayDeque<SkillTreeManager.SkillNode> queue = new ArrayDeque<>(treeManager.roots());
        while (!queue.isEmpty()) {
            SkillTreeManager.SkillNode node = queue.poll();
            int depth = depth(node);
            int row = Math.min(depth, 5);
            int col = depthIndex[row]++;
            int slot = row * 9 + Math.min(col * 2, 8);
            slots.put(node.skill().id(), slot);
            for (SkillTreeManager.SkillNode child : node.children()) {
                queue.add(child);
            }
        }
        return slots;
    }

    private int depth(SkillTreeManager.SkillNode node) {
        int depth = 0;
        SkillTreeManager.SkillNode current = node;
        while (current.parent() != null) {
            depth++;
            current = current.parent();
        }
        return depth;
    }
}

```

## File: `src/main/java/com/example/rpg/listener/ArenaListener.java`  
- Path: `src/main/java/com/example/rpg/listener/ArenaListener.java`  
- Size: 700 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.PlayerDeathEvent;

public class ArenaListener implements Listener {
    private final RPGPlugin plugin;

    public ArenaListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onDeath(PlayerDeathEvent event) {
        Player player = event.getEntity();
        event.setKeepInventory(true);
        event.getDrops().clear();
        event.setKeepLevel(true);
        event.setDroppedExp(0);
        plugin.arenaManager().handleDeath(player);
    }
}

```

## File: `src/main/java/com/example/rpg/listener/BehaviorEditorListener.java`  
- Path: `src/main/java/com/example/rpg/listener/BehaviorEditorListener.java`  
- Size: 4152 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import com.example.rpg.gui.BehaviorTreeEditorGui;
import com.example.rpg.gui.GuiHolders;
import com.example.rpg.util.Text;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryClickEvent;

public class BehaviorEditorListener implements Listener {
    private final RPGPlugin plugin;
    private final BehaviorTreeEditorGui gui;

    public BehaviorEditorListener(RPGPlugin plugin, BehaviorTreeEditorGui gui) {
        this.plugin = plugin;
        this.gui = gui;
    }

    @EventHandler
    public void onClick(InventoryClickEvent event) {
        if (!(event.getWhoClicked() instanceof Player player)) {
            return;
        }
        if (!(event.getInventory().getHolder() instanceof GuiHolders.BehaviorTreeEditorHolder holder)) {
            return;
        }
        event.setCancelled(true);
        String treeName = holder.treeName();
        switch (event.getSlot()) {
            case 10 -> promptEmergency(player, treeName);
            case 12 -> promptRanged(player, treeName);
            case 14 -> {
                plugin.behaviorTreeManager().addTemplate(treeName, Map.of("type", "melee_attack"));
                player.sendMessage(Text.mm("<green>Nahkampf hinzugefgt."));
                gui.open(player, treeName);
            }
            case 16 -> {
                plugin.behaviorTreeManager().resetTree(treeName);
                player.sendMessage(Text.mm("<yellow>Behavior Tree zurckgesetzt."));
                gui.open(player, treeName);
            }
            default -> {
            }
        }
    }

    private void promptEmergency(Player player, String treeName) {
        plugin.promptManager().prompt(player, Text.mm("<gray>Notfall-Heilung: <threshold> <skillId> <healAmount>"),
            input -> {
                String[] parts = input.split("\\s+");
                if (parts.length < 3) {
                    player.sendMessage(Text.mm("<red>Format: <threshold> <skillId> <healAmount>"));
                    return;
                }
                double threshold = parseDouble(parts[0], 0.2);
                String skillId = parts[1];
                double heal = parseDouble(parts[2], 6);
                List<Map<String, Object>> children = new ArrayList<>();
                children.add(Map.of("type", "health_below", "threshold", threshold));
                children.add(Map.of("type", "cast_skill", "skill", skillId));
                children.add(Map.of("type", "heal_self", "amount", heal));
                plugin.behaviorTreeManager().addTemplate(treeName, Map.of("type", "sequence", "children", children));
                player.sendMessage(Text.mm("<green>Notfall-Sequenz hinzugefgt."));
                gui.open(player, treeName);
            });
    }

    private void promptRanged(Player player, String treeName) {
        plugin.promptManager().prompt(player, Text.mm("<gray>Fernkampf: <distance> <skillId>"), input -> {
            String[] parts = input.split("\\s+");
            if (parts.length < 2) {
                player.sendMessage(Text.mm("<red>Format: <distance> <skillId>"));
                return;
            }
            double distance = parseDouble(parts[0], 10);
            String skillId = parts[1];
            List<Map<String, Object>> children = new ArrayList<>();
            children.add(Map.of("type", "target_distance_above", "distance", distance));
            children.add(Map.of("type", "cast_skill", "skill", skillId));
            plugin.behaviorTreeManager().addTemplate(treeName, Map.of("type", "sequence", "children", children));
            player.sendMessage(Text.mm("<green>Fernkampf-Sequenz hinzugefgt."));
            gui.open(player, treeName);
        });
    }

    private double parseDouble(String input, double fallback) {
        try {
            return Double.parseDouble(input);
        } catch (NumberFormatException e) {
            return fallback;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/listener/BuildingPlacementListener.java`  
- Path: `src/main/java/com/example/rpg/listener/BuildingPlacementListener.java`  
- Size: 1134 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import com.example.rpg.util.Text;
import org.bukkit.Location;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.player.PlayerInteractEvent;

public class BuildingPlacementListener implements Listener {
    private final RPGPlugin plugin;

    public BuildingPlacementListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onPlace(PlayerInteractEvent event) {
        if (event.getAction() != Action.RIGHT_CLICK_BLOCK) {
            return;
        }
        if (!plugin.permissionService().has(event.getPlayer(), "rpg.admin")) {
            return;
        }
        if (event.getClickedBlock() == null) {
            return;
        }
        Location target = event.getClickedBlock().getLocation().add(0, 1, 0);
        if (plugin.buildingManager().handlePlacement(event.getPlayer(), target)) {
            event.setCancelled(true);
            event.getPlayer().sendMessage(Text.mm("<gray>Platziere Gebude..."));
        }
    }
}

```

## File: `src/main/java/com/example/rpg/listener/CombatListener.java`  
- Path: `src/main/java/com/example/rpg/listener/CombatListener.java`  
- Size: 9932 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.LootEntry;
import com.example.rpg.model.LootTable;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.model.Quest;
import com.example.rpg.model.QuestProgress;
import com.example.rpg.model.QuestStep;
import com.example.rpg.model.QuestStepType;
import com.example.rpg.model.Rarity;
import java.util.Random;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.entity.EntityDeathEvent;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.inventory.CraftItemEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.projectiles.ProjectileSource;

public class CombatListener implements Listener {
    private final RPGPlugin plugin;
    private final Random random = new Random();

    public CombatListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onFriendlyFire(EntityDamageByEntityEvent event) {
        if (!(event.getDamager() instanceof Player damager)) {
            return;
        }
        if (!(event.getEntity() instanceof Player target)) {
            return;
        }
        plugin.partyManager().getParty(damager.getUniqueId()).ifPresent(party -> {
            if (party.members().contains(target.getUniqueId())) {
                event.setCancelled(true);
            }
        });
    }

    @EventHandler(ignoreCancelled = true)
    public void onCombatLog(EntityDamageByEntityEvent event) {
        Player attacker = resolveAttacker(event);
        Player victim = event.getEntity() instanceof Player player ? player : null;
        double damage = event.getFinalDamage();
        if (attacker != null && plugin.isCombatLogEnabled(attacker.getUniqueId())) {
            String targetName = event.getEntity().getName();
            attacker.sendMessage(com.example.rpg.util.Text.mm("<gray>Du triffst <white>" + targetName
                + "</white> fr <red>" + Math.round(damage) + "</red> Schaden."));
        }
        if (victim != null && plugin.isCombatLogEnabled(victim.getUniqueId())) {
            String sourceName = attacker != null ? attacker.getName() : event.getDamager().getName();
            victim.sendMessage(com.example.rpg.util.Text.mm("<gray>Du bekommst <red>" + Math.round(damage)
                + "</red> Schaden von <white>" + sourceName + "</white>."));
        }
    }

    @EventHandler
    public void onEntityDeath(EntityDeathEvent event) {
        if (event.getEntity().getPersistentDataContainer()
            .has(plugin.customMobListener().mobKey(), org.bukkit.persistence.PersistentDataType.STRING)) {
            return;
        }
        Player killer = event.getEntity().getKiller();
        if (killer == null) {
            return;
        }
        if (event.getEntity() instanceof Player) {
            return;
        }
        int xp = 10 + event.getEntity().getType().ordinal() % 10;
        var partyOpt = plugin.partyManager().getParty(killer.getUniqueId());
        java.util.List<Player> recipients = new java.util.ArrayList<>();
        if (partyOpt.isPresent()) {
            for (java.util.UUID memberId : partyOpt.get().members()) {
                Player member = plugin.getServer().getPlayer(memberId);
                if (member != null && member.getWorld().equals(killer.getWorld())
                    && member.getLocation().distanceSquared(killer.getLocation()) <= 30 * 30) {
                    recipients.add(member);
                }
            }
        } else {
            recipients.add(killer);
        }
        boolean split = plugin.getConfig().getBoolean("rpg.party.xpSplit", true);
        int share = split ? Math.max(1, xp / Math.max(1, recipients.size())) : xp;
        for (Player member : recipients) {
            PlayerProfile profile = plugin.playerDataManager().getProfile(member);
            profile.addXp(share);
            profile.applyAttributes(member, plugin.itemStatManager(), plugin.classManager());
        }

        LootTable table = plugin.lootManager().getTableFor(event.getEntity().getType().name());
        if (table != null) {
            for (LootEntry entry : table.entries()) {
                if (random.nextDouble() <= entry.chance()) {
                    Material material = Material.matchMaterial(entry.material());
                    if (material != null) {
                        int level = plugin.playerDataManager().getProfile(killer).level();
                        ItemStack item = plugin.itemGenerator().createRpgItem(material, entry.rarity(), level);
                        item.setAmount(entry.minAmount() + random.nextInt(Math.max(1, entry.maxAmount() - entry.minAmount() + 1)));
                        event.getDrops().add(item);
                        plugin.broadcastLoot(killer, item);
                    }
                }
            }
        } else {
            dropGenericLoot(killer, event);
        }

        for (Player member : recipients) {
            PlayerProfile profile = plugin.playerDataManager().getProfile(member);
            for (QuestProgress progress : profile.activeQuests().values()) {
                Quest quest = plugin.questManager().getQuest(progress.questId());
                if (quest == null) {
                    continue;
                }
                for (int i = 0; i < quest.steps().size(); i++) {
                    QuestStep step = quest.steps().get(i);
                    if (step.type() == QuestStepType.KILL && step.target().equalsIgnoreCase(event.getEntity().getType().name())) {
                        progress.incrementStepClamped(i, 1, step.amount());
                    }
                }
                plugin.completeQuestIfReady(member, quest, progress);
            }
        }

        String zoneId = plugin.zoneManager().getZoneAt(event.getEntity().getLocation()) != null
            ? plugin.zoneManager().getZoneAt(event.getEntity().getLocation()).id()
            : null;
        for (Player member : recipients) {
            plugin.worldEventManager().handleKill(member, event.getEntity().getType().name(), zoneId);
        }
    }

    @EventHandler
    public void onBlockBreak(BlockBreakEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        profile.addXp(1);
        profile.applyAttributes(player, plugin.itemStatManager(), plugin.classManager());
        String zoneId = plugin.zoneManager().getZoneAt(event.getBlock().getLocation()) != null
            ? plugin.zoneManager().getZoneAt(event.getBlock().getLocation()).id()
            : null;
        plugin.worldEventManager().handleCollect(player, event.getBlock().getType().name(), zoneId);
    }

    @EventHandler
    public void onCraft(CraftItemEvent event) {
        if (!(event.getWhoClicked() instanceof Player player)) {
            return;
        }
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        profile.addXp(2);
        profile.applyAttributes(player, plugin.itemStatManager(), plugin.classManager());
        String zoneId = plugin.zoneManager().getZoneAt(player.getLocation()) != null
            ? plugin.zoneManager().getZoneAt(player.getLocation()).id()
            : null;
        plugin.worldEventManager().handleCraft(player, event.getRecipe().getResult().getType().name(), zoneId);
    }

    private Player resolveAttacker(EntityDamageByEntityEvent event) {
        if (event.getDamager() instanceof Player player) {
            return player;
        }
        if (event.getDamager() instanceof org.bukkit.entity.Projectile projectile) {
            ProjectileSource source = projectile.getShooter();
            if (source instanceof Player player) {
                return player;
            }
        }
        return null;
    }

    private void dropGenericLoot(Player killer, EntityDeathEvent event) {
        PlayerProfile profile = plugin.playerDataManager().getProfile(killer);
        int level = Math.max(1, profile.level());
        int gold = 5 + random.nextInt(6) + level;
        profile.setGold(profile.gold() + gold);
        killer.sendMessage(com.example.rpg.util.Text.mm("<gold>+ " + gold + " Gold"));

        Material material = selectMaterialForLevel(level);
        if (material == null) {
            return;
        }
        Rarity rarity = rollRarity();
        ItemStack item = plugin.itemGenerator().createRpgItem(material, rarity, level);
        event.getDrops().add(item);
        plugin.broadcastLoot(killer, item);
    }

    private Material selectMaterialForLevel(int level) {
        Material[] low = {
            Material.WOODEN_SWORD, Material.STONE_SWORD, Material.BOW,
            Material.LEATHER_HELMET, Material.LEATHER_CHESTPLATE,
            Material.LEATHER_LEGGINGS, Material.LEATHER_BOOTS
        };
        Material[] mid = {
            Material.IRON_SWORD, Material.CROSSBOW,
            Material.CHAINMAIL_HELMET, Material.CHAINMAIL_CHESTPLATE,
            Material.CHAINMAIL_LEGGINGS, Material.CHAINMAIL_BOOTS
        };
        Material[] high = {
            Material.DIAMOND_SWORD, Material.NETHERITE_SWORD,
            Material.IRON_HELMET, Material.IRON_CHESTPLATE,
            Material.IRON_LEGGINGS, Material.IRON_BOOTS
        };
        Material[] pool = level < 5 ? low : (level < 15 ? mid : high);
        return pool[random.nextInt(pool.length)];
    }

    private Rarity rollRarity() {
        double roll = random.nextDouble();
        double total = 0.0;
        for (Rarity rarity : Rarity.values()) {
            total += rarity.weight();
            if (roll <= total) {
                return rarity;
            }
        }
        return Rarity.COMMON;
    }
}

```

## File: `src/main/java/com/example/rpg/listener/CustomMobListener.java`  
- Path: `src/main/java/com/example/rpg/listener/CustomMobListener.java`  
- Size: 12813 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import com.example.rpg.behavior.BehaviorContext;
import com.example.rpg.behavior.BehaviorNode;
import com.example.rpg.dungeon.DungeonInstance;
import com.example.rpg.model.LootEntry;
import com.example.rpg.model.LootTable;
import com.example.rpg.model.MobDefinition;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.model.Rarity;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.UUID;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.attribute.Attribute;
import org.bukkit.entity.Display;
import org.bukkit.entity.Entity;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.entity.TextDisplay;
import org.bukkit.scheduler.BukkitTask;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.entity.EntityDamageEvent;
import org.bukkit.event.entity.EntityDeathEvent;
import org.bukkit.event.entity.EntityRegainHealthEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.persistence.PersistentDataType;

public class CustomMobListener implements Listener {
    private final RPGPlugin plugin;
    private final NamespacedKey mobKey;
    private final Random random = new Random();
    private final Map<UUID, BukkitTask> behaviorTasks = new HashMap<>();
    private final Map<UUID, BehaviorContext> behaviorContexts = new HashMap<>();
    private final Map<UUID, TextDisplay> healthBars = new HashMap<>();

    public CustomMobListener(RPGPlugin plugin) {
        this.plugin = plugin;
        this.mobKey = new NamespacedKey(plugin, "custom_mob_id");
    }

    public NamespacedKey mobKey() {
        return mobKey;
    }

    @EventHandler
    public void onDamage(EntityDamageByEntityEvent event) {
        Entity damager = event.getDamager();
        if (!(damager instanceof LivingEntity living)) {
            return;
        }
        String mobId = getMobId(living);
        if (mobId == null) {
            return;
        }
        MobDefinition mob = plugin.mobManager().getMob(mobId);
        if (mob != null) {
            double damage = mob.damage();
            DungeonInstance instance = plugin.dungeonManager().instanceForWorld(living.getWorld());
            if (instance != null) {
                damage *= instance.scale();
            }
            event.setDamage(damage);
        }
    }

    @EventHandler
    public void onDeath(EntityDeathEvent event) {
        LivingEntity entity = event.getEntity();
        String mobId = getMobId(entity);
        if (mobId == null) {
            return;
        }
        removeHealthBar(entity);
        BukkitTask task = behaviorTasks.remove(entity.getUniqueId());
        if (task != null) {
            task.cancel();
        }
        behaviorContexts.remove(entity.getUniqueId());
        MobDefinition mob = plugin.mobManager().getMob(mobId);
        if (mob == null) {
            return;
        }
        DungeonInstance instance = plugin.dungeonManager().instanceForWorld(entity.getWorld());
        Player killer = entity.getKiller();
        if (killer != null) {
            PlayerProfile profile = plugin.playerDataManager().getProfile(killer);
            profile.addXp(mob.xp());
            profile.applyAttributes(killer, plugin.itemStatManager(), plugin.classManager());
            int gold = 8 + random.nextInt(8) + Math.max(1, profile.level());
            profile.setGold(profile.gold() + gold);
            killer.sendMessage(com.example.rpg.util.Text.mm("<gold>+ " + gold + " Gold"));
            String zoneId = plugin.zoneManager().getZoneAt(entity.getLocation()) != null
                ? plugin.zoneManager().getZoneAt(entity.getLocation()).id()
                : null;
            plugin.worldEventManager().handleKill(killer, mob.id(), zoneId);
            plugin.worldEventManager().handleKill(killer, entity.getType().name(), zoneId);
        }
        if (mob.lootTable() != null) {
            LootTable table = plugin.lootManager().getTable(mob.lootTable());
            if (table != null) {
                for (LootEntry entry : table.entries()) {
                    if (random.nextDouble() <= entry.chance()) {
                        Material material = Material.matchMaterial(entry.material());
                        if (material != null) {
                            ItemStack item = plugin.itemGenerator().createRpgItem(material, entry.rarity(), 1);
                            item.setAmount(entry.minAmount() + random.nextInt(Math.max(1, entry.maxAmount() - entry.minAmount() + 1)));
                            event.getDrops().add(item);
                            if (killer != null) {
                                plugin.broadcastLoot(killer, item);
                            }
                        }
                    }
                }
            }
        } else if (killer != null) {
            dropFallbackLoot(killer, event);
        }
        if (mob.boss() && instance != null) {
            plugin.dungeonManager().completeDungeon(instance);
        }
    }

    private void dropFallbackLoot(Player killer, EntityDeathEvent event) {
        PlayerProfile profile = plugin.playerDataManager().getProfile(killer);
        int level = Math.max(1, profile.level());
        Material material = selectMaterialForLevel(level);
        if (material == null) {
            return;
        }
        Rarity rarity = rollRarity();
        ItemStack item = plugin.itemGenerator().createRpgItem(material, rarity, level);
        event.getDrops().add(item);
        plugin.broadcastLoot(killer, item);
    }

    private Material selectMaterialForLevel(int level) {
        Material[] low = {
            Material.WOODEN_SWORD, Material.STONE_SWORD, Material.BOW,
            Material.LEATHER_HELMET, Material.LEATHER_CHESTPLATE,
            Material.LEATHER_LEGGINGS, Material.LEATHER_BOOTS
        };
        Material[] mid = {
            Material.IRON_SWORD, Material.CROSSBOW,
            Material.CHAINMAIL_HELMET, Material.CHAINMAIL_CHESTPLATE,
            Material.CHAINMAIL_LEGGINGS, Material.CHAINMAIL_BOOTS
        };
        Material[] high = {
            Material.DIAMOND_SWORD, Material.NETHERITE_SWORD,
            Material.IRON_HELMET, Material.IRON_CHESTPLATE,
            Material.IRON_LEGGINGS, Material.IRON_BOOTS
        };
        Material[] pool = level < 5 ? low : (level < 15 ? mid : high);
        return pool[random.nextInt(pool.length)];
    }

    private Rarity rollRarity() {
        double roll = random.nextDouble();
        double total = 0.0;
        for (Rarity rarity : Rarity.values()) {
            total += rarity.weight();
            if (roll <= total) {
                return rarity;
            }
        }
        return Rarity.COMMON;
    }

    public void applyDefinition(LivingEntity entity, MobDefinition mob) {
        String name = mob.name();
        entity.customName(null);
        entity.setCustomNameVisible(false);
        double health = mob.health();
        DungeonInstance instance = plugin.dungeonManager().instanceForWorld(entity.getWorld());
        if (instance != null) {
            health *= instance.scale();
        }
        if (entity.getAttribute(Attribute.GENERIC_MAX_HEALTH) != null) {
            entity.getAttribute(Attribute.GENERIC_MAX_HEALTH).setBaseValue(health);
        }
        entity.setHealth(health);
        entity.getPersistentDataContainer().set(mobKey, PersistentDataType.STRING, mob.id());
        if (mob.mainHand() != null) {
            Material material = Material.matchMaterial(mob.mainHand());
            if (material != null) {
                entity.getEquipment().setItemInMainHand(new ItemStack(material));
            }
        }
        if (mob.helmet() != null) {
            Material material = Material.matchMaterial(mob.helmet());
            if (material != null) {
                entity.getEquipment().setHelmet(new ItemStack(material));
            }
        }
        attachHealthBar(entity, mob, entity.getHealth());
        startBehaviorLoop(entity, mob);
    }

    private String getMobId(LivingEntity entity) {
        if (!entity.getPersistentDataContainer().has(mobKey, PersistentDataType.STRING)) {
            return null;
        }
        return entity.getPersistentDataContainer().get(mobKey, PersistentDataType.STRING);
    }

    @EventHandler
    public void onMobDamage(EntityDamageEvent event) {
        if (!(event.getEntity() instanceof LivingEntity living)) {
            return;
        }
        String mobId = getMobId(living);
        if (mobId == null) {
            return;
        }
        MobDefinition mob = plugin.mobManager().getMob(mobId);
        if (mob == null) {
            return;
        }
        double nextHealth = Math.max(0, living.getHealth() - event.getFinalDamage());
        updateHealthBar(living, mob, nextHealth);
    }

    @EventHandler
    public void onMobHeal(EntityRegainHealthEvent event) {
        if (!(event.getEntity() instanceof LivingEntity living)) {
            return;
        }
        String mobId = getMobId(living);
        if (mobId == null) {
            return;
        }
        MobDefinition mob = plugin.mobManager().getMob(mobId);
        if (mob == null) {
            return;
        }
        double maxHealth = mob.health();
        double nextHealth = Math.min(maxHealth, living.getHealth() + event.getAmount());
        updateHealthBar(living, mob, nextHealth);
    }

    private void startBehaviorLoop(LivingEntity entity, MobDefinition mob) {
        BehaviorNode root = plugin.behaviorTreeManager().getTree(mob.behaviorTree());
        BehaviorContext context = new BehaviorContext(plugin, entity, mob);
        behaviorContexts.put(entity.getUniqueId(), context);
        BukkitTask task = plugin.getServer().getScheduler().runTaskTimer(plugin, () -> {
            if (entity.isDead() || !entity.isValid()) {
                BukkitTask running = behaviorTasks.remove(entity.getUniqueId());
                if (running != null) {
                    running.cancel();
                }
                behaviorContexts.remove(entity.getUniqueId());
                return;
            }
            Player target = findTarget(entity);
            context.setTarget(target);
            if (target == null) {
                return;
            }
            root.tick(context);
        }, 1L, 1L);
        behaviorTasks.put(entity.getUniqueId(), task);
    }

    private Player findTarget(LivingEntity entity) {
        return entity.getWorld().getPlayers().stream()
            .filter(player -> player.getLocation().distanceSquared(entity.getLocation()) <= 400)
            .min((a, b) -> Double.compare(a.getLocation().distanceSquared(entity.getLocation()),
                b.getLocation().distanceSquared(entity.getLocation())))
            .orElse(null);
    }

    private void attachHealthBar(LivingEntity entity, MobDefinition mob, double health) {
        removeHealthBar(entity);
        TextDisplay display = entity.getWorld().spawn(entity.getLocation().add(0, 1.6, 0), TextDisplay.class);
        display.setBillboard(Display.Billboard.CENTER);
        display.setSeeThrough(true);
        display.setShadowed(true);
        display.text(net.kyori.adventure.text.Component.text(buildHealthText(mob, health)));
        entity.addPassenger(display);
        healthBars.put(entity.getUniqueId(), display);
    }

    private void updateHealthBar(LivingEntity entity, MobDefinition mob, double health) {
        TextDisplay display = healthBars.get(entity.getUniqueId());
        if (display == null || display.isDead()) {
            attachHealthBar(entity, mob, health);
            return;
        }
        display.text(net.kyori.adventure.text.Component.text(buildHealthText(mob, health)));
    }

    private void removeHealthBar(LivingEntity entity) {
        TextDisplay display = healthBars.remove(entity.getUniqueId());
        if (display != null && !display.isDead()) {
            display.remove();
        }
    }

    private String buildHealthText(MobDefinition mob, double health) {
        double maxHealth = Math.max(1, mob.health());
        int bars = 10;
        int filled = (int) Math.round((health / maxHealth) * bars);
        filled = Math.min(bars, Math.max(0, filled));
        int empty = bars - filled;
        StringBuilder bar = new StringBuilder();
        bar.append("7[a");
        bar.append("|".repeat(filled));
        bar.append("c");
        bar.append("|".repeat(empty));
        bar.append("7]");
        return mob.name() + " " + bar + " f" + Math.round(health) + "/" + Math.round(maxHealth) + " HP";
    }
}

```

## File: `src/main/java/com/example/rpg/listener/DamageIndicatorListener.java`  
- Path: `src/main/java/com/example/rpg/listener/DamageIndicatorListener.java`  
- Size: 2751 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import java.util.Random;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;
import org.bukkit.Location;
import org.bukkit.entity.Display;
import org.bukkit.entity.Entity;
import org.bukkit.entity.TextDisplay;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityDamageEvent;
import org.bukkit.event.entity.EntityRegainHealthEvent;

public class DamageIndicatorListener implements Listener {
    private final RPGPlugin plugin;
    private final Random random = new Random();

    public DamageIndicatorListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onDamage(EntityDamageEvent event) {
        if (event.getFinalDamage() <= 0) {
            return;
        }
        Entity entity = event.getEntity();
        if (entity instanceof TextDisplay) {
            return;
        }
        NamedTextColor color = isMagicDamage(event.getCause()) ? NamedTextColor.AQUA : NamedTextColor.RED;
        String text = "-" + Math.round(event.getFinalDamage()) + " ";
        spawnIndicator(entity.getLocation(), text, color);
    }

    @EventHandler
    public void onRegain(EntityRegainHealthEvent event) {
        if (event.getAmount() <= 0) {
            return;
        }
        Entity entity = event.getEntity();
        if (entity instanceof TextDisplay) {
            return;
        }
        String text = "+" + Math.round(event.getAmount()) + " ";
        spawnIndicator(entity.getLocation(), text, NamedTextColor.GREEN);
    }

    private boolean isMagicDamage(EntityDamageEvent.DamageCause cause) {
        return switch (cause) {
            case MAGIC, DRAGON_BREATH, WITHER, POISON -> true;
            default -> false;
        };
    }

    private void spawnIndicator(Location base, String text, NamedTextColor color) {
        Location location = base.clone().add(offset(), 1.2 + offset(), offset());
        TextDisplay display = base.getWorld().spawn(location, TextDisplay.class);
        display.text(Component.text(text, color));
        display.setBillboard(Display.Billboard.CENTER);
        display.setSeeThrough(true);
        display.setShadowed(true);

        plugin.getServer().getScheduler().runTaskTimer(plugin, task -> {
            if (display.isDead()) {
                task.cancel();
                return;
            }
            display.teleport(display.getLocation().add(0, 0.04, 0));
        }, 0L, 1L);

        plugin.getServer().getScheduler().runTaskLater(plugin, display::remove, 20L);
    }

    private double offset() {
        return (random.nextDouble() - 0.5) * 0.6;
    }
}

```

## File: `src/main/java/com/example/rpg/listener/GuiListener.java`  
- Path: `src/main/java/com/example/rpg/listener/GuiListener.java`  
- Size: 79214 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import com.example.rpg.gui.GuiHolders;
import com.example.rpg.model.ClassDefinition;
import com.example.rpg.model.LootEntry;
import com.example.rpg.model.LootTable;
import com.example.rpg.model.Npc;
import com.example.rpg.model.NpcRole;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.model.Quest;
import com.example.rpg.model.QuestProgress;
import com.example.rpg.model.QuestStep;
import com.example.rpg.model.QuestStepType;
import com.example.rpg.model.Rarity;
import com.example.rpg.model.Skill;
import com.example.rpg.model.SkillCategory;
import com.example.rpg.model.SkillType;
import com.example.rpg.skill.SkillEffectConfig;
import com.example.rpg.skill.SkillEffectType;
import com.example.rpg.util.Text;
import java.util.Locale;
import java.util.Optional;
import java.util.UUID;
import org.bukkit.Location;
import org.bukkit.NamespacedKey;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataType;
import org.bukkit.inventory.Inventory;
import org.bukkit.Sound;
import org.bukkit.Material;

public class GuiListener implements Listener {
    private final RPGPlugin plugin;

    public GuiListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onClick(InventoryClickEvent event) {
        if (!(event.getWhoClicked() instanceof Player player)) {
            return;
        }
        ItemStack current = event.getCurrentItem();
        if (current == null) {
            return;
        }
        var holder = event.getInventory().getHolder();
        if (holder instanceof GuiHolders.PlayerMenuHolder) {
            event.setCancelled(true);
            switch (event.getSlot()) {
                case 12 -> plugin.guiManager().openSkillList(player);
                case 14 -> plugin.guiManager().openQuestLog(player);
                case 15 -> plugin.guiManager().openQuestList(player);
                default -> {
                }
            }
            return;
        }
        if (holder instanceof GuiHolders.AdminMenuHolder) {
            event.setCancelled(true);
            switch (event.getSlot()) {
                case 10 -> plugin.guiManager().openZoneEditor(player);
                case 11 -> plugin.guiManager().openNpcEditor(player);
                case 12 -> plugin.guiManager().openQuestEditor(player);
                case 13 -> plugin.guiManager().openLootEditor(player);
                case 14 -> plugin.guiManager().openSkillAdmin(player);
                case 15 -> {
                    boolean enabled = plugin.toggleDebug(player.getUniqueId());
                    player.sendMessage(Text.mm(enabled ? "<green>Debug aktiviert." : "<red>Debug deaktiviert."));
                }
                case 16 -> plugin.guiManager().openBuildingCategories(player);
                case 17 -> plugin.guiManager().openPermissionsMain(player);
                default -> {
                }
            }
            return;
        }
        if (holder instanceof GuiHolders.ZoneEditorHolder zoneHolder) {
            event.setCancelled(true);
            int page = zoneHolder.page();
            if (event.getSlot() == 45) {
                plugin.guiManager().openZoneEditor(player, page - 1);
                return;
            }
            if (event.getSlot() == 53) {
                plugin.guiManager().openZoneEditor(player, page + 1);
                return;
            }
            if (event.getSlot() == 49) {
                plugin.promptManager().prompt(player, Text.mm("<yellow>Zone erstellen: <id>"), input -> {
                    String id = input.trim();
                    if (id.isBlank()) {
                        player.sendMessage(Text.mm("<red>ID darf nicht leer sein."));
                        return;
                    }
                    if (plugin.zoneManager().getZone(id) != null) {
                        player.sendMessage(Text.mm("<red>Zone existiert bereits."));
                        return;
                    }
                    Location pos1 = readPosition(player, "pos1");
                    Location pos2 = readPosition(player, "pos2");
                    if (pos1 == null || pos2 == null) {
                        player.sendMessage(Text.mm("<red>Setze Pos1/Pos2 mit der Wand."));
                        return;
                    }
                    com.example.rpg.model.Zone zone = new com.example.rpg.model.Zone(id);
                    zone.setName(id);
                    zone.setWorld(pos1.getWorld().getName());
                    zone.setBounds(pos1, pos2);
                    plugin.zoneManager().zones().put(id, zone);
                    plugin.zoneManager().saveZone(zone);
                    plugin.auditLog().log(player, "Zone erstellt (GUI): " + id);
                    player.sendMessage(Text.mm("<green>Zone erstellt: " + id));
                    plugin.guiManager().openZoneEditor(player, page);
                });
                return;
            }
            String zoneId = resolveZoneId(current);
            if (zoneId == null) {
                return;
            }
            if (event.isRightClick()) {
                if (plugin.zoneManager().zones().remove(zoneId) != null) {
                    plugin.zoneManager().saveAll();
                    plugin.auditLog().log(player, "Zone gelscht (GUI): " + zoneId);
                    player.sendMessage(Text.mm("<red>Zone gelscht: " + zoneId));
                    plugin.guiManager().openZoneEditor(player, page);
                }
                return;
            }
            var zone = plugin.zoneManager().getZone(zoneId);
            if (zone == null) {
                return;
            }
            plugin.promptManager().prompt(player, Text.mm("<yellow>Zone bearbeiten: <name|level|mod|bounds|world> ..."), input -> {
                String[] parts = input.trim().split("\\s+");
                if (parts.length == 0 || parts[0].isBlank()) {
                    player.sendMessage(Text.mm("<red>Ungltige Eingabe."));
                    return;
                }
                String action = parts[0].toLowerCase(Locale.ROOT);
                switch (action) {
                    case "name" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: name <wert>"));
                            return;
                        }
                        String name = input.substring(input.indexOf(' ') + 1).trim();
                        if (name.isBlank()) {
                            player.sendMessage(Text.mm("<red>Name darf nicht leer sein."));
                            return;
                        }
                        zone.setName(name);
                    }
                    case "level" -> {
                        if (parts.length < 3) {
                            player.sendMessage(Text.mm("<red>Format: level <min> <max>"));
                            return;
                        }
                        Integer min = parseInt(parts[1]);
                        Integer max = parseInt(parts[2]);
                        if (min == null || max == null || min < 1 || max < min) {
                            player.sendMessage(Text.mm("<red>Ungltiger Levelbereich."));
                            return;
                        }
                        zone.setMinLevel(min);
                        zone.setMaxLevel(max);
                    }
                    case "mod" -> {
                        if (parts.length < 3) {
                            player.sendMessage(Text.mm("<red>Format: mod <slow> <damage>"));
                            return;
                        }
                        Double slow = parseDouble(parts[1]);
                        Double dmg = parseDouble(parts[2]);
                        if (slow == null || dmg == null || slow <= 0.0 || dmg <= 0.0) {
                            player.sendMessage(Text.mm("<red>Ungltige Mod-Werte."));
                            return;
                        }
                        zone.setSlowMultiplier(slow);
                        zone.setDamageMultiplier(dmg);
                    }
                    case "bounds" -> {
                        Location pos1 = readPosition(player, "pos1");
                        Location pos2 = readPosition(player, "pos2");
                        if (pos1 == null || pos2 == null) {
                            player.sendMessage(Text.mm("<red>Setze Pos1/Pos2 mit der Wand."));
                            return;
                        }
                        zone.setWorld(pos1.getWorld().getName());
                        zone.setBounds(pos1, pos2);
                    }
                    case "world" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: world <name>"));
                            return;
                        }
                        zone.setWorld(parts[1]);
                    }
                    default -> {
                        player.sendMessage(Text.mm("<red>Unbekannte Aktion."));
                        return;
                    }
                }
                plugin.zoneManager().saveZone(zone);
                plugin.auditLog().log(player, "Zone aktualisiert (GUI): " + zone.id());
                player.sendMessage(Text.mm("<green>Zone aktualisiert."));
                plugin.guiManager().openZoneEditor(player, page);
            });
            return;
        }
        if (holder instanceof GuiHolders.NpcEditorHolder npcHolder) {
            event.setCancelled(true);
            int page = npcHolder.page();
            if (event.getSlot() == 45) {
                plugin.guiManager().openNpcEditor(player, page - 1);
                return;
            }
            if (event.getSlot() == 53) {
                plugin.guiManager().openNpcEditor(player, page + 1);
                return;
            }
            NpcRole templateRole = resolveNpcTemplate(current);
            if (templateRole != null) {
                handleNpcTemplateClick(player, templateRole);
                return;
            }
            if (event.getSlot() == 49) {
                plugin.promptManager().prompt(player, Text.mm("<yellow>NPC erstellen: <id> <role> [shopId]"), input -> {
                    String[] parts = input.trim().split("\\s+");
                    runSync(() -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: <id> <role> [shopId]"));
                            return;
                        }
                        String id = parts[0];
                        if (plugin.npcManager().getNpc(id) != null) {
                            player.sendMessage(Text.mm("<red>NPC existiert bereits."));
                            return;
                        }
                        Optional<NpcRole> roleOpt = parseEnum(NpcRole.class, parts[1]);
                        if (roleOpt.isEmpty()) {
                            player.sendMessage(Text.mm("<red>Unbekannte Rolle."));
                            return;
                        }
                        Npc npc = new Npc(id);
                        npc.setName(id);
                        npc.setRole(roleOpt.get());
                        npc.setLocation(player.getLocation());
                        npc.setDialog(java.util.List.of("Hallo!", "Ich habe eine Aufgabe fr dich."));
                        if (npc.role() == NpcRole.VENDOR && parts.length >= 3) {
                            npc.setShopId(parts[2]);
                        }
                        plugin.npcManager().npcs().put(id, npc);
                        plugin.npcManager().spawnNpc(npc);
                        plugin.npcManager().saveNpc(npc);
                        plugin.auditLog().log(player, "NPC erstellt (GUI): " + id);
                        player.sendMessage(Text.mm("<green>NPC erstellt: " + id));
                        plugin.guiManager().openNpcEditor(player, page);
                    });
                });
                return;
            }
            String npcId = resolveNpcId(current);
            if (npcId == null) {
                return;
            }
            if (event.isRightClick()) {
                Npc npc = plugin.npcManager().getNpc(npcId);
                if (npc != null) {
                    runSync(() -> {
                        removeNpcEntity(npc);
                        plugin.npcManager().npcs().remove(npcId);
                        plugin.npcManager().saveAll();
                        plugin.auditLog().log(player, "NPC gelscht (GUI): " + npcId);
                        player.sendMessage(Text.mm("<red>NPC gelscht: " + npcId));
                        plugin.guiManager().openNpcEditor(player, page);
                    });
                }
                return;
            }
            Npc npc = plugin.npcManager().getNpc(npcId);
            if (npc == null) {
                return;
            }
            plugin.promptManager().prompt(player, Text.mm("<yellow>NPC bearbeiten: <name|role|dialog|quest|shop|faction|rank|move> ..."), input -> {
                String[] parts = input.trim().split("\\s+");
                runSync(() -> {
                    if (parts.length == 0 || parts[0].isBlank()) {
                        player.sendMessage(Text.mm("<red>Ungltige Eingabe."));
                        return;
                    }
                    String action = parts[0].toLowerCase(Locale.ROOT);
                    boolean needsRespawn = false;
                    switch (action) {
                        case "name" -> {
                            if (parts.length < 2) {
                                player.sendMessage(Text.mm("<red>Format: name <wert>"));
                                return;
                            }
                            String name = input.substring(input.indexOf(' ') + 1).trim();
                            if (name.isBlank()) {
                                player.sendMessage(Text.mm("<red>Name darf nicht leer sein."));
                                return;
                            }
                            npc.setName(name);
                            needsRespawn = true;
                        }
                        case "role" -> {
                            if (parts.length < 2) {
                                player.sendMessage(Text.mm("<red>Format: role <rolle>"));
                                return;
                            }
                            Optional<NpcRole> roleOpt = parseEnum(NpcRole.class, parts[1]);
                            if (roleOpt.isEmpty()) {
                                player.sendMessage(Text.mm("<red>Unbekannte Rolle."));
                                return;
                            }
                            npc.setRole(roleOpt.get());
                            needsRespawn = true;
                        }
                        case "dialog" -> {
                            if (parts.length < 2) {
                                player.sendMessage(Text.mm("<red>Format: dialog <text>"));
                                return;
                            }
                            String dialog = input.substring(input.indexOf(' ') + 1).trim();
                            if (dialog.isBlank()) {
                                player.sendMessage(Text.mm("<red>Dialog darf nicht leer sein."));
                                return;
                            }
                            npc.setDialog(java.util.List.of(dialog));
                        }
                        case "quest" -> {
                            if (parts.length < 2) {
                                player.sendMessage(Text.mm("<red>Format: quest <questId|none>"));
                                return;
                            }
                            String questId = parts[1];
                            if (!questId.equalsIgnoreCase("none") && plugin.questManager().getQuest(questId) == null) {
                                player.sendMessage(Text.mm("<red>Quest nicht gefunden."));
                                return;
                            }
                            npc.setQuestLink(questId.equalsIgnoreCase("none") ? null : questId);
                        }
                        case "shop" -> {
                            if (parts.length < 2) {
                                player.sendMessage(Text.mm("<red>Format: shop <shopId|none>"));
                                return;
                            }
                            String shopId = parts[1];
                            if (!shopId.equalsIgnoreCase("none") && plugin.shopManager().getShop(shopId) == null) {
                                player.sendMessage(Text.mm("<red>Shop nicht gefunden."));
                                return;
                            }
                            npc.setShopId(shopId.equalsIgnoreCase("none") ? null : shopId);
                        }
                        case "faction" -> {
                            if (parts.length < 2) {
                                player.sendMessage(Text.mm("<red>Format: faction <factionId|none>"));
                                return;
                            }
                            String factionId = parts[1];
                            if (!factionId.equalsIgnoreCase("none") && plugin.factionManager().getFaction(factionId) == null) {
                                player.sendMessage(Text.mm("<red>Fraktion nicht gefunden."));
                                return;
                            }
                            npc.setFactionId(factionId.equalsIgnoreCase("none") ? null : factionId);
                        }
                        case "rank" -> {
                            if (parts.length < 2) {
                                player.sendMessage(Text.mm("<red>Format: rank <rankId|none>"));
                                return;
                            }
                            String rankId = parts[1];
                            npc.setRequiredRankId(rankId.equalsIgnoreCase("none") ? null : rankId);
                        }
                        case "move" -> {
                            npc.setLocation(player.getLocation());
                            needsRespawn = true;
                        }
                        default -> {
                            player.sendMessage(Text.mm("<red>Unbekannte Aktion."));
                            return;
                        }
                    }
                    if (needsRespawn) {
                        respawnNpc(npc);
                    }
                    plugin.npcManager().saveNpc(npc);
                    plugin.auditLog().log(player, "NPC aktualisiert (GUI): " + npc.id());
                    player.sendMessage(Text.mm("<green>NPC aktualisiert."));
                    plugin.guiManager().openNpcEditor(player, page);
                });
            });
            return;
        }
        if (holder instanceof GuiHolders.QuestEditorHolder) {
            event.setCancelled(true);
            GuiHolders.QuestEditorHolder questHolder = (GuiHolders.QuestEditorHolder) holder;
            int page = questHolder.page();
            int questCount = plugin.questManager().quests().size();
            int maxPage = questCount == 0 ? 0 : (questCount - 1) / 45;
            if (event.getSlot() == 45) {
                if (page > 0) {
                    plugin.guiManager().openQuestEditor(player, page - 1);
                }
                return;
            }
            if (event.getSlot() == 53) {
                if (page < maxPage) {
                    plugin.guiManager().openQuestEditor(player, page + 1);
                }
                return;
            }
            if (event.getSlot() == 49) {
                plugin.promptManager().prompt(player, Text.mm("<yellow>Quest erstellen: <id> <name>"), input -> {
                    String[] parts = input.trim().split("\\s+", 2);
                    if (parts.length < 2) {
                        player.sendMessage(Text.mm("<red>Format: <id> <name>"));
                        return;
                    }
                    String id = parts[0];
                    if (plugin.questManager().getQuest(id) != null) {
                        player.sendMessage(Text.mm("<red>Quest existiert bereits."));
                        return;
                    }
                    Quest quest = new Quest(id);
                    quest.setName(parts[1]);
                    quest.setDescription("Neue Quest");
                    quest.setRepeatable(false);
                    quest.setMinLevel(1);
                    quest.setSteps(new java.util.ArrayList<>());
                    plugin.questManager().quests().put(id, quest);
                    plugin.questManager().saveQuest(quest);
                    plugin.auditLog().log(player, "Quest erstellt (GUI): " + id);
                    player.sendMessage(Text.mm("<green>Quest erstellt: " + id));
                    plugin.guiManager().openQuestEditor(player, page);
                });
                return;
            }
            String questId = resolveQuestId(current);
            if (questId == null) {
                return;
            }
            if (event.isRightClick()) {
                if (plugin.questManager().quests().remove(questId) != null) {
                    plugin.questManager().saveAll();
                    plugin.auditLog().log(player, "Quest gelscht (GUI): " + questId);
                    player.sendMessage(Text.mm("<red>Quest gelscht: " + questId));
                    plugin.guiManager().openQuestEditor(player, page);
                }
                return;
            }
            Quest quest = plugin.questManager().getQuest(questId);
            if (quest == null) {
                return;
            }
            plugin.promptManager().prompt(player, Text.mm("<yellow>Quest bearbeiten: <name|desc|minlevel|repeatable|event|addstep> ..."), input -> {
                String[] parts = input.trim().split("\\s+");
                if (parts.length == 0 || parts[0].isBlank()) {
                    player.sendMessage(Text.mm("<red>Ungltige Eingabe."));
                    return;
                }
                String action = parts[0].toLowerCase(Locale.ROOT);
                switch (action) {
                    case "name" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: name <wert>"));
                            return;
                        }
                        String name = input.substring(input.indexOf(' ') + 1).trim();
                        if (name.isBlank()) {
                            player.sendMessage(Text.mm("<red>Name darf nicht leer sein."));
                            return;
                        }
                        quest.setName(name);
                    }
                    case "desc" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: desc <text>"));
                            return;
                        }
                        String desc = input.substring(input.indexOf(' ') + 1).trim();
                        quest.setDescription(desc);
                    }
                    case "minlevel" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: minlevel <level>"));
                            return;
                        }
                        Integer level = parseInt(parts[1]);
                        if (level == null || level < 1) {
                            player.sendMessage(Text.mm("<red>Level ungltig."));
                            return;
                        }
                        quest.setMinLevel(level);
                    }
                    case "repeatable" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: repeatable <true|false>"));
                            return;
                        }
                        quest.setRepeatable(Boolean.parseBoolean(parts[1]));
                    }
                    case "event" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: event <eventId|none>"));
                            return;
                        }
                        String eventId = parts[1];
                        quest.setRequiredEvent(eventId.equalsIgnoreCase("none") ? null : eventId);
                    }
                    case "addstep" -> {
                        if (parts.length < 4) {
                            player.sendMessage(Text.mm("<red>Format: addstep <type> <target> <amount>"));
                            return;
                        }
                        Optional<QuestStepType> typeOpt = parseEnum(QuestStepType.class, parts[1]);
                        if (typeOpt.isEmpty()) {
                            player.sendMessage(Text.mm("<red>Unbekannter Step-Typ."));
                            return;
                        }
                        Integer amount = parseInt(parts[3]);
                        if (amount == null || amount < 1) {
                            player.sendMessage(Text.mm("<red>Amount muss >= 1 sein."));
                            return;
                        }
                        quest.steps().add(new QuestStep(typeOpt.get(), parts[2], amount));
                    }
                    default -> {
                        player.sendMessage(Text.mm("<red>Unbekannte Aktion."));
                        return;
                    }
                }
                plugin.questManager().saveQuest(quest);
                plugin.auditLog().log(player, "Quest aktualisiert (GUI): " + quest.id());
                player.sendMessage(Text.mm("<green>Quest aktualisiert."));
                plugin.guiManager().openQuestEditor(player, page);
            });
            return;
        }
        if (holder instanceof GuiHolders.LootEditorHolder lootHolder) {
            event.setCancelled(true);
            int page = lootHolder.page();
            if (event.getSlot() == 45) {
                plugin.guiManager().openLootEditor(player, page - 1);
                return;
            }
            if (event.getSlot() == 53) {
                plugin.guiManager().openLootEditor(player, page + 1);
                return;
            }
            if (event.getSlot() == 49) {
                plugin.promptManager().prompt(player, Text.mm("<yellow>Loot-Tabelle erstellen: <id> <appliesTo>"), input -> {
                    String[] parts = input.trim().split("\\s+", 2);
                    if (parts.length < 2) {
                        player.sendMessage(Text.mm("<red>Format: <id> <appliesTo>"));
                        return;
                    }
                    String id = parts[0];
                    if (plugin.lootManager().getTable(id) != null) {
                        player.sendMessage(Text.mm("<red>Loot-Tabelle existiert bereits."));
                        return;
                    }
                    LootTable table = new LootTable(id);
                    table.setAppliesTo(parts[1]);
                    plugin.lootManager().tables().put(id, table);
                    plugin.lootManager().saveTable(table);
                    plugin.auditLog().log(player, "Loot-Tabelle erstellt (GUI): " + id);
                    player.sendMessage(Text.mm("<green>Loot-Tabelle erstellt."));
                    plugin.guiManager().openLootEditor(player, page);
                });
                return;
            }
            String tableId = resolveLootId(current);
            if (tableId == null) {
                return;
            }
            if (event.isRightClick()) {
                if (plugin.lootManager().tables().remove(tableId) != null) {
                    plugin.lootManager().saveAll();
                    plugin.auditLog().log(player, "Loot-Tabelle gelscht (GUI): " + tableId);
                    player.sendMessage(Text.mm("<red>Loot-Tabelle gelscht: " + tableId));
                    plugin.guiManager().openLootEditor(player, page);
                }
                return;
            }
            LootTable table = plugin.lootManager().getTable(tableId);
            if (table == null) {
                return;
            }
            plugin.promptManager().prompt(player, Text.mm("<yellow>Loot bearbeiten: <applies|addentry|clear> ..."), input -> {
                String[] parts = input.trim().split("\\s+");
                if (parts.length == 0 || parts[0].isBlank()) {
                    player.sendMessage(Text.mm("<red>Ungltige Eingabe."));
                    return;
                }
                String action = parts[0].toLowerCase(Locale.ROOT);
                switch (action) {
                    case "applies" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: applies <target>"));
                            return;
                        }
                        table.setAppliesTo(parts[1]);
                    }
                    case "addentry" -> {
                        if (parts.length < 6) {
                            player.sendMessage(Text.mm("<red>Format: addentry <material> <chance> <min> <max> <rarity>"));
                            return;
                        }
                        Material mat = Material.matchMaterial(parts[1].toUpperCase(Locale.ROOT));
                        if (mat == null) {
                            player.sendMessage(Text.mm("<red>Material ungltig."));
                            return;
                        }
                        Double chance = parseDouble(parts[2]);
                        Integer min = parseInt(parts[3]);
                        Integer max = parseInt(parts[4]);
                        Optional<Rarity> rarityOpt = parseEnum(Rarity.class, parts[5]);
                        if (chance == null || min == null || max == null || rarityOpt.isEmpty()) {
                            player.sendMessage(Text.mm("<red>Parameter ungltig."));
                            return;
                        }
                        if (chance < 0.0 || chance > 1.0 || min < 1 || max < min) {
                            player.sendMessage(Text.mm("<red>Chance 0..1 und min/max prfen."));
                            return;
                        }
                        table.entries().add(new LootEntry(mat.name(), chance, min, max, rarityOpt.get()));
                    }
                    case "clear" -> table.entries().clear();
                    default -> {
                        player.sendMessage(Text.mm("<red>Unbekannte Aktion."));
                        return;
                    }
                }
                plugin.lootManager().saveTable(table);
                plugin.auditLog().log(player, "Loot-Tabelle aktualisiert (GUI): " + table.id());
                player.sendMessage(Text.mm("<green>Loot-Tabelle aktualisiert."));
                plugin.guiManager().openLootEditor(player, page);
            });
            return;
        }
        if (holder instanceof GuiHolders.SkillAdminHolder skillAdminHolder) {
            event.setCancelled(true);
            int page = skillAdminHolder.page();
            if (event.getSlot() == 45) {
                plugin.guiManager().openSkillAdmin(player, page - 1);
                return;
            }
            if (event.getSlot() == 53) {
                plugin.guiManager().openSkillAdmin(player, page + 1);
                return;
            }
            if (event.getSlot() == 48) {
                plugin.guiManager().openClassAdmin(player, 0);
                return;
            }
            if (event.getSlot() == 49) {
                plugin.promptManager().prompt(player, Text.mm("<yellow>Skill erstellen: <id>"), input -> {
                    String id = input.trim().toLowerCase(Locale.ROOT);
                    if (id.isBlank()) {
                        player.sendMessage(Text.mm("<red>ID darf nicht leer sein."));
                        return;
                    }
                    if (plugin.skillManager().getSkill(id) != null) {
                        player.sendMessage(Text.mm("<red>Skill existiert bereits."));
                        return;
                    }
                    Skill skill = new Skill(id);
                    skill.setName(id);
                    skill.setType(SkillType.ACTIVE);
                    skill.setCategory(SkillCategory.ATTACK);
                    skill.setCooldown(10);
                    skill.setManaCost(10);
                    skill.setEffects(new java.util.ArrayList<>());
                    plugin.skillManager().skills().put(id, skill);
                    plugin.skillManager().saveSkill(skill);
                    plugin.auditLog().log(player, "Skill erstellt (GUI): " + id);
                    player.sendMessage(Text.mm("<green>Skill erstellt: " + id));
                    plugin.guiManager().openSkillAdmin(player, page);
                });
                return;
            }
            Skill skill = resolveSkill(current);
            if (skill == null) {
                return;
            }
            if (event.isRightClick()) {
                if (plugin.skillManager().skills().remove(skill.id()) != null) {
                    plugin.skillManager().saveAll();
                    removeSkillFromClasses(skill.id());
                    plugin.auditLog().log(player, "Skill gelscht (GUI): " + skill.id());
                    player.sendMessage(Text.mm("<red>Skill gelscht: " + skill.id()));
                    plugin.guiManager().openSkillAdmin(player, page);
                }
                return;
            }
            plugin.promptManager().prompt(player, Text.mm("<yellow>Skill bearbeiten: <name|cooldown|mana|category|type|requires|addeffect|cleareffects> ..."), input -> {
                String[] parts = input.trim().split("\\s+");
                if (parts.length == 0 || parts[0].isBlank()) {
                    player.sendMessage(Text.mm("<red>Ungltige Eingabe."));
                    return;
                }
                String action = parts[0].toLowerCase(Locale.ROOT);
                switch (action) {
                    case "name" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: name <wert>"));
                            return;
                        }
                        String name = input.substring(input.indexOf(' ') + 1).trim();
                        if (name.isBlank()) {
                            player.sendMessage(Text.mm("<red>Name darf nicht leer sein."));
                            return;
                        }
                        skill.setName(name);
                    }
                    case "cooldown" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: cooldown <wert>"));
                            return;
                        }
                        Integer value = parseInt(parts[1]);
                        if (value == null || value < 0) {
                            player.sendMessage(Text.mm("<red>Cooldown ungltig."));
                            return;
                        }
                        skill.setCooldown(value);
                    }
                    case "mana" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: mana <wert>"));
                            return;
                        }
                        Integer value = parseInt(parts[1]);
                        if (value == null || value < 0) {
                            player.sendMessage(Text.mm("<red>Mana ungltig."));
                            return;
                        }
                        skill.setManaCost(value);
                    }
                    case "category" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: category <kategorie>"));
                            return;
                        }
                        Optional<SkillCategory> category = parseEnum(SkillCategory.class, parts[1]);
                        if (category.isEmpty()) {
                            player.sendMessage(Text.mm("<red>Unbekannte Kategorie."));
                            return;
                        }
                        skill.setCategory(category.get());
                    }
                    case "type" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: type <typ>"));
                            return;
                        }
                        Optional<SkillType> type = parseEnum(SkillType.class, parts[1]);
                        if (type.isEmpty()) {
                            player.sendMessage(Text.mm("<red>Unbekannter Typ."));
                            return;
                        }
                        skill.setType(type.get());
                    }
                    case "requires" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: requires <skillId|none>"));
                            return;
                        }
                        skill.setRequiredSkill(parts[1].equalsIgnoreCase("none") ? null : parts[1]);
                    }
                    case "addeffect" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: addeffect <effectType> <param:value>..."));
                            return;
                        }
                        Optional<SkillEffectType> typeOpt = parseEnum(SkillEffectType.class, parts[1]);
                        if (typeOpt.isEmpty()) {
                            player.sendMessage(Text.mm("<red>Unbekannter Effekt-Typ."));
                            return;
                        }
                        java.util.Map<String, Object> params = new java.util.HashMap<>();
                        for (int i = 2; i < parts.length; i++) {
                            String token = parts[i];
                            if (!token.contains(":")) {
                                continue;
                            }
                            String[] pair = token.split(":", 2);
                            params.put(pair[0], parseParamValue(pair[1]));
                        }
                        skill.effects().add(new SkillEffectConfig(typeOpt.get(), params));
                    }
                    case "cleareffects" -> skill.effects().clear();
                    default -> {
                        player.sendMessage(Text.mm("<red>Unbekannte Aktion."));
                        return;
                    }
                }
                plugin.skillManager().saveSkill(skill);
                plugin.auditLog().log(player, "Skill aktualisiert (GUI): " + skill.id());
                player.sendMessage(Text.mm("<green>Skill aktualisiert."));
                plugin.guiManager().openSkillAdmin(player, page);
            });
            return;
        }
        if (holder instanceof GuiHolders.ClassAdminHolder classAdminHolder) {
            event.setCancelled(true);
            int page = classAdminHolder.page();
            if (event.getSlot() == 45) {
                plugin.guiManager().openClassAdmin(player, page - 1);
                return;
            }
            if (event.getSlot() == 53) {
                plugin.guiManager().openClassAdmin(player, page + 1);
                return;
            }
            if (event.getSlot() == 49) {
                plugin.promptManager().prompt(player, Text.mm("<yellow>Klasse erstellen: <id> <name>"), input -> {
                    String[] parts = input.trim().split("\\s+", 2);
                    if (parts.length < 2) {
                        player.sendMessage(Text.mm("<red>Format: <id> <name>"));
                        return;
                    }
                    String id = parts[0];
                    if (plugin.classManager().getClass(id) != null) {
                        player.sendMessage(Text.mm("<red>Klasse existiert bereits."));
                        return;
                    }
                    ClassDefinition definition = new ClassDefinition(id);
                    definition.setName(parts[1]);
                    definition.setStartSkills(new java.util.ArrayList<>());
                    plugin.classManager().classes().put(id, definition);
                    plugin.classManager().saveClass(definition);
                    plugin.auditLog().log(player, "Klasse erstellt (GUI): " + id);
                    player.sendMessage(Text.mm("<green>Klasse erstellt: " + id));
                    plugin.guiManager().openClassAdmin(player, page);
                });
                return;
            }
            String classId = resolveClassId(current);
            if (classId == null) {
                return;
            }
            if (event.isRightClick()) {
                if (plugin.classManager().classes().remove(classId) != null) {
                    plugin.classManager().saveAll();
                    plugin.auditLog().log(player, "Klasse gelscht (GUI): " + classId);
                    player.sendMessage(Text.mm("<red>Klasse gelscht: " + classId));
                    plugin.guiManager().openClassAdmin(player, page);
                }
                return;
            }
            ClassDefinition definition = plugin.classManager().getClass(classId);
            if (definition == null) {
                return;
            }
            plugin.promptManager().prompt(player, Text.mm("<yellow>Klasse bearbeiten: <name|addskill|removeskill> ..."), input -> {
                String[] parts = input.trim().split("\\s+");
                if (parts.length == 0 || parts[0].isBlank()) {
                    player.sendMessage(Text.mm("<red>Ungltige Eingabe."));
                    return;
                }
                String action = parts[0].toLowerCase(Locale.ROOT);
                switch (action) {
                    case "name" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: name <wert>"));
                            return;
                        }
                        String name = input.substring(input.indexOf(' ') + 1).trim();
                        if (name.isBlank()) {
                            player.sendMessage(Text.mm("<red>Name darf nicht leer sein."));
                            return;
                        }
                        definition.setName(name);
                    }
                    case "addskill" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: addskill <skillId>"));
                            return;
                        }
                        if (plugin.skillManager().getSkill(parts[1]) == null) {
                            player.sendMessage(Text.mm("<red>Skill nicht gefunden."));
                            return;
                        }
                        if (!definition.startSkills().contains(parts[1])) {
                            definition.startSkills().add(parts[1]);
                        }
                    }
                    case "removeskill" -> {
                        if (parts.length < 2) {
                            player.sendMessage(Text.mm("<red>Format: removeskill <skillId>"));
                            return;
                        }
                        definition.startSkills().remove(parts[1]);
                    }
                    default -> {
                        player.sendMessage(Text.mm("<red>Unbekannte Aktion."));
                        return;
                    }
                }
                plugin.classManager().saveClass(definition);
                plugin.auditLog().log(player, "Klasse aktualisiert (GUI): " + definition.id());
                player.sendMessage(Text.mm("<green>Klasse aktualisiert."));
                plugin.guiManager().openClassAdmin(player, page);
            });
            return;
        }
        if (holder instanceof GuiHolders.BuildingCategoryHolder) {
            event.setCancelled(true);
            String category = resolveBuildingCategory(current);
            if (category == null) {
                return;
            }
            if ("SINGLE".equalsIgnoreCase(category)) {
                player.closeInventory();
                plugin.promptManager().prompt(player, Text.mm("<yellow>Schematic-Dateiname eingeben (z.B. haus.schem):"), input -> {
                    plugin.buildingManager().beginSingleSchematicPlacement(player, input, com.example.rpg.schematic.Transform.Rotation.NONE);
                });
                return;
            }
            plugin.guiManager().openBuildingList(player, com.example.rpg.model.BuildingCategory.fromString(category));
            return;
        }
        if (holder instanceof GuiHolders.BuildingListHolder buildingListHolder) {
            event.setCancelled(true);
            int page = buildingListHolder.page();
            if (event.getSlot() == 45) {
                plugin.guiManager().openBuildingList(player,
                    com.example.rpg.model.BuildingCategory.fromString(buildingListHolder.category()), page - 1);
                return;
            }
            if (event.getSlot() == 53) {
                plugin.guiManager().openBuildingList(player,
                    com.example.rpg.model.BuildingCategory.fromString(buildingListHolder.category()), page + 1);
                return;
            }
            String buildingId = resolveBuilding(current);
            if (buildingId == null) {
                return;
            }
            plugin.buildingManager().beginPlacement(player, buildingId, com.example.rpg.schematic.Transform.Rotation.NONE);
            player.closeInventory();
            return;
        }
        if (holder instanceof GuiHolders.QuestListHolder questListHolder) {
            event.setCancelled(true);
            int page = questListHolder.page();
            if (event.getSlot() == 18) {
                plugin.guiManager().openQuestList(player, page - 1);
                return;
            }
            if (event.getSlot() == 26) {
                plugin.guiManager().openQuestList(player, page + 1);
                return;
            }
            Quest quest = resolveQuest(current);
            if (quest == null) {
                return;
            }
            plugin.guiManager().openQuestDetails(player, quest.id(), false, page);
            return;
        }
        if (holder instanceof GuiHolders.QuestLogHolder questLogHolder) {
            event.setCancelled(true);
            int page = questLogHolder.page();
            if (event.getSlot() == 45) {
                plugin.guiManager().openQuestLog(player, page - 1);
                return;
            }
            if (event.getSlot() == 53) {
                plugin.guiManager().openQuestLog(player, page + 1);
                return;
            }
            if (event.getSlot() == 49) {
                plugin.guiManager().openQuestList(player, 0);
                return;
            }
            Quest quest = resolveQuest(current);
            if (quest == null) {
                return;
            }
            plugin.guiManager().openQuestDetails(player, quest.id(), true, page);
            return;
        }
        if (holder instanceof GuiHolders.QuestDetailHolder questDetailHolder) {
            event.setCancelled(true);
            if (event.getSlot() == 26) {
                if (questDetailHolder.active()) {
                    plugin.guiManager().openQuestLog(player, questDetailHolder.page());
                } else {
                    plugin.guiManager().openQuestList(player, questDetailHolder.page());
                }
                return;
            }
            if (event.getSlot() != 22) {
                return;
            }
            if (questDetailHolder.active()) {
                return;
            }
            Quest quest = plugin.questManager().getQuest(questDetailHolder.questId());
            if (quest == null) {
                player.sendMessage(Text.mm("<red>Quest nicht gefunden."));
                return;
            }
            if (quest.requiredEvent() != null && !plugin.worldEventManager().isCompleted(quest.requiredEvent())) {
                player.sendMessage(Text.mm("<red>Quest noch gesperrt."));
                return;
            }
            PlayerProfile profile = plugin.playerDataManager().getProfile(player);
            if (profile.level() < quest.minLevel()) {
                player.sendMessage(Text.mm("<red>Du brauchst Level " + quest.minLevel() + "."));
                return;
            }
            if (profile.activeQuests().containsKey(quest.id())) {
                player.sendMessage(Text.mm("<yellow>Quest bereits aktiv."));
                return;
            }
            if (profile.completedQuests().contains(quest.id()) && !quest.repeatable()) {
                player.sendMessage(Text.mm("<red>Quest bereits abgeschlossen."));
                return;
            }
            profile.activeQuests().put(quest.id(), new QuestProgress(quest.id()));
            player.sendMessage(Text.mm("<green>Quest angenommen: " + quest.name()));
            plugin.guiManager().openQuestLog(player, 0);
            return;
        }
        if (holder instanceof GuiHolders.SkillListHolder skillListHolder) {
            event.setCancelled(true);
            int page = skillListHolder.page();
            if (event.getSlot() == 18) {
                plugin.guiManager().openSkillList(player, page - 1);
                return;
            }
            if (event.getSlot() == 26) {
                plugin.guiManager().openSkillList(player, page + 1);
                return;
            }
            Skill skill = resolveSkill(current);
            if (skill == null) {
                return;
            }
            PlayerProfile profile = plugin.playerDataManager().getProfile(player);
            if (profile.skillPoints() <= 0) {
                player.sendMessage(Text.mm("<red>Keine Skillpunkte."));
                return;
            }
            if (skill.requiredSkill() != null && !profile.learnedSkills().containsKey(skill.requiredSkill())) {
                player.sendMessage(Text.mm("<red>Du musst zuerst " + skill.requiredSkill() + " lernen."));
                return;
            }
            profile.learnedSkills().put(skill.id(), profile.learnedSkills().getOrDefault(skill.id(), 0) + 1);
            profile.setSkillPoints(profile.skillPoints() - 1);
            player.sendMessage(Text.mm("<green>Skill gelernt: " + skill.name()));
            plugin.guiManager().openSkillList(player, page);
            return;
        }
        if (holder instanceof GuiHolders.SkillTreeHolder) {
            event.setCancelled(true);
            Skill skill = resolveSkill(current);
            if (skill == null) {
                return;
            }
            PlayerProfile profile = plugin.playerDataManager().getProfile(player);
            if (profile.skillPoints() <= 0) {
                player.sendMessage(Text.mm("<red>Keine Skillpunkte."));
                return;
            }
            if (skill.requiredSkill() != null && !profile.learnedSkills().containsKey(skill.requiredSkill())) {
                player.sendMessage(Text.mm("<red>Du musst zuerst " + skill.requiredSkill() + " lernen."));
                return;
            }
            if (profile.learnedSkills().containsKey(skill.id())) {
                player.sendMessage(Text.mm("<yellow>Bereits gelernt."));
                return;
            }
            profile.learnedSkills().put(skill.id(), 1);
            profile.setSkillPoints(profile.skillPoints() - 1);
            player.sendMessage(Text.mm("<green>Skill gelernt: " + skill.name()));
            plugin.skillTreeGui().open(player);
            return;
        }
        if (holder instanceof GuiHolders.ShopHolder shopHolder) {
            event.setCancelled(true);
            handleShopClick(player, event.getInventory(), event.getSlot(), current, shopHolder, event.isRightClick());
        }
        if (holder instanceof GuiHolders.SchematicMoveHolder) {
            event.setCancelled(true);
            switch (event.getSlot()) {
                case 11 -> plugin.buildingManager().moveLastPlacement(player, -1, 0, 0);
                case 15 -> plugin.buildingManager().moveLastPlacement(player, 1, 0, 0);
                case 13 -> plugin.buildingManager().moveLastPlacement(player, 0, 1, 0);
                case 22 -> plugin.buildingManager().moveLastPlacement(player, 0, -1, 0);
                case 26 -> player.closeInventory();
                default -> {
                }
            }
            return;
        }
        if (holder instanceof GuiHolders.PermissionsMainHolder) {
            event.setCancelled(true);
            switch (event.getSlot()) {
                case 11 -> plugin.guiManager().openRoleList(player, 0);
                case 13 -> plugin.guiManager().openPlayerList(player);
                case 15 -> plugin.guiManager().openAuditLog(player);
                default -> {
                }
            }
            return;
        }
        if (holder instanceof GuiHolders.RoleListHolder roleListHolder) {
            event.setCancelled(true);
            if (event.getSlot() == 45) {
                plugin.guiManager().openPermissionsMain(player);
                return;
            }
            if (event.getSlot() == 53) {
                plugin.promptManager().prompt(player, Text.mm("<yellow>Rolle erstellen: <key> <displayName>"), input -> {
                    String[] parts = input.split("\\s+", 2);
                    if (parts.length < 2) {
                        player.sendMessage(Text.mm("<red>Format: <key> <displayName>"));
                        return;
                    }
                    plugin.permissionService().createRole(player, parts[0], parts[1]);
                    plugin.guiManager().openRoleList(player, roleListHolder.page());
                });
                return;
            }
            String roleKey = resolveRoleKey(current);
            if (roleKey != null) {
                plugin.guiManager().openRoleDetails(player, roleKey);
            }
            return;
        }
        if (holder instanceof GuiHolders.RoleDetailHolder roleDetailHolder) {
            event.setCancelled(true);
            String roleKey = roleDetailHolder.roleKey();
            switch (event.getSlot()) {
                case 11 -> plugin.guiManager().openRoleParents(player, roleKey);
                case 13 -> plugin.guiManager().openRoleNodes(player, roleKey, 0);
                case 15 -> plugin.promptManager().prompt(player, Text.mm("<yellow>Neuer Display-Name fr " + roleKey + ":"), input -> {
                    if (input.isBlank()) {
                        player.sendMessage(Text.mm("<red>Display-Name darf nicht leer sein."));
                        return;
                    }
                    plugin.permissionService().renameRole(player, roleKey, input.trim());
                    plugin.guiManager().openRoleDetails(player, roleKey);
                });
                case 26 -> {
                    plugin.permissionService().deleteRole(player, roleKey);
                    plugin.guiManager().openRoleList(player, 0);
                }
                default -> {
                }
            }
            return;
        }
        if (holder instanceof GuiHolders.RoleParentsHolder roleParentsHolder) {
            event.setCancelled(true);
            if (event.getSlot() == 45) {
                plugin.guiManager().openRoleDetails(player, roleParentsHolder.roleKey());
                return;
            }
            String parentKey = resolveNodeKey(current);
            if (parentKey == null) {
                return;
            }
            String roleKey = roleParentsHolder.roleKey();
            var role = plugin.permissionService().roles().get(roleKey);
            if (role == null) {
                return;
            }
            if (role.parents().contains(parentKey)) {
                plugin.permissionService().removeParent(player, roleKey, parentKey);
            } else {
                plugin.permissionService().addParent(player, roleKey, parentKey);
            }
            plugin.guiManager().openRoleParents(player, roleKey);
            return;
        }
        if (holder instanceof GuiHolders.RoleNodesHolder roleNodesHolder) {
            event.setCancelled(true);
            if (event.getSlot() == 45) {
                plugin.guiManager().openRoleDetails(player, roleNodesHolder.roleKey());
                return;
            }
            if (event.getSlot() == 53) {
                plugin.promptManager().prompt(player, Text.mm("<yellow>Node setzen: <node> <allow|deny|inherit>"), input -> {
                    String[] parts = input.split("\\s+", 2);
                    if (parts.length < 2) {
                        player.sendMessage(Text.mm("<red>Format: <node> <allow|deny|inherit>"));
                        return;
                    }
                    var decision = parseDecision(parts[1]);
                    plugin.permissionService().setRoleNode(player, roleNodesHolder.roleKey(), parts[0], decision);
                    plugin.guiManager().openRoleNodes(player, roleNodesHolder.roleKey(), roleNodesHolder.page());
                });
                return;
            }
            String node = resolveNodeKey(current);
            if (node == null) {
                return;
            }
            var role = plugin.permissionService().roles().get(roleNodesHolder.roleKey());
            if (role == null) {
                return;
            }
            var currentDecision = role.nodes().getOrDefault(node, com.example.rpg.permissions.PermissionDecision.INHERIT);
            var nextDecision = switch (currentDecision) {
                case INHERIT -> com.example.rpg.permissions.PermissionDecision.ALLOW;
                case ALLOW -> com.example.rpg.permissions.PermissionDecision.DENY;
                case DENY -> com.example.rpg.permissions.PermissionDecision.INHERIT;
            };
            plugin.permissionService().setRoleNode(player, roleNodesHolder.roleKey(), node, nextDecision);
            plugin.guiManager().openRoleNodes(player, roleNodesHolder.roleKey(), roleNodesHolder.page());
            return;
        }
        if (holder instanceof GuiHolders.PlayerListHolder playerListHolder) {
            event.setCancelled(true);
            int page = playerListHolder.page();
            if (event.getSlot() == 45) {
                plugin.guiManager().openPlayerList(player, page - 1);
                return;
            }
            if (event.getSlot() == 53) {
                plugin.guiManager().openPlayerList(player, page + 1);
                return;
            }
            if (event.getSlot() == 47) {
                plugin.guiManager().openPermissionsMain(player);
                return;
            }
            if (event.getSlot() == 49) {
                plugin.promptManager().prompt(player, Text.mm("<yellow>Spielername eingeben:"), input -> {
                    var target = plugin.getServer().getOfflinePlayer(input);
                    if (target == null) {
                        player.sendMessage(Text.mm("<red>Spieler nicht gefunden."));
                        return;
                    }
                    plugin.guiManager().openPlayerRoles(player, target.getUniqueId());
                });
                return;
            }
            UUID targetId = resolvePlayerId(current);
            if (targetId != null) {
                plugin.guiManager().openPlayerRoles(player, targetId);
            }
            return;
        }
        if (holder instanceof GuiHolders.PlayerRoleHolder playerRoleHolder) {
            event.setCancelled(true);
            UUID targetId = playerRoleHolder.targetId();
            switch (event.getSlot()) {
                case 12 -> plugin.promptManager().prompt(player, Text.mm("<yellow>Primary Rolle setzen:"), input -> {
                    plugin.permissionService().assignPrimary(player, targetId, input.trim());
                    plugin.guiManager().openPlayerRoles(player, targetId);
                });
                case 14 -> plugin.promptManager().prompt(player, Text.mm("<yellow>Rolle hinzufgen:"), input -> {
                    plugin.permissionService().addRole(player, targetId, input.trim());
                    plugin.guiManager().openPlayerRoles(player, targetId);
                });
                case 16 -> plugin.promptManager().prompt(player, Text.mm("<yellow>Rolle entfernen:"), input -> {
                    plugin.permissionService().removeRole(player, targetId, input.trim());
                    plugin.guiManager().openPlayerRoles(player, targetId);
                });
                case 22 -> plugin.promptManager().prompt(player, Text.mm("<yellow>Node prfen:"), input -> {
                    var explain = plugin.permissionService().explain(targetId, input.trim());
                    player.sendMessage(Text.mm("<yellow>Ergebnis: " + (explain.allowed() ? "ALLOW" : "DENY")));
                    if (explain.winningRole() != null) {
                        player.sendMessage(Text.mm("<gray>Role: " + explain.winningRole() + " Node: " + explain.winningNode()));
                    }
                });
                default -> {
                }
            }
            return;
        }
        if (holder instanceof GuiHolders.PermissionAuditHolder auditHolder) {
            event.setCancelled(true);
            int page = auditHolder.page();
            if (event.getSlot() == 45) {
                plugin.guiManager().openAuditLog(player, page - 1);
                return;
            }
            if (event.getSlot() == 53) {
                plugin.guiManager().openAuditLog(player, page + 1);
                return;
            }
            if (event.getSlot() == 49) {
                plugin.guiManager().openPermissionsMain(player);
            }
            return;
        }
        if (holder instanceof GuiHolders.EnchantingHolder enchantingHolder) {
            event.setCancelled(true);
            int page = enchantingHolder.page();
            if (event.getSlot() == 18) {
                plugin.guiManager().openEnchanting(player, enchantingHolder.recipeId(), page - 1);
                return;
            }
            if (event.getSlot() == 26) {
                plugin.guiManager().openEnchanting(player, enchantingHolder.recipeId(), page + 1);
                return;
            }
            if (event.getSlot() == 25) {
                player.closeInventory();
                return;
            }
            if (event.getSlot() == 22) {
                String recipeId = enchantingHolder.recipeId();
                if (recipeId == null) {
                    player.sendMessage(Text.mm("<red>Kein Rezept ausgewhlt."));
                    return;
                }
                plugin.enchantManager().applyRecipe(player, recipeId);
                plugin.guiManager().openEnchanting(player, recipeId, page);
                return;
            }
            String recipeId = resolveEnchantRecipeId(current);
            if (recipeId != null) {
                plugin.guiManager().openEnchanting(player, recipeId, page);
            }
        }
    }

    private Quest resolveQuest(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        String questId = meta.getPersistentDataContainer().get(plugin.questKey(), PersistentDataType.STRING);
        if (questId == null) {
            return null;
        }
        return plugin.questManager().getQuest(questId);
    }

    private Skill resolveSkill(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        String skillId = meta.getPersistentDataContainer().get(plugin.skillKey(), PersistentDataType.STRING);
        if (skillId == null) {
            return null;
        }
        return plugin.skillManager().getSkill(skillId);
    }

    private String resolveBuilding(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        return meta.getPersistentDataContainer().get(plugin.buildingKey(), PersistentDataType.STRING);
    }

    private String resolveBuildingCategory(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        return meta.getPersistentDataContainer().get(plugin.buildingCategoryKey(), PersistentDataType.STRING);
    }

    private String resolveRoleKey(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        return meta.getPersistentDataContainer().get(plugin.permRoleKey(), PersistentDataType.STRING);
    }

    private String resolveZoneId(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        return meta.getPersistentDataContainer().get(plugin.zoneKey(), PersistentDataType.STRING);
    }

    private String resolveNpcId(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        return meta.getPersistentDataContainer().get(plugin.npcGuiKey(), PersistentDataType.STRING);
    }

    private NpcRole resolveNpcTemplate(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        String value = meta.getPersistentDataContainer().get(plugin.npcTemplateKey(), PersistentDataType.STRING);
        if (value == null) {
            return null;
        }
        return parseEnum(NpcRole.class, value).orElse(null);
    }

    private String resolveQuestId(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        return meta.getPersistentDataContainer().get(plugin.questKey(), PersistentDataType.STRING);
    }

    private String resolveLootId(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        return meta.getPersistentDataContainer().get(plugin.lootKey(), PersistentDataType.STRING);
    }

    private String resolveClassId(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        return meta.getPersistentDataContainer().get(plugin.classKey(), PersistentDataType.STRING);
    }

    private String resolveNodeKey(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        return meta.getPersistentDataContainer().get(plugin.permNodeKey(), PersistentDataType.STRING);
    }

    private UUID resolvePlayerId(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        String value = meta.getPersistentDataContainer().get(plugin.permPlayerKey(), PersistentDataType.STRING);
        if (value == null) {
            return null;
        }
        return UUID.fromString(value);
    }

    private String resolveEnchantRecipeId(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return null;
        }
        return meta.getPersistentDataContainer().get(plugin.enchantRecipeKey(), PersistentDataType.STRING);
    }

    private com.example.rpg.permissions.PermissionDecision parseDecision(String value) {
        return switch (value.toLowerCase()) {
            case "allow" -> com.example.rpg.permissions.PermissionDecision.ALLOW;
            case "deny" -> com.example.rpg.permissions.PermissionDecision.DENY;
            default -> com.example.rpg.permissions.PermissionDecision.INHERIT;
        };
    }

    private Location readPosition(Player player, String key) {
        NamespacedKey namespacedKey = new NamespacedKey(plugin, key);
        String value = player.getPersistentDataContainer().get(namespacedKey, PersistentDataType.STRING);
        if (value == null) {
            return null;
        }
        String[] parts = value.split(",");
        if (parts.length < 4) {
            return null;
        }
        org.bukkit.World world = plugin.getServer().getWorld(parts[0]);
        if (world == null) {
            return null;
        }
        return new Location(world,
            Double.parseDouble(parts[1]), Double.parseDouble(parts[2]), Double.parseDouble(parts[3]));
    }

    private void respawnNpc(Npc npc) {
        runSync(() -> {
            removeNpcEntity(npc);
            plugin.npcManager().spawnNpc(npc);
            plugin.npcManager().saveNpc(npc);
        });
    }

    private void removeNpcEntity(Npc npc) {
        runSync(() -> {
            if (npc.uuid() == null) {
                return;
            }
            Entity entity = plugin.getServer().getEntity(npc.uuid());
            if (entity != null) {
                entity.remove();
            }
            npc.setUuid(null);
        });
    }

    private void removeSkillFromClasses(String skillId) {
        boolean updated = false;
        for (ClassDefinition definition : plugin.classManager().classes().values()) {
            if (definition.startSkills().remove(skillId)) {
                updated = true;
            }
        }
        if (updated) {
            plugin.classManager().saveAll();
        }
    }

    private void handleNpcTemplateClick(Player player, NpcRole templateRole) {
        if (templateRole == NpcRole.VENDOR) {
            plugin.promptManager().prompt(player, Text.mm("<yellow>Shop-NPC: <id> <shopId>"), input -> {
                String[] parts = input.trim().split("\\s+");
                runSync(() -> {
                    if (parts.length < 2) {
                        player.sendMessage(Text.mm("<red>Format: <id> <shopId>"));
                        return;
                    }
                    if (plugin.shopManager().getShop(parts[1]) == null) {
                        player.sendMessage(Text.mm("<red>Shop nicht gefunden."));
                        return;
                    }
                    createNpcFromTemplate(player, parts[0], templateRole, parts[1]);
                });
            });
            return;
        }
        plugin.promptManager().prompt(player, Text.mm("<yellow>NPC erstellen: <id>"), input -> {
            String id = input.trim();
            runSync(() -> {
                if (id.isBlank()) {
                    player.sendMessage(Text.mm("<red>ID darf nicht leer sein."));
                    return;
                }
                createNpcFromTemplate(player, id, templateRole, null);
            });
        });
    }

    private void createNpcFromTemplate(Player player, String id, NpcRole role, String shopId) {
        if (plugin.npcManager().getNpc(id) != null) {
            player.sendMessage(Text.mm("<red>NPC existiert bereits."));
            return;
        }
        Npc npc = new Npc(id);
        npc.setName(id);
        npc.setRole(role);
        npc.setLocation(player.getLocation());
        npc.setDialog(java.util.List.of("Hallo!", "Ich habe eine Aufgabe fr dich."));
        if (shopId != null && !shopId.isBlank()) {
            npc.setShopId(shopId);
        }
        plugin.npcManager().npcs().put(id, npc);
        plugin.npcManager().spawnNpc(npc);
        plugin.npcManager().saveNpc(npc);
        plugin.auditLog().log(player, "NPC erstellt (GUI): " + id);
        player.sendMessage(Text.mm("<green>NPC erstellt: " + id));
        plugin.guiManager().openNpcEditor(player);
    }

    private static Integer parseInt(String raw) {
        try {
            return Integer.parseInt(raw);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    private static Double parseDouble(String raw) {
        try {
            return Double.parseDouble(raw);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    private static <E extends Enum<E>> Optional<E> parseEnum(Class<E> type, String raw) {
        if (raw == null) {
            return Optional.empty();
        }
        String key = raw.trim().toUpperCase(Locale.ROOT);
        try {
            return Optional.of(Enum.valueOf(type, key));
        } catch (IllegalArgumentException e) {
            return Optional.empty();
        }
    }

    private static Object parseParamValue(String raw) {
        try {
            if (raw.contains(".")) {
                return Double.parseDouble(raw);
            }
            return Integer.parseInt(raw);
        } catch (NumberFormatException e) {
            return raw;
        }
    }

    private void runSync(Runnable action) {
        if (org.bukkit.Bukkit.isPrimaryThread()) {
            action.run();
        } else {
            plugin.getServer().getScheduler().runTask(plugin, action);
        }
    }

    private void handleShopClick(Player player, Inventory inventory, int slot, ItemStack clicked,
                                 GuiHolders.ShopHolder holder, boolean rightClick) {
        var shop = plugin.shopManager().getShop(holder.shopId());
        if (shop == null) {
            player.sendMessage(Text.mm("<red>Shop nicht gefunden."));
            return;
        }
        var shopItem = shop.items().get(slot);
        if (shopItem == null) {
            return;
        }
        var profile = plugin.playerDataManager().getProfile(player);
        Material material = Material.matchMaterial(shopItem.material());
        if (material == null) {
            player.sendMessage(Text.mm("<red>Item ungltig."));
            return;
        }
        if (rightClick) {
            int sellPrice = shopItem.sellPrice();
            if (sellPrice <= 0) {
                player.sendMessage(Text.mm("<red>Dieses Item kann nicht verkauft werden."));
                return;
            }
            boolean removed = false;
            ItemStack[] contents = player.getInventory().getContents();
            if (removeOneRpgItem(contents, material)) {
                player.getInventory().setContents(contents);
                removed = true;
            }
            if (!removed && removeOne(player.getInventory(), material)) {
                removed = true;
            }
            if (!removed) {
                player.sendMessage(Text.mm("<red>Du hast dieses Item nicht."));
                return;
            }
            profile.setGold(profile.gold() + sellPrice);
            player.playSound(player.getLocation(), Sound.ENTITY_EXPERIENCE_ORB_PICKUP, 1f, 1.2f);
            player.sendMessage(Text.mm("<green>Verkauft fr <gold>" + sellPrice + "</gold> Gold."));
        } else {
            int buyPrice = shopItem.buyPrice();
            if (buyPrice <= 0) {
                player.sendMessage(Text.mm("<red>Dieses Item kann nicht gekauft werden."));
                return;
            }
            if (profile.gold() < buyPrice) {
                player.sendMessage(Text.mm("<red>Nicht genug Gold."));
                return;
            }
            profile.setGold(profile.gold() - buyPrice);
            if (shopItem.rpgItem()) {
                var rarity = parseRarity(shopItem.rarity());
                ItemStack item = plugin.itemGenerator().createRpgItem(material, rarity, Math.max(1, shopItem.minLevel()));
                player.getInventory().addItem(item);
            } else {
                player.getInventory().addItem(new ItemStack(material));
            }
            player.playSound(player.getLocation(), Sound.ENTITY_EXPERIENCE_ORB_PICKUP, 1f, 1.2f);
            player.sendMessage(Text.mm("<green>Gekauft fr <gold>" + buyPrice + "</gold> Gold."));
        }
        player.updateInventory();
        plugin.playerDataManager().saveProfile(profile);
    }

    private boolean removeOneRpgItem(ItemStack[] contents, Material material) {
        for (int i = 0; i < contents.length; i++) {
            ItemStack item = contents[i];
            if (item == null || item.getType() != material) {
                continue;
            }
            ItemMeta meta = item.getItemMeta();
            if (meta == null) {
                continue;
            }
            if (!meta.getPersistentDataContainer().has(plugin.itemGenerator().itemKey(), PersistentDataType.INTEGER)) {
                continue;
            }
            int amount = item.getAmount();
            if (amount <= 1) {
                contents[i] = null;
            } else {
                item.setAmount(amount - 1);
            }
            return true;
        }
        return false;
    }

    private com.example.rpg.model.Rarity parseRarity(String raw) {
        if (raw == null) {
            return com.example.rpg.model.Rarity.COMMON;
        }
        try {
            return com.example.rpg.model.Rarity.valueOf(raw.toUpperCase(java.util.Locale.ROOT));
        } catch (IllegalArgumentException e) {
            return com.example.rpg.model.Rarity.COMMON;
        }
    }

    private boolean removeOne(Inventory inventory, Material material) {
        for (int i = 0; i < inventory.getSize(); i++) {
            ItemStack stack = inventory.getItem(i);
            if (stack == null || stack.getType() != material) {
                continue;
            }
            if (stack.getAmount() > 1) {
                stack.setAmount(stack.getAmount() - 1);
            } else {
                inventory.setItem(i, null);
            }
            return true;
        }
        return false;
    }
}

```

## File: `src/main/java/com/example/rpg/listener/ItemStatListener.java`  
- Path: `src/main/java/com/example/rpg/listener/ItemStatListener.java`  
- Size: 1207 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.player.PlayerJoinEvent;

public class ItemStatListener implements Listener {
    private final RPGPlugin plugin;

    public ItemStatListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onInventoryClick(InventoryClickEvent event) {
        if (!(event.getWhoClicked() instanceof Player player)) {
            return;
        }
        plugin.getServer().getScheduler().runTask(plugin, () -> {
            plugin.itemStatManager().updateSetBonus(player);
            plugin.playerDataManager().getProfile(player).applyAttributes(player, plugin.itemStatManager(), plugin.classManager());
        });
    }

    @EventHandler
    public void onJoin(PlayerJoinEvent event) {
        Player player = event.getPlayer();
        plugin.itemStatManager().updateSetBonus(player);
        plugin.playerDataManager().getProfile(player).applyAttributes(player, plugin.itemStatManager(), plugin.classManager());
    }
}

```

## File: `src/main/java/com/example/rpg/listener/MobHealthBarListener.java`  
- Path: `src/main/java/com/example/rpg/listener/MobHealthBarListener.java`  
- Size: 4096 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import net.kyori.adventure.text.Component;
import org.bukkit.attribute.Attribute;
import org.bukkit.entity.Display;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Monster;
import org.bukkit.entity.TextDisplay;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityDamageEvent;
import org.bukkit.event.entity.EntityDeathEvent;
import org.bukkit.event.entity.EntityRegainHealthEvent;
import org.bukkit.persistence.PersistentDataType;

public class MobHealthBarListener implements Listener {
    private final RPGPlugin plugin;
    private final Map<UUID, TextDisplay> healthBars = new HashMap<>();

    public MobHealthBarListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onDamage(EntityDamageEvent event) {
        if (!(event.getEntity() instanceof LivingEntity living)) {
            return;
        }
        if (!(living instanceof Monster)) {
            return;
        }
        if (isCustomMob(living)) {
            return;
        }
        updateHealthBar(living, Math.max(0, living.getHealth() - event.getFinalDamage()));
    }

    @EventHandler
    public void onRegain(EntityRegainHealthEvent event) {
        if (!(event.getEntity() instanceof LivingEntity living)) {
            return;
        }
        if (!(living instanceof Monster)) {
            return;
        }
        if (isCustomMob(living)) {
            return;
        }
        updateHealthBar(living, living.getHealth() + event.getAmount());
    }

    @EventHandler
    public void onDeath(EntityDeathEvent event) {
        if (!(event.getEntity() instanceof LivingEntity)) {
            return;
        }
        LivingEntity living = (LivingEntity) event.getEntity();
        removeHealthBar(living);
    }

    private boolean isCustomMob(LivingEntity living) {
        return living.getPersistentDataContainer()
            .has(plugin.customMobListener().mobKey(), PersistentDataType.STRING);
    }

    private void updateHealthBar(LivingEntity living, double health) {
        TextDisplay display = healthBars.get(living.getUniqueId());
        if (display == null || display.isDead()) {
            attachHealthBar(living, health);
            return;
        }
        display.text(Component.text(buildHealthText(living, health)));
    }

    private void attachHealthBar(LivingEntity living, double health) {
        removeHealthBar(living);
        TextDisplay display = living.getWorld().spawn(living.getLocation().add(0, 1.6, 0), TextDisplay.class);
        display.setBillboard(Display.Billboard.CENTER);
        display.setSeeThrough(true);
        display.setShadowed(true);
        display.text(Component.text(buildHealthText(living, health)));
        living.addPassenger(display);
        healthBars.put(living.getUniqueId(), display);
    }

    private void removeHealthBar(LivingEntity living) {
        TextDisplay display = healthBars.remove(living.getUniqueId());
        if (display != null && !display.isDead()) {
            display.remove();
        }
    }

    private String buildHealthText(LivingEntity living, double health) {
        double maxHealth = 20.0;
        if (living.getAttribute(Attribute.GENERIC_MAX_HEALTH) != null) {
            maxHealth = living.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue();
        }
        maxHealth = Math.max(1, maxHealth);
        int bars = 10;
        int filled = (int) Math.round((health / maxHealth) * bars);
        filled = Math.min(bars, Math.max(0, filled));
        int empty = bars - filled;
        StringBuilder bar = new StringBuilder();
        bar.append("7[a");
        bar.append("|".repeat(filled));
        bar.append("c");
        bar.append("|".repeat(empty));
        bar.append("7]");
        String name = living.getName();
        return name + " " + bar + " f" + Math.round(health) + "/" + Math.round(maxHealth) + " HP";
    }
}

```

## File: `src/main/java/com/example/rpg/listener/NpcListener.java`  
- Path: `src/main/java/com/example/rpg/listener/NpcListener.java`  
- Size: 14746 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.Npc;
import com.example.rpg.model.NpcRole;
import com.example.rpg.model.DialogueNode;
import com.example.rpg.model.DialogueOption;
import com.example.rpg.model.FactionRank;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.model.Rarity;
import com.example.rpg.model.ShopDefinition;
import com.example.rpg.model.ShopItem;
import com.example.rpg.util.Text;
import java.util.List;
import java.util.Map;
import java.util.Random;
import org.bukkit.Material;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerInteractEntityEvent;
import org.bukkit.persistence.PersistentDataType;

public class NpcListener implements Listener {
    private final RPGPlugin plugin;
    private final Random random = new Random();

    public NpcListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onInteract(PlayerInteractEntityEvent event) {
        Entity entity = event.getRightClicked();
        if (!entity.getPersistentDataContainer().has(plugin.npcManager().npcKey(), PersistentDataType.STRING)) {
            return;
        }
        String npcId = entity.getPersistentDataContainer().get(plugin.npcManager().npcKey(), PersistentDataType.STRING);
        if (npcId == null) {
            return;
        }
        Npc npc = plugin.npcManager().getNpc(npcId);
        if (npc == null) {
            return;
        }
        Player player = event.getPlayer();
        if (!npc.dialogueNodes().isEmpty()) {
            openDialogue(player, npc, "start");
        } else if (!npc.dialog().isEmpty()) {
            player.sendMessage(Text.mm("<gold>" + npc.name() + ":"));
            for (String line : npc.dialog()) {
                player.sendMessage(Text.mm("<gray>" + line));
            }
        }
        if (npc.factionId() != null && npc.requiredRankId() != null) {
            PlayerProfile profile = plugin.playerDataManager().getProfile(player);
            int rep = profile.factionRep().getOrDefault(npc.factionId(), 0);
            FactionRank rank = plugin.factionManager().getRank(npc.factionId(), rep);
            if (rank == null || !rank.id().equalsIgnoreCase(npc.requiredRankId())) {
                player.sendMessage(Text.mm("<red>Dein Ruf reicht nicht aus."));
                return;
            }
        }
        if (npc.role() == NpcRole.QUESTGIVER && npc.questLink() != null) {
            player.sendMessage(Text.mm("<yellow>Quest verfgbar: <white>" + npc.questLink()));
            plugin.guiManager().openQuestList(player);
        }
        if (npc.role() == NpcRole.VENDOR) {
            if (npc.shopId() != null) {
                openStaticShop(player, npc);
            } else {
                ShopDefinition shop = buildMixedVendorShop(npc, player);
                applyFactionDiscount(npc, player, shop);
                plugin.guiManager().openShop(player, shop);
            }
            return;
        }
        if (npc.role() == NpcRole.WEAPON_VENDOR
            || npc.role() == NpcRole.ARMOR_VENDOR
            || npc.role() == NpcRole.ITEM_VENDOR
            || npc.role() == NpcRole.RESOURCE_VENDOR) {
            ShopDefinition shop = buildVendorShop(npc, player);
            applyFactionDiscount(npc, player, shop);
            plugin.guiManager().openShop(player, shop);
        }
    }

    private void openStaticShop(Player player, Npc npc) {
        if (npc.shopId() == null) {
            return;
        }
        var shop = plugin.shopManager().getShop(npc.shopId());
        if (shop == null) {
            player.sendMessage(Text.mm("<red>Shop nicht gefunden."));
            return;
        }
        plugin.guiManager().openShop(player, shop);
    }

    private ShopDefinition buildVendorShop(Npc npc, Player player) {
        String title = switch (npc.role()) {
            case WEAPON_VENDOR -> "Waffenhndler";
            case ARMOR_VENDOR -> "Rstungshndler";
            case ITEM_VENDOR -> "Gegenstandshndler";
            case RESOURCE_VENDOR -> "Rohstoffhndler";
            default -> "Hndler";
        };
        ShopDefinition shop = new ShopDefinition("npc_" + npc.id());
        shop.setTitle(title);
        Map<Integer, ShopItem> items = new java.util.HashMap<>();
        List<Material> materials = switch (npc.role()) {
            case WEAPON_VENDOR -> weaponMaterials();
            case ARMOR_VENDOR -> armorMaterials();
            case ITEM_VENDOR -> itemMaterials();
            case RESOURCE_VENDOR -> resourceMaterials();
            default -> List.of(Material.BREAD);
        };
        int slot = 0;
        for (Material material : materials) {
            if (slot >= 54) {
                break;
            }
            ShopItem item = new ShopItem();
            item.setSlot(slot++);
            item.setMaterial(material.name());
            int buyPrice = priceForMaterial(material, npc.role());
            item.setBuyPrice(buyPrice);
            item.setSellPrice(Math.max(1, buyPrice / 3));
            item.setRpgItem(false);
            items.put(item.slot(), item);
        }
        shop.setItems(items);
        plugin.shopManager().registerShop(shop);
        return shop;
    }

    private ShopDefinition buildMixedVendorShop(Npc npc, Player player) {
        ShopDefinition shop = new ShopDefinition("npc_" + npc.id());
        shop.setTitle("Gemischtwaren");
        Map<Integer, ShopItem> items = new java.util.HashMap<>();
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        int level = Math.max(1, profile.level());
        List<Material> rpgMaterials = List.of(
            Material.WOODEN_SWORD, Material.STONE_SWORD, Material.IRON_SWORD,
            Material.LEATHER_HELMET, Material.LEATHER_CHESTPLATE, Material.LEATHER_LEGGINGS, Material.LEATHER_BOOTS,
            Material.CHAINMAIL_CHESTPLATE, Material.IRON_CHESTPLATE, Material.BOW
        );
        List<Material> normalMaterials = List.of(
            Material.BREAD, Material.COOKED_BEEF, Material.COOKED_CHICKEN,
            Material.IRON_NUGGET, Material.GOLD_NUGGET, Material.ARROW
        );
        int slot = 0;
        for (int i = 0; i < 6; i++) {
            Material material = rpgMaterials.get(random.nextInt(rpgMaterials.size()));
            ShopItem item = new ShopItem();
            item.setSlot(slot++);
            item.setMaterial(material.name());
            Rarity rarity = rollRarity();
            int base = 60 + (level * 12);
            int buyPrice = (int) Math.max(20, base * (1 + rarity.weight()));
            item.setBuyPrice(buyPrice);
            item.setSellPrice(Math.max(10, buyPrice / 4));
            item.setRpgItem(true);
            item.setRarity(rarity.name());
            item.setMinLevel(level);
            items.put(item.slot(), item);
        }
        for (int i = 0; i < 3; i++) {
            Material material = normalMaterials.get(random.nextInt(normalMaterials.size()));
            ShopItem item = new ShopItem();
            item.setSlot(slot++);
            item.setMaterial(material.name());
            item.setBuyPrice(20 + random.nextInt(30));
            item.setSellPrice(5 + random.nextInt(10));
            item.setRpgItem(false);
            items.put(item.slot(), item);
        }
        shop.setItems(items);
        plugin.shopManager().registerShop(shop);
        return shop;
    }

    private List<Material> weaponMaterials() {
        return List.of(
            Material.WOODEN_SWORD, Material.STONE_SWORD, Material.IRON_SWORD, Material.GOLDEN_SWORD,
            Material.DIAMOND_SWORD, Material.NETHERITE_SWORD,
            Material.WOODEN_AXE, Material.STONE_AXE, Material.IRON_AXE, Material.GOLDEN_AXE,
            Material.DIAMOND_AXE, Material.NETHERITE_AXE,
            Material.BOW, Material.CROSSBOW, Material.TRIDENT
        );
    }

    private List<Material> armorMaterials() {
        return List.of(
            Material.LEATHER_HELMET, Material.LEATHER_CHESTPLATE, Material.LEATHER_LEGGINGS, Material.LEATHER_BOOTS,
            Material.CHAINMAIL_HELMET, Material.CHAINMAIL_CHESTPLATE, Material.CHAINMAIL_LEGGINGS, Material.CHAINMAIL_BOOTS,
            Material.IRON_HELMET, Material.IRON_CHESTPLATE, Material.IRON_LEGGINGS, Material.IRON_BOOTS,
            Material.GOLDEN_HELMET, Material.GOLDEN_CHESTPLATE, Material.GOLDEN_LEGGINGS, Material.GOLDEN_BOOTS,
            Material.DIAMOND_HELMET, Material.DIAMOND_CHESTPLATE, Material.DIAMOND_LEGGINGS, Material.DIAMOND_BOOTS,
            Material.NETHERITE_HELMET, Material.NETHERITE_CHESTPLATE, Material.NETHERITE_LEGGINGS, Material.NETHERITE_BOOTS,
            Material.TURTLE_HELMET
        );
    }

    private List<Material> itemMaterials() {
        return List.of(
            Material.BREAD, Material.COOKED_BEEF, Material.COOKED_CHICKEN, Material.COOKED_PORKCHOP,
            Material.COOKED_MUTTON, Material.COOKED_RABBIT, Material.GOLDEN_APPLE,
            Material.POTION, Material.ARROW, Material.TORCH, Material.LANTERN,
            Material.SHIELD, Material.BUCKET, Material.WATER_BUCKET, Material.MILK_BUCKET
        );
    }

    private List<Material> resourceMaterials() {
        return List.of(
            Material.COAL, Material.CHARCOAL, Material.IRON_NUGGET, Material.GOLD_NUGGET,
            Material.IRON_INGOT, Material.GOLD_INGOT, Material.COPPER_INGOT,
            Material.REDSTONE, Material.LAPIS_LAZULI, Material.DIAMOND, Material.EMERALD,
            Material.QUARTZ, Material.NETHERITE_SCRAP, Material.AMETHYST_SHARD
        );
    }

    private int priceForMaterial(Material material, NpcRole role) {
        String name = material.name();
        int base = switch (role) {
            case RESOURCE_VENDOR -> 25;
            case ITEM_VENDOR -> 40;
            default -> 80;
        };
        if (name.contains("NETHERITE")) {
            return base + 900;
        }
        if (name.contains("DIAMOND")) {
            return base + 600;
        }
        if (name.contains("GOLD")) {
            return base + 350;
        }
        if (name.contains("IRON") || name.contains("CHAINMAIL")) {
            return base + 200;
        }
        if (name.contains("STONE")) {
            return base + 80;
        }
        if (name.contains("WOOD") || name.contains("LEATHER")) {
            return base + 40;
        }
        if (name.contains("EMERALD")) {
            return base + 500;
        }
        if (name.contains("COAL") || name.contains("COPPER")) {
            return base + 60;
        }
        return base + 120;
    }

    private Rarity rollRarity() {
        double roll = random.nextDouble();
        double total = 0.0;
        for (Rarity rarity : Rarity.values()) {
            total += rarity.weight();
            if (roll <= total) {
                return rarity;
            }
        }
        return Rarity.COMMON;
    }

    private void applyFactionDiscount(Npc npc, Player player, ShopDefinition shop) {
        if (npc.factionId() == null) {
            return;
        }
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        int rep = profile.factionRep().getOrDefault(npc.factionId(), 0);
        FactionRank rank = plugin.factionManager().getRank(npc.factionId(), rep);
        if (rank == null || rank.shopDiscount() <= 0) {
            return;
        }
        for (ShopItem item : shop.items().values()) {
            int buy = item.buyPrice();
            if (buy <= 0) {
                continue;
            }
            int discounted = (int) Math.max(1, Math.round(buy * (1 - rank.shopDiscount())));
            item.setBuyPrice(discounted);
        }
    }

    private void openDialogue(Player player, Npc npc, String nodeId) {
        DialogueNode node = npc.dialogueNodes().get(nodeId);
        if (node == null) {
            return;
        }
        player.sendMessage(Text.mm("<gold>" + npc.name() + ": <white>" + node.text()));
        if (node.options().isEmpty()) {
            return;
        }
        java.util.List<DialogueOption> available = new java.util.ArrayList<>();
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        for (DialogueOption option : node.options()) {
            if (option.requiredFactionId() != null) {
                int rep = profile.factionRep().getOrDefault(option.requiredFactionId(), 0);
                if (rep < option.minRep()) {
                    continue;
                }
            }
            if (option.requiredQuestId() != null) {
                boolean completed = profile.completedQuests().contains(option.requiredQuestId());
                boolean active = profile.activeQuests().containsKey(option.requiredQuestId());
                if (option.requireQuestCompleted() && !completed) {
                    continue;
                }
                if (!option.requireQuestCompleted() && !active && !completed) {
                    continue;
                }
            }
            available.add(option);
        }
        if (available.isEmpty()) {
            player.sendMessage(Text.mm("<gray>Keine Optionen verfgbar."));
            return;
        }
        int index = 1;
        for (DialogueOption option : available) {
            player.sendMessage(Text.mm("<yellow>" + index++ + ". <white>" + option.text()));
        }
        plugin.promptManager().prompt(player, Text.mm("<gray>Whle eine Option (Zahl):"), input -> {
            int choice;
            try {
                choice = Integer.parseInt(input);
            } catch (NumberFormatException e) {
                player.sendMessage(Text.mm("<red>Ungltige Auswahl."));
                return;
            }
            if (choice < 1 || choice > available.size()) {
                player.sendMessage(Text.mm("<red>Ungltige Auswahl."));
                return;
            }
            DialogueOption selected = available.get(choice - 1);
            if (selected.grantQuestId() != null) {
                var quest = plugin.questManager().getQuest(selected.grantQuestId());
                if (quest != null && !profile.activeQuests().containsKey(quest.id())) {
                    profile.activeQuests().put(quest.id(), new com.example.rpg.model.QuestProgress(quest.id()));
                    player.sendMessage(Text.mm("<green>Quest angenommen: " + quest.name()));
                }
            }
            if (selected.nextId() != null && !"end".equalsIgnoreCase(selected.nextId())) {
                openDialogue(player, npc, selected.nextId());
            }
        });
    }
}

```

## File: `src/main/java/com/example/rpg/listener/NpcProtectionListener.java`  
- Path: `src/main/java/com/example/rpg/listener/NpcProtectionListener.java`  
- Size: 1270 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import org.bukkit.entity.Entity;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityDamageEvent;
import org.bukkit.event.entity.EntityTargetEvent;
import org.bukkit.persistence.PersistentDataType;

/**
 * Schutz: NPCs sollen nicht beschdigt, nicht getargetet und nicht "interaktiv kaputt" gemacht werden.
 * (Ohne externe Plugins.)
 */
public class NpcProtectionListener implements Listener {
    private final RPGPlugin plugin;

    public NpcProtectionListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    private boolean isNpc(Entity entity) {
        return entity.getPersistentDataContainer().has(plugin.npcManager().npcKey(), PersistentDataType.STRING);
    }

    @EventHandler
    public void onDamage(EntityDamageEvent event) {
        if (isNpc(event.getEntity())) {
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onTarget(EntityTargetEvent event) {
        if (event.getTarget() != null && isNpc(event.getTarget())) {
            event.setCancelled(true);
        }
    }

    // Intentionally no PlayerInteractAtEntityEvent cancel to avoid breaking normal right-click.
}

```

## File: `src/main/java/com/example/rpg/listener/PlayerListener.java`  
- Path: `src/main/java/com/example/rpg/listener/PlayerListener.java`  
- Size: 5592 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.util.Text;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import org.bukkit.Material;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataType;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.entity.PlayerDeathEvent;
import org.bukkit.event.player.AsyncPlayerChatEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.inventory.ItemStack;

public class PlayerListener implements Listener {
    private final RPGPlugin plugin;
    private final Map<UUID, Float> walkSpeed = new HashMap<>();
    private final Map<UUID, Float> flySpeed = new HashMap<>();

    public PlayerListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onJoin(PlayerJoinEvent event) {
        Player player = event.getPlayer();
        freeze(player);
        plugin.playerDataManager().loadProfileAsync(player.getUniqueId()).whenComplete((profile, error) -> {
            plugin.getServer().getScheduler().runTask(plugin, () -> {
                if (!player.isOnline()) {
                    return;
                }
                PlayerProfile resolved = profile != null ? profile : plugin.playerDataManager().getProfile(player);
                resolved.applyAttributes(player, plugin.itemStatManager(), plugin.classManager());
                unfreeze(player);
            });
        });
    }

    @EventHandler
    public void onChat(AsyncPlayerChatEvent event) {
        Player player = event.getPlayer();
        if (plugin.promptManager().handle(player, event.getMessage())) {
            event.setCancelled(true);
            return;
        }
        var profile = plugin.playerDataManager().getProfile(player);
        if (profile.title() != null && !profile.title().isBlank()) {
            event.setFormat("[" + profile.title() + "] " + player.getName() + ": " + event.getMessage());
        }
    }

    @EventHandler
    public void onDeath(PlayerDeathEvent event) {
        event.setKeepInventory(true);
        event.getDrops().clear();
        event.setKeepLevel(true);
        event.setDroppedExp(0);
        plugin.dungeonManager().markDeath(event.getEntity());
    }

    @EventHandler
    public void onWandUse(PlayerInteractEvent event) {
        Player player = event.getPlayer();
        if (!plugin.permissionService().has(player, "rpg.editor")) {
            return;
        }
        ItemStack item = event.getItem();
        if (item == null || item.getType() != Material.STICK) {
            return;
        }
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return;
        }
        if (!meta.getPersistentDataContainer().has(plugin.wandKey(), PersistentDataType.BYTE)) {
            return;
        }
        if (event.getClickedBlock() == null) {
            return;
        }
        if (event.getAction() == Action.LEFT_CLICK_BLOCK) {
            player.sendMessage(Text.mm("<green>Pos1 gesetzt: " + event.getClickedBlock().getLocation().toVector()));
            player.getPersistentDataContainer().set(
                new org.bukkit.NamespacedKey(plugin, "pos1"),
                org.bukkit.persistence.PersistentDataType.STRING,
                serializeLocation(event.getClickedBlock().getLocation())
            );
        } else if (event.getAction() == Action.RIGHT_CLICK_BLOCK) {
            player.sendMessage(Text.mm("<green>Pos2 gesetzt: " + event.getClickedBlock().getLocation().toVector()));
            player.getPersistentDataContainer().set(
                new org.bukkit.NamespacedKey(plugin, "pos2"),
                org.bukkit.persistence.PersistentDataType.STRING,
                serializeLocation(event.getClickedBlock().getLocation())
            );
        }
    }

    @EventHandler
    public void onUseItem(PlayerInteractEvent event) {
        if (event.getItem() == null || event.getItem().getType().isAir()) {
            return;
        }
        if (event.getAction() != Action.RIGHT_CLICK_AIR && event.getAction() != Action.RIGHT_CLICK_BLOCK) {
            return;
        }
        String zoneId = plugin.zoneManager().getZoneAt(event.getPlayer().getLocation()) != null
            ? plugin.zoneManager().getZoneAt(event.getPlayer().getLocation()).id()
            : null;
        plugin.worldEventManager().handleUseItem(event.getPlayer(), event.getItem().getType().name(), zoneId);
    }

    private String serializeLocation(org.bukkit.Location location) {
        return location.getWorld().getName() + "," + location.getBlockX() + "," + location.getBlockY() + "," + location.getBlockZ();
    }

    private void freeze(Player player) {
        walkSpeed.put(player.getUniqueId(), player.getWalkSpeed());
        flySpeed.put(player.getUniqueId(), player.getFlySpeed());
        player.setWalkSpeed(0f);
        player.setFlySpeed(0f);
        player.setInvulnerable(true);
        player.setCollidable(false);
    }

    private void unfreeze(Player player) {
        Float walk = walkSpeed.remove(player.getUniqueId());
        Float fly = flySpeed.remove(player.getUniqueId());
        player.setWalkSpeed(walk != null ? walk : 0.2f);
        player.setFlySpeed(fly != null ? fly : 0.1f);
        player.setInvulnerable(false);
        player.setCollidable(true);
    }
}

```

## File: `src/main/java/com/example/rpg/listener/ProfessionListener.java`  
- Path: `src/main/java/com/example/rpg/listener/ProfessionListener.java`  
- Size: 4603 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.util.Text;
import org.bukkit.Material;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.inventory.CraftItemEvent;
import org.bukkit.inventory.ItemStack;

public class ProfessionListener implements Listener {
    private final RPGPlugin plugin;

    public ProfessionListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onBlockBreak(BlockBreakEvent event) {
        if (event.isCancelled()) {
            return;
        }
        Material material = event.getBlock().getType();
        var node = plugin.resourceNodeManager().nodeAt(event.getBlock().getLocation());
        if (node != null) {
            long now = System.currentTimeMillis();
            if (node.nextAvailableAt() > now) {
                event.setCancelled(true);
                event.getPlayer().sendMessage(Text.mm("<red>Dieser Knoten regeneriert gerade."));
                return;
            }
            Material nodeMaterial = Material.matchMaterial(node.material());
            if (nodeMaterial != null && nodeMaterial != material) {
                event.setCancelled(true);
                event.getPlayer().sendMessage(Text.mm("<red>Falscher Knoten-Typ."));
                return;
            }
            node.setNextAvailableAt(now + (node.respawnSeconds() * 1000L));
            plugin.resourceNodeManager().saveNode(node);
            event.setDropItems(false);
            event.getBlock().setType(Material.AIR);
            event.getBlock().getWorld().dropItemNaturally(event.getBlock().getLocation(), new ItemStack(material));
            PlayerProfile profile = plugin.playerDataManager().getProfile(event.getPlayer());
            plugin.professionManager().addXp(profile, node.profession(), node.xp(), event.getPlayer());
            plugin.getServer().getScheduler().runTaskLater(plugin, () -> {
                if (event.getBlock().getType() == Material.AIR) {
                    event.getBlock().setType(material);
                }
            }, node.respawnSeconds() * 20L);
        }
        String materialKey = material.name();
        PlayerProfile profile = plugin.playerDataManager().getProfile(event.getPlayer());
        int miningXp = plugin.professionManager().xpForMaterial("mining", materialKey);
        int herbalismXp = plugin.professionManager().xpForMaterial("herbalism", materialKey);
        if (miningXp > 0) {
            plugin.professionManager().addXp(profile, "mining", miningXp, event.getPlayer());
        }
        if (herbalismXp > 0) {
            plugin.professionManager().addXp(profile, "herbalism", herbalismXp, event.getPlayer());
        }
    }

    @EventHandler
    public void onCraft(CraftItemEvent event) {
        if (!(event.getWhoClicked() instanceof org.bukkit.entity.Player player)) {
            return;
        }
        ItemStack result = event.getRecipe().getResult();
        if (result == null || result.getType().isAir()) {
            return;
        }
        String materialKey = result.getType().name();
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        int required = plugin.professionManager().requiredLevelForCraft("blacksmithing", materialKey);
        if (required > 0 && plugin.professionManager().getLevel(profile, "blacksmithing") < required) {
            event.setCancelled(true);
            player.sendMessage(Text.mm("<red>Bentigtes Schmiede-Level: " + required));
            return;
        }
        int xp = plugin.professionManager().xpForMaterial("blacksmithing", materialKey);
        if (xp > 0) {
            plugin.professionManager().addXp(profile, "blacksmithing", xp, player);
        }
        plugin.guildManager().guildFor(player.getUniqueId()).ifPresent(guild -> {
            var hall = plugin.guildManager().hallLocation(guild);
            if (hall != null && hall.getWorld().equals(player.getWorld())
                && player.getLocation().distanceSquared(hall) <= 20 * 20) {
                int bonusLevel = guild.hallUpgrades().getOrDefault("craft", 0);
                if (bonusLevel > 0) {
                    int bonusXp = bonusLevel * 2;
                    plugin.professionManager().addXp(profile, "blacksmithing", bonusXp, player);
                    player.sendMessage(Text.mm("<gold>Gildenhalle-Bonus: +" + bonusXp + " XP"));
                }
            }
        });
    }
}

```

## File: `src/main/java/com/example/rpg/listener/SkillHotbarListener.java`  
- Path: `src/main/java/com/example/rpg/listener/SkillHotbarListener.java`  
- Size: 1156 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.EquipmentSlot;

public class SkillHotbarListener implements Listener {
    private final RPGPlugin plugin;

    public SkillHotbarListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onInteract(PlayerInteractEvent event) {
        if (event.getHand() != EquipmentSlot.HAND) {
            return;
        }
        Action action = event.getAction();
        if (action != Action.RIGHT_CLICK_AIR && action != Action.RIGHT_CLICK_BLOCK) {
            return;
        }
        var player = event.getPlayer();
        int slot = player.getInventory().getHeldItemSlot() + 1;
        var profile = plugin.playerDataManager().getProfile(player);
        String skillId = plugin.skillHotbarManager().getBinding(profile, slot);
        if (skillId == null || skillId.isBlank()) {
            return;
        }
        plugin.useSkill(player, skillId);
    }
}

```

## File: `src/main/java/com/example/rpg/listener/ZoneListener.java`  
- Path: `src/main/java/com/example/rpg/listener/ZoneListener.java`  
- Size: 2638 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.listener;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.model.Quest;
import com.example.rpg.model.QuestProgress;
import com.example.rpg.model.QuestStep;
import com.example.rpg.model.QuestStepType;
import com.example.rpg.model.Zone;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;

public class ZoneListener implements Listener {
    private final RPGPlugin plugin;
    private final Map<UUID, String> lastZone = new HashMap<>();

    public ZoneListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onMove(PlayerMoveEvent event) {
        Player player = event.getPlayer();
        Zone zone = plugin.zoneManager().getZoneAt(event.getTo());
        String zoneId = zone != null ? zone.id() : null;
        String previous = lastZone.get(player.getUniqueId());
        if ((zoneId == null && previous != null) || (zoneId != null && !zoneId.equals(previous))) {
            lastZone.put(player.getUniqueId(), zoneId);
            if (zone != null) {
                player.sendMessage(ChatColor.AQUA + "Zone betreten: " + zone.name());
                if (zone.slowMultiplier() < 1.0) {
                    player.addPotionEffect(new PotionEffect(PotionEffectType.SLOW, 200, 0));
                }
                handleExploreQuests(player, zone);
                plugin.worldEventManager().handleExplore(player, zone.id());
            } else {
                player.sendMessage(ChatColor.GRAY + "Zone verlassen.");
            }
        }
    }

    private void handleExploreQuests(Player player, Zone zone) {
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        for (QuestProgress progress : profile.activeQuests().values()) {
            Quest quest = plugin.questManager().getQuest(progress.questId());
            if (quest == null) {
                continue;
            }
            for (int i = 0; i < quest.steps().size(); i++) {
                QuestStep step = quest.steps().get(i);
                if (step.type() == QuestStepType.EXPLORE && step.target().equalsIgnoreCase(zone.id())) {
                    progress.incrementStepClamped(i, 1, step.amount());
                }
            }
            plugin.completeQuestIfReady(player, quest, progress);
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/ArenaManager.java`  
- Path: `src/main/java/com/example/rpg/manager/ArenaManager.java`  
- Size: 7629 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.Arena;
import com.example.rpg.model.ArenaStatus;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.util.EloCalculator;
import com.example.rpg.util.Text;
import java.io.File;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Queue;
import java.util.UUID;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;

public class ArenaManager {
    private final RPGPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, Arena> arenas = new HashMap<>();
    private final Map<UUID, Arena> arenaByPlayer = new HashMap<>();
    private final Queue<UUID> queue = new ArrayDeque<>();

    public ArenaManager(RPGPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "arenas.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        if (!file.exists()) {
            seedDefaults();
        }
        load();
    }

    public void joinQueue(Player player) {
        if (arenaByPlayer.containsKey(player.getUniqueId())) {
            player.sendMessage(Text.mm("<red>Du bist bereits in einer Arena."));
            return;
        }
        if (queue.contains(player.getUniqueId())) {
            player.sendMessage(Text.mm("<yellow>Du bist bereits in der Warteschlange."));
            return;
        }
        queue.add(player.getUniqueId());
        player.sendMessage(Text.mm("<green>Du bist der PvP-Warteschlange beigetreten."));
        tryStartMatch();
    }

    public void removeFromQueue(Player player) {
        queue.remove(player.getUniqueId());
    }

    public Optional<Arena> arenaFor(Player player) {
        return Optional.ofNullable(arenaByPlayer.get(player.getUniqueId()));
    }

    public void handleDeath(Player loser) {
        Arena arena = arenaByPlayer.get(loser.getUniqueId());
        if (arena == null) {
            return;
        }
        Player winner = plugin.getServer().getPlayer(other(arena, loser.getUniqueId()));
        endMatch(arena, winner, loser);
    }

    public List<PlayerProfile> topPlayers(int limit) {
        List<PlayerProfile> profiles = new ArrayList<>(plugin.playerDataManager().profiles().values());
        profiles.sort(Comparator.comparingInt(PlayerProfile::elo).reversed());
        return profiles.subList(0, Math.min(limit, profiles.size()));
    }

    private void tryStartMatch() {
        if (queue.size() < 2) {
            return;
        }
        Arena arena = arenas.values().stream()
            .filter(a -> a.status() == ArenaStatus.WAITING)
            .findFirst()
            .orElse(null);
        if (arena == null) {
            return;
        }
        UUID playerOne = queue.poll();
        UUID playerTwo = queue.poll();
        Player p1 = plugin.getServer().getPlayer(playerOne);
        Player p2 = plugin.getServer().getPlayer(playerTwo);
        if (p1 == null || p2 == null) {
            if (p1 != null) {
                queue.add(p1.getUniqueId());
            }
            if (p2 != null) {
                queue.add(p2.getUniqueId());
            }
            return;
        }
        arena.setPlayerOne(playerOne);
        arena.setPlayerTwo(playerTwo);
        arena.setStatus(ArenaStatus.FIGHTING);
        arenaByPlayer.put(playerOne, arena);
        arenaByPlayer.put(playerTwo, arena);
        teleportPlayers(arena, p1, p2);
        p1.sendMessage(Text.mm("<gold>PvP-Kampf gestartet!"));
        p2.sendMessage(Text.mm("<gold>PvP-Kampf gestartet!"));
    }

    private void teleportPlayers(Arena arena, Player p1, Player p2) {
        World world = plugin.getServer().getWorld(arena.world());
        if (world == null) {
            return;
        }
        p1.teleport(new Location(world, arena.spawn1x() + 0.5, arena.spawn1y(), arena.spawn1z() + 0.5));
        p2.teleport(new Location(world, arena.spawn2x() + 0.5, arena.spawn2y(), arena.spawn2z() + 0.5));
    }

    private void endMatch(Arena arena, Player winner, Player loser) {
        arena.setStatus(ArenaStatus.ENDING);
        if (winner != null && loser != null) {
            PlayerProfile winnerProfile = plugin.playerDataManager().getProfile(winner);
            PlayerProfile loserProfile = plugin.playerDataManager().getProfile(loser);
            int winnerNew = EloCalculator.calculateNewRating(winnerProfile.elo(), loserProfile.elo(), 1.0, 32);
            int loserNew = EloCalculator.calculateNewRating(loserProfile.elo(), winnerProfile.elo(), 0.0, 32);
            winnerProfile.setElo(winnerNew);
            loserProfile.setElo(loserNew);
            winner.sendMessage(Text.mm("<green>Du hast gewonnen! Neuer ELO: " + winnerNew));
            loser.sendMessage(Text.mm("<red>Du hast verloren! Neuer ELO: " + loserNew));
            plugin.playerDataManager().saveProfile(winnerProfile);
            plugin.playerDataManager().saveProfile(loserProfile);
        }
        arenaByPlayer.remove(arena.playerOne());
        arenaByPlayer.remove(arena.playerTwo());
        arena.setPlayerOne(null);
        arena.setPlayerTwo(null);
        arena.setStatus(ArenaStatus.WAITING);
    }

    private UUID other(Arena arena, UUID player) {
        if (arena.playerOne() != null && arena.playerOne().equals(player)) {
            return arena.playerTwo();
        }
        return arena.playerOne();
    }

    private void load() {
        arenas.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            Arena arena = new Arena(id);
            arena.setWorld(section.getString("world", "world"));
            arena.setX1(section.getInt("pos1.x"));
            arena.setY1(section.getInt("pos1.y"));
            arena.setZ1(section.getInt("pos1.z"));
            arena.setX2(section.getInt("pos2.x"));
            arena.setY2(section.getInt("pos2.y"));
            arena.setZ2(section.getInt("pos2.z"));
            arena.setSpawn1x(section.getInt("spawn1.x"));
            arena.setSpawn1y(section.getInt("spawn1.y"));
            arena.setSpawn1z(section.getInt("spawn1.z"));
            arena.setSpawn2x(section.getInt("spawn2.x"));
            arena.setSpawn2y(section.getInt("spawn2.y"));
            arena.setSpawn2z(section.getInt("spawn2.z"));
            arenas.put(id, arena);
        }
    }

    private void seedDefaults() {
        config.set("arena1.world", "world");
        config.set("arena1.pos1.x", -10);
        config.set("arena1.pos1.y", 60);
        config.set("arena1.pos1.z", -10);
        config.set("arena1.pos2.x", 10);
        config.set("arena1.pos2.y", 70);
        config.set("arena1.pos2.z", 10);
        config.set("arena1.spawn1.x", -5);
        config.set("arena1.spawn1.y", 65);
        config.set("arena1.spawn1.z", 0);
        config.set("arena1.spawn2.x", 5);
        config.set("arena1.spawn2.y", 65);
        config.set("arena1.spawn2.z", 0);
        save();
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save arenas.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/AuctionHouseManager.java`  
- Path: `src/main/java/com/example/rpg/manager/AuctionHouseManager.java`  
- Size: 3726 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.AuctionListing;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.inventory.ItemStack;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.util.io.BukkitObjectInputStream;
import org.bukkit.util.io.BukkitObjectOutputStream;

public class AuctionHouseManager {
    private final JavaPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, AuctionListing> listings = new HashMap<>();

    public AuctionHouseManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "auctions.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        load();
    }

    public Map<String, AuctionListing> listings() {
        return listings;
    }

    public AuctionListing getListing(String id) {
        return listings.get(id);
    }

    public void addListing(AuctionListing listing) {
        listings.put(listing.id(), listing);
        saveListing(listing);
    }

    public void removeListing(String id) {
        listings.remove(id);
        config.set(id, null);
        save();
    }

    public void saveListing(AuctionListing listing) {
        ConfigurationSection section = config.createSection(listing.id());
        section.set("seller", listing.seller() != null ? listing.seller().toString() : null);
        section.set("price", listing.price());
        section.set("item", listing.itemData());
        save();
    }

    public String serializeItem(ItemStack item) {
        try (java.io.ByteArrayOutputStream output = new java.io.ByteArrayOutputStream();
             BukkitObjectOutputStream dataOut = new BukkitObjectOutputStream(output)) {
            dataOut.writeObject(item);
            return java.util.Base64.getEncoder().encodeToString(output.toByteArray());
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to serialize item: " + e.getMessage());
            return null;
        }
    }

    public ItemStack deserializeItem(String data) {
        if (data == null) {
            return null;
        }
        try (java.io.ByteArrayInputStream input = new java.io.ByteArrayInputStream(java.util.Base64.getDecoder().decode(data));
             BukkitObjectInputStream dataIn = new BukkitObjectInputStream(input)) {
            Object obj = dataIn.readObject();
            return obj instanceof ItemStack item ? item : null;
        } catch (IOException | ClassNotFoundException e) {
            plugin.getLogger().warning("Failed to deserialize item: " + e.getMessage());
            return null;
        }
    }

    private void load() {
        listings.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            AuctionListing listing = new AuctionListing(id);
            String seller = section.getString("seller", null);
            listing.setSeller(seller != null ? UUID.fromString(seller) : null);
            listing.setPrice(section.getInt("price", 0));
            listing.setItemData(section.getString("item", null));
            listings.put(id, listing);
        }
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save auctions.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/BehaviorTreeManager.java`  
- Path: `src/main/java/com/example/rpg/manager/BehaviorTreeManager.java`  
- Size: 8095 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.behavior.BehaviorNode;
import com.example.rpg.behavior.CastSkillNode;
import com.example.rpg.behavior.CooldownNode;
import com.example.rpg.behavior.FleeNode;
import com.example.rpg.behavior.HealthBelowNode;
import com.example.rpg.behavior.HealSelfNode;
import com.example.rpg.behavior.InverterNode;
import com.example.rpg.behavior.MeleeAttackNode;
import com.example.rpg.behavior.SelectorNode;
import com.example.rpg.behavior.SequenceNode;
import com.example.rpg.behavior.TargetDistanceAboveNode;
import com.example.rpg.behavior.WalkToTargetNode;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.plugin.java.JavaPlugin;

public class BehaviorTreeManager {
    private final JavaPlugin plugin;
    private final File folder;
    private final Map<String, BehaviorNode> trees = new HashMap<>();

    public BehaviorTreeManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.folder = new File(plugin.getDataFolder(), "behaviors");
        if (!folder.exists()) {
            folder.mkdirs();
        }
        seedSkeletonKing();
        loadAll();
    }

    public BehaviorNode getTree(String name) {
        if (name == null) {
            return defaultTree();
        }
        return trees.getOrDefault(name, defaultTree());
    }

    public void addTemplate(String treeName, Map<String, Object> template) {
        YamlConfiguration config = loadConfig(treeName);
        List<Map<?, ?>> children = new ArrayList<>(config.getMapList("children"));
        children.add(template);
        config.set("type", "selector");
        config.set("children", children);
        saveConfig(treeName, config);
        loadAll();
    }

    public void resetTree(String treeName) {
        YamlConfiguration config = new YamlConfiguration();
        config.set("type", "selector");
        config.set("children", new ArrayList<>());
        saveConfig(treeName, config);
        loadAll();
    }

    private void loadAll() {
        trees.clear();
        File[] files = folder.listFiles((dir, file) -> file.endsWith(".yml"));
        if (files == null) {
            return;
        }
        for (File file : files) {
            YamlConfiguration config = YamlConfiguration.loadConfiguration(file);
            BehaviorNode root = parseNode(config, "root");
            String key = file.getName().replace(".yml", "");
            if (root != null) {
                trees.put(key, root);
            }
        }
    }

    private BehaviorNode parseNode(ConfigurationSection section, String fallbackId) {
        if (section == null) {
            return null;
        }
        String type = section.getString("type", "selector");
        String id = section.getString("id", fallbackId + "-" + UUID.randomUUID());
        return buildNode(type, id, section);
    }

    private BehaviorNode buildNode(String type, String id, ConfigurationSection section) {
        return switch (type.toLowerCase()) {
            case "selector" -> buildComposite(new SelectorNode(id), section);
            case "sequence" -> buildComposite(new SequenceNode(id), section);
            case "inverter" -> {
                BehaviorNode child = parseChild(section, "child", id);
                yield child != null ? new InverterNode(id, child) : null;
            }
            case "cooldown" -> {
                BehaviorNode child = parseChild(section, "child", id);
                long cooldown = (long) (section.getDouble("cooldownSeconds", 5) * 1000);
                yield child != null ? new CooldownNode(id, child, cooldown) : null;
            }
            case "melee_attack" -> new MeleeAttackNode(id);
            case "cast_skill" -> new CastSkillNode(id, section.getString("skill", "ember_shot"));
            case "flee" -> new FleeNode(id);
            case "heal_self" -> new HealSelfNode(id, section.getDouble("amount", 6));
            case "walk_to_target" -> new WalkToTargetNode(id);
            case "health_below" -> new HealthBelowNode(id, section.getDouble("threshold", 0.2));
            case "target_distance_above" -> new TargetDistanceAboveNode(id, section.getDouble("distance", 10));
            default -> null;
        };
    }

    private BehaviorNode buildComposite(com.example.rpg.behavior.CompositeNode node, ConfigurationSection section) {
        List<Map<?, ?>> children = section.getMapList("children");
        for (int i = 0; i < children.size(); i++) {
            Map<?, ?> data = children.get(i);
            if (!(data.get("type") instanceof String childType)) {
                continue;
            }
            YamlConfiguration childConfig = new YamlConfiguration();
            for (Map.Entry<?, ?> entry : data.entrySet()) {
                childConfig.set(String.valueOf(entry.getKey()), entry.getValue());
            }
            BehaviorNode child = buildNode(childType, node.id() + "-child-" + i, childConfig);
            if (child != null) {
                node.children().add(child);
            }
        }
        return node;
    }

    private BehaviorNode parseChild(ConfigurationSection section, String key, String id) {
        ConfigurationSection childSection = section.getConfigurationSection(key);
        if (childSection != null) {
            return parseNode(childSection, id + "-child");
        }
        return null;
    }

    private BehaviorNode defaultTree() {
        SelectorNode root = new SelectorNode("default-root");
        SequenceNode chase = new SequenceNode("default-chase");
        chase.children().add(new TargetDistanceAboveNode("default-dist", 2));
        chase.children().add(new WalkToTargetNode("default-walk"));
        root.children().add(chase);
        root.children().add(new MeleeAttackNode("default-melee"));
        return root;
    }

    private void seedSkeletonKing() {
        File file = new File(folder, "skeleton_king.yml");
        if (file.exists()) {
            return;
        }
        YamlConfiguration config = new YamlConfiguration();
        config.set("type", "selector");
        List<Map<String, Object>> children = new ArrayList<>();

        Map<String, Object> emergency = new HashMap<>();
        emergency.put("type", "sequence");
        List<Map<String, Object>> emergencyChildren = new ArrayList<>();
        emergencyChildren.add(Map.of("type", "health_below", "threshold", 0.2));
        emergencyChildren.add(Map.of("type", "cast_skill", "skill", "shield_wall"));
        emergencyChildren.add(Map.of("type", "heal_self", "amount", 8));
        emergency.put("children", emergencyChildren);
        children.add(emergency);

        Map<String, Object> ranged = new HashMap<>();
        ranged.put("type", "sequence");
        List<Map<String, Object>> rangedChildren = new ArrayList<>();
        rangedChildren.add(Map.of("type", "target_distance_above", "distance", 10));
        rangedChildren.add(Map.of("type", "cast_skill", "skill", "ember_shot"));
        ranged.put("children", rangedChildren);
        children.add(ranged);

        children.add(Map.of("type", "melee_attack"));
        config.set("children", children);
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to seed skeleton_king.yml: " + e.getMessage());
        }
    }

    private YamlConfiguration loadConfig(String treeName) {
        File file = new File(folder, treeName + ".yml");
        return YamlConfiguration.loadConfiguration(file);
    }

    private void saveConfig(String treeName, YamlConfiguration config) {
        File file = new File(folder, treeName + ".yml");
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save behavior tree " + treeName + ": " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/BuildingManager.java`  
- Path: `src/main/java/com/example/rpg/manager/BuildingManager.java`  
- Size: 25005 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.BuildingCategory;
import com.example.rpg.model.BuildingDefinition;
import com.example.rpg.model.FurnitureDefinition;
import com.example.rpg.schematic.Schematic;
import com.example.rpg.schematic.SchematicPaster;
import com.example.rpg.schematic.SpongeSchemLoader;
import com.example.rpg.schematic.Transform;
import com.example.rpg.util.Text;
import java.io.File;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executor;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.util.BoundingBox;

public class BuildingManager {
    private final RPGPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, BuildingDefinition> buildings = new HashMap<>();
    private final Map<UUID, PlacementSession> placementSessions = new HashMap<>();
    private final SpongeSchemLoader loader = new SpongeSchemLoader();
    private final Map<String, CompletableFuture<Schematic>> schematicCache = new ConcurrentHashMap<>();
    private final Map<UUID, Deque<com.example.rpg.schematic.UndoBuffer>> undoHistory = new HashMap<>();
    private final Map<UUID, PlacementRecord> lastPlacement = new HashMap<>();
    private final Random random = new Random();
    private final Executor asyncExecutor = CompletableFuture.delayedExecutor(0, java.util.concurrent.TimeUnit.MILLISECONDS);

    public BuildingManager(RPGPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "buildings.yml");
        if (!file.exists()) {
            plugin.saveResource("buildings.yml", false);
        }
        this.config = YamlConfiguration.loadConfiguration(file);
        ensureSchematicsFolder();
        load();
    }

    public Map<String, BuildingDefinition> buildings() {
        return buildings;
    }

    public Map<BuildingCategory, List<BuildingDefinition>> byCategory() {
        Map<BuildingCategory, List<BuildingDefinition>> categorized = new EnumMap<>(BuildingCategory.class);
        for (BuildingCategory category : BuildingCategory.values()) {
            categorized.put(category, new ArrayList<>());
        }
        for (BuildingDefinition definition : buildings.values()) {
            categorized.get(definition.category()).add(definition);
        }
        return categorized;
    }

    public BuildingDefinition getBuilding(String id) {
        return buildings.get(id);
    }

    public void beginPlacement(Player player, String buildingId, Transform.Rotation rotation) {
        BuildingDefinition definition = buildings.get(buildingId);
        if (definition == null) {
            player.sendMessage(Text.mm("<red>Gebude nicht gefunden."));
            return;
        }
        placementSessions.put(player.getUniqueId(), new PlacementSession(buildingId, null, rotation));
        player.sendMessage(Text.mm("<green>Platzierungsmodus aktiv. Rechtsklick auf einen Block zum Platzieren."));
    }

    public void beginSingleSchematicPlacement(Player player, String schematicName, Transform.Rotation rotation) {
        if (schematicName == null || schematicName.isBlank()) {
            player.sendMessage(Text.mm("<red>Kein Schematic angegeben."));
            return;
        }
        placementSessions.put(player.getUniqueId(), new PlacementSession(null, schematicName.trim(), rotation));
        player.sendMessage(Text.mm("<green>Platzierungsmodus aktiv. Rechtsklick auf einen Block zum Platzieren."));
    }

    public boolean handlePlacement(Player player, Location target) {
        PlacementSession session = placementSessions.remove(player.getUniqueId());
        if (session == null) {
            return false;
        }
        if (session.schematicName() != null) {
            placeSingleSchematic(player, target, session.schematicName(), session.rotation());
            return true;
        }
        BuildingDefinition definition = buildings.get(session.buildingId());
        if (definition == null) {
            player.sendMessage(Text.mm("<red>Gebude nicht gefunden."));
            return true;
        }
        placeBuilding(player, target, definition, session.rotation());
        return true;
    }

    private void placeBuilding(Player player, Location origin, BuildingDefinition definition, Transform.Rotation rotation) {
        String schematicName = definition.schematic();
        if (schematicName == null || schematicName.isBlank()) {
            player.sendMessage(Text.mm("<red>Kein Haupt-Schematic gesetzt."));
            return;
        }
        List<CompletableFuture<Schematic>> futures = new ArrayList<>();
        CompletableFuture<Schematic> baseFuture = loadSchematicAsync(schematicName);
        futures.add(baseFuture);
        CompletableFuture<Schematic> floorFuture = null;
        if (definition.floorSchematic() != null) {
            floorFuture = loadSchematicAsync(definition.floorSchematic());
            futures.add(floorFuture);
        }
        CompletableFuture<Schematic> basementFuture = null;
        if (definition.basementSchematic() != null) {
            basementFuture = loadSchematicAsync(definition.basementSchematic());
            futures.add(basementFuture);
        }
        Map<FurnitureDefinition, CompletableFuture<Schematic>> furnitureFutures = new HashMap<>();
        for (FurnitureDefinition furniture : definition.furniture()) {
            CompletableFuture<Schematic> furnitureFuture = loadSchematicAsync(furniture.schematic());
            furnitureFutures.put(furniture, furnitureFuture);
            futures.add(furnitureFuture);
        }
        final CompletableFuture<Schematic> finalBaseFuture = baseFuture;
        final CompletableFuture<Schematic> finalFloorFuture = floorFuture;
        final CompletableFuture<Schematic> finalBasementFuture = basementFuture;
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .whenCompleteAsync((ignored, throwable) -> plugin.getServer().getScheduler().runTask(plugin, () -> {
                if (throwable != null) {
                    plugin.getLogger().warning("Failed to load schematic: " + throwable.getMessage());
                    player.sendMessage(Text.mm("<red>Gebude konnte nicht geladen werden."));
                    return;
                }
                try {
                    com.example.rpg.schematic.UndoBuffer undoBuffer = new com.example.rpg.schematic.UndoBuffer();
                    int floors = resolveFloors(definition);
                    List<PlacementPart> parts = pasteBuilding(origin, definition, rotation, floors, finalBaseFuture.join(),
                        finalFloorFuture != null ? finalFloorFuture.join() : null,
                        finalBasementFuture != null ? finalBasementFuture.join() : null,
                        furnitureFutures,
                        undoBuffer);
                    pushUndo(player.getUniqueId(), undoBuffer);
                    recordPlacement(player.getUniqueId(), origin, parts);
                    player.sendMessage(Text.mm("<green>Gebude platziert: " + definition.name()));
                    plugin.guiManager().openSchematicMoveGui(player);
                } catch (Exception ex) {
                    plugin.getLogger().warning("Failed to paste building: " + ex.getMessage());
                    player.sendMessage(Text.mm("<red>Gebude konnte nicht platziert werden."));
                }
            }), asyncExecutor);
    }

    private void placeSingleSchematic(Player player, Location origin, String schematicName, Transform.Rotation rotation) {
        CompletableFuture<Schematic> future = loadSchematicAsync(schematicName);
        future.whenCompleteAsync((schematic, throwable) -> plugin.getServer().getScheduler().runTask(plugin, () -> {
            if (throwable != null) {
                plugin.getLogger().warning("Failed to load schematic: " + throwable.getMessage());
                player.sendMessage(Text.mm("<red>Schematic konnte nicht geladen werden."));
                return;
            }
            try {
                SchematicPaster paster = new SchematicPaster(plugin);
                Transform transform = new Transform(rotation, 0, 0, 0);
                com.example.rpg.schematic.UndoBuffer undoBuffer = new com.example.rpg.schematic.UndoBuffer();
                prepareArea(origin, schematic, transform, 3, undoBuffer);
                paster.pasteInBatches(origin.getWorld(), origin, schematic,
                    new SchematicPaster.PasteOptions(false, transform, undoBuffer), 5000);
                pushUndo(player.getUniqueId(), undoBuffer);
                recordPlacement(player.getUniqueId(), origin, List.of(new PlacementPart(schematic, transform, false)));
                player.sendMessage(Text.mm("<green>Schematic platziert: " + schematicName));
                plugin.guiManager().openSchematicMoveGui(player);
            } catch (Exception ex) {
                plugin.getLogger().warning("Failed to paste schematic: " + ex.getMessage());
                player.sendMessage(Text.mm("<red>Bereinigung oder Platzierung fehlgeschlagen."));
            }
        }), asyncExecutor);
    }

    public void undoLast(Player player) {
        if (!undoInternal(player)) {
            player.sendMessage(Text.mm("<yellow>Kein Gebude zum Rckgngig machen."));
            return;
        }
        player.sendMessage(Text.mm("<green>Letztes Gebude rckgngig gemacht."));
    }

    public void moveLastPlacement(Player player, int dx, int dy, int dz) {
        PlacementRecord record = lastPlacement.get(player.getUniqueId());
        if (record == null) {
            player.sendMessage(Text.mm("<yellow>Kein Schematic zum Verschieben gefunden."));
            return;
        }
        if (!undoInternal(player)) {
            player.sendMessage(Text.mm("<yellow>Kein Schematic zum Verschieben gefunden."));
            return;
        }
        Location newOrigin = record.origin().clone().add(dx, dy, dz);
        com.example.rpg.schematic.UndoBuffer undoBuffer = new com.example.rpg.schematic.UndoBuffer();
        for (PlacementPart part : record.parts()) {
            prepareArea(newOrigin, part.schematic(), part.transform(), 3, undoBuffer);
            new SchematicPaster(plugin).pasteInBatches(newOrigin.getWorld(), newOrigin, part.schematic(),
                new SchematicPaster.PasteOptions(part.includeAir(), part.transform(), undoBuffer), 5000);
        }
        pushUndo(player.getUniqueId(), undoBuffer);
        recordPlacement(player.getUniqueId(), newOrigin, record.parts());
        player.sendMessage(Text.mm("<green>Schematic verschoben."));
    }

    private void pushUndo(UUID playerId, com.example.rpg.schematic.UndoBuffer buffer) {
        undoHistory.computeIfAbsent(playerId, key -> new ArrayDeque<>()).push(buffer);
    }

    private List<PlacementPart> pasteBuilding(Location origin, BuildingDefinition definition, Transform.Rotation rotation, int floors, Schematic base,
                               Schematic floor, Schematic basement, Map<FurnitureDefinition, CompletableFuture<Schematic>> furnitureFutures,
                               com.example.rpg.schematic.UndoBuffer undoBuffer) {
        SchematicPaster paster = new SchematicPaster(plugin);
        List<PlacementPart> parts = new ArrayList<>();
        Transform baseTransform = new Transform(rotation, definition.offsetX(), definition.offsetY(), definition.offsetZ());
        prepareArea(origin, base, baseTransform, 3, undoBuffer);
        paster.pasteInBatches(origin.getWorld(), origin, base,
            new SchematicPaster.PasteOptions(definition.includeAir(), baseTransform, undoBuffer), 5000);
        parts.add(new PlacementPart(base, baseTransform, definition.includeAir()));
        if (basement != null && definition.basementDepth() > 0) {
            Transform basementTransform = new Transform(rotation, definition.offsetX(), definition.offsetY() - definition.basementDepth(), definition.offsetZ());
            prepareArea(origin, basement, basementTransform, 3, undoBuffer);
            paster.pasteInBatches(origin.getWorld(), origin, basement,
                new SchematicPaster.PasteOptions(definition.includeAir(), basementTransform, undoBuffer), 5000);
            parts.add(new PlacementPart(basement, basementTransform, definition.includeAir()));
        }
        for (int i = 1; i < floors; i++) {
            Schematic floorSchematic = floor != null ? floor : base;
            Transform floorTransform = new Transform(rotation, definition.offsetX(), definition.offsetY() + definition.floorHeight() * i, definition.offsetZ());
            prepareArea(origin, floorSchematic, floorTransform, 3, undoBuffer);
            paster.pasteInBatches(origin.getWorld(), origin, floorSchematic,
                new SchematicPaster.PasteOptions(definition.includeAir(), floorTransform, undoBuffer), 5000);
            parts.add(new PlacementPart(floorSchematic, floorTransform, definition.includeAir()));
        }
        for (var entry : furnitureFutures.entrySet()) {
            FurnitureDefinition furniture = entry.getKey();
            Schematic furnitureSchematic = entry.getValue().join();
            Transform.Rotation combinedRotation = rotationForDegrees((rotationToDegrees(rotation) + furniture.rotation()) % 360);
            Transform transform = new Transform(combinedRotation,
                definition.offsetX() + furniture.offsetX(),
                definition.offsetY() + furniture.offsetY(),
                definition.offsetZ() + furniture.offsetZ());
            prepareArea(origin, furnitureSchematic, transform, 3, undoBuffer);
            paster.pasteInBatches(origin.getWorld(), origin, furnitureSchematic,
                new SchematicPaster.PasteOptions(definition.includeAir(), transform, undoBuffer), 2000);
            parts.add(new PlacementPart(furnitureSchematic, transform, definition.includeAir()));
        }
        return parts;
    }

    private int resolveFloors(BuildingDefinition definition) {
        int minFloors = Math.max(1, definition.minFloors());
        int maxFloors = Math.max(minFloors, definition.maxFloors());
        return Math.max(1, random.nextInt(maxFloors - minFloors + 1) + minFloors);
    }

    private void prepareArea(Location origin, Schematic schematic, Transform transform, int buffer,
                             com.example.rpg.schematic.UndoBuffer undoBuffer) {
        if (origin.getWorld() == null) {
            throw new IllegalStateException("World not available for placement.");
        }
        Bounds bounds = calculateBounds(schematic, transform, buffer);
        loadChunks(origin, bounds);
        clearEntities(origin, bounds);
        clearBlocks(origin, bounds, undoBuffer);
    }

    private void clearBlocks(Location origin, Bounds bounds, com.example.rpg.schematic.UndoBuffer undoBuffer) {
        for (int x = bounds.minX; x <= bounds.maxX; x++) {
            for (int y = bounds.minY; y <= bounds.maxY; y++) {
                for (int z = bounds.minZ; z <= bounds.maxZ; z++) {
                    var block = origin.getWorld().getBlockAt(origin.getBlockX() + x, origin.getBlockY() + y, origin.getBlockZ() + z);
                    if (block.getType().isAir()) {
                        continue;
                    }
                    if (isSupportedGround(block.getType()) && y == bounds.minY) {
                        continue;
                    }
                    if (undoBuffer != null) {
                        undoBuffer.add(block.getLocation(), block.getBlockData());
                    }
                    block.setType(Material.AIR, false);
                }
            }
        }
    }

    private void clearEntities(Location origin, Bounds bounds) {
        BoundingBox box = BoundingBox.of(
            new org.bukkit.util.Vector(
                origin.getBlockX() + bounds.minX,
                origin.getBlockY() + bounds.minY,
                origin.getBlockZ() + bounds.minZ
            ),
            new org.bukkit.util.Vector(
                origin.getBlockX() + bounds.maxX + 1,
                origin.getBlockY() + bounds.maxY + 1,
                origin.getBlockZ() + bounds.maxZ + 1
            )
        );
        for (var entity : origin.getWorld().getNearbyEntities(box)) {
            if (entity instanceof Player) {
                continue;
            }
            entity.remove();
        }
    }

    private boolean isSupportedGround(Material material) {
        return material == Material.DIRT
            || material == Material.GRASS_BLOCK
            || material == Material.STONE
            || material == Material.COBBLESTONE;
    }

    private void loadChunks(Location origin, Bounds bounds) {
        if (origin.getWorld() == null) {
            return;
        }
        int minX = origin.getBlockX() + bounds.minX;
        int maxX = origin.getBlockX() + bounds.maxX;
        int minZ = origin.getBlockZ() + bounds.minZ;
        int maxZ = origin.getBlockZ() + bounds.maxZ;
        for (int x = minX >> 4; x <= maxX >> 4; x++) {
            for (int z = minZ >> 4; z <= maxZ >> 4; z++) {
                if (!origin.getWorld().isChunkLoaded(x, z)) {
                    origin.getWorld().getChunkAt(x, z);
                }
            }
        }
    }

    private Bounds calculateBounds(Schematic schematic, Transform transform, int buffer) {
        int width = schematic.width();
        int height = schematic.height();
        int length = schematic.length();
        int[][] corners = new int[][]{
            transform.apply(0, 0, 0, width, length),
            transform.apply(width - 1, 0, 0, width, length),
            transform.apply(0, 0, length - 1, width, length),
            transform.apply(width - 1, 0, length - 1, width, length),
            transform.apply(0, height - 1, 0, width, length),
            transform.apply(width - 1, height - 1, 0, width, length),
            transform.apply(0, height - 1, length - 1, width, length),
            transform.apply(width - 1, height - 1, length - 1, width, length)
        };
        int minX = corners[0][0];
        int maxX = corners[0][0];
        int minY = corners[0][1];
        int maxY = corners[0][1];
        int minZ = corners[0][2];
        int maxZ = corners[0][2];
        for (int[] corner : corners) {
            minX = Math.min(minX, corner[0]);
            maxX = Math.max(maxX, corner[0]);
            minY = Math.min(minY, corner[1]);
            maxY = Math.max(maxY, corner[1]);
            minZ = Math.min(minZ, corner[2]);
            maxZ = Math.max(maxZ, corner[2]);
        }
        return new Bounds(minX - buffer, maxX + buffer, minY, maxY, minZ - buffer, maxZ + buffer);
    }

    private CompletableFuture<Schematic> loadSchematicAsync(String name) {
        return schematicCache.computeIfAbsent(name, key -> CompletableFuture.supplyAsync(() -> {
            File file = new File(schematicsFolder(), key);
            if (!file.exists()) {
                throw new IllegalStateException("Schematic not found: " + key);
            }
            try {
                return loader.load(file);
            } catch (IOException e) {
                throw new IllegalStateException(e.getMessage(), e);
            }
        }).whenComplete((result, throwable) -> {
            if (throwable != null) {
                schematicCache.remove(key);
            }
        }));
    }

    private File schematicsFolder() {
        String folderName = plugin.getConfig().getString("building.schematicsFolder", "schematics");
        return new File(plugin.getDataFolder(), folderName);
    }

    private void ensureSchematicsFolder() {
        File folder = schematicsFolder();
        if (!folder.exists() && !folder.mkdirs()) {
            plugin.getLogger().warning("Could not create schematics folder: " + folder.getAbsolutePath());
        }
    }

    private void load() {
        buildings.clear();
        ConfigurationSection root = config.getConfigurationSection("buildings");
        if (root == null) {
            return;
        }
        for (String id : root.getKeys(false)) {
            ConfigurationSection section = root.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            BuildingDefinition definition = new BuildingDefinition(id);
            definition.setName(section.getString("name", id));
            definition.setCategory(BuildingCategory.fromString(section.getString("category")));
            definition.setSchematic(section.getString("schematic", null));
            definition.setFloorSchematic(section.getString("floorSchematic", null));
            definition.setMinFloors(section.getInt("minFloors", 1));
            definition.setMaxFloors(section.getInt("maxFloors", definition.minFloors()));
            if (definition.maxFloors() < definition.minFloors()) {
                definition.setMaxFloors(definition.minFloors());
            }
            definition.setFloorHeight(section.getInt("floorHeight", 5));
            definition.setIncludeAir(section.getBoolean("includeAir", false));
            ConfigurationSection offset = section.getConfigurationSection("offset");
            if (offset != null) {
                definition.setOffset(offset.getInt("x", 0), offset.getInt("y", 0), offset.getInt("z", 0));
            }
            ConfigurationSection basement = section.getConfigurationSection("basement");
            if (basement != null) {
                definition.setBasementSchematic(basement.getString("schematic", null));
                definition.setBasementDepth(basement.getInt("depth", 0));
            }
            List<Map<?, ?>> furnitureList = section.getMapList("furniture");
            for (Map<?, ?> entry : furnitureList) {
                Object schematicValue = entry.get("schematic");
                String furnitureSchematic = schematicValue != null ? String.valueOf(schematicValue) : "";
                int offsetX = parseInt(entry.get("x"), 0);
                int offsetY = parseInt(entry.get("y"), 0);
                int offsetZ = parseInt(entry.get("z"), 0);
                int rotation = parseInt(entry.get("rotation"), 0);
                if (!furnitureSchematic.isBlank()) {
                    definition.addFurniture(new FurnitureDefinition(furnitureSchematic, offsetX, offsetY, offsetZ, rotation));
                }
            }
            buildings.put(id, definition);
        }
    }

    private int parseInt(Object value, int fallback) {
        if (value == null) {
            return fallback;
        }
        try {
            return Integer.parseInt(String.valueOf(value));
        } catch (NumberFormatException e) {
            return fallback;
        }
    }

    private Transform.Rotation rotationForDegrees(int degrees) {
        return switch (degrees) {
            case 90 -> Transform.Rotation.CLOCKWISE_90;
            case 180 -> Transform.Rotation.CLOCKWISE_180;
            case 270 -> Transform.Rotation.CLOCKWISE_270;
            default -> Transform.Rotation.NONE;
        };
    }

    private int rotationToDegrees(Transform.Rotation rotation) {
        return switch (rotation) {
            case CLOCKWISE_90 -> 90;
            case CLOCKWISE_180 -> 180;
            case CLOCKWISE_270 -> 270;
            default -> 0;
        };
    }

    private boolean undoInternal(Player player) {
        Deque<com.example.rpg.schematic.UndoBuffer> history = undoHistory.get(player.getUniqueId());
        if (history == null || history.isEmpty()) {
            return false;
        }
        com.example.rpg.schematic.UndoBuffer buffer = history.pop();
        for (var snapshot : buffer.snapshots()) {
            snapshot.location().getBlock().setBlockData(snapshot.data(), false);
        }
        return true;
    }

    private void recordPlacement(UUID playerId, Location origin, List<PlacementPart> parts) {
        lastPlacement.put(playerId, new PlacementRecord(origin, parts));
    }

    private record PlacementSession(String buildingId, String schematicName, Transform.Rotation rotation) {
    }

    private record PlacementRecord(Location origin, List<PlacementPart> parts) {
    }

    private record PlacementPart(Schematic schematic, Transform transform, boolean includeAir) {
    }

    private record Bounds(int minX, int maxX, int minY, int maxY, int minZ, int maxZ) {
    }
}

```

## File: `src/main/java/com/example/rpg/manager/ClassManager.java`  
- Path: `src/main/java/com/example/rpg/manager/ClassManager.java`  
- Size: 3815 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.ClassDefinition;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.plugin.java.JavaPlugin;

public class ClassManager {
    private final JavaPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, ClassDefinition> classes = new HashMap<>();

    public ClassManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "classes.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        if (!file.exists()) {
            seedDefaults();
        }
        load();
    }

    public ClassDefinition getClass(String id) {
        return classes.get(id);
    }

    public Map<String, ClassDefinition> classes() {
        return classes;
    }

    public void saveClass(ClassDefinition definition) {
        ConfigurationSection section = config.createSection(definition.id());
        section.set("name", definition.name());
        section.set("startSkills", definition.startSkills());
        save();
    }

    public void saveAll() {
        config.getKeys(false).forEach(key -> config.set(key, null));
        for (ClassDefinition definition : classes.values()) {
            saveClass(definition);
        }
        save();
    }

    public Map<com.example.rpg.model.RPGStat, Integer> classBonuses(String classId) {
        Map<com.example.rpg.model.RPGStat, Integer> bonuses = new HashMap<>();
        if (classId == null) {
            return bonuses;
        }
        switch (classId.toLowerCase()) {
            case "warrior" -> {
                bonuses.put(com.example.rpg.model.RPGStat.STRENGTH, 3);
                bonuses.put(com.example.rpg.model.RPGStat.CONSTITUTION, 2);
            }
            case "ranger" -> {
                bonuses.put(com.example.rpg.model.RPGStat.DEXTERITY, 3);
                bonuses.put(com.example.rpg.model.RPGStat.LUCK, 1);
            }
            case "mage" -> {
                bonuses.put(com.example.rpg.model.RPGStat.INTELLIGENCE, 3);
                bonuses.put(com.example.rpg.model.RPGStat.CONSTITUTION, 1);
            }
            default -> {
            }
        }
        return bonuses;
    }

    private void load() {
        classes.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            ClassDefinition definition = new ClassDefinition(id);
            definition.setName(section.getString("name", id));
            definition.setStartSkills(section.getStringList("startSkills"));
            classes.put(id, definition);
        }
    }

    private void seedDefaults() {
        ClassDefinition warrior = new ClassDefinition("warrior");
        warrior.setName("Krieger");
        warrior.setStartSkills(List.of("taunt"));

        ClassDefinition ranger = new ClassDefinition("ranger");
        ranger.setName("Ranger");
        ranger.setStartSkills(List.of("dash"));

        ClassDefinition mage = new ClassDefinition("mage");
        mage.setName("Magier");
        mage.setStartSkills(List.of("heal"));

        classes.put(warrior.id(), warrior);
        classes.put(ranger.id(), ranger);
        classes.put(mage.id(), mage);
        saveAll();
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save classes.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/CraftingOrderManager.java`  
- Path: `src/main/java/com/example/rpg/manager/CraftingOrderManager.java`  
- Size: 2447 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.CraftingOrder;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;

public class CraftingOrderManager {
    private final RPGPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, CraftingOrder> orders = new HashMap<>();

    public CraftingOrderManager(RPGPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "crafting_orders.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        load();
    }

    public Map<String, CraftingOrder> orders() {
        return orders;
    }

    public CraftingOrder getOrder(String id) {
        return orders.get(id);
    }

    public void saveOrder(CraftingOrder order) {
        ConfigurationSection section = config.createSection(order.id());
        section.set("requester", order.requester() != null ? order.requester().toString() : null);
        section.set("material", order.material());
        section.set("amount", order.amount());
        section.set("rewardGold", order.rewardGold());
        save();
    }

    public void removeOrder(String id) {
        orders.remove(id);
        config.set(id, null);
        save();
    }

    private void load() {
        orders.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            CraftingOrder order = new CraftingOrder(id);
            String requester = section.getString("requester", null);
            if (requester != null) {
                order.setRequester(UUID.fromString(requester));
            }
            order.setMaterial(section.getString("material", ""));
            order.setAmount(section.getInt("amount", 1));
            order.setRewardGold(section.getInt("rewardGold", 10));
            orders.put(id, order);
        }
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save crafting_orders.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/DungeonManager.java`  
- Path: `src/main/java/com/example/rpg/manager/DungeonManager.java`  
- Size: 10289 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.RPGPlugin;
import com.example.rpg.dungeon.DungeonGenerator;
import com.example.rpg.dungeon.DungeonInstance;
import com.example.rpg.util.Text;
import com.example.rpg.util.WorldUtils;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.bukkit.Location;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;

public class DungeonManager {
    private final RPGPlugin plugin;
    private final FileConfiguration config;
    private Location entrance;
    private Location exit;
    private final Map<UUID, Location> returnLocations = new HashMap<>();
    private final DungeonGenerator generator;
    private final Map<UUID, DungeonInstance> activeInstances = new HashMap<>();
    private final List<DungeonInstance> allInstances = new ArrayList<>();
    private final Map<String, DungeonInstance> instanceByWorld = new HashMap<>();
    private final Map<String, java.util.List<UUID>> queueByTheme = new HashMap<>();
    private final Map<UUID, String> queuedTheme = new HashMap<>();

    public DungeonManager(RPGPlugin plugin) {
        this.plugin = plugin;
        this.config = plugin.getConfig();
        this.generator = new DungeonGenerator(plugin);
        load();
    }

    public Location getEntrance() {
        return entrance;
    }

    public void enterDungeon(org.bukkit.entity.Player player) {
        returnLocations.put(player.getUniqueId(), player.getLocation());
        if (entrance != null) {
            player.teleport(entrance);
        }
    }

    public void leaveDungeon(org.bukkit.entity.Player player) {
        Location back = returnLocations.remove(player.getUniqueId());
        activeInstances.remove(player.getUniqueId());
        if (back != null) {
            player.teleport(back);
            return;
        }
        if (exit != null) {
            player.teleport(exit);
            return;
        }
        if (!plugin.getServer().getWorlds().isEmpty()) {
            player.teleport(plugin.getServer().getWorlds().get(0).getSpawnLocation());
        }
    }

    public void generateDungeon(Player player, String theme, List<Player> party) {
        if (!party.contains(player)) {
            party.add(player);
        }
        java.util.Set<UUID> participants = new java.util.HashSet<>();
        for (Player member : party) {
            participants.add(member.getUniqueId());
        }
        double scale = computeScale(party);
        java.util.function.Consumer<DungeonInstance> onGenerated = instance -> {
            allInstances.add(instance);
            instanceByWorld.put(instance.world().getName(), instance);
            for (Player member : party) {
                returnLocations.put(member.getUniqueId(), member.getLocation());
                activeInstances.put(member.getUniqueId(), instance);
                if (instance.start() != null) {
                    member.teleport(instance.start());
                    member.sendMessage(Text.mm("<green>Dungeon generiert: " + theme));
                }
            }
            plugin.getServer().getScheduler().runTaskLater(plugin, () -> closeDungeon(instance), 20L * 60L * 15L);
        };

        if ("wfc".equalsIgnoreCase(theme)) {
            generator.generateWfc(theme, party, participants, scale, onGenerated);
            return;
        }
        DungeonInstance instance = generator.generate(theme, party, participants, scale);
        onGenerated.accept(instance);
    }

    public void closeDungeon(DungeonInstance instance) {
        if (!allInstances.contains(instance)) {
            return;
        }
        WorldUtils.unloadAndDeleteWorld(instance.world(), exit != null ? exit : entrance);
        allInstances.remove(instance);
        activeInstances.values().removeIf(active -> active.equals(instance));
        instanceByWorld.remove(instance.world().getName());
    }

    public void shutdown() {
        for (DungeonInstance instance : new ArrayList<>(allInstances)) {
            WorldUtils.unloadAndDeleteWorld(instance.world(), exit);
        }
        allInstances.clear();
        activeInstances.clear();
        instanceByWorld.clear();
    }

    public void joinQueue(Player player, String theme) {
        if (!hasFactionAccess(player, theme)) {
            player.sendMessage(Text.mm("<red>Dein Ruf reicht fr diesen Dungeon nicht aus."));
            return;
        }
        if (queuedTheme.containsKey(player.getUniqueId()) || activeInstances.containsKey(player.getUniqueId())) {
            player.sendMessage(Text.mm("<red>Du bist bereits in einer Queue oder Instanz."));
            return;
        }
        queueByTheme.computeIfAbsent(theme, ignored -> new ArrayList<>()).add(player.getUniqueId());
        queuedTheme.put(player.getUniqueId(), theme);
        player.sendMessage(Text.mm("<green>Dungeon-Queue beigetreten: " + theme));
        tryMatch(theme);
    }

    public void leaveQueue(Player player) {
        String theme = queuedTheme.remove(player.getUniqueId());
        if (theme == null) {
            return;
        }
        queueByTheme.getOrDefault(theme, new ArrayList<>()).remove(player.getUniqueId());
        player.sendMessage(Text.mm("<yellow>Dungeon-Queue verlassen."));
    }

    public DungeonInstance instanceForWorld(org.bukkit.World world) {
        return instanceByWorld.get(world.getName());
    }

    public void markDeath(Player player) {
        DungeonInstance instance = activeInstances.get(player.getUniqueId());
        if (instance != null) {
            instance.setNoDeath(false);
        }
    }

    public void completeDungeon(DungeonInstance instance) {
        if (instance == null) {
            return;
        }
        for (UUID participant : instance.participants()) {
            Player player = plugin.getServer().getPlayer(participant);
            if (player == null) {
                continue;
            }
            var profile = plugin.playerDataManager().getProfile(player);
            int xp = (int) Math.round(120 * instance.scale());
            int gold = (int) Math.round(80 * instance.scale());
            if (instance.noDeath()) {
                xp += 50;
                gold += 40;
            }
            profile.addXp(xp);
            profile.setGold(profile.gold() + gold);
            player.sendMessage(Text.mm("<gold>Dungeon abgeschlossen!</gold> +" + xp + " XP, +" + gold + " Gold"));
            if (instance.noDeath()) {
                player.sendMessage(Text.mm("<green>No-Death Bonus erhalten!"));
            }
        }
        closeDungeon(instance);
    }

    public boolean hasFactionAccess(Player player, String theme) {
        String factionId = config.getString("dungeon.requireFaction." + theme, null);
        if (factionId == null) {
            return true;
        }
        var profile = plugin.playerDataManager().getProfile(player);
        int rep = profile.factionRep().getOrDefault(factionId, 0);
        var rank = plugin.factionManager().getRank(factionId, rep);
        return rank != null && rank.dungeonAccess();
    }

    private void load() {
        String world = config.getString("dungeon.entrance.world", null);
        if (world != null && plugin.getServer().getWorld(world) != null) {
            entrance = new Location(plugin.getServer().getWorld(world),
                config.getDouble("dungeon.entrance.x"),
                config.getDouble("dungeon.entrance.y"),
                config.getDouble("dungeon.entrance.z"));
        }
        String exitWorld = config.getString("dungeon.exit.world", null);
        if (exitWorld != null && plugin.getServer().getWorld(exitWorld) != null) {
            exit = new Location(plugin.getServer().getWorld(exitWorld),
                config.getDouble("dungeon.exit.x"),
                config.getDouble("dungeon.exit.y"),
                config.getDouble("dungeon.exit.z"));
        }
    }

    private void tryMatch(String theme) {
        java.util.List<UUID> queue = queueByTheme.getOrDefault(theme, new ArrayList<>());
        if (queue.size() < 4) {
            return;
        }
        UUID tank = null;
        UUID heal = null;
        java.util.List<UUID> dps = new ArrayList<>();
        for (UUID uuid : new ArrayList<>(queue)) {
            var profile = plugin.playerDataManager().getProfile(uuid);
            String role = profile.dungeonRole() != null ? profile.dungeonRole().toUpperCase() : "DPS";
            switch (role) {
                case "TANK" -> {
                    if (tank == null) {
                        tank = uuid;
                    }
                }
                case "HEAL" -> {
                    if (heal == null) {
                        heal = uuid;
                    }
                }
                default -> dps.add(uuid);
            }
        }
        if (tank == null || heal == null || dps.size() < 2) {
            return;
        }
        java.util.List<Player> party = new ArrayList<>();
        addIfOnline(party, tank);
        addIfOnline(party, heal);
        addIfOnline(party, dps.get(0));
        addIfOnline(party, dps.get(1));
        queue.remove(tank);
        queue.remove(heal);
        queue.remove(dps.get(0));
        queue.remove(dps.get(1));
        queuedTheme.remove(tank);
        queuedTheme.remove(heal);
        queuedTheme.remove(dps.get(0));
        queuedTheme.remove(dps.get(1));
        for (Player member : party) {
            member.sendMessage(Text.mm("<green>Dungeon-Gruppe gefunden!"));
        }
        if (!party.isEmpty()) {
            generateDungeon(party.get(0), theme, party);
        }
    }

    private void addIfOnline(List<Player> party, UUID uuid) {
        Player player = plugin.getServer().getPlayer(uuid);
        if (player != null) {
            party.add(player);
        }
    }

    private double computeScale(List<Player> party) {
        if (party.isEmpty()) {
            return 1.0;
        }
        double avg = party.stream()
            .mapToInt(player -> plugin.playerDataManager().getProfile(player).level())
            .average()
            .orElse(1.0);
        return Math.max(1.0, 1.0 + ((avg - 1) * 0.05));
    }
}

```

## File: `src/main/java/com/example/rpg/manager/EnchantManager.java`  
- Path: `src/main/java/com/example/rpg/manager/EnchantManager.java`  
- Size: 15131 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.EnchantRecipeType;
import com.example.rpg.model.EnchantTargetSlot;
import com.example.rpg.model.EnchantmentRecipe;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.model.RPGStat;
import com.example.rpg.skill.SkillEffectConfig;
import com.example.rpg.skill.SkillEffectType;
import com.example.rpg.util.Text;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataContainer;
import org.bukkit.persistence.PersistentDataType;

public class EnchantManager {
    private final RPGPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, EnchantmentRecipe> recipes = new HashMap<>();
    private final NamespacedKey rpgItemKey;
    private final NamespacedKey affixKey;
    private final Map<String, RPGStat> affixStatBonuses = Map.of(
        "Praezision", RPGStat.DEXTERITY
    );

    public EnchantManager(RPGPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "enchantments.yml");
        if (!file.exists()) {
            plugin.saveResource("enchantments.yml", false);
        }
        this.config = YamlConfiguration.loadConfiguration(file);
        this.rpgItemKey = new NamespacedKey(plugin, "rpg_item");
        this.affixKey = new NamespacedKey(plugin, "enchant_affixes");
        load();
    }

    public Map<String, EnchantmentRecipe> recipes() {
        return recipes;
    }

    public List<EnchantmentRecipe> availableRecipes(Player player, ItemStack target) {
        if (!isRpgItem(target)) {
            return List.of();
        }
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        List<EnchantmentRecipe> available = new ArrayList<>();
        for (EnchantmentRecipe recipe : recipes.values()) {
            if (profile.level() < recipe.minLevel()) {
                continue;
            }
            if (!recipe.targetSlot().matches(target)) {
                continue;
            }
            available.add(recipe);
        }
        return available;
    }

    public boolean applyRecipe(Player player, String recipeId) {
        EnchantmentRecipe recipe = recipes.get(recipeId);
        if (recipe == null) {
            player.sendMessage(Text.mm("<red>Verzauberung nicht gefunden."));
            return false;
        }
        ItemStack target = getTargetItem(player, recipe.targetSlot());
        if (target == null || !isRpgItem(target)) {
            player.sendMessage(Text.mm("<red>Kein gltiges Ziel-Item."));
            return false;
        }
        if (!recipe.targetSlot().matches(target)) {
            player.sendMessage(Text.mm("<red>Dieses Item passt nicht zum Ziel-Slot."));
            return false;
        }
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        if (profile.level() < recipe.minLevel()) {
            player.sendMessage(Text.mm("<red>Level zu niedrig."));
            return false;
        }
        if (profile.gold() < recipe.costGold()) {
            player.sendMessage(Text.mm("<red>Nicht genug Gold."));
            return false;
        }
        if (!hasCostItem(player, recipe)) {
            player.sendMessage(Text.mm("<red>Fehlende Materialien."));
            return false;
        }
        profile.setGold(profile.gold() - recipe.costGold());
        removeCostItem(player, recipe);
        ItemMeta meta = target.getItemMeta();
        if (meta == null) {
            return false;
        }
        String itemName = resolveItemName(target, meta);
        List<String> changeLines = new ArrayList<>();
        switch (recipe.type()) {
            case STAT_UPGRADE -> {
                int delta = applyStatUpgrade(meta, recipe);
                if (recipe.statToImprove() != null && delta > 0) {
                    changeLines.add("+" + delta + " " + recipe.statToImprove().name());
                }
            }
            case AFFIX -> {
                AffixResult result = applyAffix(meta, recipe);
                if (result.added()) {
                    changeLines.add("Affix: " + result.affixName());
                }
                if (result.statBonus() != null && result.statDelta() > 0) {
                    changeLines.add("+" + result.statDelta() + " " + result.statBonus().name());
                }
            }
        }
        plugin.itemStatManager().updateLore(meta);
        target.setItemMeta(meta);
        setTargetItem(player, recipe.targetSlot(), target);
        applyEffects(player, profile, recipe.effects());
        if (changeLines.isEmpty()) {
            player.sendMessage(Text.mm("<green>Verzauberung angewendet auf <white>" + itemName));
        } else {
            player.sendMessage(Text.mm("<green>Verzauberung angewendet:</green> <white>" + itemName));
            for (String line : changeLines) {
                player.sendMessage(Text.mm("<gray> - " + line));
            }
        }
        return true;
    }

    public NamespacedKey affixKey() {
        return affixKey;
    }

    private void load() {
        recipes.clear();
        for (String key : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(key);
            if (section == null) {
                continue;
            }
            EnchantmentRecipe recipe = new EnchantmentRecipe(key);
            recipe.setType(parseEnum(EnchantRecipeType.class, section.getString("type"))
                .orElse(EnchantRecipeType.STAT_UPGRADE));
            recipe.setTargetSlot(parseEnum(EnchantTargetSlot.class, section.getString("targetSlot"))
                .orElse(EnchantTargetSlot.HAND));
            recipe.setStatToImprove(parseEnum(RPGStat.class, section.getString("statToImprove"))
                .orElse(null));
            recipe.setMinLevel(section.getInt("minLevel", 1));
            recipe.setCostGold(section.getInt("costGold", 0));
            parseCostItem(section.getString("costItem"), recipe);
            recipe.setAffix(section.getString("affix", null));
            parseEffects(section.getMapList("effects"), recipe.effects());
            recipes.put(key, recipe);
        }
    }

    private void parseCostItem(String raw, EnchantmentRecipe recipe) {
        if (raw == null || raw.isBlank() || !raw.contains(":")) {
            return;
        }
        String[] parts = raw.split(":", 2);
        Material material = Material.matchMaterial(parts[0].trim().toUpperCase());
        if (material == null) {
            return;
        }
        recipe.setCostMaterial(material);
        try {
            recipe.setCostAmount(Integer.parseInt(parts[1].trim()));
        } catch (NumberFormatException e) {
            recipe.setCostAmount(1);
        }
    }

    private void parseEffects(List<Map<?, ?>> effectList, List<SkillEffectConfig> target) {
        if (effectList == null || effectList.isEmpty()) {
            return;
        }
        for (Map<?, ?> entry : effectList) {
            Object typeValue = entry.get("type");
            SkillEffectType type = parseEnum(SkillEffectType.class, typeValue != null ? typeValue.toString() : null)
                .orElse(null);
            if (type == null) {
                continue;
            }
            Map<String, Object> params = new HashMap<>();
            Object paramsValue = entry.get("params");
            if (paramsValue instanceof Map<?, ?> paramMap) {
                for (Map.Entry<?, ?> paramEntry : paramMap.entrySet()) {
                    params.put(String.valueOf(paramEntry.getKey()), paramEntry.getValue());
                }
            }
            target.add(new SkillEffectConfig(type, params));
        }
    }

    private boolean isRpgItem(ItemStack item) {
        if (item == null || item.getItemMeta() == null) {
            return false;
        }
        PersistentDataContainer data = item.getItemMeta().getPersistentDataContainer();
        return data.has(rpgItemKey, PersistentDataType.INTEGER);
    }

    private ItemStack getTargetItem(Player player, EnchantTargetSlot targetSlot) {
        return switch (targetSlot) {
            case HAND -> player.getInventory().getItemInMainHand();
            case OFF_HAND, SHIELD -> player.getInventory().getItemInOffHand();
            case ARMOR_HEAD -> player.getInventory().getHelmet();
            case ARMOR_CHEST -> player.getInventory().getChestplate();
            case ARMOR_LEGS -> player.getInventory().getLeggings();
            case ARMOR_FEET -> player.getInventory().getBoots();
        };
    }

    private void setTargetItem(Player player, EnchantTargetSlot targetSlot, ItemStack item) {
        switch (targetSlot) {
            case HAND -> player.getInventory().setItemInMainHand(item);
            case OFF_HAND, SHIELD -> player.getInventory().setItemInOffHand(item);
            case ARMOR_HEAD -> player.getInventory().setHelmet(item);
            case ARMOR_CHEST -> player.getInventory().setChestplate(item);
            case ARMOR_LEGS -> player.getInventory().setLeggings(item);
            case ARMOR_FEET -> player.getInventory().setBoots(item);
        }
        player.updateInventory();
    }

    private boolean hasCostItem(Player player, EnchantmentRecipe recipe) {
        if (recipe.costMaterial() == null || recipe.costAmount() <= 0) {
            return true;
        }
        int total = 0;
        for (ItemStack item : player.getInventory().getContents()) {
            if (item == null || item.getType() != recipe.costMaterial()) {
                continue;
            }
            total += item.getAmount();
            if (total >= recipe.costAmount()) {
                return true;
            }
        }
        return false;
    }

    private void removeCostItem(Player player, EnchantmentRecipe recipe) {
        if (recipe.costMaterial() == null || recipe.costAmount() <= 0) {
            return;
        }
        int remaining = recipe.costAmount();
        ItemStack[] contents = player.getInventory().getContents();
        for (int i = 0; i < contents.length; i++) {
            ItemStack item = contents[i];
            if (item == null || item.getType() != recipe.costMaterial()) {
                continue;
            }
            int remove = Math.min(item.getAmount(), remaining);
            item.setAmount(item.getAmount() - remove);
            remaining -= remove;
            if (item.getAmount() <= 0) {
                contents[i] = null;
            }
            if (remaining <= 0) {
                break;
            }
        }
        player.getInventory().setContents(contents);
    }

    private int applyStatUpgrade(ItemMeta meta, EnchantmentRecipe recipe) {
        if (recipe.statToImprove() == null) {
            return 0;
        }
        NamespacedKey key = plugin.itemStatManager().enchantStatKey(recipe.statToImprove());
        PersistentDataContainer data = meta.getPersistentDataContainer();
        int current = data.getOrDefault(key, PersistentDataType.INTEGER, 0);
        data.set(key, PersistentDataType.INTEGER, current + 1);
        applyBaseStatBonus(meta, recipe.statToImprove(), 1);
        return 1;
    }

    private AffixResult applyAffix(ItemMeta meta, EnchantmentRecipe recipe) {
        if (recipe.affix() == null || recipe.affix().isBlank()) {
            return AffixResult.none();
        }
        PersistentDataContainer data = meta.getPersistentDataContainer();
        String current = data.getOrDefault(affixKey, PersistentDataType.STRING, "");
        List<String> affixes = new ArrayList<>();
        if (!current.isBlank()) {
            affixes.addAll(List.of(current.split(",")));
        }
        boolean added = false;
        if (!affixes.contains(recipe.affix())) {
            affixes.add(recipe.affix());
            added = true;
        }
        data.set(affixKey, PersistentDataType.STRING, String.join(",", affixes));
        RPGStat statBonus = affixStatBonuses.getOrDefault(recipe.affix(), RPGStat.STRENGTH);
        NamespacedKey statKey = plugin.itemStatManager().enchantStatKey(statBonus);
        int currentStat = data.getOrDefault(statKey, PersistentDataType.INTEGER, 0);
        data.set(statKey, PersistentDataType.INTEGER, currentStat + 1);
        applyBaseStatBonus(meta, statBonus, 1);
        return new AffixResult(added, recipe.affix(), statBonus, 1);
    }

    private void applyEffects(Player player, PlayerProfile profile, List<SkillEffectConfig> effects) {
        for (SkillEffectConfig config : effects) {
            plugin.skillEffects().apply(config, player, profile);
        }
    }

    private static <E extends Enum<E>> Optional<E> parseEnum(Class<E> type, String raw) {
        if (raw == null) {
            return Optional.empty();
        }
        String key = raw.trim().toUpperCase();
        try {
            return Optional.of(Enum.valueOf(type, key));
        } catch (IllegalArgumentException e) {
            return Optional.empty();
        }
    }

    private String resolveItemName(ItemStack item, ItemMeta meta) {
        if (meta != null && meta.hasDisplayName()) {
            return meta.getDisplayName();
        }
        return item.getType().name().toLowerCase().replace("_", " ");
    }

    private void applyBaseStatBonus(ItemMeta meta, RPGStat stat, int amount) {
        PersistentDataContainer data = meta.getPersistentDataContainer();
        switch (stat) {
            case STRENGTH -> {
                NamespacedKey key = plugin.itemStatManager().strengthKey();
                int current = data.getOrDefault(key, PersistentDataType.INTEGER, 0);
                data.set(key, PersistentDataType.INTEGER, current + amount);
            }
            case DEXTERITY -> {
                NamespacedKey key = plugin.itemStatManager().critKey();
                double current = data.getOrDefault(key, PersistentDataType.DOUBLE, 0.0);
                data.set(key, PersistentDataType.DOUBLE, current + (amount * 0.01));
            }
            case CONSTITUTION -> {
                NamespacedKey key = plugin.itemStatManager().healthKey();
                int current = data.getOrDefault(key, PersistentDataType.INTEGER, 0);
                data.set(key, PersistentDataType.INTEGER, current + amount);
            }
            case INTELLIGENCE, LUCK -> {
                // No direct base stat stored; keep as enchant stat only.
            }
        }
    }

    private record AffixResult(boolean added, String affixName, RPGStat statBonus, int statDelta) {
        private static AffixResult none() {
            return new AffixResult(false, "", null, 0);
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/FactionManager.java`  
- Path: `src/main/java/com/example/rpg/manager/FactionManager.java`  
- Size: 6039 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.Faction;
import com.example.rpg.model.FactionRank;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.plugin.java.JavaPlugin;

public class FactionManager {
    private final JavaPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, Faction> factions = new HashMap<>();

    public FactionManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "factions.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        if (!file.exists()) {
            seedDefaults();
        }
        load();
    }

    public Faction getFaction(String id) {
        return factions.get(id);
    }

    public Map<String, Faction> factions() {
        return factions;
    }

    public FactionRank getRank(String factionId, int rep) {
        Faction faction = factions.get(factionId);
        if (faction == null) {
            return null;
        }
        return faction.rankForRep(rep);
    }

    public void saveFaction(Faction faction) {
        ConfigurationSection section = config.createSection(faction.id());
        section.set("name", faction.name());
        section.set("ranks", serializeRanks(faction));
        save();
    }

    public void saveAll() {
        config.getKeys(false).forEach(key -> config.set(key, null));
        for (Faction faction : factions.values()) {
            saveFaction(faction);
        }
        save();
    }

    private void load() {
        factions.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            Faction faction = new Faction(id);
            faction.setName(section.getString("name", id));
            faction.setRanks(loadRanks(section));
            factions.put(id, faction);
        }
    }

    private void seedDefaults() {
        Faction faction = new Faction("adventurers");
        faction.setName("Abenteurergilde");
        faction.setRanks(new ArrayList<>());
        FactionRank neutral = new FactionRank("neutral");
        neutral.setName("Neutral");
        neutral.setMinRep(0);
        neutral.setShopDiscount(0.0);
        neutral.setDungeonAccess(false);
        FactionRank friendly = new FactionRank("friendly");
        friendly.setName("Freundlich");
        friendly.setMinRep(250);
        friendly.setShopDiscount(0.1);
        friendly.setDungeonAccess(false);
        FactionRank revered = new FactionRank("revered");
        revered.setName("Ehrfrchtig");
        revered.setMinRep(750);
        revered.setShopDiscount(0.2);
        revered.setDungeonAccess(true);
        faction.ranks().add(neutral);
        faction.ranks().add(friendly);
        faction.ranks().add(revered);
        factions.put(faction.id(), faction);
        saveAll();
    }

    private java.util.List<Map<String, Object>> serializeRanks(Faction faction) {
        java.util.List<Map<String, Object>> ranks = new ArrayList<>();
        for (FactionRank rank : faction.ranks()) {
            Map<String, Object> data = new HashMap<>();
            data.put("id", rank.id());
            data.put("name", rank.name());
            data.put("minRep", rank.minRep());
            data.put("shopDiscount", rank.shopDiscount());
            data.put("dungeonAccess", rank.dungeonAccess());
            ranks.add(data);
        }
        return ranks;
    }

    private java.util.List<FactionRank> loadRanks(ConfigurationSection section) {
        java.util.List<FactionRank> ranks = new ArrayList<>();
        for (Map<?, ?> raw : section.getMapList("ranks")) {
            String idValue = mapString(raw, "id", "rank");
            String nameValue = mapString(raw, "name", idValue);
            int minValue = mapInt(raw, "minRep", 0);
            double discountValue = mapDouble(raw, "shopDiscount", 0.0);
            boolean accessValue = mapBool(raw, "dungeonAccess", false);
            FactionRank rank = new FactionRank(idValue);
            rank.setName(nameValue);
            rank.setMinRep(minValue);
            rank.setShopDiscount(discountValue);
            rank.setDungeonAccess(accessValue);
            ranks.add(rank);
        }
        return ranks;
    }

    private String mapString(Map<?, ?> raw, String key, String fallback) {
        Object value = raw.get(key);
        if (value == null) {
            return fallback;
        }
        String resolved = String.valueOf(value);
        return resolved.isBlank() ? fallback : resolved;
    }

    private int mapInt(Map<?, ?> raw, String key, int fallback) {
        Object value = raw.get(key);
        if (value == null) {
            return fallback;
        }
        try {
            return Integer.parseInt(String.valueOf(value));
        } catch (NumberFormatException e) {
            return fallback;
        }
    }

    private double mapDouble(Map<?, ?> raw, String key, double fallback) {
        Object value = raw.get(key);
        if (value == null) {
            return fallback;
        }
        try {
            return Double.parseDouble(String.valueOf(value));
        } catch (NumberFormatException e) {
            return fallback;
        }
    }

    private boolean mapBool(Map<?, ?> raw, String key, boolean fallback) {
        Object value = raw.get(key);
        if (value == null) {
            return fallback;
        }
        return Boolean.parseBoolean(String.valueOf(value));
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save factions.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/GuildManager.java`  
- Path: `src/main/java/com/example/rpg/manager/GuildManager.java`  
- Size: 9045 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.Guild;
import com.example.rpg.model.GuildMemberRole;
import com.example.rpg.model.GuildQuest;
import com.example.rpg.model.PlayerProfile;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.Location;

public class GuildManager {
    private final RPGPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, Guild> guilds = new HashMap<>();
    private final Map<UUID, String> guildByMember = new HashMap<>();
    private final Map<UUID, String> pendingInvites = new HashMap<>();

    public GuildManager(RPGPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "guilds.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        load();
    }

    public Optional<Guild> guildById(String id) {
        return Optional.ofNullable(guilds.get(id));
    }

    public Optional<Guild> guildFor(UUID member) {
        String id = guildByMember.get(member);
        return id == null ? Optional.empty() : guildById(id);
    }

    public Location hallLocation(Guild guild) {
        if (guild.hallWorld() == null) {
            return null;
        }
        var world = plugin.getServer().getWorld(guild.hallWorld());
        if (world == null) {
            return null;
        }
        return new Location(world, guild.hallX(), guild.hallY(), guild.hallZ());
    }

    public boolean isMember(UUID member) {
        return guildByMember.containsKey(member);
    }

    public void createGuild(String id, String name, Player leader) {
        Guild guild = new Guild(id);
        guild.setName(name);
        guild.setLeader(leader.getUniqueId());
        guild.members().put(leader.getUniqueId(), GuildMemberRole.LEADER);
        guilds.put(id, guild);
        guildByMember.put(leader.getUniqueId(), id);
        PlayerProfile profile = plugin.playerDataManager().getProfile(leader);
        profile.setGuildId(id);
        saveGuild(guild);
    }

    public void disbandGuild(Guild guild) {
        for (UUID member : guild.members().keySet()) {
            guildByMember.remove(member);
            PlayerProfile profile = plugin.playerDataManager().getProfile(member);
            profile.setGuildId(null);
        }
        guilds.remove(guild.id());
        config.set(guild.id(), null);
        save();
    }

    public void invite(UUID target, String guildId) {
        pendingInvites.put(target, guildId);
    }

    public Optional<Guild> acceptInvite(UUID playerId) {
        String guildId = pendingInvites.remove(playerId);
        if (guildId == null) {
            return Optional.empty();
        }
        Guild guild = guilds.get(guildId);
        if (guild == null) {
            return Optional.empty();
        }
        guild.members().put(playerId, GuildMemberRole.MEMBER);
        guildByMember.put(playerId, guildId);
        PlayerProfile profile = plugin.playerDataManager().getProfile(playerId);
        profile.setGuildId(guildId);
        saveGuild(guild);
        return Optional.of(guild);
    }

    public void leaveGuild(UUID member) {
        String guildId = guildByMember.remove(member);
        if (guildId == null) {
            return;
        }
        Guild guild = guilds.get(guildId);
        if (guild == null) {
            return;
        }
        if (guild.leader() != null && guild.leader().equals(member)) {
            disbandGuild(guild);
            return;
        }
        guild.members().remove(member);
        PlayerProfile profile = plugin.playerDataManager().getProfile(member);
        profile.setGuildId(null);
        saveGuild(guild);
    }

    public void setRole(Guild guild, UUID member, GuildMemberRole role) {
        guild.members().put(member, role);
        saveGuild(guild);
    }

    public void deposit(Guild guild, int amount) {
        guild.setBankGold(guild.bankGold() + amount);
        saveGuild(guild);
    }

    public boolean withdraw(Guild guild, int amount) {
        if (guild.bankGold() < amount) {
            return false;
        }
        guild.setBankGold(guild.bankGold() - amount);
        saveGuild(guild);
        return true;
    }

    public void saveAll() {
        for (Guild guild : guilds.values()) {
            saveGuild(guild);
        }
        save();
    }

    private void load() {
        guilds.clear();
        guildByMember.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            Guild guild = new Guild(id);
            guild.setName(section.getString("name", id));
            String leader = section.getString("leader", null);
            if (leader != null) {
                guild.setLeader(UUID.fromString(leader));
            }
            guild.setBankGold(section.getInt("bankGold", 0));
            guild.setHall(section.getString("hall.world", null),
                section.getDouble("hall.x"), section.getDouble("hall.y"), section.getDouble("hall.z"));
            ConfigurationSection upgrades = section.getConfigurationSection("hall.upgrades");
            if (upgrades != null) {
                for (String key : upgrades.getKeys(false)) {
                    guild.hallUpgrades().put(key, upgrades.getInt(key, 0));
                }
            }
            ConfigurationSection members = section.getConfigurationSection("members");
            if (members != null) {
                for (String uuid : members.getKeys(false)) {
                    try {
                        GuildMemberRole role = GuildMemberRole.valueOf(members.getString(uuid, "MEMBER"));
                        UUID memberId = UUID.fromString(uuid);
                        guild.members().put(memberId, role);
                        guildByMember.put(memberId, id);
                    } catch (IllegalArgumentException ignored) {
                    }
                }
            }
            ConfigurationSection quests = section.getConfigurationSection("quests");
            if (quests != null) {
                for (String questId : quests.getKeys(false)) {
                    ConfigurationSection questSection = quests.getConfigurationSection(questId);
                    if (questSection == null) {
                        continue;
                    }
                    GuildQuest quest = new GuildQuest(questId);
                    quest.setName(questSection.getString("name", questId));
                    quest.setDescription(questSection.getString("description", ""));
                    quest.setGoal(questSection.getInt("goal", 1));
                    quest.setProgress(questSection.getInt("progress", 0));
                    quest.setCompleted(questSection.getBoolean("completed", false));
                    guild.quests().put(questId, quest);
                }
            }
            guilds.put(id, guild);
        }
    }

    private void saveGuild(Guild guild) {
        ConfigurationSection section = config.createSection(guild.id());
        section.set("name", guild.name());
        section.set("leader", guild.leader() != null ? guild.leader().toString() : null);
        section.set("bankGold", guild.bankGold());
        section.set("hall.world", guild.hallWorld());
        section.set("hall.x", guild.hallX());
        section.set("hall.y", guild.hallY());
        section.set("hall.z", guild.hallZ());
        ConfigurationSection upgrades = section.createSection("hall.upgrades");
        for (Map.Entry<String, Integer> entry : guild.hallUpgrades().entrySet()) {
            upgrades.set(entry.getKey(), entry.getValue());
        }
        ConfigurationSection members = section.createSection("members");
        for (Map.Entry<UUID, GuildMemberRole> entry : guild.members().entrySet()) {
            members.set(entry.getKey().toString(), entry.getValue().name());
        }
        ConfigurationSection quests = section.createSection("quests");
        for (GuildQuest quest : guild.quests().values()) {
            ConfigurationSection questSection = quests.createSection(quest.id());
            questSection.set("name", quest.name());
            questSection.set("description", quest.description());
            questSection.set("goal", quest.goal());
            questSection.set("progress", quest.progress());
            questSection.set("completed", quest.completed());
        }
        save();
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save guilds.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/ItemStatManager.java`  
- Path: `src/main/java/com/example/rpg/manager/ItemStatManager.java`  
- Size: 7566 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.RPGStat;
import com.example.rpg.util.Text;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.EnumMap;
import net.kyori.adventure.text.Component;
import org.bukkit.NamespacedKey;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataContainer;
import org.bukkit.persistence.PersistentDataType;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;

public class ItemStatManager {
    private final Random random = new Random();
    private final NamespacedKey strengthKey;
    private final NamespacedKey critKey;
    private final NamespacedKey healthKey;
    private final NamespacedKey setIdKey;
    private final NamespacedKey enchantAffixKey;
    private final Map<RPGStat, NamespacedKey> enchantStatKeys = new EnumMap<>(RPGStat.class);
    private final Map<String, PotionEffectType> setBonuses = Map.of(
        "ember", PotionEffectType.FIRE_RESISTANCE,
        "guardian", PotionEffectType.DAMAGE_RESISTANCE,
        "swift", PotionEffectType.SPEED
    );

    public ItemStatManager(JavaPlugin plugin) {
        this.strengthKey = new NamespacedKey(plugin, "stat_strength");
        this.critKey = new NamespacedKey(plugin, "stat_crit");
        this.healthKey = new NamespacedKey(plugin, "stat_health");
        this.setIdKey = new NamespacedKey(plugin, "set_id");
        this.enchantAffixKey = new NamespacedKey(plugin, "enchant_affixes");
        for (RPGStat stat : RPGStat.values()) {
            enchantStatKeys.put(stat, new NamespacedKey(plugin, "enchant_stat_" + stat.name().toLowerCase()));
        }
    }

    public void applyAffixes(ItemStack item) {
        ItemMeta meta = item.getItemMeta();
        if (meta == null) {
            return;
        }
        String prefix = randomFrom(List.of("Brennendes", "Gefrorenes", "Sthlernen", "Mystisches"));
        String suffix = randomFrom(List.of("der Strke", "der Przision", "des Lebens"));
        meta.displayName(Component.text(prefix + " " + prettyName(item.getType().name()) + " " + suffix));

        PersistentDataContainer data = meta.getPersistentDataContainer();
        data.set(strengthKey, PersistentDataType.INTEGER, 1 + random.nextInt(4));
        data.set(critKey, PersistentDataType.DOUBLE, 0.02 + random.nextDouble() * 0.08);
        data.set(healthKey, PersistentDataType.INTEGER, 2 + random.nextInt(6));
        data.set(setIdKey, PersistentDataType.STRING, randomFrom(setBonuses.keySet().stream().toList()));

        updateLore(meta);
        item.setItemMeta(meta);
    }

    public void updateLore(ItemMeta meta) {
        PersistentDataContainer data = meta.getPersistentDataContainer();
        int strength = data.getOrDefault(strengthKey, PersistentDataType.INTEGER, 0);
        double crit = data.getOrDefault(critKey, PersistentDataType.DOUBLE, 0.0);
        int health = data.getOrDefault(healthKey, PersistentDataType.INTEGER, 0);
        String setId = data.get(setIdKey, PersistentDataType.STRING);
        List<Component> lore = new java.util.ArrayList<>();
        lore.add(Text.mm("<gray>Strke: <white>" + strength));
        lore.add(Text.mm("<gray>Krit-Chance: <white>" + String.format("%.1f%%", crit * 100)));
        lore.add(Text.mm("<gray>Leben: <white>" + health));
        if (setId != null) {
            lore.add(Text.mm("<gold>Set: " + setId + " (4 Teile)"));
        } else {
            lore.add(Text.mm("<gray>Kein Set"));
        }
        for (RPGStat stat : RPGStat.values()) {
            NamespacedKey key = enchantStatKeys.get(stat);
            if (key == null) {
                continue;
            }
            int value = data.getOrDefault(key, PersistentDataType.INTEGER, 0);
            if (value > 0) {
                lore.add(Text.mm("<aqua>Affix " + stat.name() + ": <white>+" + value));
            }
        }
        String affixes = data.get(enchantAffixKey, PersistentDataType.STRING);
        if (affixes != null && !affixes.isBlank()) {
            lore.add(Text.mm("<light_purple>Affixe: <white>" + affixes));
        }
        meta.lore(lore);
    }

    public void updateSetBonus(Player player) {
        Map<String, Integer> counts = new java.util.HashMap<>();
        for (ItemStack item : player.getInventory().getArmorContents()) {
            if (item == null || item.getItemMeta() == null) {
                continue;
            }
            String setId = item.getItemMeta().getPersistentDataContainer().get(setIdKey, PersistentDataType.STRING);
            if (setId == null) {
                continue;
            }
            counts.put(setId, counts.getOrDefault(setId, 0) + 1);
        }
        for (Map.Entry<String, PotionEffectType> entry : setBonuses.entrySet()) {
            PotionEffectType type = entry.getValue();
            if (type == null) {
                continue;
            }
            if (counts.getOrDefault(entry.getKey(), 0) >= 4) {
                player.addPotionEffect(new PotionEffect(type, 220, 0, true, false));
            } else {
                player.removePotionEffect(type);
            }
        }
    }

    public Map<RPGStat, Integer> collectStatBonuses(Player player) {
        Map<RPGStat, Integer> totals = new EnumMap<>(RPGStat.class);
        for (RPGStat stat : RPGStat.values()) {
            totals.put(stat, 0);
        }
        List<ItemStack> equipment = new java.util.ArrayList<>();
        equipment.add(player.getInventory().getItemInMainHand());
        equipment.add(player.getInventory().getItemInOffHand());
        for (ItemStack item : player.getInventory().getArmorContents()) {
            equipment.add(item);
        }
        for (ItemStack item : equipment) {
            if (item == null || item.getItemMeta() == null) {
                continue;
            }
            PersistentDataContainer data = item.getItemMeta().getPersistentDataContainer();
            addStat(totals, RPGStat.STRENGTH, data.getOrDefault(strengthKey, PersistentDataType.INTEGER, 0));
            addStat(totals, RPGStat.CONSTITUTION, data.getOrDefault(healthKey, PersistentDataType.INTEGER, 0));
            for (RPGStat stat : RPGStat.values()) {
                NamespacedKey key = enchantStatKeys.get(stat);
                if (key == null) {
                    continue;
                }
                addStat(totals, stat, data.getOrDefault(key, PersistentDataType.INTEGER, 0));
            }
        }
        return totals;
    }

    public NamespacedKey strengthKey() {
        return strengthKey;
    }

    public NamespacedKey critKey() {
        return critKey;
    }

    public NamespacedKey healthKey() {
        return healthKey;
    }

    public NamespacedKey setIdKey() {
        return setIdKey;
    }

    public NamespacedKey enchantStatKey(RPGStat stat) {
        return enchantStatKeys.get(stat);
    }

    public NamespacedKey enchantAffixKey() {
        return enchantAffixKey;
    }

    private void addStat(Map<RPGStat, Integer> totals, RPGStat stat, int amount) {
        if (amount == 0) {
            return;
        }
        totals.put(stat, totals.getOrDefault(stat, 0) + amount);
    }

    private String randomFrom(List<String> values) {
        return values.get(random.nextInt(values.size()));
    }

    private String prettyName(String material) {
        return material.toLowerCase().replace("_", " ");
    }
}

```

## File: `src/main/java/com/example/rpg/manager/LootManager.java`  
- Path: `src/main/java/com/example/rpg/manager/LootManager.java`  
- Size: 4381 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.LootEntry;
import com.example.rpg.model.LootTable;
import com.example.rpg.model.Rarity;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.plugin.java.JavaPlugin;

public class LootManager {
    private final JavaPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, LootTable> tables = new HashMap<>();

    public LootManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "loot.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        if (!file.exists()) {
            seedDefaults();
        }
        load();
    }

    public Map<String, LootTable> tables() {
        return tables;
    }

    public LootTable getTable(String id) {
        return tables.get(id);
    }

    public LootTable getTableFor(String key) {
        for (LootTable table : tables.values()) {
            if (table.appliesTo().equalsIgnoreCase(key)) {
                return table;
            }
        }
        return null;
    }

    public void saveTable(LootTable table) {
        ConfigurationSection section = config.createSection(table.id());
        section.set("appliesTo", table.appliesTo());
        List<Map<String, Object>> entries = new ArrayList<>();
        for (LootEntry entry : table.entries()) {
            Map<String, Object> map = new HashMap<>();
            map.put("material", entry.material());
            map.put("chance", entry.chance());
            map.put("minAmount", entry.minAmount());
            map.put("maxAmount", entry.maxAmount());
            map.put("rarity", entry.rarity().name());
            entries.add(map);
        }
        section.set("entries", entries);
        save();
    }

    public void saveAll() {
        config.getKeys(false).forEach(key -> config.set(key, null));
        for (LootTable table : tables.values()) {
            saveTable(table);
        }
        save();
    }

    private void load() {
        tables.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            LootTable table = new LootTable(id);
            table.setAppliesTo(section.getString("appliesTo", "ZOMBIE"));
            List<LootEntry> entries = new ArrayList<>();
            for (Map<?, ?> raw : section.getMapList("entries")) {
                Object materialValue = raw.containsKey("material") ? raw.get("material") : "IRON_NUGGET";
                Object chanceValue = raw.containsKey("chance") ? raw.get("chance") : 0.3;
                Object minValue = raw.containsKey("minAmount") ? raw.get("minAmount") : 1;
                Object maxValue = raw.containsKey("maxAmount") ? raw.get("maxAmount") : 1;
                Object rarityValue = raw.containsKey("rarity") ? raw.get("rarity") : "COMMON";
                String material = String.valueOf(materialValue);
                double chance = Double.parseDouble(String.valueOf(chanceValue));
                int minAmount = Integer.parseInt(String.valueOf(minValue));
                int maxAmount = Integer.parseInt(String.valueOf(maxValue));
                Rarity rarity = Rarity.valueOf(String.valueOf(rarityValue));
                entries.add(new LootEntry(material, chance, minAmount, maxAmount, rarity));
            }
            table.setEntries(entries);
            tables.put(id, table);
        }
    }

    private void seedDefaults() {
        LootTable table = new LootTable("forest_mobs");
        table.setAppliesTo("ZOMBIE");
        table.setEntries(List.of(
            new LootEntry("IRON_NUGGET", 0.5, 1, 3, Rarity.COMMON),
            new LootEntry("EMERALD", 0.15, 1, 1, Rarity.RARE)
        ));
        tables.put(table.id(), table);
        saveAll();
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save loot.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/MobManager.java`  
- Path: `src/main/java/com/example/rpg/manager/MobManager.java`  
- Size: 4521 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.MobDefinition;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.plugin.java.JavaPlugin;

public class MobManager {
    private final JavaPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, MobDefinition> mobs = new HashMap<>();

    public MobManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "mobs.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        if (!file.exists()) {
            seedDefaults();
        }
        load();
    }

    public MobDefinition getMob(String id) {
        return mobs.get(id);
    }

    public Map<String, MobDefinition> mobs() {
        return mobs;
    }

    public void saveMob(MobDefinition mob) {
        ConfigurationSection section = config.createSection(mob.id());
        section.set("name", mob.name());
        section.set("type", mob.type());
        section.set("health", mob.health());
        section.set("damage", mob.damage());
        section.set("mainHand", mob.mainHand());
        section.set("helmet", mob.helmet());
        section.set("skills", mob.skills());
        section.set("skillIntervalSeconds", mob.skillIntervalSeconds());
        section.set("xp", mob.xp());
        section.set("lootTable", mob.lootTable());
        section.set("behaviorTree", mob.behaviorTree());
        section.set("boss", mob.boss());
        save();
    }

    public void saveAll() {
        config.getKeys(false).forEach(key -> config.set(key, null));
        for (MobDefinition mob : mobs.values()) {
            saveMob(mob);
        }
        save();
    }

    private void load() {
        mobs.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            MobDefinition mob = new MobDefinition(id);
            mob.setName(section.getString("name", id));
            mob.setType(section.getString("type", "ZOMBIE"));
            mob.setHealth(section.getDouble("health", 40));
            mob.setDamage(section.getDouble("damage", 6));
            mob.setMainHand(section.getString("mainHand", null));
            mob.setHelmet(section.getString("helmet", null));
            mob.setSkills(section.getStringList("skills"));
            mob.setSkillIntervalSeconds(section.getInt("skillIntervalSeconds", 8));
            mob.setXp(section.getInt("xp", 50));
            mob.setLootTable(section.getString("lootTable", null));
            mob.setBehaviorTree(section.getString("behaviorTree", null));
            mob.setBoss(section.getBoolean("boss", false));
            mobs.put(id, mob);
        }
    }

    private void seedDefaults() {
        MobDefinition zombie = new MobDefinition("boss_zombie");
        zombie.setName("cSeuchenbringer");
        zombie.setType("ZOMBIE");
        zombie.setHealth(60);
        zombie.setDamage(8);
        zombie.setMainHand("IRON_SWORD");
        zombie.setHelmet("IRON_HELMET");
        zombie.setSkills(List.of("ember_shot", "whirlwind"));
        zombie.setSkillIntervalSeconds(10);
        zombie.setXp(120);
        zombie.setLootTable("forest_mobs");
        zombie.setBoss(true);
        mobs.put(zombie.id(), zombie);

        MobDefinition skeletonKing = new MobDefinition("skeleton_king");
        skeletonKing.setName("cSkelettknig");
        skeletonKing.setType("SKELETON");
        skeletonKing.setHealth(80);
        skeletonKing.setDamage(10);
        skeletonKing.setMainHand("DIAMOND_SWORD");
        skeletonKing.setHelmet("GOLDEN_HELMET");
        skeletonKing.setSkills(List.of("shield_wall", "ember_shot"));
        skeletonKing.setSkillIntervalSeconds(8);
        skeletonKing.setXp(180);
        skeletonKing.setLootTable("forest_mobs");
        skeletonKing.setBehaviorTree("skeleton_king");
        skeletonKing.setBoss(true);
        mobs.put(skeletonKing.id(), skeletonKing);
        saveAll();
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save mobs.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/NpcManager.java`  
- Path: `src/main/java/com/example/rpg/manager/NpcManager.java`  
- Size: 9079 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.DialogueNode;
import com.example.rpg.model.DialogueOption;
import com.example.rpg.model.Npc;
import com.example.rpg.model.NpcRole;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import net.kyori.adventure.text.Component;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.NamespacedKey;
import org.bukkit.World;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Villager;
import org.bukkit.persistence.PersistentDataType;
import org.bukkit.plugin.java.JavaPlugin;

public class NpcManager {
    private final JavaPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, Npc> npcs = new HashMap<>();
    private final NamespacedKey npcKey;

    public NpcManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "npcs.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        this.npcKey = new NamespacedKey(plugin, "npc_id");
        load();
    }

    public NamespacedKey npcKey() {
        return npcKey;
    }

    public Map<String, Npc> npcs() {
        return npcs;
    }

    public Npc getNpc(String id) {
        return npcs.get(id);
    }

    public void spawnAll() {
        for (Npc npc : npcs.values()) {
            spawnNpc(npc);
        }
    }

    public void spawnNpc(Npc npc) {
        World world = Bukkit.getWorld(npc.world());
        if (world == null) {
            return;
        }
        Location location = npc.toLocation(world);
        Villager villager = (Villager) world.spawnEntity(location, EntityType.VILLAGER);
        villager.customName(Component.text(npc.name()));
        villager.setCustomNameVisible(true);
        villager.setAI(false);
        villager.setInvulnerable(true);
        villager.setSilent(true);
        villager.getPersistentDataContainer().set(npcKey, PersistentDataType.STRING, npc.id());
        npc.setUuid(villager.getUniqueId());
    }

    public void saveNpc(Npc npc) {
        ConfigurationSection section = config.createSection(npc.id());
        section.set("name", npc.name());
        section.set("role", npc.role().name());
        section.set("world", npc.world());
        section.set("x", npc.x());
        section.set("y", npc.y());
        section.set("z", npc.z());
        section.set("yaw", npc.yaw());
        section.set("pitch", npc.pitch());
        section.set("dialog", npc.dialog());
        section.set("questLink", npc.questLink());
        section.set("shopId", npc.shopId());
        section.set("factionId", npc.factionId());
        section.set("requiredRankId", npc.requiredRankId());
        section.set("dialogueNodes", serializeDialogue(npc));
        section.set("uuid", npc.uuid() != null ? npc.uuid().toString() : null);
        save();
    }

    public void saveAll() {
        config.getKeys(false).forEach(key -> config.set(key, null));
        for (Npc npc : npcs.values()) {
            saveNpc(npc);
        }
        save();
    }

    private void load() {
        npcs.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            Npc npc = new Npc(id);
            npc.setName(section.getString("name", id));
            npc.setRole(NpcRole.valueOf(section.getString("role", "QUESTGIVER")));
            npc.setWorld(section.getString("world", "world"));
            npc.setDialog(section.getStringList("dialog"));
            npc.setQuestLink(section.getString("questLink", null));
            npc.setShopId(section.getString("shopId", null));
            npc.setFactionId(section.getString("factionId", null));
            npc.setRequiredRankId(section.getString("requiredRankId", null));
            loadDialogue(section, npc);
            npc.setUuid(section.contains("uuid") ? UUID.fromString(section.getString("uuid")) : null);
            World world = Bukkit.getWorld(npc.world());
            double x = section.getDouble("x");
            double y = section.getDouble("y");
            double z = section.getDouble("z");
            float yaw = (float) section.getDouble("yaw");
            float pitch = (float) section.getDouble("pitch");
            if (world != null) {
                npc.setLocation(new Location(world, x, y, z, yaw, pitch));
            } else {
                npc.setRawLocation(npc.world(), x, y, z, yaw, pitch);
            }
            npcs.put(id, npc);
        }
    }

    private java.util.List<java.util.Map<String, Object>> serializeDialogue(Npc npc) {
        java.util.List<java.util.Map<String, Object>> nodes = new java.util.ArrayList<>();
        for (DialogueNode node : npc.dialogueNodes().values()) {
            java.util.Map<String, Object> data = new java.util.HashMap<>();
            data.put("id", node.id());
            data.put("text", node.text());
            java.util.List<java.util.Map<String, Object>> options = new java.util.ArrayList<>();
            for (DialogueOption option : node.options()) {
                java.util.Map<String, Object> optionData = new java.util.HashMap<>();
                optionData.put("text", option.text());
                optionData.put("nextId", option.nextId());
                optionData.put("requiredFactionId", option.requiredFactionId());
                optionData.put("minRep", option.minRep());
                optionData.put("requiredQuestId", option.requiredQuestId());
                optionData.put("requireQuestCompleted", option.requireQuestCompleted());
                optionData.put("grantQuestId", option.grantQuestId());
                options.add(optionData);
            }
            data.put("options", options);
            nodes.add(data);
        }
        return nodes;
    }

    private void loadDialogue(ConfigurationSection section, Npc npc) {
        npc.dialogueNodes().clear();
        for (java.util.Map<?, ?> raw : section.getMapList("dialogueNodes")) {
            String idValue = mapString(raw, "id", "start");
            DialogueNode node = new DialogueNode(idValue);
            node.setText(mapString(raw, "text", ""));
            Object optionsRaw = raw.get("options");
            if (optionsRaw instanceof java.util.List<?> options) {
                for (Object entry : options) {
                    if (!(entry instanceof java.util.Map<?, ?> optRaw)) {
                        continue;
                    }
                    DialogueOption option = new DialogueOption();
                    option.setText(mapString(optRaw, "text", "Weiter"));
                    option.setNextId(mapString(optRaw, "nextId", "end"));
                    option.setRequiredFactionId(valueOrNull(optRaw.get("requiredFactionId")));
                    option.setMinRep(mapInt(optRaw, "minRep", 0));
                    option.setRequiredQuestId(valueOrNull(optRaw.get("requiredQuestId")));
                    option.setRequireQuestCompleted(mapBool(optRaw, "requireQuestCompleted", false));
                    option.setGrantQuestId(valueOrNull(optRaw.get("grantQuestId")));
                    node.options().add(option);
                }
            }
            npc.dialogueNodes().put(node.id(), node);
        }
    }

    private String mapString(java.util.Map<?, ?> raw, String key, String fallback) {
        Object value = raw.get(key);
        if (value == null) {
            return fallback;
        }
        String resolved = String.valueOf(value);
        return resolved.isBlank() ? fallback : resolved;
    }

    private int mapInt(java.util.Map<?, ?> raw, String key, int fallback) {
        Object value = raw.get(key);
        if (value == null) {
            return fallback;
        }
        try {
            return Integer.parseInt(String.valueOf(value));
        } catch (NumberFormatException e) {
            return fallback;
        }
    }

    private boolean mapBool(java.util.Map<?, ?> raw, String key, boolean fallback) {
        Object value = raw.get(key);
        if (value == null) {
            return fallback;
        }
        return Boolean.parseBoolean(String.valueOf(value));
    }

    private String valueOrNull(Object raw) {
        if (raw == null) {
            return null;
        }
        String value = String.valueOf(raw);
        return value.isBlank() ? null : value;
    }

    private int parseInt(Object raw) {
        try {
            return Integer.parseInt(String.valueOf(raw));
        } catch (NumberFormatException e) {
            return 0;
        }
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save npcs.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/PartyManager.java`  
- Path: `src/main/java/com/example/rpg/manager/PartyManager.java`  
- Size: 1251 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.Party;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

public class PartyManager {
    private final Map<UUID, Party> partiesByMember = new HashMap<>();

    public Party createParty(UUID leader) {
        Party party = new Party(leader);
        partiesByMember.put(leader, party);
        return party;
    }

    public Optional<Party> getParty(UUID member) {
        return Optional.ofNullable(partiesByMember.get(member));
    }

    public void addMember(Party party, UUID member) {
        party.addMember(member);
        partiesByMember.put(member, party);
    }

    public void removeMember(UUID member) {
        Party party = partiesByMember.get(member);
        if (party == null) {
            return;
        }

        party.removeMember(member);
        partiesByMember.remove(member);

        if (party.leader().equals(member)) {
            for (UUID uuid : party.members()) {
                partiesByMember.remove(uuid);
            }
            party.members().clear();
            return;
        }

        if (party.members().isEmpty()) {
            partiesByMember.remove(party.leader());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/PlayerDataManager.java`  
- Path: `src/main/java/com/example/rpg/manager/PlayerDataManager.java`  
- Size: 1837 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.db.PlayerDao;
import com.example.rpg.model.PlayerProfile;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import org.bukkit.entity.Player;
import org.bukkit.plugin.java.JavaPlugin;

public class PlayerDataManager {
    private final JavaPlugin plugin;
    private final PlayerDao playerDao;
    private final Map<UUID, PlayerProfile> profiles = new HashMap<>();

    public PlayerDataManager(JavaPlugin plugin, PlayerDao playerDao) {
        this.plugin = plugin;
        this.playerDao = playerDao;
    }

    public PlayerProfile getProfile(UUID uuid) {
        return profiles.computeIfAbsent(uuid, PlayerProfile::new);
    }

    public PlayerProfile getProfile(Player player) {
        return getProfile(player.getUniqueId());
    }

    public Map<UUID, PlayerProfile> profiles() {
        return profiles;
    }

    public CompletableFuture<PlayerProfile> loadProfileAsync(UUID uuid) {
        return playerDao.loadPlayer(uuid).exceptionally(error -> {
            plugin.getLogger().warning("Failed to load player " + uuid + ": " + error.getMessage());
            return null;
        }).thenApply(profile -> {
            PlayerProfile resolved = profile != null ? profile : new PlayerProfile(uuid);
            profiles.put(uuid, resolved);
            return resolved;
        });
    }

    public void saveProfile(PlayerProfile profile) {
        playerDao.savePlayer(profile).exceptionally(error -> {
            plugin.getLogger().warning("Failed to save player " + profile.uuid() + ": " + error.getMessage());
            return null;
        });
    }

    public void saveAll() {
        for (PlayerProfile profile : profiles.values()) {
            saveProfile(profile);
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/ProfessionManager.java`  
- Path: `src/main/java/com/example/rpg/manager/ProfessionManager.java`  
- Size: 7825 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.PlayerProfile;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.plugin.java.JavaPlugin;

public class ProfessionManager {
    private final JavaPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, ProfessionDefinition> professions = new HashMap<>();

    public ProfessionManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "professions.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        if (!file.exists()) {
            seedDefaults();
        }
        load();
    }

    public int getLevel(PlayerProfile profile, String profession) {
        return profile.professions().getOrDefault(profession + "_level", 1);
    }

    public void setLevel(PlayerProfile profile, String profession, int level) {
        profile.professions().put(profession + "_level", Math.max(1, level));
    }

    public Map<String, Integer> professions(PlayerProfile profile) {
        return profile.professions();
    }

    public int addXp(PlayerProfile profile, String profession, int xp, Player player) {
        int currentXp = profile.professions().getOrDefault(profession + "_xp", 0);
        int newXp = currentXp + Math.max(0, xp);
        profile.professions().put(profession + "_xp", newXp);
        int level = profile.professions().getOrDefault(profession + "_level", 1);
        int oldLevel = level;
        int threshold = level * 100;
        while (newXp >= threshold) {
            newXp -= threshold;
            level++;
            threshold = level * 100;
        }
        profile.professions().put(profession + "_level", level);
        profile.professions().put(profession + "_xp", newXp);
        if (player != null && level > oldLevel) {
            fireLevelRewards(profession, level, player);
        }
        return level;
    }

    public int xpForMaterial(String profession, String material) {
        ProfessionDefinition definition = professions.get(profession);
        if (definition == null) {
            return 0;
        }
        return definition.xpSources().getOrDefault(material, 0);
    }

    public int requiredLevelForCraft(String profession, String resultMaterial) {
        ProfessionDefinition definition = professions.get(profession);
        if (definition == null) {
            return 0;
        }
        return definition.craftRequirements().getOrDefault(resultMaterial, 0);
    }

    public Map<String, ProfessionDefinition> definitions() {
        return professions;
    }

    private void fireLevelRewards(String profession, int level, Player player) {
        ProfessionDefinition definition = professions.get(profession);
        if (definition == null) {
            return;
        }
        List<String> commands = definition.levelRewards().get(level);
        if (commands == null) {
            return;
        }
        for (String command : commands) {
            String resolved = command.replace("{player}", player.getName());
            plugin.getServer().dispatchCommand(plugin.getServer().getConsoleSender(), resolved);
        }
        player.sendMessage(com.example.rpg.util.Text.mm("<gold>Beruf " + definition.displayName()
            + " Level " + level + " erreicht!"));
    }

    private void load() {
        professions.clear();
        ConfigurationSection root = config.getConfigurationSection("professions");
        if (root == null) {
            return;
        }
        for (String id : root.getKeys(false)) {
            ConfigurationSection section = root.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            ProfessionDefinition definition = new ProfessionDefinition(id);
            definition.setDisplayName(section.getString("display", id));
            ConfigurationSection xpSources = section.getConfigurationSection("xpSources");
            if (xpSources != null) {
                for (String material : xpSources.getKeys(false)) {
                    definition.xpSources().put(material, xpSources.getInt(material, 0));
                }
            }
            ConfigurationSection craftReq = section.getConfigurationSection("craftRequirements");
            if (craftReq != null) {
                for (String material : craftReq.getKeys(false)) {
                    definition.craftRequirements().put(material, craftReq.getInt(material, 0));
                }
            }
            ConfigurationSection rewards = section.getConfigurationSection("levelRewards");
            if (rewards != null) {
                for (String levelKey : rewards.getKeys(false)) {
                    try {
                        int lvl = Integer.parseInt(levelKey);
                        definition.levelRewards().put(lvl, rewards.getStringList(levelKey));
                    } catch (NumberFormatException ignored) {
                    }
                }
            }
            professions.put(id, definition);
        }
    }

    private void seedDefaults() {
        config.set("professions.mining.display", "Bergbau");
        config.set("professions.mining.xpSources.COAL_ORE", 5);
        config.set("professions.mining.xpSources.IRON_ORE", 8);
        config.set("professions.mining.xpSources.DIAMOND_ORE", 15);
        config.set("professions.mining.levelRewards.5", List.of("give {player} iron_pickaxe 1"));

        config.set("professions.herbalism.display", "Kruterkunde");
        config.set("professions.herbalism.xpSources.WHEAT", 4);
        config.set("professions.herbalism.xpSources.CARROTS", 4);
        config.set("professions.herbalism.xpSources.NETHER_WART", 8);
        config.set("professions.herbalism.levelRewards.5", List.of("give {player} golden_apple 1"));

        config.set("professions.blacksmithing.display", "Schmiedekunst");
        config.set("professions.blacksmithing.xpSources.IRON_SWORD", 10);
        config.set("professions.blacksmithing.xpSources.DIAMOND_SWORD", 20);
        config.set("professions.blacksmithing.craftRequirements.IRON_SWORD", 3);
        config.set("professions.blacksmithing.craftRequirements.DIAMOND_SWORD", 6);
        config.set("professions.blacksmithing.levelRewards.5", List.of("give {player} anvil 1"));
        save();
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save professions.yml: " + e.getMessage());
        }
    }

    public static class ProfessionDefinition {
        private final String id;
        private String displayName;
        private final Map<String, Integer> xpSources = new HashMap<>();
        private final Map<String, Integer> craftRequirements = new HashMap<>();
        private final Map<Integer, List<String>> levelRewards = new HashMap<>();

        public ProfessionDefinition(String id) {
            this.id = id;
        }

        public String id() {
            return id;
        }

        public String displayName() {
            return displayName;
        }

        public void setDisplayName(String displayName) {
            this.displayName = displayName;
        }

        public Map<String, Integer> xpSources() {
            return xpSources;
        }

        public Map<String, Integer> craftRequirements() {
            return craftRequirements;
        }

        public Map<Integer, List<String>> levelRewards() {
            return levelRewards;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/PvpSeasonManager.java`  
- Path: `src/main/java/com/example/rpg/manager/PvpSeasonManager.java`  
- Size: 3654 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.PvpSeason;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.util.Text;
import java.io.File;
import java.io.IOException;
import java.util.Comparator;
import java.util.List;
import org.bukkit.configuration.file.YamlConfiguration;

public class PvpSeasonManager {
    private final RPGPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private PvpSeason season;

    public PvpSeasonManager(RPGPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "pvp_season.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        load();
    }

    public PvpSeason currentSeason() {
        return season;
    }

    public void startSeason(String id, String name, long endTimestamp) {
        PvpSeason newSeason = new PvpSeason(id);
        newSeason.setName(name);
        newSeason.setEndTimestamp(endTimestamp);
        this.season = newSeason;
        resetRatings();
        save();
        plugin.getServer().broadcast(Text.mm("<gold>PvP-Saison gestartet:</gold> " + name));
    }

    public void endSeason() {
        if (season == null) {
            return;
        }
        awardRewards();
        save();
        plugin.getServer().broadcast(Text.mm("<yellow>PvP-Saison beendet:</yellow> " + season.name()));
        season = null;
    }

    public void checkSeasonEnd() {
        if (season == null) {
            return;
        }
        if (!season.isActive()) {
            endSeason();
        }
    }

    private void resetRatings() {
        for (PlayerProfile profile : plugin.playerDataManager().profiles().values()) {
            profile.setElo(1000);
        }
    }

    private void awardRewards() {
        List<PlayerProfile> top = plugin.playerDataManager().profiles().values().stream()
            .sorted(Comparator.comparingInt(PlayerProfile::elo).reversed())
            .limit(3)
            .toList();
        if (top.isEmpty()) {
            return;
        }
        award(top.get(0), "Champion", "pvp_title_champion");
        if (top.size() > 1) {
            award(top.get(1), "Gladiator", "pvp_title_gladiator");
        }
        if (top.size() > 2) {
            award(top.get(2), "Contender", "pvp_title_contender");
        }
    }

    private void award(PlayerProfile profile, String title, String cosmeticId) {
        profile.setTitle(title);
        profile.cosmetics().add(cosmeticId);
        var player = plugin.getServer().getPlayer(profile.uuid());
        if (player != null) {
            player.sendMessage(Text.mm("<gold>PvP-Belohnung:</gold> Titel " + title));
        }
    }

    private void load() {
        if (!file.exists()) {
            return;
        }
        String id = config.getString("id", null);
        if (id == null) {
            return;
        }
        season = new PvpSeason(id);
        season.setName(config.getString("name", id));
        season.setEndTimestamp(config.getLong("endTimestamp", 0));
    }

    private void save() {
        if (season == null) {
            config.set("id", null);
            config.set("name", null);
            config.set("endTimestamp", null);
        } else {
            config.set("id", season.id());
            config.set("name", season.name());
            config.set("endTimestamp", season.endTimestamp());
        }
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save pvp_season.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/QuestManager.java`  
- Path: `src/main/java/com/example/rpg/manager/QuestManager.java`  
- Size: 5519 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.Quest;
import com.example.rpg.model.QuestReward;
import com.example.rpg.model.QuestStep;
import com.example.rpg.model.QuestStepType;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.InvalidConfigurationException;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.plugin.java.JavaPlugin;

public class QuestManager {
    private final JavaPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, Quest> quests = new HashMap<>();

    public QuestManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "quests.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        if (!file.exists()) {
            seedDefaults();
        }
        load();
    }

    public Quest getQuest(String id) {
        return quests.get(id);
    }

    public Map<String, Quest> quests() {
        return quests;
    }

    public void saveQuest(Quest quest) {
        ConfigurationSection section = config.createSection(quest.id());
        section.set("name", quest.name());
        section.set("description", quest.description());
        section.set("repeatable", quest.repeatable());
        section.set("minLevel", quest.minLevel());
        section.set("requiredEvent", quest.requiredEvent());
        List<Map<String, Object>> steps = new ArrayList<>();
        for (QuestStep step : quest.steps()) {
            Map<String, Object> map = new HashMap<>();
            map.put("type", step.type().name());
            map.put("target", step.target());
            map.put("amount", step.amount());
            steps.add(map);
        }
        section.set("steps", steps);
        QuestReward reward = quest.reward();
        section.set("reward.xp", reward.xp());
        section.set("reward.skillPoints", reward.skillPoints());
        section.set("reward.factionRep", reward.factionRep());
        save();
    }

    public void saveAll() {
        config.getKeys(false).forEach(key -> config.set(key, null));
        for (Quest quest : quests.values()) {
            saveQuest(quest);
        }
        save();
    }

    public void reload() {
        try {
            config.load(file);
        } catch (IOException | InvalidConfigurationException e) {
            plugin.getLogger().warning("Failed to reload quests.yml: " + e.getMessage());
        }
        load();
    }

    private void load() {
        quests.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            Quest quest = new Quest(id);
            quest.setName(section.getString("name", id));
            quest.setDescription(section.getString("description", ""));
            quest.setRepeatable(section.getBoolean("repeatable", false));
            quest.setMinLevel(section.getInt("minLevel", 1));
            quest.setRequiredEvent(section.getString("requiredEvent", null));
            List<QuestStep> steps = new ArrayList<>();
            for (Map<?, ?> raw : section.getMapList("steps")) {
                Object typeValue = raw.containsKey("type") ? raw.get("type") : "KILL";
                Object targetValue = raw.containsKey("target") ? raw.get("target") : "ZOMBIE";
                Object amountValue = raw.containsKey("amount") ? raw.get("amount") : 1;
                String typeName = String.valueOf(typeValue);
                String target = String.valueOf(targetValue);
                int amount = Integer.parseInt(String.valueOf(amountValue));
                QuestStepType type = QuestStepType.valueOf(typeName);
                steps.add(new QuestStep(type, target, amount));
            }
            quest.setSteps(steps);
            QuestReward reward = new QuestReward();
            reward.setXp(section.getInt("reward.xp", 50));
            reward.setSkillPoints(section.getInt("reward.skillPoints", 1));
            ConfigurationSection factionRep = section.getConfigurationSection("reward.factionRep");
            if (factionRep != null) {
                Map<String, Integer> rep = new HashMap<>();
                for (String faction : factionRep.getKeys(false)) {
                    rep.put(faction, factionRep.getInt(faction));
                }
                reward.setFactionRep(rep);
            }
            quest.setReward(reward);
            quests.put(id, quest);
        }
    }

    private void seedDefaults() {
        Quest quest = new Quest("starter_hunt");
        quest.setName("Wolfsplage");
        quest.setDescription("Jage 3 Wlfe und kehre zurck.");
        quest.setRepeatable(false);
        quest.setMinLevel(1);
        quest.setSteps(List.of(new QuestStep(QuestStepType.KILL, "WOLF", 3)));
        QuestReward reward = new QuestReward();
        reward.setXp(120);
        reward.setSkillPoints(1);
        quest.setReward(reward);
        quests.put(quest.id(), quest);
        saveAll();
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save quests.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/ResourceNodeManager.java`  
- Path: `src/main/java/com/example/rpg/manager/ResourceNodeManager.java`  
- Size: 3861 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.ResourceNode;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;

public class ResourceNodeManager {
    private final RPGPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, ResourceNode> nodes = new HashMap<>();

    public ResourceNodeManager(RPGPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "resource_nodes.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        load();
    }

    public Map<String, ResourceNode> nodes() {
        return nodes;
    }

    public ResourceNode nodeAt(Location location) {
        return nodes.values().stream()
            .filter(node -> node.world().equals(location.getWorld().getName())
                && node.x() == location.getBlockX()
                && node.y() == location.getBlockY()
                && node.z() == location.getBlockZ())
            .findFirst()
            .orElse(null);
    }

    public void createNode(Player player, String profession, Material material, int respawnSeconds, int xp) {
        String id = "node_" + nodes.size();
        Location loc = player.getLocation().getBlock().getLocation();
        ResourceNode node = new ResourceNode(id);
        node.setWorld(loc.getWorld().getName());
        node.setX(loc.getBlockX());
        node.setY(loc.getBlockY());
        node.setZ(loc.getBlockZ());
        node.setMaterial(material.name());
        node.setProfession(profession);
        node.setRespawnSeconds(respawnSeconds);
        node.setXp(xp);
        nodes.put(id, node);
        saveNode(node);
    }

    public void saveNode(ResourceNode node) {
        ConfigurationSection section = config.createSection(node.id());
        section.set("world", node.world());
        section.set("x", node.x());
        section.set("y", node.y());
        section.set("z", node.z());
        section.set("material", node.material());
        section.set("profession", node.profession());
        section.set("respawnSeconds", node.respawnSeconds());
        section.set("xp", node.xp());
        section.set("nextAvailableAt", node.nextAvailableAt());
        save();
    }

    public void saveAll() {
        config.getKeys(false).forEach(key -> config.set(key, null));
        for (ResourceNode node : nodes.values()) {
            saveNode(node);
        }
        save();
    }

    private void load() {
        nodes.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            ResourceNode node = new ResourceNode(id);
            node.setWorld(section.getString("world", "world"));
            node.setX(section.getInt("x"));
            node.setY(section.getInt("y"));
            node.setZ(section.getInt("z"));
            node.setMaterial(section.getString("material", "STONE"));
            node.setProfession(section.getString("profession", "mining"));
            node.setRespawnSeconds(section.getInt("respawnSeconds", 60));
            node.setXp(section.getInt("xp", 5));
            node.setNextAvailableAt(section.getLong("nextAvailableAt", 0));
            nodes.put(id, node);
        }
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save resource_nodes.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/ShopManager.java`  
- Path: `src/main/java/com/example/rpg/manager/ShopManager.java`  
- Size: 5252 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.ShopDefinition;
import com.example.rpg.model.ShopItem;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.plugin.java.JavaPlugin;

public class ShopManager {
    private final JavaPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, ShopDefinition> shops = new HashMap<>();

    public ShopManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "shops.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        if (!file.exists()) {
            seedDefaults();
        }
        load();
    }

    public ShopDefinition getShop(String id) {
        return shops.get(id);
    }

    public Map<String, ShopDefinition> shops() {
        return shops;
    }

    public void registerShop(ShopDefinition shop) {
        shops.put(shop.id(), shop);
    }

    public void saveShop(ShopDefinition shop) {
        ConfigurationSection section = config.createSection(shop.id());
        section.set("title", shop.title());
        List<Map<String, Object>> items = new java.util.ArrayList<>();
            for (ShopItem item : shop.items().values()) {
                Map<String, Object> map = new HashMap<>();
                map.put("slot", item.slot());
                map.put("material", item.material());
                map.put("name", item.name());
                map.put("buyPrice", item.buyPrice());
                map.put("sellPrice", item.sellPrice());
                map.put("rpgItem", item.rpgItem());
                map.put("rarity", item.rarity());
                map.put("minLevel", item.minLevel());
                items.add(map);
            }
        section.set("items", items);
        save();
    }

    public void saveAll() {
        config.getKeys(false).forEach(key -> config.set(key, null));
        for (ShopDefinition shop : shops.values()) {
            saveShop(shop);
        }
        save();
    }

    private void load() {
        shops.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            ShopDefinition shop = new ShopDefinition(id);
            shop.setTitle(section.getString("title", id));
            Map<Integer, ShopItem> items = new HashMap<>();
            for (Map<?, ?> raw : section.getMapList("items")) {
                ShopItem item = new ShopItem();
                Object slotValue = raw.containsKey("slot") ? raw.get("slot") : 0;
                Object materialValue = raw.containsKey("material") ? raw.get("material") : "STONE";
                Object nameValue = raw.containsKey("name") ? raw.get("name") : "";
                Object buyValue = raw.containsKey("buyPrice") ? raw.get("buyPrice") : 0;
                Object sellValue = raw.containsKey("sellPrice") ? raw.get("sellPrice") : 0;
                Object rpgValue = raw.containsKey("rpgItem") ? raw.get("rpgItem") : false;
                Object rarityValue = raw.containsKey("rarity") ? raw.get("rarity") : null;
                Object minLevelValue = raw.containsKey("minLevel") ? raw.get("minLevel") : 1;
                item.setSlot(Integer.parseInt(String.valueOf(slotValue)));
                item.setMaterial(String.valueOf(materialValue));
                item.setName(String.valueOf(nameValue));
                item.setBuyPrice(Integer.parseInt(String.valueOf(buyValue)));
                item.setSellPrice(Integer.parseInt(String.valueOf(sellValue)));
                item.setRpgItem(Boolean.parseBoolean(String.valueOf(rpgValue)));
                item.setRarity(rarityValue != null ? String.valueOf(rarityValue) : null);
                item.setMinLevel(Integer.parseInt(String.valueOf(minLevelValue)));
                items.put(item.slot(), item);
            }
            shop.setItems(items);
            shops.put(id, shop);
        }
    }

    private void seedDefaults() {
        ShopDefinition shop = new ShopDefinition("blacksmith");
        shop.setTitle("Dorfschmied");
        ShopItem sword = new ShopItem();
        sword.setSlot(0);
        sword.setMaterial("IRON_SWORD");
        sword.setName("&7Eisenschwert");
        sword.setBuyPrice(100);
        sword.setSellPrice(20);
        ShopItem potion = new ShopItem();
        potion.setSlot(1);
        potion.setMaterial("POTION");
        potion.setName("&aHeiltrank");
        potion.setBuyPrice(50);
        potion.setSellPrice(10);
        Map<Integer, ShopItem> items = new HashMap<>();
        items.put(sword.slot(), sword);
        items.put(potion.slot(), potion);
        shop.setItems(items);
        shops.put(shop.id(), shop);
        saveAll();
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save shops.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/SkillHotbarManager.java`  
- Path: `src/main/java/com/example/rpg/manager/SkillHotbarManager.java`  
- Size: 603 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.PlayerProfile;

public class SkillHotbarManager {
    private final PlayerDataManager playerDataManager;

    public SkillHotbarManager(PlayerDataManager playerDataManager) {
        this.playerDataManager = playerDataManager;
    }

    public void bindSkill(PlayerProfile profile, int slot, String skillId) {
        profile.skillBindings().put(slot, skillId);
        playerDataManager.saveProfile(profile);
    }

    public String getBinding(PlayerProfile profile, int slot) {
        return profile.skillBindings().get(slot);
    }
}

```

## File: `src/main/java/com/example/rpg/manager/SkillManager.java`  
- Path: `src/main/java/com/example/rpg/manager/SkillManager.java`  
- Size: 15212 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.Skill;
import com.example.rpg.model.SkillCategory;
import com.example.rpg.model.SkillType;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.plugin.java.JavaPlugin;

public class SkillManager {
    private final JavaPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, Skill> skills = new HashMap<>();

    public SkillManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "skills.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        if (!file.exists()) {
            seedDefaults();
        }
        load();
    }

    public Skill getSkill(String id) {
        return skills.get(id);
    }

    public Map<String, Skill> skills() {
        return skills;
    }

    public void saveSkill(Skill skill) {
        ConfigurationSection section = config.createSection(skill.id());
        section.set("name", skill.name());
        section.set("type", skill.type().name());
        section.set("category", skill.category().name());
        section.set("cooldown", skill.cooldown());
        section.set("manaCost", skill.manaCost());
        section.set("effects", serializeEffects(skill.effects()));
        section.set("parent", skill.requiredSkill());
        save();
    }

    public void saveAll() {
        config.getKeys(false).forEach(key -> config.set(key, null));
        for (Skill skill : skills.values()) {
            saveSkill(skill);
        }
        save();
    }

    private void load() {
        skills.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            Skill skill = new Skill(id);
            skill.setName(section.getString("name", id));
            skill.setType(SkillType.valueOf(section.getString("type", "ACTIVE")));
            skill.setCategory(SkillCategory.valueOf(section.getString("category", "ATTACK")));
            skill.setCooldown(section.getInt("cooldown", 10));
            skill.setManaCost(section.getInt("manaCost", 20));
            String parent = section.getString("parent", null);
            if (parent == null) {
                parent = section.getString("requiredSkill", null);
            }
            skill.setRequiredSkill(parent);
            skill.setEffects(loadEffects(section));
            skills.put(id, skill);
        }
    }

    private void seedDefaults() {
        Skill healPulse = new Skill("heal_pulse");
        healPulse.setName("Heilpuls");
        healPulse.setType(SkillType.ACTIVE);
        healPulse.setCategory(SkillCategory.HEALING);
        healPulse.setCooldown(20);
        healPulse.setManaCost(20);
        healPulse.setEffects(List.of(effectConfig("HEAL", Map.of("amount", 4))));

        Skill greaterHeal = new Skill("greater_heal");
        greaterHeal.setName("Groe Heilung");
        greaterHeal.setType(SkillType.ACTIVE);
        greaterHeal.setCategory(SkillCategory.HEALING);
        greaterHeal.setCooldown(30);
        greaterHeal.setManaCost(35);
        greaterHeal.setEffects(List.of(effectConfig("HEAL", Map.of("amount", 8))));
        greaterHeal.setRequiredSkill("heal_pulse");

        Skill divineBlessing = new Skill("divine_blessing");
        divineBlessing.setName("Segen");
        divineBlessing.setType(SkillType.ACTIVE);
        divineBlessing.setCategory(SkillCategory.HEALING);
        divineBlessing.setCooldown(45);
        divineBlessing.setManaCost(45);
        divineBlessing.setEffects(List.of(effectConfig("HEAL", Map.of("amount", 12)),
            effectConfig("SOUND", Map.of("sound", "BLOCK_BEACON_POWER_SELECT", "volume", 1.0, "pitch", 1.0))));
        divineBlessing.setRequiredSkill("greater_heal");

        Skill emberShot = new Skill("ember_shot");
        emberShot.setName("Flammensto");
        emberShot.setType(SkillType.ACTIVE);
        emberShot.setCategory(SkillCategory.MAGIC);
        emberShot.setCooldown(12);
        emberShot.setManaCost(18);
        emberShot.setEffects(List.of(effectConfig("PROJECTILE", Map.of("type", "SMALL_FIREBALL")),
            effectConfig("SOUND", Map.of("sound", "ENTITY_BLAZE_SHOOT", "volume", 1.0, "pitch", 1.2))));

        Skill frostBolt = new Skill("frost_bolt");
        frostBolt.setName("Frostbolzen");
        frostBolt.setType(SkillType.ACTIVE);
        frostBolt.setCategory(SkillCategory.MAGIC);
        frostBolt.setCooldown(18);
        frostBolt.setManaCost(25);
        frostBolt.setEffects(List.of(effectConfig("PROJECTILE", Map.of("type", "SNOWBALL")),
            effectConfig("POTION", Map.of("type", "SLOW", "duration", 60, "amplifier", 1, "radius", 6)),
            effectConfig("SOUND", Map.of("sound", "BLOCK_GLASS_BREAK", "volume", 0.8, "pitch", 1.4))));
        frostBolt.setRequiredSkill("ember_shot");

        Skill arcaneBurst = new Skill("arcane_burst");
        arcaneBurst.setName("Arkane Explosion");
        arcaneBurst.setType(SkillType.ACTIVE);
        arcaneBurst.setCategory(SkillCategory.MAGIC);
        arcaneBurst.setCooldown(30);
        arcaneBurst.setManaCost(35);
        arcaneBurst.setEffects(List.of(effectConfig("DAMAGE", Map.of("amount", 6, "radius", 5, "maxTargets", 10)),
            effectConfig("SOUND", Map.of("sound", "ENTITY_ILLUSIONER_CAST_SPELL", "volume", 1.0, "pitch", 1.2))));
        arcaneBurst.setRequiredSkill("frost_bolt");

        Skill powerStrike = new Skill("power_strike");
        powerStrike.setName("Machtsto");
        powerStrike.setType(SkillType.ACTIVE);
        powerStrike.setCategory(SkillCategory.ATTACK);
        powerStrike.setCooldown(8);
        powerStrike.setManaCost(10);
        powerStrike.setEffects(List.of(effectConfig("DAMAGE", Map.of("amount", 8, "radius", 3, "maxTargets", 1)),
            effectConfig("SOUND", Map.of("sound", "ENTITY_PLAYER_ATTACK_STRONG", "volume", 1.0, "pitch", 1.0))));

        Skill whirlwind = new Skill("whirlwind");
        whirlwind.setName("Wirbelwind");
        whirlwind.setType(SkillType.ACTIVE);
        whirlwind.setCategory(SkillCategory.ATTACK);
        whirlwind.setCooldown(20);
        whirlwind.setManaCost(20);
        whirlwind.setEffects(List.of(effectConfig("DAMAGE", Map.of("amount", 5, "radius", 4, "maxTargets", 10)),
            effectConfig("SOUND", Map.of("sound", "ENTITY_PLAYER_ATTACK_SWEEP", "volume", 1.0, "pitch", 0.8))));
        whirlwind.setRequiredSkill("power_strike");

        Skill execute = new Skill("execute");
        execute.setName("Hinrichtung");
        execute.setType(SkillType.ACTIVE);
        execute.setCategory(SkillCategory.ATTACK);
        execute.setCooldown(35);
        execute.setManaCost(30);
        execute.setEffects(List.of(effectConfig("DAMAGE", Map.of("amount", 12, "radius", 3, "maxTargets", 1)),
            effectConfig("SOUND", Map.of("sound", "ENTITY_WITHER_SKELETON_HURT", "volume", 1.0, "pitch", 0.9))));
        execute.setRequiredSkill("whirlwind");

        Skill shieldWall = new Skill("shield_wall");
        shieldWall.setName("Schildwall");
        shieldWall.setType(SkillType.ACTIVE);
        shieldWall.setCategory(SkillCategory.DEFENSE);
        shieldWall.setCooldown(25);
        shieldWall.setManaCost(15);
        shieldWall.setEffects(List.of(effectConfig("POTION", Map.of("type", "DAMAGE_RESISTANCE", "duration", 120, "amplifier", 0)),
            effectConfig("SOUND", Map.of("sound", "ITEM_SHIELD_BLOCK", "volume", 1.0, "pitch", 1.0))));

        Skill fortify = new Skill("fortify");
        fortify.setName("Bollwerk");
        fortify.setType(SkillType.ACTIVE);
        fortify.setCategory(SkillCategory.DEFENSE);
        fortify.setCooldown(35);
        fortify.setManaCost(25);
        fortify.setEffects(List.of(effectConfig("POTION", Map.of("type", "DAMAGE_RESISTANCE", "duration", 200, "amplifier", 1)),
            effectConfig("POTION", Map.of("type", "ABSORPTION", "duration", 200, "amplifier", 1)),
            effectConfig("SOUND", Map.of("sound", "BLOCK_ANVIL_USE", "volume", 0.7, "pitch", 1.0))));
        fortify.setRequiredSkill("shield_wall");

        Skill deflect = new Skill("deflect");
        deflect.setName("Abwehrhaltung");
        deflect.setType(SkillType.ACTIVE);
        deflect.setCategory(SkillCategory.DEFENSE);
        deflect.setCooldown(45);
        deflect.setManaCost(30);
        deflect.setEffects(List.of(effectConfig("POTION", Map.of("type", "FIRE_RESISTANCE", "duration", 200, "amplifier", 0)),
            effectConfig("POTION", Map.of("type", "DAMAGE_RESISTANCE", "duration", 200, "amplifier", 0)),
            effectConfig("SOUND", Map.of("sound", "ITEM_SHIELD_BLOCK", "volume", 1.0, "pitch", 1.2))));
        deflect.setRequiredSkill("fortify");

        Skill miningFocus = new Skill("mining_focus");
        miningFocus.setName("Bergbau-Fokus");
        miningFocus.setType(SkillType.ACTIVE);
        miningFocus.setCategory(SkillCategory.PROFESSION);
        miningFocus.setCooldown(60);
        miningFocus.setManaCost(15);
        miningFocus.setEffects(List.of(effectConfig("POTION", Map.of("type", "FAST_DIGGING", "duration", 300, "amplifier", 1)),
            effectConfig("XP", Map.of("amount", 10)),
            effectConfig("SOUND", Map.of("sound", "BLOCK_STONE_HIT", "volume", 0.8, "pitch", 1.0))));

        Skill craftingInsight = new Skill("crafting_insight");
        craftingInsight.setName("Handwerkskunst");
        craftingInsight.setType(SkillType.ACTIVE);
        craftingInsight.setCategory(SkillCategory.PROFESSION);
        craftingInsight.setCooldown(60);
        craftingInsight.setManaCost(20);
        craftingInsight.setEffects(List.of(effectConfig("POTION", Map.of("type", "LUCK", "duration", 300, "amplifier", 1)),
            effectConfig("XP", Map.of("amount", 10)),
            effectConfig("SOUND", Map.of("sound", "BLOCK_ANVIL_PLACE", "volume", 0.8, "pitch", 1.1))));
        craftingInsight.setRequiredSkill("mining_focus");

        Skill alchemyMastery = new Skill("alchemy_mastery");
        alchemyMastery.setName("Alchemie-Meister");
        alchemyMastery.setType(SkillType.ACTIVE);
        alchemyMastery.setCategory(SkillCategory.PROFESSION);
        alchemyMastery.setCooldown(90);
        alchemyMastery.setManaCost(30);
        alchemyMastery.setEffects(List.of(effectConfig("POTION", Map.of("type", "REGENERATION", "duration", 120, "amplifier", 0)),
            effectConfig("XP", Map.of("amount", 15)),
            effectConfig("SOUND", Map.of("sound", "BLOCK_BREWING_STAND_BREW", "volume", 0.8, "pitch", 1.0))));
        alchemyMastery.setRequiredSkill("crafting_insight");

        skills.put(healPulse.id(), healPulse);
        skills.put(greaterHeal.id(), greaterHeal);
        skills.put(divineBlessing.id(), divineBlessing);
        skills.put(emberShot.id(), emberShot);
        skills.put(frostBolt.id(), frostBolt);
        skills.put(arcaneBurst.id(), arcaneBurst);
        skills.put(powerStrike.id(), powerStrike);
        skills.put(whirlwind.id(), whirlwind);
        skills.put(execute.id(), execute);
        skills.put(shieldWall.id(), shieldWall);
        skills.put(fortify.id(), fortify);
        skills.put(deflect.id(), deflect);
        skills.put(miningFocus.id(), miningFocus);
        skills.put(craftingInsight.id(), craftingInsight);
        skills.put(alchemyMastery.id(), alchemyMastery);
        saveAll();
    }

    private List<Map<String, Object>> serializeEffects(List<com.example.rpg.skill.SkillEffectConfig> effects) {
        List<Map<String, Object>> list = new ArrayList<>();
        for (com.example.rpg.skill.SkillEffectConfig config : effects) {
            Map<String, Object> map = new HashMap<>();
            map.put("type", config.type().name());
            map.put("params", config.params());
            list.add(map);
        }
        return list;
    }

    private List<com.example.rpg.skill.SkillEffectConfig> loadEffects(ConfigurationSection section) {
        List<com.example.rpg.skill.SkillEffectConfig> effects = new ArrayList<>();
        for (Map<?, ?> raw : section.getMapList("effects")) {
            Object typeValue = raw.containsKey("type") ? raw.get("type") : "HEAL";
            com.example.rpg.skill.SkillEffectType type = com.example.rpg.skill.SkillEffectType.valueOf(String.valueOf(typeValue));
            Map<String, Object> params = new HashMap<>();
            Object paramsValue = raw.get("params");
            if (paramsValue instanceof Map<?, ?> paramMap) {
                for (Map.Entry<?, ?> entry : paramMap.entrySet()) {
                    params.put(String.valueOf(entry.getKey()), entry.getValue());
                }
            }
            effects.add(new com.example.rpg.skill.SkillEffectConfig(type, params));
        }
        if (effects.isEmpty() && section.contains("effect")) {
            String legacy = section.getString("effect", "");
            effects.add(mapLegacyEffect(legacy));
        }
        return effects;
    }

    private com.example.rpg.skill.SkillEffectConfig mapLegacyEffect(String legacy) {
        if (legacy == null) {
            return new com.example.rpg.skill.SkillEffectConfig(com.example.rpg.skill.SkillEffectType.HEAL, Map.of("amount", 4));
        }
        return switch (legacy) {
            case "heal_small" -> effectConfig("HEAL", Map.of("amount", 4));
            case "heal_medium" -> effectConfig("HEAL", Map.of("amount", 8));
            case "heal_large" -> effectConfig("HEAL", Map.of("amount", 12));
            case "fireball" -> effectConfig("PROJECTILE", Map.of("type", "SMALL_FIREBALL"));
            case "frostbolt" -> effectConfig("PROJECTILE", Map.of("type", "SNOWBALL"));
            case "arcane_blast" -> effectConfig("DAMAGE", Map.of("amount", 6, "radius", 5, "maxTargets", 10));
            case "power_strike" -> effectConfig("DAMAGE", Map.of("amount", 8, "radius", 3, "maxTargets", 1));
            case "whirlwind" -> effectConfig("DAMAGE", Map.of("amount", 5, "radius", 4, "maxTargets", 10));
            case "execute" -> effectConfig("DAMAGE", Map.of("amount", 12, "radius", 3, "maxTargets", 1));
            case "dash" -> effectConfig("VELOCITY", Map.of("forward", 1.2, "up", 0.3, "add", false));
            case "taunt" -> effectConfig("AGGRO", Map.of("radius", 8));
            default -> effectConfig("HEAL", Map.of("amount", 4));
        };
    }

    private com.example.rpg.skill.SkillEffectConfig effectConfig(String type, Map<String, Object> params) {
        return new com.example.rpg.skill.SkillEffectConfig(
            com.example.rpg.skill.SkillEffectType.valueOf(type),
            params
        );
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save skills.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/SkillSynergyManager.java`  
- Path: `src/main/java/com/example/rpg/manager/SkillSynergyManager.java`  
- Size: 6708 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.model.SkillSynergy;
import com.example.rpg.skill.SkillEffectConfig;
import com.example.rpg.skill.SkillEffectType;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;

public class SkillSynergyManager {
    private final RPGPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, SkillSynergy> synergies = new HashMap<>();

    public SkillSynergyManager(RPGPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "skill_synergies.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        if (!file.exists()) {
            seedDefaults();
        }
        load();
    }

    public void onSkillUsed(Player player, String skillId) {
        long now = System.currentTimeMillis();
        PlayerProfile profile = plugin.playerDataManager().getProfile(player);
        profile.setLastSkill(skillId, now);
        for (SkillSynergy synergy : synergies.values()) {
            if (!synergy.skills().contains(skillId)) {
                continue;
            }
            if (!hasRequiredSkills(player, synergy)) {
                continue;
            }
            for (SkillEffectConfig effect : synergy.effects()) {
                plugin.skillEffects().apply(effect, player, profile);
            }
            player.sendMessage(com.example.rpg.util.Text.mm("<aqua>Synergie ausgelst: " + synergy.id()));
        }
    }

    private boolean hasRequiredSkills(Player player, SkillSynergy synergy) {
        long window = synergy.windowSeconds() * 1000L;
        List<Player> scopePlayers = resolveScope(player, synergy);
        for (String required : synergy.skills()) {
            boolean matched = false;
            for (Player member : scopePlayers) {
                PlayerProfile profile = plugin.playerDataManager().getProfile(member);
                if (required.equalsIgnoreCase(profile.lastSkillId())
                    && (System.currentTimeMillis() - profile.lastSkillTime()) <= window) {
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                return false;
            }
        }
        return true;
    }

    private List<Player> resolveScope(Player player, SkillSynergy synergy) {
        List<Player> players = new ArrayList<>();
        players.add(player);
        String scope = synergy.scope() != null ? synergy.scope().toUpperCase() : "PARTY";
        double radius = synergy.radius();
        if ("PARTY".equals(scope)) {
            plugin.partyManager().getParty(player.getUniqueId()).ifPresent(party -> {
                for (var memberId : party.members()) {
                    Player member = plugin.getServer().getPlayer(memberId);
                    if (member != null && member.getWorld().equals(player.getWorld())
                        && member.getLocation().distanceSquared(player.getLocation()) <= radius * radius) {
                        players.add(member);
                    }
                }
            });
        } else if ("GUILD".equals(scope)) {
            plugin.guildManager().guildFor(player.getUniqueId()).ifPresent(guild -> {
                for (var memberId : guild.members().keySet()) {
                    Player member = plugin.getServer().getPlayer(memberId);
                    if (member != null && member.getWorld().equals(player.getWorld())
                        && member.getLocation().distanceSquared(player.getLocation()) <= radius * radius) {
                        players.add(member);
                    }
                }
            });
        } else {
            for (Player nearby : player.getWorld().getPlayers()) {
                if (nearby.getLocation().distanceSquared(player.getLocation()) <= radius * radius) {
                    players.add(nearby);
                }
            }
        }
        return players;
    }

    private void load() {
        synergies.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            SkillSynergy synergy = new SkillSynergy(id);
            synergy.setSkills(section.getStringList("skills"));
            synergy.setScope(section.getString("scope", "PARTY"));
            synergy.setRadius(section.getDouble("radius", 8));
            synergy.setWindowSeconds(section.getInt("windowSeconds", 6));
            List<Map<?, ?>> rawEffects = section.getMapList("effects");
            for (Map<?, ?> raw : rawEffects) {
                String typeName = mapString(raw, "type", "DAMAGE");
                SkillEffectType type = SkillEffectType.valueOf(typeName);
                Map<String, Object> params = new HashMap<>();
                Object paramsRaw = raw.get("params");
                if (paramsRaw instanceof Map<?, ?> map) {
                    for (Map.Entry<?, ?> entry : map.entrySet()) {
                        params.put(String.valueOf(entry.getKey()), entry.getValue());
                    }
                }
                synergy.effects().add(new SkillEffectConfig(type, params));
            }
            synergies.put(id, synergy);
        }
    }

    private String mapString(Map<?, ?> raw, String key, String fallback) {
        Object value = raw.get(key);
        if (value == null) {
            return fallback;
        }
        String resolved = String.valueOf(value);
        return resolved.isBlank() ? fallback : resolved;
    }

    private void seedDefaults() {
        config.set("steam_burst.skills", List.of("frost_bolt", "ember_shot"));
        config.set("steam_burst.scope", "PARTY");
        config.set("steam_burst.radius", 6);
        config.set("steam_burst.windowSeconds", 6);
        Map<String, Object> damageParams = new HashMap<>();
        damageParams.put("amount", 6);
        damageParams.put("radius", 4);
        config.set("steam_burst.effects", List.of(Map.of("type", "DAMAGE", "params", damageParams)));
        save();
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save skill_synergies.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/SkillTreeManager.java`  
- Path: `src/main/java/com/example/rpg/manager/SkillTreeManager.java`  
- Size: 2011 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.Skill;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SkillTreeManager {
    private final SkillManager skillManager;
    private final Map<String, SkillNode> nodes = new HashMap<>();

    public SkillTreeManager(SkillManager skillManager) {
        this.skillManager = skillManager;
        rebuild();
    }

    public void rebuild() {
        nodes.clear();
        for (Skill skill : skillManager.skills().values()) {
            nodes.put(skill.id(), new SkillNode(skill));
        }
        for (SkillNode node : nodes.values()) {
            String parentId = node.skill().requiredSkill();
            if (parentId != null) {
                SkillNode parent = nodes.get(parentId);
                if (parent != null) {
                    parent.children().add(node);
                    node.setParent(parent);
                }
            }
        }
    }

    public List<SkillNode> roots() {
        List<SkillNode> roots = new ArrayList<>();
        for (SkillNode node : nodes.values()) {
            if (node.parent() == null) {
                roots.add(node);
            }
        }
        roots.sort(Comparator.comparing(n -> n.skill().id()));
        return roots;
    }

    public Map<String, SkillNode> nodes() {
        return nodes;
    }

    public static class SkillNode {
        private final Skill skill;
        private SkillNode parent;
        private final List<SkillNode> children = new ArrayList<>();

        public SkillNode(Skill skill) {
            this.skill = skill;
        }

        public Skill skill() {
            return skill;
        }

        public SkillNode parent() {
            return parent;
        }

        public void setParent(SkillNode parent) {
            this.parent = parent;
        }

        public List<SkillNode> children() {
            return children;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/SpawnerManager.java`  
- Path: `src/main/java/com/example/rpg/manager/SpawnerManager.java`  
- Size: 6871 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.MobDefinition;
import com.example.rpg.model.Spawner;
import com.example.rpg.model.Zone;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.persistence.PersistentDataType;

public class SpawnerManager {
    private final RPGPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, Spawner> spawners = new HashMap<>();
    private final Random random = new Random();

    public SpawnerManager(RPGPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "spawners.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        if (!file.exists()) {
            seedDefaults();
        }
        load();
        startTask();
    }

    public Spawner getSpawner(String id) {
        return spawners.get(id);
    }

    public Map<String, Spawner> spawners() {
        return spawners;
    }

    public void saveSpawner(Spawner spawner) {
        ConfigurationSection section = config.createSection(spawner.id());
        section.set("zoneId", spawner.zoneId());
        section.set("maxMobs", spawner.maxMobs());
        section.set("spawnInterval", spawner.spawnInterval());
        section.set("mobs", spawner.mobs());
        save();
    }

    public void saveAll() {
        config.getKeys(false).forEach(key -> config.set(key, null));
        for (Spawner spawner : spawners.values()) {
            saveSpawner(spawner);
        }
        save();
    }

    private void load() {
        spawners.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            Spawner spawner = new Spawner(id);
            spawner.setZoneId(section.getString("zoneId", null));
            spawner.setMaxMobs(section.getInt("maxMobs", 6));
            spawner.setSpawnInterval(section.getInt("spawnInterval", 200));
            ConfigurationSection mobsSection = section.getConfigurationSection("mobs");
            if (mobsSection != null) {
                Map<String, Double> mobs = new HashMap<>();
                for (String mobId : mobsSection.getKeys(false)) {
                    mobs.put(mobId, mobsSection.getDouble(mobId, 1.0));
                }
                spawner.setMobs(mobs);
            }
            spawners.put(id, spawner);
        }
    }

    private void seedDefaults() {
        Spawner spawner = new Spawner("forest_spawner");
        spawner.setZoneId("startzone");
        spawner.setMaxMobs(6);
        spawner.setSpawnInterval(200);
        spawner.setMobs(Map.of("boss_zombie", 1.0));
        spawners.put(spawner.id(), spawner);
        saveAll();
    }

    private void startTask() {
        plugin.getServer().getScheduler().runTaskTimer(plugin, () -> {
            long now = plugin.getServer().getCurrentTick();
            for (Spawner spawner : spawners.values()) {
                if (spawner.spawnInterval() <= 0) {
                    continue;
                }
                if (now % spawner.spawnInterval() != 0) {
                    continue;
                }
                if (spawner.zoneId() == null) {
                    continue;
                }
                Zone zone = plugin.zoneManager().getZone(spawner.zoneId());
                if (zone == null) {
                    continue;
                }
                if (!hasPlayersInZone(zone)) {
                    continue;
                }
                int current = countMobsInZone(zone);
                if (current >= spawner.maxMobs()) {
                    continue;
                }
                MobDefinition mob = pickMob(spawner);
                if (mob == null) {
                    continue;
                }
                spawnMobInZone(zone, mob);
            }
        }, 40L, 40L);
    }

    private boolean hasPlayersInZone(Zone zone) {
        World world = plugin.getServer().getWorld(zone.world());
        if (world == null) {
            return false;
        }
        return world.getPlayers().stream().anyMatch(player -> zone.contains(player.getLocation()));
    }

    private int countMobsInZone(Zone zone) {
        World world = plugin.getServer().getWorld(zone.world());
        if (world == null) {
            return 0;
        }
        return (int) world.getLivingEntities().stream()
            .filter(entity -> entity.getPersistentDataContainer()
                .has(plugin.customMobListener().mobKey(), PersistentDataType.STRING))
            .filter(entity -> zone.contains(entity.getLocation()))
            .count();
    }

    private MobDefinition pickMob(Spawner spawner) {
        if (spawner.mobs().isEmpty()) {
            return null;
        }
        double total = spawner.mobs().values().stream().mapToDouble(Double::doubleValue).sum();
        double roll = random.nextDouble() * total;
        double current = 0;
        for (Map.Entry<String, Double> entry : spawner.mobs().entrySet()) {
            current += entry.getValue();
            if (roll <= current) {
                return plugin.mobManager().getMob(entry.getKey());
            }
        }
        String fallback = spawner.mobs().keySet().iterator().next();
        return plugin.mobManager().getMob(fallback);
    }

    private void spawnMobInZone(Zone zone, MobDefinition mob) {
        World world = plugin.getServer().getWorld(zone.world());
        if (world == null) {
            return;
        }
        int x = randomBetween(zone.x1(), zone.x2());
        int z = randomBetween(zone.z1(), zone.z2());
        int y = world.getHighestBlockYAt(x, z);
        Location location = new Location(world, x + 0.5, y + 1, z + 0.5);
        var type = org.bukkit.entity.EntityType.valueOf(mob.type().toUpperCase());
        var entity = world.spawnEntity(location, type);
        if (entity instanceof org.bukkit.entity.LivingEntity living) {
            plugin.customMobListener().applyDefinition(living, mob);
        } else {
            entity.remove();
        }
    }

    private int randomBetween(int min, int max) {
        int low = Math.min(min, max);
        int high = Math.max(min, max);
        return low + random.nextInt(Math.max(1, high - low + 1));
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save spawners.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/TradeManager.java`  
- Path: `src/main/java/com/example/rpg/manager/TradeManager.java`  
- Size: 797 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.TradeRequest;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class TradeManager {
    private final Map<UUID, TradeRequest> requests = new HashMap<>();

    public void requestTrade(UUID requester, UUID target) {
        TradeRequest request = new TradeRequest(requester, target);
        requests.put(requester, request);
        requests.put(target, request);
    }

    public TradeRequest getRequest(UUID player) {
        return requests.get(player);
    }

    public void clear(UUID player) {
        TradeRequest request = requests.remove(player);
        if (request != null) {
            requests.remove(request.requester());
            requests.remove(request.target());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/VoiceChatManager.java`  
- Path: `src/main/java/com/example/rpg/manager/VoiceChatManager.java`  
- Size: 3358 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.RPGPlugin;
import com.example.rpg.util.Text;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import org.bukkit.entity.Player;

public class VoiceChatManager {
    private final RPGPlugin plugin;
    private final Map<UUID, String> channels = new HashMap<>();
    private Object voiceApi;
    private Method setPlayerGroup;
    private Method createGroup;

    public VoiceChatManager(RPGPlugin plugin) {
        this.plugin = plugin;
        tryInitApi();
    }

    public void joinParty(Player player) {
        Optional<com.example.rpg.model.Party> party = plugin.partyManager().getParty(player.getUniqueId());
        if (party.isEmpty()) {
            player.sendMessage(Text.mm("<red>Du bist in keiner Party."));
            return;
        }
        String channel = "party-" + party.get().leader().toString();
        joinChannel(player, channel, "Party");
    }

    public void joinGuild(Player player) {
        String guildId = plugin.playerDataManager().getProfile(player).guildId();
        if (guildId == null) {
            player.sendMessage(Text.mm("<red>Du bist in keiner Gilde."));
            return;
        }
        String channel = "guild-" + guildId;
        joinChannel(player, channel, "Gilde");
    }

    public void leave(Player player) {
        channels.remove(player.getUniqueId());
        if (!setGroup(player, null, "Lobby")) {
            player.sendMessage(Text.mm("<yellow>Sprachkanal verlassen."));
        }
    }

    private void joinChannel(Player player, String channel, String label) {
        channels.put(player.getUniqueId(), channel);
        if (!setGroup(player, channel, label)) {
            player.sendMessage(Text.mm("<green>Sprachchat (" + label + ") aktiviert."));
            player.sendMessage(Text.mm("<gray>Installiere Simple Voice Chat fr Mikrofon-Untersttzung."));
        }
    }

    private boolean setGroup(Player player, String groupId, String label) {
        if (voiceApi == null || setPlayerGroup == null || createGroup == null) {
            return false;
        }
        try {
            UUID uuid = groupId != null ? UUID.nameUUIDFromBytes(groupId.getBytes()) : null;
            Object group = null;
            if (groupId != null) {
                group = createGroup.invoke(voiceApi, uuid, label + " " + groupId);
            }
            setPlayerGroup.invoke(voiceApi, player.getUniqueId(), group);
            player.sendMessage(Text.mm("<green>Sprachchat (" + label + ") aktiviert."));
            return true;
        } catch (ReflectiveOperationException e) {
            plugin.getLogger().warning("Voice chat API error: " + e.getMessage());
            return false;
        }
    }

    private void tryInitApi() {
        try {
            Class<?> apiClass = Class.forName("de.maxhenkel.voicechat.api.VoicechatServerApi");
            Method getInstance = apiClass.getMethod("getInstance");
            voiceApi = getInstance.invoke(null);
            createGroup = apiClass.getMethod("createGroup", UUID.class, String.class);
            setPlayerGroup = apiClass.getMethod("setPlayerGroup", UUID.class, Object.class);
        } catch (ReflectiveOperationException e) {
            voiceApi = null;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/WorldEventManager.java`  
- Path: `src/main/java/com/example/rpg/manager/WorldEventManager.java`  
- Size: 12393 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.RPGPlugin;
import com.example.rpg.model.PlayerProfile;
import com.example.rpg.model.Quest;
import com.example.rpg.model.QuestStep;
import com.example.rpg.model.QuestStepType;
import com.example.rpg.model.WorldEvent;
import com.example.rpg.util.Text;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;

public class WorldEventManager {
    private final RPGPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, WorldEvent> events = new HashMap<>();
    private final Map<String, Boolean> completed = new HashMap<>();

    public WorldEventManager(RPGPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "events.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        load();
    }

    public Map<String, WorldEvent> events() {
        return events;
    }

    public WorldEvent getEvent(String id) {
        return events.get(id);
    }

    public boolean isCompleted(String id) {
        return completed.getOrDefault(id, false);
    }

    public void startEvent(String id) {
        WorldEvent event = events.get(id);
        if (event == null) {
            return;
        }
        event.setActive(true);
        event.progress().clear();
        event.participants().clear();
        saveEvent(event);
        broadcast("<gold>Welt-Event gestartet:</gold> <white>" + event.name());
    }

    public void stopEvent(String id) {
        WorldEvent event = events.get(id);
        if (event == null) {
            return;
        }
        event.setActive(false);
        saveEvent(event);
        broadcast("<yellow>Welt-Event beendet:</yellow> <white>" + event.name());
    }

    public void trackParticipation(Player player, WorldEvent event) {
        event.participants().add(player.getUniqueId());
    }

    public void increment(WorldEvent event, int stepIndex, int amount) {
        int current = event.progress().getOrDefault(stepIndex, 0);
        int updated = current + amount;
        event.progress().put(stepIndex, updated);
        saveEvent(event);
        checkCompletion(event);
    }

    public void handleKill(Player player, String mobType, String zoneId) {
        for (WorldEvent event : activeEvents(zoneId)) {
            for (int i = 0; i < event.steps().size(); i++) {
                QuestStep step = event.steps().get(i);
                if (step.type() == QuestStepType.KILL && step.target().equalsIgnoreCase(mobType)) {
                    trackParticipation(player, event);
                    increment(event, i, 1);
                }
                if (step.type() == QuestStepType.DEFEND && step.target().equalsIgnoreCase(zoneId)) {
                    trackParticipation(player, event);
                    increment(event, i, 1);
                }
            }
        }
    }

    public void handleExplore(Player player, String zoneId) {
        for (WorldEvent event : activeEvents(zoneId)) {
            for (int i = 0; i < event.steps().size(); i++) {
                QuestStep step = event.steps().get(i);
                if (step.type() == QuestStepType.EXPLORE && step.target().equalsIgnoreCase(zoneId)) {
                    trackParticipation(player, event);
                    increment(event, i, 1);
                }
                if (step.type() == QuestStepType.ESCORT && step.target().equalsIgnoreCase(zoneId)) {
                    trackParticipation(player, event);
                    increment(event, i, 1);
                }
            }
        }
    }

    public void handleCraft(Player player, String material, String zoneId) {
        for (WorldEvent event : activeEvents(zoneId)) {
            for (int i = 0; i < event.steps().size(); i++) {
                QuestStep step = event.steps().get(i);
                if (step.type() == QuestStepType.CRAFT && step.target().equalsIgnoreCase(material)) {
                    trackParticipation(player, event);
                    increment(event, i, 1);
                }
            }
        }
    }

    public void handleCollect(Player player, String material, String zoneId) {
        for (WorldEvent event : activeEvents(zoneId)) {
            for (int i = 0; i < event.steps().size(); i++) {
                QuestStep step = event.steps().get(i);
                if (step.type() == QuestStepType.COLLECT && step.target().equalsIgnoreCase(material)) {
                    trackParticipation(player, event);
                    increment(event, i, 1);
                }
            }
        }
    }

    public void handleUseItem(Player player, String material, String zoneId) {
        for (WorldEvent event : activeEvents(zoneId)) {
            for (int i = 0; i < event.steps().size(); i++) {
                QuestStep step = event.steps().get(i);
                if (step.type() == QuestStepType.USE_ITEM && step.target().equalsIgnoreCase(material)) {
                    trackParticipation(player, event);
                    increment(event, i, 1);
                }
            }
        }
    }

    private List<WorldEvent> activeEvents(String zoneId) {
        List<WorldEvent> active = new ArrayList<>();
        for (WorldEvent event : events.values()) {
            if (!event.active()) {
                continue;
            }
            if (event.zoneId() != null && zoneId != null && event.zoneId().equalsIgnoreCase(zoneId)) {
                active.add(event);
            }
        }
        return active;
    }

    private void checkCompletion(WorldEvent event) {
        for (int i = 0; i < event.steps().size(); i++) {
            QuestStep step = event.steps().get(i);
            int required = step.amount();
            int current = event.progress().getOrDefault(i, 0);
            if (current < required) {
                return;
            }
        }
        completeEvent(event);
    }

    private void completeEvent(WorldEvent event) {
        event.setActive(false);
        completed.put(event.id(), true);
        saveEvent(event);
        saveCompleted();
        broadcast("<green>Welt-Event abgeschlossen:</green> <white>" + event.name());
        for (UUID participant : event.participants()) {
            Player player = plugin.getServer().getPlayer(participant);
            if (player == null) {
                continue;
            }
            PlayerProfile profile = plugin.playerDataManager().getProfile(player);
            profile.addXp(event.rewardXp());
            profile.setGold(profile.gold() + event.rewardGold());
            event.rewardFactionRep().forEach((faction, amount) ->
                profile.factionRep().put(faction, profile.factionRep().getOrDefault(faction, 0) + amount)
            );
            player.sendMessage(Text.mm("<gold>Event-Belohnung:</gold> +" + event.rewardXp() + " XP, +" + event.rewardGold() + " Gold"));
            for (String questId : event.unlockQuests()) {
                Quest quest = plugin.questManager().getQuest(questId);
                if (quest != null) {
                    quest.setRequiredEvent(event.id());
                    plugin.questManager().saveQuest(quest);
                }
            }
        }
        event.participants().clear();
    }

    public void saveEvent(WorldEvent event) {
        ConfigurationSection section = config.createSection(event.id());
        section.set("name", event.name());
        section.set("zoneId", event.zoneId());
        section.set("active", event.active());
        section.set("reward.xp", event.rewardXp());
        section.set("reward.gold", event.rewardGold());
        section.set("reward.factionRep", event.rewardFactionRep());
        section.set("unlockQuests", event.unlockQuests());
        List<Map<String, Object>> steps = new ArrayList<>();
        for (QuestStep step : event.steps()) {
            Map<String, Object> map = new HashMap<>();
            map.put("type", step.type().name());
            map.put("target", step.target());
            map.put("amount", step.amount());
            steps.add(map);
        }
        section.set("steps", steps);
        section.set("progress", event.progress());
        save();
    }

    public void saveAll() {
        config.getKeys(false).forEach(key -> config.set(key, null));
        for (WorldEvent event : events.values()) {
            saveEvent(event);
        }
        saveCompleted();
        save();
    }

    private void load() {
        events.clear();
        completed.clear();
        ConfigurationSection completedSection = config.getConfigurationSection("completed");
        if (completedSection != null) {
            for (String id : completedSection.getKeys(false)) {
                completed.put(id, completedSection.getBoolean(id, false));
            }
        }
        for (String id : config.getKeys(false)) {
            if ("completed".equals(id)) {
                continue;
            }
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            WorldEvent event = new WorldEvent(id);
            event.setName(section.getString("name", id));
            event.setZoneId(section.getString("zoneId", null));
            event.setActive(section.getBoolean("active", false));
            event.setRewardXp(section.getInt("reward.xp", 100));
            event.setRewardGold(section.getInt("reward.gold", 50));
            ConfigurationSection repSection = section.getConfigurationSection("reward.factionRep");
            if (repSection != null) {
                for (String faction : repSection.getKeys(false)) {
                    event.rewardFactionRep().put(faction, repSection.getInt(faction));
                }
            }
            event.unlockQuests().addAll(section.getStringList("unlockQuests"));
            for (Map<?, ?> raw : section.getMapList("steps")) {
                String typeName = mapString(raw, "type", "KILL");
                String target = mapString(raw, "target", "ZOMBIE");
                int amount = mapInt(raw, "amount", 1);
                event.steps().add(new QuestStep(QuestStepType.valueOf(typeName), target, amount));
            }
            ConfigurationSection progressSection = section.getConfigurationSection("progress");
            if (progressSection != null) {
                for (String key : progressSection.getKeys(false)) {
                    try {
                        int index = Integer.parseInt(key);
                        event.progress().put(index, progressSection.getInt(key));
                    } catch (NumberFormatException ignored) {
                    }
                }
            }
            events.put(id, event);
        }
    }

    private String mapString(Map<?, ?> raw, String key, String fallback) {
        Object value = raw.get(key);
        if (value == null) {
            return fallback;
        }
        String resolved = String.valueOf(value);
        return resolved.isBlank() ? fallback : resolved;
    }

    private int mapInt(Map<?, ?> raw, String key, int fallback) {
        Object value = raw.get(key);
        if (value == null) {
            return fallback;
        }
        try {
            return Integer.parseInt(String.valueOf(value));
        } catch (NumberFormatException e) {
            return fallback;
        }
    }

    private void saveCompleted() {
        ConfigurationSection section = config.getConfigurationSection("completed");
        if (section == null) {
            section = config.createSection("completed");
        }
        for (Map.Entry<String, Boolean> entry : completed.entrySet()) {
            section.set(entry.getKey(), entry.getValue());
        }
    }

    private void broadcast(String message) {
        plugin.getServer().broadcast(Text.mm(message));
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save events.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/manager/ZoneManager.java`  
- Path: `src/main/java/com/example/rpg/manager/ZoneManager.java`  
- Size: 3173 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.manager;

import com.example.rpg.model.Zone;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import org.bukkit.Location;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.plugin.java.JavaPlugin;

public class ZoneManager {
    private final JavaPlugin plugin;
    private final File file;
    private final YamlConfiguration config;
    private final Map<String, Zone> zones = new HashMap<>();

    public ZoneManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "zones.yml");
        this.config = YamlConfiguration.loadConfiguration(file);
        load();
    }

    public Map<String, Zone> zones() {
        return zones;
    }

    public Zone getZone(String id) {
        return zones.get(id);
    }

    public Zone getZoneAt(Location location) {
        for (Zone zone : zones.values()) {
            if (zone.contains(location)) {
                return zone;
            }
        }
        return null;
    }

    public void saveZone(Zone zone) {
        ConfigurationSection section = config.createSection(zone.id());
        section.set("name", zone.name());
        section.set("world", zone.world());
        section.set("minLevel", zone.minLevel());
        section.set("maxLevel", zone.maxLevel());
        section.set("slowMultiplier", zone.slowMultiplier());
        section.set("damageMultiplier", zone.damageMultiplier());
        section.set("x1", zone.x1());
        section.set("y1", zone.y1());
        section.set("z1", zone.z1());
        section.set("x2", zone.x2());
        section.set("y2", zone.y2());
        section.set("z2", zone.z2());
        save();
    }

    public void saveAll() {
        config.getKeys(false).forEach(key -> config.set(key, null));
        for (Zone zone : zones.values()) {
            saveZone(zone);
        }
        save();
    }

    private void load() {
        zones.clear();
        for (String id : config.getKeys(false)) {
            ConfigurationSection section = config.getConfigurationSection(id);
            if (section == null) {
                continue;
            }
            Zone zone = new Zone(id);
            zone.setName(section.getString("name", id));
            zone.setWorld(section.getString("world", "world"));
            zone.setMinLevel(section.getInt("minLevel", 1));
            zone.setMaxLevel(section.getInt("maxLevel", 60));
            zone.setSlowMultiplier(section.getDouble("slowMultiplier", 1.0));
            zone.setDamageMultiplier(section.getDouble("damageMultiplier", 1.0));
            zone.setCoordinates(
                section.getInt("x1"), section.getInt("y1"), section.getInt("z1"),
                section.getInt("x2"), section.getInt("y2"), section.getInt("z2")
            );
            zones.put(id, zone);
        }
    }

    private void save() {
        try {
            config.save(file);
        } catch (IOException e) {
            plugin.getLogger().warning("Failed to save zones.yml: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/model/Arena.java`  
- Path: `src/main/java/com/example/rpg/model/Arena.java`  
- Size: 2700 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.UUID;

public class Arena {
    private final String id;
    private String world;
    private int x1;
    private int y1;
    private int z1;
    private int x2;
    private int y2;
    private int z2;
    private int spawn1x;
    private int spawn1y;
    private int spawn1z;
    private int spawn2x;
    private int spawn2y;
    private int spawn2z;
    private ArenaStatus status = ArenaStatus.WAITING;
    private UUID playerOne;
    private UUID playerTwo;

    public Arena(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String world() {
        return world;
    }

    public void setWorld(String world) {
        this.world = world;
    }

    public int x1() {
        return x1;
    }

    public void setX1(int x1) {
        this.x1 = x1;
    }

    public int y1() {
        return y1;
    }

    public void setY1(int y1) {
        this.y1 = y1;
    }

    public int z1() {
        return z1;
    }

    public void setZ1(int z1) {
        this.z1 = z1;
    }

    public int x2() {
        return x2;
    }

    public void setX2(int x2) {
        this.x2 = x2;
    }

    public int y2() {
        return y2;
    }

    public void setY2(int y2) {
        this.y2 = y2;
    }

    public int z2() {
        return z2;
    }

    public void setZ2(int z2) {
        this.z2 = z2;
    }

    public int spawn1x() {
        return spawn1x;
    }

    public void setSpawn1x(int spawn1x) {
        this.spawn1x = spawn1x;
    }

    public int spawn1y() {
        return spawn1y;
    }

    public void setSpawn1y(int spawn1y) {
        this.spawn1y = spawn1y;
    }

    public int spawn1z() {
        return spawn1z;
    }

    public void setSpawn1z(int spawn1z) {
        this.spawn1z = spawn1z;
    }

    public int spawn2x() {
        return spawn2x;
    }

    public void setSpawn2x(int spawn2x) {
        this.spawn2x = spawn2x;
    }

    public int spawn2y() {
        return spawn2y;
    }

    public void setSpawn2y(int spawn2y) {
        this.spawn2y = spawn2y;
    }

    public int spawn2z() {
        return spawn2z;
    }

    public void setSpawn2z(int spawn2z) {
        this.spawn2z = spawn2z;
    }

    public ArenaStatus status() {
        return status;
    }

    public void setStatus(ArenaStatus status) {
        this.status = status;
    }

    public UUID playerOne() {
        return playerOne;
    }

    public void setPlayerOne(UUID playerOne) {
        this.playerOne = playerOne;
    }

    public UUID playerTwo() {
        return playerTwo;
    }

    public void setPlayerTwo(UUID playerTwo) {
        this.playerTwo = playerTwo;
    }
}

```

## File: `src/main/java/com/example/rpg/model/ArenaStatus.java`  
- Path: `src/main/java/com/example/rpg/model/ArenaStatus.java`  
- Size: 98 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public enum ArenaStatus {
    WAITING,
    FIGHTING,
    ENDING
}

```

## File: `src/main/java/com/example/rpg/model/AuctionListing.java`  
- Path: `src/main/java/com/example/rpg/model/AuctionListing.java`  
- Size: 726 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.UUID;

public class AuctionListing {
    private final String id;
    private UUID seller;
    private String itemData;
    private int price;

    public AuctionListing(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public UUID seller() {
        return seller;
    }

    public void setSeller(UUID seller) {
        this.seller = seller;
    }

    public String itemData() {
        return itemData;
    }

    public void setItemData(String itemData) {
        this.itemData = itemData;
    }

    public int price() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }
}

```

## File: `src/main/java/com/example/rpg/model/BuildingCategory.java`  
- Path: `src/main/java/com/example/rpg/model/BuildingCategory.java`  
- Size: 809 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.Locale;

public enum BuildingCategory {
    RESIDENTIAL("Wohngebude"),
    SHOP("Geschfte"),
    PUBLIC("ffentliche Einrichtungen"),
    CRAFTING("Hersteller");

    private final String displayName;

    BuildingCategory(String displayName) {
        this.displayName = displayName;
    }

    public String displayName() {
        return displayName;
    }

    public static BuildingCategory fromString(String raw) {
        if (raw == null) {
            return RESIDENTIAL;
        }
        String normalized = raw.trim().toUpperCase(Locale.ROOT);
        for (BuildingCategory category : values()) {
            if (category.name().equals(normalized)) {
                return category;
            }
        }
        return RESIDENTIAL;
    }
}

```

## File: `src/main/java/com/example/rpg/model/BuildingDefinition.java`  
- Path: `src/main/java/com/example/rpg/model/BuildingDefinition.java`  
- Size: 3041 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class BuildingDefinition {
    private final String id;
    private String name;
    private BuildingCategory category = BuildingCategory.RESIDENTIAL;
    private String schematic;
    private String floorSchematic;
    private int minFloors = 1;
    private int maxFloors = 1;
    private int floorHeight = 5;
    private String basementSchematic;
    private int basementDepth = 0;
    private boolean includeAir = false;
    private int offsetX;
    private int offsetY;
    private int offsetZ;
    private final List<FurnitureDefinition> furniture = new ArrayList<>();

    public BuildingDefinition(String id) {
        this.id = id;
        this.name = id;
    }

    public String id() {
        return id;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public BuildingCategory category() {
        return category;
    }

    public void setCategory(BuildingCategory category) {
        this.category = category;
    }

    public String schematic() {
        return schematic;
    }

    public void setSchematic(String schematic) {
        this.schematic = schematic;
    }

    public String floorSchematic() {
        return floorSchematic;
    }

    public void setFloorSchematic(String floorSchematic) {
        this.floorSchematic = floorSchematic;
    }

    public int minFloors() {
        return minFloors;
    }

    public void setMinFloors(int minFloors) {
        this.minFloors = minFloors;
    }

    public int maxFloors() {
        return maxFloors;
    }

    public void setMaxFloors(int maxFloors) {
        this.maxFloors = maxFloors;
    }

    public int floorHeight() {
        return floorHeight;
    }

    public void setFloorHeight(int floorHeight) {
        this.floorHeight = floorHeight;
    }

    public String basementSchematic() {
        return basementSchematic;
    }

    public void setBasementSchematic(String basementSchematic) {
        this.basementSchematic = basementSchematic;
    }

    public int basementDepth() {
        return basementDepth;
    }

    public void setBasementDepth(int basementDepth) {
        this.basementDepth = basementDepth;
    }

    public boolean includeAir() {
        return includeAir;
    }

    public void setIncludeAir(boolean includeAir) {
        this.includeAir = includeAir;
    }

    public int offsetX() {
        return offsetX;
    }

    public int offsetY() {
        return offsetY;
    }

    public int offsetZ() {
        return offsetZ;
    }

    public void setOffset(int x, int y, int z) {
        this.offsetX = x;
        this.offsetY = y;
        this.offsetZ = z;
    }

    public List<FurnitureDefinition> furniture() {
        return Collections.unmodifiableList(furniture);
    }

    public void addFurniture(FurnitureDefinition furnitureDefinition) {
        furniture.add(furnitureDefinition);
    }
}

```

## File: `src/main/java/com/example/rpg/model/ClassDefinition.java`  
- Path: `src/main/java/com/example/rpg/model/ClassDefinition.java`  
- Size: 657 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.ArrayList;
import java.util.List;

public class ClassDefinition {
    private final String id;
    private String name;
    private List<String> startSkills = new ArrayList<>();

    public ClassDefinition(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List<String> startSkills() {
        return startSkills;
    }

    public void setStartSkills(List<String> startSkills) {
        this.startSkills = startSkills;
    }
}

```

## File: `src/main/java/com/example/rpg/model/CraftingOrder.java`  
- Path: `src/main/java/com/example/rpg/model/CraftingOrder.java`  
- Size: 937 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.UUID;

public class CraftingOrder {
    private final String id;
    private UUID requester;
    private String material;
    private int amount;
    private int rewardGold;

    public CraftingOrder(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public UUID requester() {
        return requester;
    }

    public void setRequester(UUID requester) {
        this.requester = requester;
    }

    public String material() {
        return material;
    }

    public void setMaterial(String material) {
        this.material = material;
    }

    public int amount() {
        return amount;
    }

    public void setAmount(int amount) {
        this.amount = amount;
    }

    public int rewardGold() {
        return rewardGold;
    }

    public void setRewardGold(int rewardGold) {
        this.rewardGold = rewardGold;
    }
}

```

## File: `src/main/java/com/example/rpg/model/DialogueNode.java`  
- Path: `src/main/java/com/example/rpg/model/DialogueNode.java`  
- Size: 555 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.ArrayList;
import java.util.List;

public class DialogueNode {
    private final String id;
    private String text;
    private final List<DialogueOption> options = new ArrayList<>();

    public DialogueNode(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String text() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public List<DialogueOption> options() {
        return options;
    }
}

```

## File: `src/main/java/com/example/rpg/model/DialogueOption.java`  
- Path: `src/main/java/com/example/rpg/model/DialogueOption.java`  
- Size: 1493 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public class DialogueOption {
    private String text;
    private String nextId;
    private String requiredFactionId;
    private int minRep;
    private String requiredQuestId;
    private boolean requireQuestCompleted;
    private String grantQuestId;

    public String text() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public String nextId() {
        return nextId;
    }

    public void setNextId(String nextId) {
        this.nextId = nextId;
    }

    public String requiredFactionId() {
        return requiredFactionId;
    }

    public void setRequiredFactionId(String requiredFactionId) {
        this.requiredFactionId = requiredFactionId;
    }

    public int minRep() {
        return minRep;
    }

    public void setMinRep(int minRep) {
        this.minRep = minRep;
    }

    public String requiredQuestId() {
        return requiredQuestId;
    }

    public void setRequiredQuestId(String requiredQuestId) {
        this.requiredQuestId = requiredQuestId;
    }

    public boolean requireQuestCompleted() {
        return requireQuestCompleted;
    }

    public void setRequireQuestCompleted(boolean requireQuestCompleted) {
        this.requireQuestCompleted = requireQuestCompleted;
    }

    public String grantQuestId() {
        return grantQuestId;
    }

    public void setGrantQuestId(String grantQuestId) {
        this.grantQuestId = grantQuestId;
    }
}

```

## File: `src/main/java/com/example/rpg/model/EnchantmentRecipe.java`  
- Path: `src/main/java/com/example/rpg/model/EnchantmentRecipe.java`  
- Size: 2025 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import com.example.rpg.skill.SkillEffectConfig;
import java.util.ArrayList;
import java.util.List;
import org.bukkit.Material;

public class EnchantmentRecipe {
    private final String id;
    private EnchantRecipeType type;
    private EnchantTargetSlot targetSlot;
    private RPGStat statToImprove;
    private int minLevel;
    private int costGold;
    private Material costMaterial;
    private int costAmount;
    private String affix;
    private final List<SkillEffectConfig> effects = new ArrayList<>();

    public EnchantmentRecipe(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public EnchantRecipeType type() {
        return type;
    }

    public void setType(EnchantRecipeType type) {
        this.type = type;
    }

    public EnchantTargetSlot targetSlot() {
        return targetSlot;
    }

    public void setTargetSlot(EnchantTargetSlot targetSlot) {
        this.targetSlot = targetSlot;
    }

    public RPGStat statToImprove() {
        return statToImprove;
    }

    public void setStatToImprove(RPGStat statToImprove) {
        this.statToImprove = statToImprove;
    }

    public int minLevel() {
        return minLevel;
    }

    public void setMinLevel(int minLevel) {
        this.minLevel = minLevel;
    }

    public int costGold() {
        return costGold;
    }

    public void setCostGold(int costGold) {
        this.costGold = costGold;
    }

    public Material costMaterial() {
        return costMaterial;
    }

    public void setCostMaterial(Material costMaterial) {
        this.costMaterial = costMaterial;
    }

    public int costAmount() {
        return costAmount;
    }

    public void setCostAmount(int costAmount) {
        this.costAmount = costAmount;
    }

    public String affix() {
        return affix;
    }

    public void setAffix(String affix) {
        this.affix = affix;
    }

    public List<SkillEffectConfig> effects() {
        return effects;
    }
}

```

## File: `src/main/java/com/example/rpg/model/EnchantRecipeType.java`  
- Path: `src/main/java/com/example/rpg/model/EnchantRecipeType.java`  
- Size: 94 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public enum EnchantRecipeType {
    STAT_UPGRADE,
    AFFIX
}

```

## File: `src/main/java/com/example/rpg/model/EnchantTargetSlot.java`  
- Path: `src/main/java/com/example/rpg/model/EnchantTargetSlot.java`  
- Size: 905 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;

public enum EnchantTargetSlot {
    HAND,
    OFF_HAND,
    ARMOR_HEAD,
    ARMOR_CHEST,
    ARMOR_LEGS,
    ARMOR_FEET,
    SHIELD;

    public boolean matches(ItemStack item) {
        if (item == null || item.getType().isAir()) {
            return false;
        }
        Material material = item.getType();
        String name = material.name();
        return switch (this) {
            case HAND -> true;
            case OFF_HAND -> true;
            case SHIELD -> material == Material.SHIELD;
            case ARMOR_HEAD -> name.endsWith("HELMET") || name.endsWith("HEAD") || name.endsWith("SKULL");
            case ARMOR_CHEST -> name.endsWith("CHESTPLATE");
            case ARMOR_LEGS -> name.endsWith("LEGGINGS");
            case ARMOR_FEET -> name.endsWith("BOOTS");
        };
    }
}

```

## File: `src/main/java/com/example/rpg/model/Faction.java`  
- Path: `src/main/java/com/example/rpg/model/Faction.java`  
- Size: 943 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public class Faction {
    private final String id;
    private String name;
    private java.util.List<FactionRank> ranks = new java.util.ArrayList<>();

    public Faction(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public java.util.List<FactionRank> ranks() {
        return ranks;
    }

    public void setRanks(java.util.List<FactionRank> ranks) {
        this.ranks = ranks;
    }

    public FactionRank rankForRep(int rep) {
        FactionRank result = null;
        for (FactionRank rank : ranks) {
            if (rep >= rank.minRep()) {
                if (result == null || rank.minRep() > result.minRep()) {
                    result = rank;
                }
            }
        }
        return result;
    }
}

```

## File: `src/main/java/com/example/rpg/model/FactionRank.java`  
- Path: `src/main/java/com/example/rpg/model/FactionRank.java`  
- Size: 941 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public class FactionRank {
    private final String id;
    private String name;
    private int minRep;
    private double shopDiscount;
    private boolean dungeonAccess;

    public FactionRank(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int minRep() {
        return minRep;
    }

    public void setMinRep(int minRep) {
        this.minRep = minRep;
    }

    public double shopDiscount() {
        return shopDiscount;
    }

    public void setShopDiscount(double shopDiscount) {
        this.shopDiscount = shopDiscount;
    }

    public boolean dungeonAccess() {
        return dungeonAccess;
    }

    public void setDungeonAccess(boolean dungeonAccess) {
        this.dungeonAccess = dungeonAccess;
    }
}

```

## File: `src/main/java/com/example/rpg/model/FurnitureDefinition.java`  
- Path: `src/main/java/com/example/rpg/model/FurnitureDefinition.java`  
- Size: 141 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public record FurnitureDefinition(String schematic, int offsetX, int offsetY, int offsetZ, int rotation) {
}

```

## File: `src/main/java/com/example/rpg/model/Guild.java`  
- Path: `src/main/java/com/example/rpg/model/Guild.java`  
- Size: 1740 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class Guild {
    private final String id;
    private String name;
    private UUID leader;
    private int bankGold;
    private final Map<UUID, GuildMemberRole> members = new HashMap<>();
    private final Map<String, GuildQuest> quests = new HashMap<>();
    private String hallWorld;
    private double hallX;
    private double hallY;
    private double hallZ;
    private final Map<String, Integer> hallUpgrades = new HashMap<>();

    public Guild(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public UUID leader() {
        return leader;
    }

    public void setLeader(UUID leader) {
        this.leader = leader;
    }

    public int bankGold() {
        return bankGold;
    }

    public void setBankGold(int bankGold) {
        this.bankGold = Math.max(0, bankGold);
    }

    public Map<UUID, GuildMemberRole> members() {
        return members;
    }

    public Map<String, GuildQuest> quests() {
        return quests;
    }

    public String hallWorld() {
        return hallWorld;
    }

    public void setHall(String world, double x, double y, double z) {
        this.hallWorld = world;
        this.hallX = x;
        this.hallY = y;
        this.hallZ = z;
    }

    public double hallX() {
        return hallX;
    }

    public double hallY() {
        return hallY;
    }

    public double hallZ() {
        return hallZ;
    }

    public Map<String, Integer> hallUpgrades() {
        return hallUpgrades;
    }
}

```

## File: `src/main/java/com/example/rpg/model/GuildMemberRole.java`  
- Path: `src/main/java/com/example/rpg/model/GuildMemberRole.java`  
- Size: 100 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public enum GuildMemberRole {
    LEADER,
    OFFICER,
    MEMBER
}

```

## File: `src/main/java/com/example/rpg/model/GuildQuest.java`  
- Path: `src/main/java/com/example/rpg/model/GuildQuest.java`  
- Size: 1087 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public class GuildQuest {
    private final String id;
    private String name;
    private String description;
    private int goal;
    private int progress;
    private boolean completed;

    public GuildQuest(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String description() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public int goal() {
        return goal;
    }

    public void setGoal(int goal) {
        this.goal = Math.max(1, goal);
    }

    public int progress() {
        return progress;
    }

    public void setProgress(int progress) {
        this.progress = Math.max(0, progress);
    }

    public boolean completed() {
        return completed;
    }

    public void setCompleted(boolean completed) {
        this.completed = completed;
    }
}

```

## File: `src/main/java/com/example/rpg/model/LootEntry.java`  
- Path: `src/main/java/com/example/rpg/model/LootEntry.java`  
- Size: 1200 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public class LootEntry {
    private String material;
    private double chance;
    private int minAmount;
    private int maxAmount;
    private Rarity rarity;

    public LootEntry(String material, double chance, int minAmount, int maxAmount, Rarity rarity) {
        this.material = material;
        this.chance = chance;
        this.minAmount = minAmount;
        this.maxAmount = maxAmount;
        this.rarity = rarity;
    }

    public String material() {
        return material;
    }

    public void setMaterial(String material) {
        this.material = material;
    }

    public double chance() {
        return chance;
    }

    public void setChance(double chance) {
        this.chance = chance;
    }

    public int minAmount() {
        return minAmount;
    }

    public void setMinAmount(int minAmount) {
        this.minAmount = minAmount;
    }

    public int maxAmount() {
        return maxAmount;
    }

    public void setMaxAmount(int maxAmount) {
        this.maxAmount = maxAmount;
    }

    public Rarity rarity() {
        return rarity;
    }

    public void setRarity(Rarity rarity) {
        this.rarity = rarity;
    }
}

```

## File: `src/main/java/com/example/rpg/model/LootTable.java`  
- Path: `src/main/java/com/example/rpg/model/LootTable.java`  
- Size: 661 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.ArrayList;
import java.util.List;

public class LootTable {
    private final String id;
    private String appliesTo;
    private List<LootEntry> entries = new ArrayList<>();

    public LootTable(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String appliesTo() {
        return appliesTo;
    }

    public void setAppliesTo(String appliesTo) {
        this.appliesTo = appliesTo;
    }

    public List<LootEntry> entries() {
        return entries;
    }

    public void setEntries(List<LootEntry> entries) {
        this.entries = entries;
    }
}

```

## File: `src/main/java/com/example/rpg/model/MobDefinition.java`  
- Path: `src/main/java/com/example/rpg/model/MobDefinition.java`  
- Size: 2382 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.ArrayList;
import java.util.List;

public class MobDefinition {
    private final String id;
    private String name;
    private String type;
    private double health;
    private double damage;
    private String mainHand;
    private String helmet;
    private List<String> skills = new ArrayList<>();
    private int skillIntervalSeconds;
    private int xp;
    private String lootTable;
    private String behaviorTree;
    private boolean boss;

    public MobDefinition(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String type() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public double health() {
        return health;
    }

    public void setHealth(double health) {
        this.health = health;
    }

    public double damage() {
        return damage;
    }

    public void setDamage(double damage) {
        this.damage = damage;
    }

    public String mainHand() {
        return mainHand;
    }

    public void setMainHand(String mainHand) {
        this.mainHand = mainHand;
    }

    public String helmet() {
        return helmet;
    }

    public void setHelmet(String helmet) {
        this.helmet = helmet;
    }

    public List<String> skills() {
        return skills;
    }

    public void setSkills(List<String> skills) {
        this.skills = skills;
    }

    public int skillIntervalSeconds() {
        return skillIntervalSeconds;
    }

    public void setSkillIntervalSeconds(int skillIntervalSeconds) {
        this.skillIntervalSeconds = skillIntervalSeconds;
    }

    public int xp() {
        return xp;
    }

    public void setXp(int xp) {
        this.xp = xp;
    }

    public String lootTable() {
        return lootTable;
    }

    public void setLootTable(String lootTable) {
        this.lootTable = lootTable;
    }

    public String behaviorTree() {
        return behaviorTree;
    }

    public void setBehaviorTree(String behaviorTree) {
        this.behaviorTree = behaviorTree;
    }

    public boolean boss() {
        return boss;
    }

    public void setBoss(boolean boss) {
        this.boss = boss;
    }
}

```

## File: `src/main/java/com/example/rpg/model/Npc.java`  
- Path: `src/main/java/com/example/rpg/model/Npc.java`  
- Size: 3098 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.bukkit.Location;

public class Npc {
    private final String id;
    private UUID uuid;
    private String name;
    private NpcRole role;
    private String world;
    private double x;
    private double y;
    private double z;
    private float yaw;
    private float pitch;
    private List<String> dialog = new ArrayList<>();
    private String questLink;
    private String shopId;
    private String factionId;
    private String requiredRankId;
    private final java.util.Map<String, DialogueNode> dialogueNodes = new java.util.HashMap<>();

    public Npc(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public UUID uuid() {
        return uuid;
    }

    public void setUuid(UUID uuid) {
        this.uuid = uuid;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public NpcRole role() {
        return role;
    }

    public void setRole(NpcRole role) {
        this.role = role;
    }

    public String world() {
        return world;
    }

    public void setWorld(String world) {
        this.world = world;
    }

    public void setLocation(Location location) {
        this.world = location.getWorld().getName();
        this.x = location.getX();
        this.y = location.getY();
        this.z = location.getZ();
        this.yaw = location.getYaw();
        this.pitch = location.getPitch();
    }

    public void setRawLocation(String world, double x, double y, double z, float yaw, float pitch) {
        this.world = world;
        this.x = x;
        this.y = y;
        this.z = z;
        this.yaw = yaw;
        this.pitch = pitch;
    }

    public Location toLocation(org.bukkit.World world) {
        return new Location(world, x, y, z, yaw, pitch);
    }

    public double x() {
        return x;
    }

    public double y() {
        return y;
    }

    public double z() {
        return z;
    }

    public float yaw() {
        return yaw;
    }

    public float pitch() {
        return pitch;
    }

    public List<String> dialog() {
        return dialog;
    }

    public void setDialog(List<String> dialog) {
        this.dialog = dialog;
    }

    public String questLink() {
        return questLink;
    }

    public void setQuestLink(String questLink) {
        this.questLink = questLink;
    }

    public String shopId() {
        return shopId;
    }

    public void setShopId(String shopId) {
        this.shopId = shopId;
    }

    public String factionId() {
        return factionId;
    }

    public void setFactionId(String factionId) {
        this.factionId = factionId;
    }

    public String requiredRankId() {
        return requiredRankId;
    }

    public void setRequiredRankId(String requiredRankId) {
        this.requiredRankId = requiredRankId;
    }

    public java.util.Map<String, DialogueNode> dialogueNodes() {
        return dialogueNodes;
    }
}

```

## File: `src/main/java/com/example/rpg/model/NpcRole.java`  
- Path: `src/main/java/com/example/rpg/model/NpcRole.java`  
- Size: 218 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public enum NpcRole {
    QUESTGIVER,
    VENDOR,
    WEAPON_VENDOR,
    ARMOR_VENDOR,
    ITEM_VENDOR,
    RESOURCE_VENDOR,
    TRAINER,
    TELEPORTER,
    BANKER,
    FACTION_AGENT
}

```

## File: `src/main/java/com/example/rpg/model/Party.java`  
- Path: `src/main/java/com/example/rpg/model/Party.java`  
- Size: 584 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

public class Party {
    private final UUID leader;
    private final Set<UUID> members = new HashSet<>();

    public Party(UUID leader) {
        this.leader = leader;
        members.add(leader);
    }

    public UUID leader() {
        return leader;
    }

    public Set<UUID> members() {
        return members;
    }

    public void addMember(UUID uuid) {
        members.add(uuid);
    }

    public void removeMember(UUID uuid) {
        members.remove(uuid);
    }
}

```

## File: `src/main/java/com/example/rpg/model/PlayerProfile.java`  
- Path: `src/main/java/com/example/rpg/model/PlayerProfile.java`  
- Size: 7426 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import org.bukkit.attribute.Attribute;
import org.bukkit.entity.Player;

public class PlayerProfile {
    private final UUID uuid;
    private int level = 1;
    private int xp = 0;
    private int skillPoints = 0;
    private int mana = 100;
    private int maxMana = 100;
    private String classId;
    private final Map<RPGStat, Integer> stats = new EnumMap<>(RPGStat.class);
    private final Map<String, Integer> learnedSkills = new HashMap<>();
    private final Map<String, QuestProgress> activeQuests = new HashMap<>();
    private final Set<String> completedQuests = new HashSet<>();
    private final Map<String, Integer> factionRep = new HashMap<>();
    /**
     * Skill-Cooldowns persistent: skillId -> lastUseMillis
     */
    private final Map<String, Long> skillCooldowns = new HashMap<>();
    private final Map<Integer, String> skillBindings = new HashMap<>();
    private int gold = 0;
    private final Map<String, Integer> professions = new HashMap<>();
    private String guildId;
    private int elo = 1000;
    private String dungeonRole = "DPS";
    private String homeWorld;
    private double homeX;
    private double homeY;
    private double homeZ;
    private final Map<String, Integer> housingUpgrades = new HashMap<>();
    private String lastSkillId;
    private long lastSkillTime;
    private final Set<String> cosmetics = new HashSet<>();
    private String title;

    public PlayerProfile(UUID uuid) {
        this.uuid = uuid;
        for (RPGStat stat : RPGStat.values()) {
            stats.put(stat, 5);
        }
    }

    public UUID uuid() {
        return uuid;
    }

    public int level() {
        return level;
    }

    public void setLevel(int level) {
        this.level = level;
    }

    public int xp() {
        return xp;
    }

    public void setXp(int xp) {
        this.xp = xp;
    }

    public int skillPoints() {
        return skillPoints;
    }

    public void setSkillPoints(int skillPoints) {
        this.skillPoints = skillPoints;
    }

    public int mana() {
        return mana;
    }

    public void setMana(int mana) {
        this.mana = mana;
    }

    public int maxMana() {
        return maxMana;
    }

    public void setMaxMana(int maxMana) {
        this.maxMana = maxMana;
    }

    public String classId() {
        return classId;
    }

    public void setClassId(String classId) {
        this.classId = classId;
    }

    public Map<RPGStat, Integer> stats() {
        return stats;
    }

    public Map<String, Integer> learnedSkills() {
        return learnedSkills;
    }

    public Map<String, QuestProgress> activeQuests() {
        return activeQuests;
    }

    public Set<String> completedQuests() {
        return completedQuests;
    }

    public Map<String, Integer> factionRep() {
        return factionRep;
    }

    public Map<String, Long> skillCooldowns() {
        return skillCooldowns;
    }

    public Map<Integer, String> skillBindings() {
        return skillBindings;
    }

    public int gold() {
        return gold;
    }

    public void setGold(int gold) {
        this.gold = Math.max(0, gold);
    }

    public Map<String, Integer> professions() {
        return professions;
    }

    public String guildId() {
        return guildId;
    }

    public void setGuildId(String guildId) {
        this.guildId = guildId;
    }

    public int elo() {
        return elo;
    }

    public void setElo(int elo) {
        this.elo = Math.max(0, elo);
    }

    public String dungeonRole() {
        return dungeonRole;
    }

    public void setDungeonRole(String dungeonRole) {
        this.dungeonRole = dungeonRole;
    }

    public String homeWorld() {
        return homeWorld;
    }

    public void setHome(String world, double x, double y, double z) {
        this.homeWorld = world;
        this.homeX = x;
        this.homeY = y;
        this.homeZ = z;
    }

    public double homeX() {
        return homeX;
    }

    public double homeY() {
        return homeY;
    }

    public double homeZ() {
        return homeZ;
    }

    public Map<String, Integer> housingUpgrades() {
        return housingUpgrades;
    }

    public String lastSkillId() {
        return lastSkillId;
    }

    public void setLastSkill(String skillId, long time) {
        this.lastSkillId = skillId;
        this.lastSkillTime = time;
    }

    public long lastSkillTime() {
        return lastSkillTime;
    }

    public Set<String> cosmetics() {
        return cosmetics;
    }

    public String title() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void addXp(int amount) {
        xp += amount;
        while (xp >= xpNeeded()) {
            xp -= xpNeeded();
            level++;
            skillPoints += 2;
        }
    }

    public int xpNeeded() {
        return 100 + (level - 1) * 50;
    }

    public void applyAttributes(Player player, com.example.rpg.manager.ItemStatManager itemStatManager,
                                com.example.rpg.manager.ClassManager classManager) {
        Map<RPGStat, Integer> totalStats = totalStats(player, itemStatManager, classManager);
        int strength = totalStats.getOrDefault(RPGStat.STRENGTH, 5);
        int dex = totalStats.getOrDefault(RPGStat.DEXTERITY, 5);
        int con = totalStats.getOrDefault(RPGStat.CONSTITUTION, 5);
        int intel = totalStats.getOrDefault(RPGStat.INTELLIGENCE, 5);

        if (player.getAttribute(Attribute.GENERIC_ATTACK_DAMAGE) != null) {
            player.getAttribute(Attribute.GENERIC_ATTACK_DAMAGE).setBaseValue(1.0 + strength * 0.2);
        }
        if (player.getAttribute(Attribute.GENERIC_MAX_HEALTH) != null) {
            player.getAttribute(Attribute.GENERIC_MAX_HEALTH).setBaseValue(20.0 + con * 0.8);
        }
        if (player.getAttribute(Attribute.GENERIC_ATTACK_SPEED) != null) {
            player.getAttribute(Attribute.GENERIC_ATTACK_SPEED).setBaseValue(4.0 + dex * 0.05);
        }
        if (player.getAttribute(Attribute.GENERIC_MOVEMENT_SPEED) != null) {
            player.getAttribute(Attribute.GENERIC_MOVEMENT_SPEED).setBaseValue(0.1 + dex * 0.002);
        }
        maxMana = 100 + intel * 5;
        mana = Math.min(mana, maxMana);
    }

    public Map<RPGStat, Integer> totalStats(Player player, com.example.rpg.manager.ItemStatManager itemStatManager,
                                            com.example.rpg.manager.ClassManager classManager) {
        Map<RPGStat, Integer> totals = new java.util.EnumMap<>(RPGStat.class);
        for (RPGStat stat : RPGStat.values()) {
            totals.put(stat, stats.getOrDefault(stat, 5));
        }
        Map<RPGStat, Integer> gear = itemStatManager.collectStatBonuses(player);
        for (Map.Entry<RPGStat, Integer> entry : gear.entrySet()) {
            totals.put(entry.getKey(), totals.getOrDefault(entry.getKey(), 0) + entry.getValue());
        }
        Map<RPGStat, Integer> classBonus = classManager.classBonuses(classId);
        for (Map.Entry<RPGStat, Integer> entry : classBonus.entrySet()) {
            totals.put(entry.getKey(), totals.getOrDefault(entry.getKey(), 0) + entry.getValue());
        }
        return totals;
    }
}

```

## File: `src/main/java/com/example/rpg/model/Profession.java`  
- Path: `src/main/java/com/example/rpg/model/Profession.java`  
- Size: 87 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public enum Profession {
    GATHERING,
    CRAFTING
}

```

## File: `src/main/java/com/example/rpg/model/PvpSeason.java`  
- Path: `src/main/java/com/example/rpg/model/PvpSeason.java`  
- Size: 703 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.time.Instant;

public class PvpSeason {
    private final String id;
    private String name;
    private long endTimestamp;

    public PvpSeason(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public long endTimestamp() {
        return endTimestamp;
    }

    public void setEndTimestamp(long endTimestamp) {
        this.endTimestamp = endTimestamp;
    }

    public boolean isActive() {
        return endTimestamp == 0 || Instant.now().toEpochMilli() < endTimestamp;
    }
}

```

## File: `src/main/java/com/example/rpg/model/Quest.java`  
- Path: `src/main/java/com/example/rpg/model/Quest.java`  
- Size: 1589 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.ArrayList;
import java.util.List;

public class Quest {
    private final String id;
    private String name;
    private String description;
    private boolean repeatable;
    private int minLevel;
    private String requiredEvent;
    private List<QuestStep> steps = new ArrayList<>();
    private QuestReward reward = new QuestReward();

    public Quest(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String description() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public boolean repeatable() {
        return repeatable;
    }

    public void setRepeatable(boolean repeatable) {
        this.repeatable = repeatable;
    }

    public int minLevel() {
        return minLevel;
    }

    public void setMinLevel(int minLevel) {
        this.minLevel = minLevel;
    }

    public String requiredEvent() {
        return requiredEvent;
    }

    public void setRequiredEvent(String requiredEvent) {
        this.requiredEvent = requiredEvent;
    }

    public List<QuestStep> steps() {
        return steps;
    }

    public void setSteps(List<QuestStep> steps) {
        this.steps = steps;
    }

    public QuestReward reward() {
        return reward;
    }

    public void setReward(QuestReward reward) {
        this.reward = reward;
    }
}

```

## File: `src/main/java/com/example/rpg/model/QuestProgress.java`  
- Path: `src/main/java/com/example/rpg/model/QuestProgress.java`  
- Size: 1355 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.HashMap;
import java.util.Map;

public class QuestProgress {
    private final String questId;
    private final Map<Integer, Integer> stepProgress = new HashMap<>();
    private boolean completed;

    public QuestProgress(String questId) {
        this.questId = questId;
    }

    public String questId() {
        return questId;
    }

    public Map<Integer, Integer> stepProgress() {
        return stepProgress;
    }

    public void incrementStep(int index, int amount) {
        stepProgress.put(index, stepProgress.getOrDefault(index, 0) + amount);
    }

    /**
     * Erhht den Fortschritt, aber nie ber "required" hinaus.
     * Damit bleibt Progress stabil, und Auswertungen werden deterministisch.
     */
    public void incrementStepClamped(int index, int amount, int required) {
        int current = stepProgress.getOrDefault(index, 0);
        int next = current + Math.max(0, amount);
        if (required > 0) {
            next = Math.min(required, next);
        }
        stepProgress.put(index, next);
    }

    public int getStepProgress(int index) {
        return stepProgress.getOrDefault(index, 0);
    }

    public boolean completed() {
        return completed;
    }

    public void setCompleted(boolean completed) {
        this.completed = completed;
    }
}

```

## File: `src/main/java/com/example/rpg/model/QuestReward.java`  
- Path: `src/main/java/com/example/rpg/model/QuestReward.java`  
- Size: 685 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.HashMap;
import java.util.Map;

public class QuestReward {
    private int xp;
    private int skillPoints;
    private Map<String, Integer> factionRep = new HashMap<>();

    public int xp() {
        return xp;
    }

    public void setXp(int xp) {
        this.xp = xp;
    }

    public int skillPoints() {
        return skillPoints;
    }

    public void setSkillPoints(int skillPoints) {
        this.skillPoints = skillPoints;
    }

    public Map<String, Integer> factionRep() {
        return factionRep;
    }

    public void setFactionRep(Map<String, Integer> factionRep) {
        this.factionRep = factionRep;
    }
}

```

## File: `src/main/java/com/example/rpg/model/QuestStep.java`  
- Path: `src/main/java/com/example/rpg/model/QuestStep.java`  
- Size: 718 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public class QuestStep {
    private QuestStepType type;
    private String target;
    private int amount;

    public QuestStep(QuestStepType type, String target, int amount) {
        this.type = type;
        this.target = target;
        this.amount = amount;
    }

    public QuestStepType type() {
        return type;
    }

    public void setType(QuestStepType type) {
        this.type = type;
    }

    public String target() {
        return target;
    }

    public void setTarget(String target) {
        this.target = target;
    }

    public int amount() {
        return amount;
    }

    public void setAmount(int amount) {
        this.amount = amount;
    }
}

```

## File: `src/main/java/com/example/rpg/model/QuestStepType.java`  
- Path: `src/main/java/com/example/rpg/model/QuestStepType.java`  
- Size: 156 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public enum QuestStepType {
    KILL,
    COLLECT,
    TALK,
    EXPLORE,
    CRAFT,
    USE_ITEM,
    DEFEND,
    ESCORT
}

```

## File: `src/main/java/com/example/rpg/model/Rarity.java`  
- Path: `src/main/java/com/example/rpg/model/Rarity.java`  
- Size: 627 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import net.kyori.adventure.text.format.NamedTextColor;

public enum Rarity {
    COMMON(NamedTextColor.WHITE, 1.0),
    UNCOMMON(NamedTextColor.GREEN, 0.6),
    RARE(NamedTextColor.BLUE, 0.35),
    EPIC(NamedTextColor.DARK_PURPLE, 0.15),
    LEGENDARY(NamedTextColor.GOLD, 0.05);

    private final NamedTextColor color;
    private final double weight;

    Rarity(NamedTextColor color, double weight) {
        this.color = color;
        this.weight = weight;
    }

    public NamedTextColor color() {
        return color;
    }

    public double weight() {
        return weight;
    }
}

```

## File: `src/main/java/com/example/rpg/model/ResourceNode.java`  
- Path: `src/main/java/com/example/rpg/model/ResourceNode.java`  
- Size: 1672 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public class ResourceNode {
    private final String id;
    private String world;
    private int x;
    private int y;
    private int z;
    private String material;
    private String profession;
    private int respawnSeconds;
    private int xp;
    private long nextAvailableAt;

    public ResourceNode(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String world() {
        return world;
    }

    public void setWorld(String world) {
        this.world = world;
    }

    public int x() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int y() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public int z() {
        return z;
    }

    public void setZ(int z) {
        this.z = z;
    }

    public String material() {
        return material;
    }

    public void setMaterial(String material) {
        this.material = material;
    }

    public String profession() {
        return profession;
    }

    public void setProfession(String profession) {
        this.profession = profession;
    }

    public int respawnSeconds() {
        return respawnSeconds;
    }

    public void setRespawnSeconds(int respawnSeconds) {
        this.respawnSeconds = respawnSeconds;
    }

    public int xp() {
        return xp;
    }

    public void setXp(int xp) {
        this.xp = xp;
    }

    public long nextAvailableAt() {
        return nextAvailableAt;
    }

    public void setNextAvailableAt(long nextAvailableAt) {
        this.nextAvailableAt = nextAvailableAt;
    }
}

```

## File: `src/main/java/com/example/rpg/model/RPGStat.java`  
- Path: `src/main/java/com/example/rpg/model/RPGStat.java`  
- Size: 130 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public enum RPGStat {
    STRENGTH,
    DEXTERITY,
    CONSTITUTION,
    INTELLIGENCE,
    LUCK
}

```

## File: `src/main/java/com/example/rpg/model/ShopDefinition.java`  
- Path: `src/main/java/com/example/rpg/model/ShopDefinition.java`  
- Size: 645 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.HashMap;
import java.util.Map;

public class ShopDefinition {
    private final String id;
    private String title;
    private Map<Integer, ShopItem> items = new HashMap<>();

    public ShopDefinition(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String title() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Map<Integer, ShopItem> items() {
        return items;
    }

    public void setItems(Map<Integer, ShopItem> items) {
        this.items = items;
    }
}

```

## File: `src/main/java/com/example/rpg/model/ShopItem.java`  
- Path: `src/main/java/com/example/rpg/model/ShopItem.java`  
- Size: 1395 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public class ShopItem {
    private int slot;
    private String material;
    private String name;
    private int buyPrice;
    private int sellPrice;
    private boolean rpgItem;
    private String rarity;
    private int minLevel;

    public int slot() {
        return slot;
    }

    public void setSlot(int slot) {
        this.slot = slot;
    }

    public String material() {
        return material;
    }

    public void setMaterial(String material) {
        this.material = material;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int buyPrice() {
        return buyPrice;
    }

    public void setBuyPrice(int buyPrice) {
        this.buyPrice = buyPrice;
    }

    public int sellPrice() {
        return sellPrice;
    }

    public void setSellPrice(int sellPrice) {
        this.sellPrice = sellPrice;
    }

    public boolean rpgItem() {
        return rpgItem;
    }

    public void setRpgItem(boolean rpgItem) {
        this.rpgItem = rpgItem;
    }

    public String rarity() {
        return rarity;
    }

    public void setRarity(String rarity) {
        this.rarity = rarity;
    }

    public int minLevel() {
        return minLevel;
    }

    public void setMinLevel(int minLevel) {
        this.minLevel = minLevel;
    }
}

```

## File: `src/main/java/com/example/rpg/model/Skill.java`  
- Path: `src/main/java/com/example/rpg/model/Skill.java`  
- Size: 1615 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public class Skill {
    private final String id;
    private String name;
    private SkillType type;
    private SkillCategory category;
    private int cooldown;
    private int manaCost;
    private String requiredSkill;
    private java.util.List<com.example.rpg.skill.SkillEffectConfig> effects = new java.util.ArrayList<>();

    public Skill(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public SkillType type() {
        return type;
    }

    public void setType(SkillType type) {
        this.type = type;
    }

    public SkillCategory category() {
        return category;
    }

    public void setCategory(SkillCategory category) {
        this.category = category;
    }

    public int cooldown() {
        return cooldown;
    }

    public void setCooldown(int cooldown) {
        this.cooldown = cooldown;
    }

    public int manaCost() {
        return manaCost;
    }

    public void setManaCost(int manaCost) {
        this.manaCost = manaCost;
    }

    public java.util.List<com.example.rpg.skill.SkillEffectConfig> effects() {
        return effects;
    }

    public void setEffects(java.util.List<com.example.rpg.skill.SkillEffectConfig> effects) {
        this.effects = effects;
    }

    public String requiredSkill() {
        return requiredSkill;
    }

    public void setRequiredSkill(String requiredSkill) {
        this.requiredSkill = requiredSkill;
    }
}

```

## File: `src/main/java/com/example/rpg/model/SkillCategory.java`  
- Path: `src/main/java/com/example/rpg/model/SkillCategory.java`  
- Size: 126 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public enum SkillCategory {
    HEALING,
    MAGIC,
    ATTACK,
    DEFENSE,
    PROFESSION
}

```

## File: `src/main/java/com/example/rpg/model/SkillSynergy.java`  
- Path: `src/main/java/com/example/rpg/model/SkillSynergy.java`  
- Size: 1192 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import com.example.rpg.skill.SkillEffectConfig;
import java.util.ArrayList;
import java.util.List;

public class SkillSynergy {
    private final String id;
    private List<String> skills = new ArrayList<>();
    private String scope;
    private double radius;
    private int windowSeconds;
    private final List<SkillEffectConfig> effects = new ArrayList<>();

    public SkillSynergy(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public List<String> skills() {
        return skills;
    }

    public void setSkills(List<String> skills) {
        this.skills = skills;
    }

    public String scope() {
        return scope;
    }

    public void setScope(String scope) {
        this.scope = scope;
    }

    public double radius() {
        return radius;
    }

    public void setRadius(double radius) {
        this.radius = radius;
    }

    public int windowSeconds() {
        return windowSeconds;
    }

    public void setWindowSeconds(int windowSeconds) {
        this.windowSeconds = windowSeconds;
    }

    public List<SkillEffectConfig> effects() {
        return effects;
    }
}

```

## File: `src/main/java/com/example/rpg/model/SkillType.java`  
- Path: `src/main/java/com/example/rpg/model/SkillType.java`  
- Size: 82 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

public enum SkillType {
    ACTIVE,
    PASSIVE
}

```

## File: `src/main/java/com/example/rpg/model/Spawner.java`  
- Path: `src/main/java/com/example/rpg/model/Spawner.java`  
- Size: 992 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.HashMap;
import java.util.Map;

public class Spawner {
    private final String id;
    private String zoneId;
    private int maxMobs;
    private int spawnInterval;
    private Map<String, Double> mobs = new HashMap<>();

    public Spawner(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String zoneId() {
        return zoneId;
    }

    public void setZoneId(String zoneId) {
        this.zoneId = zoneId;
    }

    public int maxMobs() {
        return maxMobs;
    }

    public void setMaxMobs(int maxMobs) {
        this.maxMobs = maxMobs;
    }

    public int spawnInterval() {
        return spawnInterval;
    }

    public void setSpawnInterval(int spawnInterval) {
        this.spawnInterval = spawnInterval;
    }

    public Map<String, Double> mobs() {
        return mobs;
    }

    public void setMobs(Map<String, Double> mobs) {
        this.mobs = mobs;
    }
}

```

## File: `src/main/java/com/example/rpg/model/TradeRequest.java`  
- Path: `src/main/java/com/example/rpg/model/TradeRequest.java`  
- Size: 1198 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.UUID;

public class TradeRequest {
    private final UUID requester;
    private final UUID target;
    private int goldOffer;
    private int goldRequest;
    private boolean requesterReady;
    private boolean targetReady;

    public TradeRequest(UUID requester, UUID target) {
        this.requester = requester;
        this.target = target;
    }

    public UUID requester() {
        return requester;
    }

    public UUID target() {
        return target;
    }

    public int goldOffer() {
        return goldOffer;
    }

    public void setGoldOffer(int goldOffer) {
        this.goldOffer = goldOffer;
    }

    public int goldRequest() {
        return goldRequest;
    }

    public void setGoldRequest(int goldRequest) {
        this.goldRequest = goldRequest;
    }

    public boolean requesterReady() {
        return requesterReady;
    }

    public void setRequesterReady(boolean requesterReady) {
        this.requesterReady = requesterReady;
    }

    public boolean targetReady() {
        return targetReady;
    }

    public void setTargetReady(boolean targetReady) {
        this.targetReady = targetReady;
    }
}

```

## File: `src/main/java/com/example/rpg/model/WorldEvent.java`  
- Path: `src/main/java/com/example/rpg/model/WorldEvent.java`  
- Size: 1935 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

public class WorldEvent {
    private final String id;
    private String name;
    private String zoneId;
    private boolean active;
    private final List<QuestStep> steps = new ArrayList<>();
    private final Map<Integer, Integer> progress = new HashMap<>();
    private int rewardXp;
    private int rewardGold;
    private final Map<String, Integer> rewardFactionRep = new HashMap<>();
    private final List<String> unlockQuests = new ArrayList<>();
    private final Set<UUID> participants = new HashSet<>();

    public WorldEvent(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String zoneId() {
        return zoneId;
    }

    public void setZoneId(String zoneId) {
        this.zoneId = zoneId;
    }

    public boolean active() {
        return active;
    }

    public void setActive(boolean active) {
        this.active = active;
    }

    public List<QuestStep> steps() {
        return steps;
    }

    public Map<Integer, Integer> progress() {
        return progress;
    }

    public int rewardXp() {
        return rewardXp;
    }

    public void setRewardXp(int rewardXp) {
        this.rewardXp = rewardXp;
    }

    public int rewardGold() {
        return rewardGold;
    }

    public void setRewardGold(int rewardGold) {
        this.rewardGold = rewardGold;
    }

    public Map<String, Integer> rewardFactionRep() {
        return rewardFactionRep;
    }

    public List<String> unlockQuests() {
        return unlockQuests;
    }

    public Set<UUID> participants() {
        return participants;
    }
}

```

## File: `src/main/java/com/example/rpg/model/Zone.java`  
- Path: `src/main/java/com/example/rpg/model/Zone.java`  
- Size: 2786 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.model;

import org.bukkit.Location;

public class Zone {
    private final String id;
    private String name;
    private String world;
    private int minLevel;
    private int maxLevel;
    private double slowMultiplier = 1.0;
    private double damageMultiplier = 1.0;
    private int x1;
    private int y1;
    private int z1;
    private int x2;
    private int y2;
    private int z2;

    public Zone(String id) {
        this.id = id;
    }

    public String id() {
        return id;
    }

    public String name() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String world() {
        return world;
    }

    public void setWorld(String world) {
        this.world = world;
    }

    public int minLevel() {
        return minLevel;
    }

    public void setMinLevel(int minLevel) {
        this.minLevel = minLevel;
    }

    public int maxLevel() {
        return maxLevel;
    }

    public void setMaxLevel(int maxLevel) {
        this.maxLevel = maxLevel;
    }

    public double slowMultiplier() {
        return slowMultiplier;
    }

    public void setSlowMultiplier(double slowMultiplier) {
        this.slowMultiplier = slowMultiplier;
    }

    public double damageMultiplier() {
        return damageMultiplier;
    }

    public void setDamageMultiplier(double damageMultiplier) {
        this.damageMultiplier = damageMultiplier;
    }

    public void setBounds(Location pos1, Location pos2) {
        this.x1 = Math.min(pos1.getBlockX(), pos2.getBlockX());
        this.y1 = Math.min(pos1.getBlockY(), pos2.getBlockY());
        this.z1 = Math.min(pos1.getBlockZ(), pos2.getBlockZ());
        this.x2 = Math.max(pos1.getBlockX(), pos2.getBlockX());
        this.y2 = Math.max(pos1.getBlockY(), pos2.getBlockY());
        this.z2 = Math.max(pos1.getBlockZ(), pos2.getBlockZ());
    }

    public boolean contains(Location location) {
        if (location == null || !location.getWorld().getName().equals(world)) {
            return false;
        }
        int x = location.getBlockX();
        int y = location.getBlockY();
        int z = location.getBlockZ();
        return x >= x1 && x <= x2 && y >= y1 && y <= y2 && z >= z1 && z <= z2;
    }

    public int x1() {
        return x1;
    }

    public int y1() {
        return y1;
    }

    public int z1() {
        return z1;
    }

    public int x2() {
        return x2;
    }

    public int y2() {
        return y2;
    }

    public int z2() {
        return z2;
    }

    public void setCoordinates(int x1, int y1, int z1, int x2, int y2, int z2) {
        this.x1 = x1;
        this.y1 = y1;
        this.z1 = z1;
        this.x2 = x2;
        this.y2 = y2;
        this.z2 = z2;
    }
}

```

## File: `src/main/java/com/example/rpg/permissions/PermissionAuditLog.java`  
- Path: `src/main/java/com/example/rpg/permissions/PermissionAuditLog.java`  
- Size: 2406 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.permissions;

import com.example.rpg.db.DatabaseService;
import com.google.gson.Gson;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class PermissionAuditLog {
    private final DatabaseService database;
    private final Gson gson = new Gson();

    public PermissionAuditLog(DatabaseService database) {
        this.database = database;
    }

    public void log(UUID actorUuid, String actorName, String action, String target, Object before, Object after) {
        String sql = "INSERT INTO rpg_audit_log (actor_uuid, actor_name, action, target, before, after) VALUES (?, ?, ?, ?, ?::jsonb, ?::jsonb)";
        try (Connection connection = database.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setObject(1, actorUuid);
            stmt.setString(2, actorName);
            stmt.setString(3, action);
            stmt.setString(4, target);
            stmt.setString(5, before != null ? gson.toJson(before) : null);
            stmt.setString(6, after != null ? gson.toJson(after) : null);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new IllegalStateException("Failed to write audit log: " + e.getMessage(), e);
        }
    }

    public List<String> recent(int limit) {
        String sql = "SELECT ts, actor_name, action, target FROM rpg_audit_log ORDER BY ts DESC LIMIT ?";
        List<String> entries = new ArrayList<>();
        try (Connection connection = database.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setInt(1, limit);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    String ts = rs.getString("ts");
                    String actor = rs.getString("actor_name");
                    String action = rs.getString("action");
                    String target = rs.getString("target");
                    entries.add(ts + " | " + actor + " | " + action + " | " + target);
                }
            }
        } catch (SQLException e) {
            throw new IllegalStateException("Failed to read audit log: " + e.getMessage(), e);
        }
        return entries;
    }
}

```

## File: `src/main/java/com/example/rpg/permissions/PermissionDecision.java`  
- Path: `src/main/java/com/example/rpg/permissions/PermissionDecision.java`  
- Size: 106 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.permissions;

public enum PermissionDecision {
    ALLOW,
    DENY,
    INHERIT
}

```

## File: `src/main/java/com/example/rpg/permissions/PermissionExplanation.java`  
- Path: `src/main/java/com/example/rpg/permissions/PermissionExplanation.java`  
- Size: 1096 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.permissions;

import java.util.ArrayList;
import java.util.List;

public class PermissionExplanation {
    private final boolean allowed;
    private final String winningRole;
    private final String winningNode;
    private final PermissionDecision winningDecision;
    private final List<String> trace;

    public PermissionExplanation(boolean allowed, String winningRole, String winningNode, PermissionDecision winningDecision,
                                 List<String> trace) {
        this.allowed = allowed;
        this.winningRole = winningRole;
        this.winningNode = winningNode;
        this.winningDecision = winningDecision;
        this.trace = trace != null ? trace : new ArrayList<>();
    }

    public boolean allowed() {
        return allowed;
    }

    public String winningRole() {
        return winningRole;
    }

    public String winningNode() {
        return winningNode;
    }

    public PermissionDecision winningDecision() {
        return winningDecision;
    }

    public List<String> trace() {
        return trace;
    }
}

```

## File: `src/main/java/com/example/rpg/permissions/PermissionListener.java`  
- Path: `src/main/java/com/example/rpg/permissions/PermissionListener.java`  
- Size: 724 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.permissions;

import com.example.rpg.RPGPlugin;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerQuitEvent;

public class PermissionListener implements Listener {
    private final RPGPlugin plugin;

    public PermissionListener(RPGPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onJoin(PlayerJoinEvent event) {
        plugin.permissionService().applyAttachments(event.getPlayer());
    }

    @EventHandler
    public void onQuit(PlayerQuitEvent event) {
        plugin.permissionService().removeAttachment(event.getPlayer().getUniqueId());
    }
}

```

## File: `src/main/java/com/example/rpg/permissions/PermissionRepository.java`  
- Path: `src/main/java/com/example/rpg/permissions/PermissionRepository.java`  
- Size: 402 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.permissions;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

public interface PermissionRepository {
    List<Role> loadAllRoles();
    void saveRole(Role role);
    void deleteRole(String roleKey);
    Optional<PlayerRoles> loadPlayerRoles(UUID playerId);
    void savePlayerRoles(PlayerRoles playerRoles);
    List<PlayerRoles> listPlayerRoles();
}

```

## File: `src/main/java/com/example/rpg/permissions/PermissionResolver.java`  
- Path: `src/main/java/com/example/rpg/permissions/PermissionResolver.java`  
- Size: 4200 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.permissions;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

public class PermissionResolver {
    private final Map<String, Role> roles;
    private final PermissionDecision defaultDecision;

    public PermissionResolver(Map<String, Role> roles, PermissionDecision defaultDecision) {
        this.roles = roles;
        this.defaultDecision = defaultDecision;
    }

    public PermissionExplanation explain(PlayerRoles playerRoles, String node) {
        List<String> trace = new ArrayList<>();
        if (playerRoles == null) {
            return finalizeDecision(defaultDecision, null, null, trace);
        }
        Set<String> roleKeys = collectRoleKeys(playerRoles);
        DecisionResult result = resolveForRoles(roleKeys, node, trace);
        return finalizeDecision(result.decision(), result.roleKey(), result.node(), trace);
    }

    public boolean resolve(PlayerRoles playerRoles, String node) {
        return explain(playerRoles, node).allowed();
    }

    private PermissionExplanation finalizeDecision(PermissionDecision decision, String roleKey, String node, List<String> trace) {
        boolean allowed = decision == PermissionDecision.ALLOW;
        return new PermissionExplanation(allowed, roleKey, node, decision, trace);
    }

    private Set<String> collectRoleKeys(PlayerRoles playerRoles) {
        Set<String> keys = new HashSet<>();
        if (playerRoles.primaryRole() != null) {
            keys.add(playerRoles.primaryRole());
        }
        keys.addAll(playerRoles.extraRoles());
        Set<String> resolved = new HashSet<>();
        Queue<String> queue = new ArrayDeque<>(keys);
        while (!queue.isEmpty()) {
            String key = queue.poll();
            if (!resolved.add(key)) {
                continue;
            }
            Role role = roles.get(key);
            if (role == null) {
                continue;
            }
            for (String parent : role.parents()) {
                if (!resolved.contains(parent)) {
                    queue.add(parent);
                }
            }
        }
        return resolved;
    }

    private DecisionResult resolveForRoles(Set<String> roleKeys, String node, List<String> trace) {
        PermissionDecision finalDecision = PermissionDecision.INHERIT;
        String winningRole = null;
        String winningNode = null;
        for (String roleKey : roleKeys) {
            Role role = roles.get(roleKey);
            if (role == null) {
                continue;
            }
            for (Map.Entry<String, PermissionDecision> entry : role.nodes().entrySet()) {
                String nodeKey = entry.getKey();
                PermissionDecision decision = entry.getValue();
                if (!matches(nodeKey, node)) {
                    continue;
                }
                trace.add(roleKey + " -> " + nodeKey + " = " + decision);
                if (decision == PermissionDecision.DENY) {
                    return new DecisionResult(PermissionDecision.DENY, roleKey, nodeKey);
                }
                if (decision == PermissionDecision.ALLOW && finalDecision != PermissionDecision.ALLOW) {
                    finalDecision = PermissionDecision.ALLOW;
                    winningRole = roleKey;
                    winningNode = nodeKey;
                }
            }
        }
        if (finalDecision == PermissionDecision.INHERIT) {
            finalDecision = defaultDecision;
        }
        return new DecisionResult(finalDecision, winningRole, winningNode);
    }

    private boolean matches(String rule, String node) {
        if (rule == null) {
            return false;
        }
        if (rule.equalsIgnoreCase(node)) {
            return true;
        }
        if (rule.endsWith(".*")) {
            String prefix = rule.substring(0, rule.length() - 2).toLowerCase();
            return node.toLowerCase().startsWith(prefix);
        }
        return false;
    }

    private record DecisionResult(PermissionDecision decision, String roleKey, String node) {
    }
}

```

## File: `src/main/java/com/example/rpg/permissions/PermissionService.java`  
- Path: `src/main/java/com/example/rpg/permissions/PermissionService.java`  
- Size: 12885 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.permissions;

import com.example.rpg.db.DatabaseService;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.permissions.PermissionAttachment;
import org.bukkit.plugin.java.JavaPlugin;

public class PermissionService {
    private final JavaPlugin plugin;
    private final PermissionRepository repository;
    private final PermissionAuditLog auditLog;
    private final Map<String, Role> roles = new ConcurrentHashMap<>();
    private final Map<UUID, PlayerRoles> playerRoles = new ConcurrentHashMap<>();
    private final Map<UUID, PermissionAttachment> attachments = new ConcurrentHashMap<>();
    private final Map<UUID, Map<String, CacheEntry>> resolvedCache = new ConcurrentHashMap<>();
    private final PermissionDecision defaultDecision;
    private final String defaultRole;
    private final boolean opBypass;
    private final boolean enabled;
    private final boolean auditEnabled;
    private final long cacheTtlMillis;

    public PermissionService(JavaPlugin plugin, DatabaseService database, boolean enabled, String defaultRole,
                             PermissionDecision defaultDecision, boolean opBypass, boolean auditEnabled, long cacheTtlSeconds) {
        this.plugin = plugin;
        this.repository = new PostgresPermissionRepository(database);
        this.auditLog = new PermissionAuditLog(database);
        this.enabled = enabled;
        this.defaultRole = defaultRole;
        this.defaultDecision = defaultDecision;
        this.opBypass = opBypass;
        this.auditEnabled = auditEnabled;
        this.cacheTtlMillis = Math.max(0, cacheTtlSeconds) * 1000L;
        reload();
    }

    public void reload() {
        roles.clear();
        for (Role role : repository.loadAllRoles()) {
            roles.put(role.key(), role);
        }
        if (roles.isEmpty()) {
            bootstrapDefaults();
        }
        resolvedCache.clear();
        playerRoles.clear();
    }

    public boolean has(Player player, String node) {
        if (player == null) {
            return false;
        }
        if (!enabled) {
            return player.hasPermission(node);
        }
        if (opBypass && player.isOp()) {
            return true;
        }
        return resolve(player.getUniqueId(), node);
    }

    public PermissionExplanation explain(Player player, String node) {
        PlayerRoles roles = getPlayerRoles(player.getUniqueId());
        PermissionResolver resolver = new PermissionResolver(roles(), defaultDecision);
        return resolver.explain(roles, node);
    }

    public void applyAttachments(Player player) {
        removeAttachment(player.getUniqueId());
        if (!enabled) {
            return;
        }
        PermissionAttachment attachment = player.addAttachment(plugin);
        PlayerRoles roles = getPlayerRoles(player.getUniqueId());
        if (roles != null) {
            PermissionResolver resolver = new PermissionResolver(roles(), defaultDecision);
            Map<String, PermissionDecision> decisions = collectDecisions(roles);
            for (Map.Entry<String, PermissionDecision> entry : decisions.entrySet()) {
                if (entry.getValue() == PermissionDecision.INHERIT) {
                    continue;
                }
                boolean allowed = resolver.resolve(roles, entry.getKey());
                attachment.setPermission(entry.getKey(), allowed);
            }
        }
        attachments.put(player.getUniqueId(), attachment);
    }

    public void removeAttachment(UUID playerId) {
        PermissionAttachment attachment = attachments.remove(playerId);
        if (attachment != null) {
            attachment.remove();
        }
    }

    public void createRole(Player actor, String key, String displayName) {
        Role role = new Role(key, displayName);
        roles.put(key, role);
        repository.saveRole(role);
        audit(actor, "role.create", key, null, role);
        invalidateAll();
    }

    public void renameRole(Player actor, String key, String displayName) {
        Role role = roles.get(key);
        if (role == null) {
            return;
        }
        Role before = cloneRole(role);
        role.setDisplayName(displayName);
        repository.saveRole(role);
        audit(actor, "role.rename", key, before, role);
        invalidateAll();
    }

    public void deleteRole(Player actor, String key) {
        Role before = roles.remove(key);
        repository.deleteRole(key);
        audit(actor, "role.delete", key, before, null);
        invalidateAll();
    }

    public void setRoleNode(Player actor, String roleKey, String node, PermissionDecision decision) {
        Role role = roles.get(roleKey);
        if (role == null) {
            return;
        }
        Role before = cloneRole(role);
        if (decision == PermissionDecision.INHERIT) {
            role.nodes().remove(node);
        } else {
            role.nodes().put(node, decision);
        }
        repository.saveRole(role);
        audit(actor, "role.node", roleKey + ":" + node, before, role);
        invalidateAll();
    }

    public boolean addParent(Player actor, String roleKey, String parentKey) {
        Role role = roles.get(roleKey);
        Role parent = roles.get(parentKey);
        if (role == null || parent == null) {
            return false;
        }
        if (createsCycle(roleKey, parentKey)) {
            return false;
        }
        Role before = cloneRole(role);
        role.parents().add(parentKey);
        repository.saveRole(role);
        audit(actor, "role.parent.add", roleKey + "<-" + parentKey, before, role);
        invalidateAll();
        return true;
    }

    public void removeParent(Player actor, String roleKey, String parentKey) {
        Role role = roles.get(roleKey);
        if (role == null) {
            return;
        }
        Role before = cloneRole(role);
        role.parents().remove(parentKey);
        repository.saveRole(role);
        audit(actor, "role.parent.remove", roleKey + "<-" + parentKey, before, role);
        invalidateAll();
    }

    public void assignPrimary(Player actor, UUID playerId, String roleKey) {
        PlayerRoles roles = getPlayerRoles(playerId);
        PlayerRoles before = clonePlayerRoles(roles);
        roles.setPrimaryRole(roleKey);
        repository.savePlayerRoles(roles);
        audit(actor, "player.primary", playerId.toString(), before, roles);
        invalidatePlayer(playerId);
    }

    public void addRole(Player actor, UUID playerId, String roleKey) {
        PlayerRoles roles = getPlayerRoles(playerId);
        PlayerRoles before = clonePlayerRoles(roles);
        roles.extraRoles().add(roleKey);
        repository.savePlayerRoles(roles);
        audit(actor, "player.role.add", playerId + ":" + roleKey, before, roles);
        invalidatePlayer(playerId);
    }

    public void removeRole(Player actor, UUID playerId, String roleKey) {
        PlayerRoles roles = getPlayerRoles(playerId);
        PlayerRoles before = clonePlayerRoles(roles);
        roles.extraRoles().remove(roleKey);
        if (roleKey.equals(roles.primaryRole())) {
            roles.setPrimaryRole(null);
        }
        repository.savePlayerRoles(roles);
        audit(actor, "player.role.remove", playerId + ":" + roleKey, before, roles);
        invalidatePlayer(playerId);
    }

    public Map<String, Role> roles() {
        return roles;
    }

    public PlayerRoles getPlayerRoles(UUID playerId) {
        return playerRoles.computeIfAbsent(playerId, uuid -> repository.loadPlayerRoles(uuid).orElseGet(() -> {
            PlayerRoles roles = new PlayerRoles(uuid);
            roles.setPrimaryRole(getDefaultRole());
            repository.savePlayerRoles(roles);
            return roles;
        }));
    }

    public List<PlayerRoles> listPlayerRoles() {
        return repository.listPlayerRoles();
    }

    public PermissionExplanation explain(UUID playerId, String node) {
        PlayerRoles roles = getPlayerRoles(playerId);
        PermissionResolver resolver = new PermissionResolver(roles(), defaultDecision);
        return resolver.explain(roles, node);
    }

    public PermissionAuditLog auditLog() {
        return auditLog;
    }

    private boolean resolve(UUID playerId, String node) {
        if (cacheTtlMillis <= 0) {
            PlayerRoles roles = getPlayerRoles(playerId);
            PermissionResolver resolver = new PermissionResolver(roles(), defaultDecision);
            return resolver.resolve(roles, node);
        }
        Map<String, CacheEntry> cache = resolvedCache.computeIfAbsent(playerId, key -> new ConcurrentHashMap<>());
        long now = System.currentTimeMillis();
        CacheEntry entry = cache.get(node);
        if (entry != null && entry.expiresAt() > now) {
            return entry.allowed();
        }
        PlayerRoles roles = getPlayerRoles(playerId);
        PermissionResolver resolver = new PermissionResolver(roles(), defaultDecision);
        boolean allowed = resolver.resolve(roles, node);
        cache.put(node, new CacheEntry(allowed, now + cacheTtlMillis));
        return allowed;
    }

    private void invalidateAll() {
        resolvedCache.clear();
        for (UUID uuid : attachments.keySet()) {
            Player player = Bukkit.getPlayer(uuid);
            if (player != null) {
                applyAttachments(player);
            }
        }
    }

    private void invalidatePlayer(UUID playerId) {
        resolvedCache.remove(playerId);
        Player player = Bukkit.getPlayer(playerId);
        if (player != null) {
            applyAttachments(player);
        }
    }

    private void audit(Player actor, String action, String target, Object before, Object after) {
        if (actor == null || !auditEnabled) {
            return;
        }
        auditLog.log(actor.getUniqueId(), actor.getName(), action, target, before, after);
    }

    private Map<String, PermissionDecision> collectDecisions(PlayerRoles roles) {
        Map<String, PermissionDecision> decisions = new HashMap<>();
        Set<String> visited = new HashSet<>();
        Deque<String> queue = new ArrayDeque<>();
        if (roles.primaryRole() != null) {
            queue.add(roles.primaryRole());
        }
        queue.addAll(roles.extraRoles());
        while (!queue.isEmpty()) {
            String key = queue.pop();
            if (!visited.add(key)) {
                continue;
            }
            Role role = this.roles.get(key);
            if (role == null) {
                continue;
            }
            decisions.putAll(role.nodes());
            queue.addAll(role.parents());
        }
        return decisions;
    }

    private boolean createsCycle(String roleKey, String parentKey) {
        Set<String> visited = new HashSet<>();
        Deque<String> stack = new ArrayDeque<>();
        stack.push(parentKey);
        while (!stack.isEmpty()) {
            String current = stack.pop();
            if (!visited.add(current)) {
                continue;
            }
            if (current.equals(roleKey)) {
                return true;
            }
            Role role = roles.get(current);
            if (role != null) {
                stack.addAll(role.parents());
            }
        }
        return false;
    }

    private Role cloneRole(Role role) {
        Role clone = new Role(role.key(), role.displayName());
        clone.parents().addAll(role.parents());
        clone.nodes().putAll(role.nodes());
        return clone;
    }

    private PlayerRoles clonePlayerRoles(PlayerRoles roles) {
        PlayerRoles clone = new PlayerRoles(roles.playerId());
        clone.setPrimaryRole(roles.primaryRole());
        clone.extraRoles().addAll(roles.extraRoles());
        return clone;
    }

    private String getDefaultRole() {
        if (defaultRole != null && roles.containsKey(defaultRole)) {
            return defaultRole;
        }
        return roles.containsKey("player") ? "player" : null;
    }

    private void bootstrapDefaults() {
        Role player = new Role("player", "Spieler");
        Role moderator = new Role("moderator", "Moderator");
        Role admin = new Role("admin", "Admin");
        admin.nodes().put("rpg.admin.*", PermissionDecision.ALLOW);
        roles.put(player.key(), player);
        roles.put(moderator.key(), moderator);
        roles.put(admin.key(), admin);
        repository.saveRole(player);
        repository.saveRole(moderator);
        repository.saveRole(admin);
    }

    private record CacheEntry(boolean allowed, long expiresAt) {
    }
}

```

## File: `src/main/java/com/example/rpg/permissions/PlayerRoles.java`  
- Path: `src/main/java/com/example/rpg/permissions/PlayerRoles.java`  
- Size: 647 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.permissions;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

public class PlayerRoles {
    private final UUID playerId;
    private String primaryRole;
    private final Set<String> extraRoles = new HashSet<>();

    public PlayerRoles(UUID playerId) {
        this.playerId = playerId;
    }

    public UUID playerId() {
        return playerId;
    }

    public String primaryRole() {
        return primaryRole;
    }

    public void setPrimaryRole(String primaryRole) {
        this.primaryRole = primaryRole;
    }

    public Set<String> extraRoles() {
        return extraRoles;
    }
}

```

## File: `src/main/java/com/example/rpg/permissions/PostgresPermissionRepository.java`  
- Path: `src/main/java/com/example/rpg/permissions/PostgresPermissionRepository.java`  
- Size: 6942 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.permissions;

import com.example.rpg.db.DatabaseService;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;

public class PostgresPermissionRepository implements PermissionRepository {
    private final DatabaseService database;
    private final Gson gson = new Gson();
    private final Type setType = new TypeToken<Set<String>>() {}.getType();
    private final Type mapType = new TypeToken<Map<String, PermissionDecision>>() {}.getType();

    public PostgresPermissionRepository(DatabaseService database) {
        this.database = database;
    }

    @Override
    public List<Role> loadAllRoles() {
        List<Role> roles = new ArrayList<>();
        String sql = "SELECT role_key, display_name, parents, nodes FROM rpg_roles";
        try (Connection connection = database.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {
            while (rs.next()) {
                String key = rs.getString("role_key");
                String displayName = rs.getString("display_name");
                Role role = new Role(key, displayName);
                String parentsJson = rs.getString("parents");
                String nodesJson = rs.getString("nodes");
                if (parentsJson != null && !parentsJson.isBlank()) {
                    Set<String> parents = gson.fromJson(parentsJson, setType);
                    if (parents != null) {
                        role.parents().addAll(parents);
                    }
                }
                if (nodesJson != null && !nodesJson.isBlank()) {
                    Map<String, PermissionDecision> nodes = gson.fromJson(nodesJson, mapType);
                    if (nodes != null) {
                        role.nodes().putAll(nodes);
                    }
                }
                roles.add(role);
            }
        } catch (SQLException e) {
            throw new IllegalStateException("Failed to load roles: " + e.getMessage(), e);
        }
        return roles;
    }

    @Override
    public void saveRole(Role role) {
        String sql = "INSERT INTO rpg_roles (role_key, display_name, parents, nodes) VALUES (?, ?, ?::jsonb, ?::jsonb) "
            + "ON CONFLICT (role_key) DO UPDATE SET display_name = EXCLUDED.display_name, parents = EXCLUDED.parents, nodes = EXCLUDED.nodes";
        try (Connection connection = database.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, role.key());
            stmt.setString(2, role.displayName());
            stmt.setString(3, gson.toJson(role.parents()));
            stmt.setString(4, gson.toJson(role.nodes()));
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new IllegalStateException("Failed to save role: " + e.getMessage(), e);
        }
    }

    @Override
    public void deleteRole(String roleKey) {
        String sql = "DELETE FROM rpg_roles WHERE role_key = ?";
        try (Connection connection = database.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, roleKey);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new IllegalStateException("Failed to delete role: " + e.getMessage(), e);
        }
    }

    @Override
    public Optional<PlayerRoles> loadPlayerRoles(UUID playerId) {
        String sql = "SELECT primary_role, extra_roles FROM rpg_player_roles WHERE player_uuid = ?";
        try (Connection connection = database.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setObject(1, playerId);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    PlayerRoles roles = new PlayerRoles(playerId);
                    roles.setPrimaryRole(rs.getString("primary_role"));
                    String extraJson = rs.getString("extra_roles");
                    if (extraJson != null && !extraJson.isBlank()) {
                        Set<String> extra = gson.fromJson(extraJson, setType);
                        if (extra != null) {
                            roles.extraRoles().addAll(extra);
                        }
                    }
                    return Optional.of(roles);
                }
            }
        } catch (SQLException e) {
            throw new IllegalStateException("Failed to load player roles: " + e.getMessage(), e);
        }
        return Optional.empty();
    }

    @Override
    public void savePlayerRoles(PlayerRoles playerRoles) {
        String sql = "INSERT INTO rpg_player_roles (player_uuid, primary_role, extra_roles) VALUES (?, ?, ?::jsonb) "
            + "ON CONFLICT (player_uuid) DO UPDATE SET primary_role = EXCLUDED.primary_role, extra_roles = EXCLUDED.extra_roles";
        try (Connection connection = database.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setObject(1, playerRoles.playerId());
            stmt.setString(2, playerRoles.primaryRole());
            stmt.setString(3, gson.toJson(playerRoles.extraRoles()));
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new IllegalStateException("Failed to save player roles: " + e.getMessage(), e);
        }
    }

    @Override
    public List<PlayerRoles> listPlayerRoles() {
        List<PlayerRoles> list = new ArrayList<>();
        String sql = "SELECT player_uuid, primary_role, extra_roles FROM rpg_player_roles";
        try (Connection connection = database.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {
            while (rs.next()) {
                UUID uuid = rs.getObject("player_uuid", java.util.UUID.class);
                PlayerRoles roles = new PlayerRoles(uuid);
                roles.setPrimaryRole(rs.getString("primary_role"));
                String extraJson = rs.getString("extra_roles");
                if (extraJson != null && !extraJson.isBlank()) {
                    Set<String> extra = gson.fromJson(extraJson, setType);
                    if (extra != null) {
                        roles.extraRoles().addAll(extra);
                    }
                }
                list.add(roles);
            }
        } catch (SQLException e) {
            throw new IllegalStateException("Failed to list player roles: " + e.getMessage(), e);
        }
        return list;
    }
}

```

## File: `src/main/java/com/example/rpg/permissions/Role.java`  
- Path: `src/main/java/com/example/rpg/permissions/Role.java`  
- Size: 842 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.permissions;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class Role {
    private final String key;
    private String displayName;
    private final Set<String> parents = new HashSet<>();
    private final Map<String, PermissionDecision> nodes = new HashMap<>();

    public Role(String key, String displayName) {
        this.key = key;
        this.displayName = displayName;
    }

    public String key() {
        return key;
    }

    public String displayName() {
        return displayName;
    }

    public void setDisplayName(String displayName) {
        this.displayName = displayName;
    }

    public Set<String> parents() {
        return parents;
    }

    public Map<String, PermissionDecision> nodes() {
        return nodes;
    }
}

```

## File: `src/main/java/com/example/rpg/RPGPlugin.java`  
- Path: `src/main/java/com/example/rpg/RPGPlugin.java`  
- Size: 32029 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg;

import com.example.rpg.command.PartyCommand;
import com.example.rpg.command.RPGAdminCommand;
import com.example.rpg.command.RPGCommand;
import com.example.rpg.command.AuctionCommand;
import com.example.rpg.command.DungeonCommand;
import com.example.rpg.command.GuildCommand;
import com.example.rpg.command.PvpCommand;
import com.example.rpg.command.TradeCommand;
import com.example.rpg.command.BehaviorCommand;
import com.example.rpg.command.LootChatCommand;
import com.example.rpg.command.VoiceChatCommand;
import com.example.rpg.db.DatabaseService;
import com.example.rpg.db.PlayerDao;
import com.example.rpg.db.SqlPlayerDao;
import com.example.rpg.gui.BehaviorTreeEditorGui;
import com.example.rpg.gui.GuiManager;
import com.example.rpg.gui.SkillTreeGui;
import com.example.rpg.listener.BehaviorEditorListener;
import com.example.rpg.listener.ArenaListener;
import com.example.rpg.listener.CombatListener;
import com.example.rpg.listener.CustomMobListener;
import com.example.rpg.listener.DamageIndicatorListener;
import com.example.rpg.listener.GuiListener;
import com.example.rpg.listener.ItemStatListener;
import com.example.rpg.listener.BuildingPlacementListener;
import com.example.rpg.listener.NpcListener;
import com.example.rpg.listener.NpcProtectionListener;
import com.example.rpg.listener.PlayerListener;
import com.example.rpg.listener.ProfessionListener;
import com.example.rpg.listener.SkillHotbarListener;
import com.example.rpg.listener.ZoneListener;
import com.example.rpg.manager.ArenaManager;
import com.example.rpg.manager.BehaviorTreeManager;
import com.example.rpg.manager.ClassManager;
import com.example.rpg.manager.DungeonManager;
import com.example.rpg.manager.GuildManager;
import com.example.rpg.manager.FactionManager;
import com.example.rpg.manager.ItemStatManager;
import com.example.rpg.manager.PvpSeasonManager;
import com.example.rpg.manager.LootManager;
import com.example.rpg.manager.MobManager;
import com.example.rpg.manager.NpcManager;
import com.example.rpg.manager.PartyManager;
import com.example.rpg.manager.PlayerDataManager;
import com.example.rpg.manager.SkillTreeManager;
import com.example.rpg.manager.QuestManager;
import com.example.rpg.manager.WorldEventManager;
import com.example.rpg.manager.AuctionHouseManager;
import com.example.rpg.manager.ShopManager;
import com.example.rpg.manager.SkillHotbarManager;
import com.example.rpg.manager.SkillManager;
import com.example.rpg.manager.SpawnerManager;
import com.example.rpg.manager.ZoneManager;
import com.example.rpg.manager.TradeManager;
import com.example.rpg.manager.ProfessionManager;
import com.example.rpg.manager.ResourceNodeManager;
import com.example.rpg.manager.CraftingOrderManager;
import com.example.rpg.manager.SkillSynergyManager;
import com.example.rpg.manager.BuildingManager;
import com.example.rpg.manager.VoiceChatManager;
import com.example.rpg.util.ItemGenerator;
import com.example.rpg.util.AuditLog;
import com.example.rpg.util.PromptManager;
import com.example.rpg.permissions.PermissionService;
import com.example.rpg.permissions.PermissionDecision;
import com.example.rpg.permissions.PermissionListener;
import com.example.rpg.manager.EnchantManager;
import com.example.rpg.skill.SkillEffectRegistry;
import com.example.rpg.skill.SkillEffectType;
import com.example.rpg.skill.effects.DamageEffect;
import com.example.rpg.skill.effects.HealEffect;
import com.example.rpg.skill.effects.ParticleEffect;
import com.example.rpg.skill.effects.PotionStatusEffect;
import com.example.rpg.skill.effects.ProjectileEffect;
import com.example.rpg.skill.effects.SoundEffect;
import com.example.rpg.skill.effects.VelocityEffect;
import com.example.rpg.skill.effects.AggroEffect;
import com.example.rpg.skill.effects.XpEffect;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;
import org.bukkit.Bukkit;
import org.bukkit.NamespacedKey;
import org.bukkit.entity.Player;
import org.bukkit.plugin.java.JavaPlugin;

public class RPGPlugin extends JavaPlugin {
    private DatabaseService databaseService;
    private PlayerDataManager playerDataManager;
    private QuestManager questManager;
    private ZoneManager zoneManager;
    private NpcManager npcManager;
    private LootManager lootManager;
    private MobManager mobManager;
    private SkillManager skillManager;
    private SkillHotbarManager skillHotbarManager;
    private ClassManager classManager;
    private SpawnerManager spawnerManager;
    private ShopManager shopManager;
    private AuctionHouseManager auctionHouseManager;
    private TradeManager tradeManager;
    private ProfessionManager professionManager;
    private ResourceNodeManager resourceNodeManager;
    private CraftingOrderManager craftingOrderManager;
    private DungeonManager dungeonManager;
    private ArenaManager arenaManager;
    private PvpSeasonManager pvpSeasonManager;
    private BehaviorTreeManager behaviorTreeManager;
    private GuildManager guildManager;
    private FactionManager factionManager;
    private PartyManager partyManager;
    private GuiManager guiManager;
    private SkillTreeGui skillTreeGui;
    private SkillTreeManager skillTreeManager;
    private ItemStatManager itemStatManager;
    private BehaviorTreeEditorGui behaviorTreeEditorGui;
    private VoiceChatManager voiceChatManager;
    private PermissionService permissionService;
    private BuildingManager buildingManager;
    private EnchantManager enchantManager;
    private PromptManager promptManager;
    private ItemGenerator itemGenerator;
    private SkillEffectRegistry skillEffects;
    private WorldEventManager worldEventManager;
    private SkillSynergyManager skillSynergyManager;
    private final Set<UUID> debugPlayers = new HashSet<>();
    private final Set<UUID> combatLogDisabled = new HashSet<>();
    private CustomMobListener customMobListener;
    private final java.util.Map<UUID, Long> actionBarErrorUntil = new java.util.HashMap<>();
    private final java.util.Map<UUID, String> actionBarErrorMessage = new java.util.HashMap<>();
    private NamespacedKey questKey;
    private NamespacedKey skillKey;
    private NamespacedKey wandKey;
    private NamespacedKey buildingKey;
    private NamespacedKey buildingCategoryKey;
    private NamespacedKey zoneKey;
    private NamespacedKey npcGuiKey;
    private NamespacedKey npcTemplateKey;
    private NamespacedKey lootKey;
    private NamespacedKey classKey;
    private NamespacedKey permRoleKey;
    private NamespacedKey permPlayerKey;
    private NamespacedKey permNodeKey;
    private NamespacedKey permActionKey;
    private NamespacedKey enchantRecipeKey;
    private AuditLog auditLog;

    @Override
    public void onEnable() {
        saveDefaultConfig();
        databaseService = new DatabaseService(this);
        databaseService.initTables();
        PlayerDao playerDao = new SqlPlayerDao(databaseService);
        playerDataManager = new PlayerDataManager(this, playerDao);
        questManager = new QuestManager(this);
        worldEventManager = new WorldEventManager(this);
        zoneManager = new ZoneManager(this);
        npcManager = new NpcManager(this);
        lootManager = new LootManager(this);
        mobManager = new MobManager(this);
        behaviorTreeManager = new BehaviorTreeManager(this);
        voiceChatManager = new VoiceChatManager(this);
        skillManager = new SkillManager(this);
        skillHotbarManager = new SkillHotbarManager(playerDataManager);
        classManager = new ClassManager(this);
        factionManager = new FactionManager(this);
        spawnerManager = new SpawnerManager(this);
        shopManager = new ShopManager(this);
        auctionHouseManager = new AuctionHouseManager(this);
        tradeManager = new TradeManager();
        professionManager = new ProfessionManager(this);
        resourceNodeManager = new ResourceNodeManager(this);
        craftingOrderManager = new CraftingOrderManager(this);
        dungeonManager = new DungeonManager(this);
        arenaManager = new ArenaManager(this);
        pvpSeasonManager = new PvpSeasonManager(this);
        guildManager = new GuildManager(this);
        partyManager = new PartyManager();
        promptManager = new PromptManager();
        itemStatManager = new ItemStatManager(this);
        itemGenerator = new ItemGenerator(this, itemStatManager);
        buildingManager = new BuildingManager(this);
        questKey = new NamespacedKey(this, "quest_id");
        skillKey = new NamespacedKey(this, "skill_id");
        wandKey = new NamespacedKey(this, "editor_wand");
        buildingKey = new NamespacedKey(this, "building_id");
        buildingCategoryKey = new NamespacedKey(this, "building_category");
        zoneKey = new NamespacedKey(this, "zone_id");
        npcGuiKey = new NamespacedKey(this, "npc_gui_id");
        npcTemplateKey = new NamespacedKey(this, "npc_template");
        lootKey = new NamespacedKey(this, "loot_id");
        classKey = new NamespacedKey(this, "class_id");
        permRoleKey = new NamespacedKey(this, "perm_role");
        permPlayerKey = new NamespacedKey(this, "perm_player");
        permNodeKey = new NamespacedKey(this, "perm_node");
        permActionKey = new NamespacedKey(this, "perm_action");
        enchantRecipeKey = new NamespacedKey(this, "enchant_recipe");
        skillEffects = new SkillEffectRegistry()
            .register(SkillEffectType.HEAL, new HealEffect())
            .register(SkillEffectType.DAMAGE, new DamageEffect())
            .register(SkillEffectType.PROJECTILE, new ProjectileEffect())
            .register(SkillEffectType.POTION, new PotionStatusEffect())
            .register(SkillEffectType.SOUND, new SoundEffect())
            .register(SkillEffectType.XP, new XpEffect())
            .register(SkillEffectType.PARTICLE, new ParticleEffect())
            .register(SkillEffectType.VELOCITY, new VelocityEffect())
            .register(SkillEffectType.AGGRO, new AggroEffect());
        skillTreeManager = new SkillTreeManager(skillManager);
        skillTreeGui = new SkillTreeGui(this);
        behaviorTreeEditorGui = new BehaviorTreeEditorGui(this);
        auditLog = new AuditLog(this);
        enchantManager = new EnchantManager(this);
        skillSynergyManager = new SkillSynergyManager(this);
        permissionService = new PermissionService(this, databaseService,
            getConfig().getBoolean("permissions.enabled", true),
            getConfig().getString("permissions.defaultRole", "player"),
            PermissionDecision.valueOf(getConfig().getString("permissions.defaultDecision", "DENY")),
            getConfig().getBoolean("permissions.opBypass", true),
            getConfig().getBoolean("permissions.auditEnabled", true),
            getConfig().getLong("permissions.cacheTtlSeconds", 30));
        guiManager = new GuiManager(playerDataManager, questManager, worldEventManager, skillManager, classManager, factionManager,
            buildingManager, permissionService, enchantManager, itemStatManager, itemGenerator, questKey, skillKey, buildingKey,
            buildingCategoryKey,
            zoneKey, npcGuiKey, npcTemplateKey, lootKey, classKey, permRoleKey, permPlayerKey, permNodeKey, permActionKey, enchantRecipeKey);

        Bukkit.getPluginManager().registerEvents(new PlayerListener(this), this);
        Bukkit.getPluginManager().registerEvents(new CombatListener(this), this);
        Bukkit.getPluginManager().registerEvents(new ZoneListener(this), this);
        Bukkit.getPluginManager().registerEvents(new DamageIndicatorListener(this), this);
        Bukkit.getPluginManager().registerEvents(new NpcListener(this), this);
        Bukkit.getPluginManager().registerEvents(new NpcProtectionListener(this), this);
        Bukkit.getPluginManager().registerEvents(new GuiListener(this), this);
        Bukkit.getPluginManager().registerEvents(new SkillHotbarListener(this), this);
        Bukkit.getPluginManager().registerEvents(new ProfessionListener(this), this);
        Bukkit.getPluginManager().registerEvents(new ItemStatListener(this), this);
        Bukkit.getPluginManager().registerEvents(new ArenaListener(this), this);
        Bukkit.getPluginManager().registerEvents(new BehaviorEditorListener(this, behaviorTreeEditorGui), this);
        Bukkit.getPluginManager().registerEvents(new BuildingPlacementListener(this), this);
        Bukkit.getPluginManager().registerEvents(new PermissionListener(this), this);
        Bukkit.getPluginManager().registerEvents(new com.example.rpg.listener.MobHealthBarListener(this), this);
        customMobListener = new CustomMobListener(this);
        Bukkit.getPluginManager().registerEvents(customMobListener, this);

        getCommand("rpg").setExecutor(new RPGCommand(this));
        getCommand("rpgadmin").setExecutor(new RPGAdminCommand(this));
        getCommand("party").setExecutor(new PartyCommand(this));
        getCommand("p").setExecutor(new PartyCommand(this));
        getCommand("auction").setExecutor(new AuctionCommand(this));
        getCommand("trade").setExecutor(new TradeCommand(this));
        getCommand("dungeon").setExecutor(new DungeonCommand(this));
        getCommand("guild").setExecutor(new GuildCommand(this));
        getCommand("g").setExecutor(new GuildCommand(this));
        getCommand("pvp").setExecutor(new PvpCommand(this));
        getCommand("behavior").setExecutor(new BehaviorCommand(this));
        getCommand("lootchat").setExecutor(new LootChatCommand(this));
        getCommand("voicechat").setExecutor(new VoiceChatCommand(this));

        npcManager.spawnAll();
        startDebugTask();
        startManaRegenTask();
        startHudTask();
        startGuildHallBuffTask();
        startSeasonCheckTask();
    }

    @Override
    public void onDisable() {
        if (playerDataManager != null) {
            playerDataManager.saveAll();
        }
        if (questManager != null) {
            questManager.saveAll();
        }
        if (worldEventManager != null) {
            worldEventManager.saveAll();
        }
        if (zoneManager != null) {
            zoneManager.saveAll();
        }
        if (npcManager != null) {
            npcManager.saveAll();
        }
        if (lootManager != null) {
            lootManager.saveAll();
        }
        if (mobManager != null) {
            mobManager.saveAll();
        }
        if (skillManager != null) {
            skillManager.saveAll();
        }
        if (classManager != null) {
            classManager.saveAll();
        }
        if (factionManager != null) {
            factionManager.saveAll();
        }
        if (spawnerManager != null) {
            spawnerManager.saveAll();
        }
        if (shopManager != null) {
            shopManager.saveAll();
        }
        if (auctionHouseManager != null) {
            auctionHouseManager.listings().values().forEach(auctionHouseManager::saveListing);
        }
        if (guildManager != null) {
            guildManager.saveAll();
        }
        if (resourceNodeManager != null) {
            resourceNodeManager.saveAll();
        }
        if (dungeonManager != null) {
            getLogger().info("Cleaning up dungeon worlds...");
            dungeonManager.shutdown();
        }
        if (databaseService != null) {
            databaseService.shutdown();
        }
    }

    public PlayerDataManager playerDataManager() {
        return playerDataManager;
    }

    public QuestManager questManager() {
        return questManager;
    }

    public WorldEventManager worldEventManager() {
        return worldEventManager;
    }

    public ZoneManager zoneManager() {
        return zoneManager;
    }

    public NpcManager npcManager() {
        return npcManager;
    }

    public LootManager lootManager() {
        return lootManager;
    }

    public MobManager mobManager() {
        return mobManager;
    }

    public BehaviorTreeManager behaviorTreeManager() {
        return behaviorTreeManager;
    }

    public SkillManager skillManager() {
        return skillManager;
    }

    public SkillHotbarManager skillHotbarManager() {
        return skillHotbarManager;
    }

    public ClassManager classManager() {
        return classManager;
    }

    public FactionManager factionManager() {
        return factionManager;
    }

    public PartyManager partyManager() {
        return partyManager;
    }

    public GuiManager guiManager() {
        return guiManager;
    }

    public PromptManager promptManager() {
        return promptManager;
    }

    public ItemGenerator itemGenerator() {
        return itemGenerator;
    }

    public SkillEffectRegistry skillEffects() {
        return skillEffects;
    }

    public SkillSynergyManager skillSynergyManager() {
        return skillSynergyManager;
    }

    public SpawnerManager spawnerManager() {
        return spawnerManager;
    }

    public ShopManager shopManager() {
        return shopManager;
    }

    public AuctionHouseManager auctionHouseManager() {
        return auctionHouseManager;
    }

    public TradeManager tradeManager() {
        return tradeManager;
    }

    public ProfessionManager professionManager() {
        return professionManager;
    }

    public ResourceNodeManager resourceNodeManager() {
        return resourceNodeManager;
    }

    public CraftingOrderManager craftingOrderManager() {
        return craftingOrderManager;
    }

    public DungeonManager dungeonManager() {
        return dungeonManager;
    }

    public ArenaManager arenaManager() {
        return arenaManager;
    }

    public PvpSeasonManager pvpSeasonManager() {
        return pvpSeasonManager;
    }

    public GuildManager guildManager() {
        return guildManager;
    }

    public SkillTreeManager skillTreeManager() {
        return skillTreeManager;
    }

    public SkillTreeGui skillTreeGui() {
        return skillTreeGui;
    }

    public ItemStatManager itemStatManager() {
        return itemStatManager;
    }

    public BehaviorTreeEditorGui behaviorTreeEditorGui() {
        return behaviorTreeEditorGui;
    }

    public VoiceChatManager voiceChatManager() {
        return voiceChatManager;
    }

    public PermissionService permissionService() {
        return permissionService;
    }

    public BuildingManager buildingManager() {
        return buildingManager;
    }

    public EnchantManager enchantManager() {
        return enchantManager;
    }

    public CustomMobListener customMobListener() {
        return customMobListener;
    }

    public AuditLog auditLog() {
        return auditLog;
    }

    public NamespacedKey questKey() {
        return questKey;
    }

    public NamespacedKey skillKey() {
        return skillKey;
    }

    public NamespacedKey wandKey() {
        return wandKey;
    }

    public NamespacedKey buildingKey() {
        return buildingKey;
    }

    public NamespacedKey buildingCategoryKey() {
        return buildingCategoryKey;
    }

    public NamespacedKey zoneKey() {
        return zoneKey;
    }

    public NamespacedKey npcGuiKey() {
        return npcGuiKey;
    }

    public NamespacedKey npcTemplateKey() {
        return npcTemplateKey;
    }

    public NamespacedKey lootKey() {
        return lootKey;
    }

    public NamespacedKey classKey() {
        return classKey;
    }

    public NamespacedKey permRoleKey() {
        return permRoleKey;
    }

    public NamespacedKey permPlayerKey() {
        return permPlayerKey;
    }

    public NamespacedKey permNodeKey() {
        return permNodeKey;
    }

    public NamespacedKey permActionKey() {
        return permActionKey;
    }

    public NamespacedKey enchantRecipeKey() {
        return enchantRecipeKey;
    }

    public void broadcastLoot(Player player, org.bukkit.inventory.ItemStack item) {
        if (!getConfig().getBoolean("lootchat.enabled", true)) {
            return;
        }
        String name = item.getType().name().toLowerCase().replace("_", " ");
        String message = "<gold>" + player.getName() + "</gold> hat <yellow>" + item.getAmount()
            + "x " + name + "</yellow> gelootet.";
        getServer().broadcast(com.example.rpg.util.Text.mm(message));
    }

    public boolean useSkill(Player player, String skillId) {
        var skill = skillManager.getSkill(skillId);
        if (skill == null) {
            notifySkillError(player, "Unbekannter Skill");
            return false;
        }
        var profile = playerDataManager.getProfile(player);
        if (!profile.learnedSkills().containsKey(skillId)) {
            notifySkillError(player, "Skill nicht gelernt");
            return false;
        }
        if (skill.type() == com.example.rpg.model.SkillType.PASSIVE) {
            notifySkillError(player, "Passiver Skill ist aktiv");
            return false;
        }
        long now = System.currentTimeMillis();
        long last = profile.skillCooldowns().getOrDefault(skillId, 0L);
        if (now - last < skill.cooldown() * 1000L) {
            long remaining = (skill.cooldown() * 1000L - (now - last)) / 1000L;
            notifySkillError(player, "Cooldown: " + remaining + "s");
            return false;
        }
        if (profile.mana() < skill.manaCost()) {
            notifySkillError(player, "Nicht genug Mana");
            return false;
        }
        profile.setMana(profile.mana() - skill.manaCost());
        for (var effect : skill.effects()) {
            skillEffects.apply(effect, player, profile);
        }
        profile.skillCooldowns().put(skillId, now);
        player.sendMessage("aSkill benutzt: " + skill.name());
        skillSynergyManager.onSkillUsed(player, skillId);
        return true;
    }

    public boolean useMobSkill(org.bukkit.entity.LivingEntity caster, Player target, String skillId) {
        var skill = skillManager.getSkill(skillId);
        if (skill == null) {
            return false;
        }
        for (var effect : skill.effects()) {
            switch (effect.type()) {
                case DAMAGE -> {
                    double amount = parseDouble(effect.params().getOrDefault("amount", 4));
                    target.damage(amount, caster);
                }
                case PROJECTILE -> {
                    String type = String.valueOf(effect.params().getOrDefault("type", "SNOWBALL")).toUpperCase();
                    if ("SMALL_FIREBALL".equals(type)) {
                        caster.launchProjectile(org.bukkit.entity.SmallFireball.class);
                    } else {
                        caster.launchProjectile(org.bukkit.entity.Snowball.class);
                    }
                }
                case POTION -> {
                    String type = String.valueOf(effect.params().getOrDefault("type", "SLOW")).toUpperCase();
                    int duration = (int) parseDouble(effect.params().getOrDefault("duration", 60));
                    int amplifier = (int) parseDouble(effect.params().getOrDefault("amplifier", 0));
                    var potion = org.bukkit.potion.PotionEffectType.getByName(type);
                    if (potion != null) {
                        target.addPotionEffect(new org.bukkit.potion.PotionEffect(potion, duration, amplifier));
                    }
                }
                case PARTICLE -> {
                    String particleName = String.valueOf(effect.params().getOrDefault("type", "SMOKE")).toUpperCase();
                    int count = (int) parseDouble(effect.params().getOrDefault("count", 10));
                    double speed = parseDouble(effect.params().getOrDefault("speed", 0.01));
                    org.bukkit.Particle particle;
                    try {
                        particle = org.bukkit.Particle.valueOf(particleName);
                    } catch (IllegalArgumentException e) {
                        particle = org.bukkit.Particle.SMOKE_NORMAL;
                    }
                    caster.getWorld().spawnParticle(particle, caster.getLocation().add(0, 1.0, 0), count, 0.3, 0.6, 0.3, speed);
                }
                case SOUND -> {
                    String soundName = String.valueOf(effect.params().getOrDefault("sound", "ENTITY_ZOMBIE_HURT")).toUpperCase();
                    float volume = (float) parseDouble(effect.params().getOrDefault("volume", 1.0));
                    float pitch = (float) parseDouble(effect.params().getOrDefault("pitch", 1.0));
                    org.bukkit.Sound sound;
                    try {
                        sound = org.bukkit.Sound.valueOf(soundName);
                    } catch (IllegalArgumentException e) {
                        sound = org.bukkit.Sound.ENTITY_ZOMBIE_HURT;
                    }
                    caster.getWorld().playSound(caster.getLocation(), sound, volume, pitch);
                }
                default -> {
                }
            }
        }
        return true;
    }

    private double parseDouble(Object raw) {
        try {
            return Double.parseDouble(String.valueOf(raw));
        } catch (NumberFormatException e) {
            return 0.0;
        }
    }

    public void notifySkillError(Player player, String message) {
        actionBarErrorUntil.put(player.getUniqueId(), System.currentTimeMillis() + 2000L);
        actionBarErrorMessage.put(player.getUniqueId(), message);
        player.sendActionBar("c" + message);
    }

    private void startHudTask() {
        Bukkit.getScheduler().runTaskTimer(this, () -> {
            for (Player player : Bukkit.getOnlinePlayers()) {
                var profile = playerDataManager.getProfile(player);
                String health = String.format(" Leben: %.0f/%.0f", player.getHealth(),
                    player.getAttribute(org.bukkit.attribute.Attribute.GENERIC_MAX_HEALTH) != null
                        ? player.getAttribute(org.bukkit.attribute.Attribute.GENERIC_MAX_HEALTH).getValue()
                        : 20.0);
                String mana = " Mana: " + profile.mana() + "/" + profile.maxMana();
                String gold = " " + profile.gold();
                Long until = actionBarErrorUntil.get(player.getUniqueId());
                if (until != null && until > System.currentTimeMillis()) {
                    String msg = actionBarErrorMessage.getOrDefault(player.getUniqueId(), "Fehler");
                    player.sendActionBar("c" + msg);
                } else {
                    player.sendActionBar("f" + health + " 7| f" + mana + " 7| 6" + gold);
                }

                int slot = player.getInventory().getHeldItemSlot() + 1;
                String skillId = skillHotbarManager.getBinding(profile, slot);
                if (skillId != null) {
                    var skill = skillManager.getSkill(skillId);
                    if (skill != null && skill.cooldown() > 0) {
                        long last = profile.skillCooldowns().getOrDefault(skillId, 0L);
                        long remaining = skill.cooldown() * 1000L - (System.currentTimeMillis() - last);
                        if (remaining > 0) {
                            float progress = Math.max(0f, Math.min(1f, remaining / (skill.cooldown() * 1000f)));
                            player.setExp(progress);
                            player.setLevel((int) Math.ceil(remaining / 1000f));
                        } else {
                            player.setExp(0f);
                            player.setLevel(profile.level());
                        }
                    }
                }
            }
        }, 10L, 10L);
    }

    public boolean toggleDebug(UUID uuid) {
        if (debugPlayers.contains(uuid)) {
            debugPlayers.remove(uuid);
            return false;
        }
        debugPlayers.add(uuid);
        return true;
    }

    public boolean toggleCombatLog(UUID uuid) {
        if (combatLogDisabled.contains(uuid)) {
            combatLogDisabled.remove(uuid);
            return true;
        }
        combatLogDisabled.add(uuid);
        return false;
    }

    public void setCombatLog(UUID uuid, boolean enabled) {
        if (enabled) {
            combatLogDisabled.remove(uuid);
        } else {
            combatLogDisabled.add(uuid);
        }
    }

    public boolean isCombatLogEnabled(UUID uuid) {
        return !combatLogDisabled.contains(uuid);
    }

    private void startDebugTask() {
        Bukkit.getScheduler().runTaskTimer(this, () -> {
            for (UUID uuid : debugPlayers) {
                Player player = Bukkit.getPlayer(uuid);
                if (player == null) {
                    continue;
                }
                var zone = zoneManager.getZoneAt(player.getLocation());
                String zoneName = zone != null ? zone.name() : "Keine Zone";
                player.sendActionBar("7Zone: f" + zoneName + " 7Quest: f" + playerDataManager.getProfile(player).activeQuests().size());
            }
        }, 20L, 40L);
    }

    private void startManaRegenTask() {
        Bukkit.getScheduler().runTaskTimer(this, () -> {
            for (Player player : Bukkit.getOnlinePlayers()) {
                var profile = playerDataManager.getProfile(player);
                profile.setMana(Math.min(profile.maxMana(), profile.mana() + 5));
            }
        }, 20L, 40L);
    }

    private void startGuildHallBuffTask() {
        Bukkit.getScheduler().runTaskTimer(this, () -> {
            for (Player player : Bukkit.getOnlinePlayers()) {
                var guildOpt = guildManager.guildFor(player.getUniqueId());
                if (guildOpt.isEmpty()) {
                    continue;
                }
                var guild = guildOpt.get();
                var hall = guildManager.hallLocation(guild);
                if (hall == null || !hall.getWorld().equals(player.getWorld())) {
                    continue;
                }
                if (player.getLocation().distanceSquared(hall) > 20 * 20) {
                    continue;
                }
                int buffLevel = guild.hallUpgrades().getOrDefault("buff", 0);
                if (buffLevel > 0) {
                    player.addPotionEffect(new org.bukkit.potion.PotionEffect(
                        org.bukkit.potion.PotionEffectType.REGENERATION, 200, Math.max(0, buffLevel - 1), true, false));
                    player.addPotionEffect(new org.bukkit.potion.PotionEffect(
                        org.bukkit.potion.PotionEffectType.DAMAGE_RESISTANCE, 200, Math.max(0, buffLevel - 1), true, false));
                }
            }
        }, 40L, 40L);
    }

    private void startSeasonCheckTask() {
        Bukkit.getScheduler().runTaskTimer(this, () -> {
            pvpSeasonManager.checkSeasonEnd();
        }, 20L * 60L, 20L * 60L);
    }

    public boolean completeQuestIfReady(Player player, com.example.rpg.model.Quest quest, com.example.rpg.model.QuestProgress progress) {
        if (progress.completed()) {
            return false;
        }
        boolean done = true;
        for (int i = 0; i < quest.steps().size(); i++) {
            int required = quest.steps().get(i).amount();
            if (progress.getStepProgress(i) < required) {
                done = false;
                break;
            }
        }
        if (!done) {
            return false;
        }
        progress.setCompleted(true);
        var profile = playerDataManager.getProfile(player);
        profile.completedQuests().add(quest.id());
        profile.activeQuests().remove(quest.id());
        profile.addXp(quest.reward().xp());
        profile.setSkillPoints(profile.skillPoints() + quest.reward().skillPoints());
        quest.reward().factionRep().forEach((id, amount) ->
            profile.factionRep().put(id, profile.factionRep().getOrDefault(id, 0) + amount)
        );
        player.sendMessage("aQuest abgeschlossen: " + quest.name());
        return true;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/BlockEntityApplier.java`  
- Path: `src/main/java/com/example/rpg/schematic/BlockEntityApplier.java`  
- Size: 5233 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic;

import com.example.rpg.schematic.nbt.NbtCompound;
import com.example.rpg.schematic.nbt.NbtList;
import java.util.List;
import java.util.logging.Logger;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.block.BlockState;
import org.bukkit.block.Sign;
import org.bukkit.block.Barrel;
import org.bukkit.block.Chest;
import org.bukkit.block.CreatureSpawner;
import org.bukkit.entity.EntityType;
import net.kyori.adventure.text.Component;
import org.bukkit.Nameable;

public class BlockEntityApplier {
    private final Logger logger;

    public BlockEntityApplier(Logger logger) {
        this.logger = logger;
    }

    public void apply(World world, Location origin, NbtCompound nbt, Transform transform, int width, int length) {
        int[] pos = readPos(nbt);
        if (pos == null || pos.length < 3) {
            return;
        }
        int[] transformed = transform.apply(pos[0], pos[1], pos[2], width, length);
        Location location = origin.clone().add(transformed[0], transformed[1], transformed[2]);
        Block block = world.getBlockAt(location);
        BlockState state = block.getState();
        if (state instanceof Sign sign) {
            applySign(sign, nbt);
        } else if (state instanceof CreatureSpawner spawner) {
            applySpawner(spawner, nbt);
        } else if (state instanceof Chest chest) {
            applyContainerName(chest, nbt);
        } else if (state instanceof Barrel barrel) {
            applyContainerName(barrel, nbt);
        }
    }

    private void applySign(Sign sign, NbtCompound nbt) {
        String[] lines = new String[4];
        boolean hasLine = false;
        for (int i = 0; i < 4; i++) {
            String key = "Text" + (i + 1);
            String value = nbt.getString(key, null);
            if (value != null) {
                lines[i] = parseSignText(value);
                hasLine = true;
            }
        }
        NbtCompound frontText = nbt.getCompound("front_text");
        if (frontText != null) {
            NbtList messages = frontText.getList("messages");
            if (messages != null) {
                List<String> msgList = messages.strings();
                for (int i = 0; i < Math.min(4, msgList.size()); i++) {
                    lines[i] = parseSignText(msgList.get(i));
                    hasLine = true;
                }
            }
        }
        if (!hasLine) {
            return;
        }
        for (int i = 0; i < 4; i++) {
            if (lines[i] != null) {
                sign.setLine(i, lines[i]);
            }
        }
        sign.update(true, false);
    }

    private void applySpawner(CreatureSpawner spawner, NbtCompound nbt) {
        NbtCompound spawnData = nbt.getCompound("SpawnData");
        String id = null;
        if (spawnData != null) {
            id = spawnData.getString("id", null);
            if (id == null) {
                NbtCompound entity = spawnData.getCompound("entity");
                if (entity != null) {
                    id = entity.getString("id", null);
                }
            }
        }
        if (id == null) {
            id = nbt.getString("EntityId", null);
        }
        if (id == null) {
            return;
        }
        EntityType type = EntityType.fromName(stripNamespace(id));
        if (type != null) {
            spawner.setSpawnedType(type);
            spawner.update(true, false);
        }
    }

    private void applyContainerName(BlockState container, NbtCompound nbt) {
        String name = nbt.getString("CustomName", null);
        if (name == null) {
            return;
        }
        if (container instanceof Nameable nameable) {
            nameable.customName(Component.text(parseSignText(name)));
            container.update(true, false);
        }
    }

    private int[] readPos(NbtCompound nbt) {
        int[] pos = nbt.getIntArray("Pos");
        if (pos != null) {
            return pos;
        }
        NbtList list = nbt.getList("Pos");
        if (list != null) {
            List<Double> values = list.doubles();
            if (values.size() >= 3) {
                return new int[]{values.get(0).intValue(), values.get(1).intValue(), values.get(2).intValue()};
            }
        }
        return null;
    }

    private String parseSignText(String raw) {
        if (raw == null) {
            return "";
        }
        if (raw.startsWith("{") && raw.contains("\"text\"")) {
            int start = raw.indexOf("\"text\"");
            int colon = raw.indexOf(':', start);
            int firstQuote = raw.indexOf('"', colon + 1);
            if (firstQuote >= 0) {
                int secondQuote = raw.indexOf('"', firstQuote + 1);
                if (secondQuote > firstQuote) {
                    return raw.substring(firstQuote + 1, secondQuote);
                }
            }
        }
        return raw.replace('"', ' ').trim();
    }

    private String stripNamespace(String id) {
        if (id == null) {
            return null;
        }
        if (id.contains(":")) {
            return id.substring(id.indexOf(':') + 1);
        }
        return id;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/BlockPalette.java`  
- Path: `src/main/java/com/example/rpg/schematic/BlockPalette.java`  
- Size: 394 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic;

import java.util.Map;

public class BlockPalette {
    private final Map<Integer, String> idToState;

    public BlockPalette(Map<Integer, String> idToState) {
        this.idToState = Map.copyOf(idToState);
    }

    public String getState(int id) {
        return idToState.get(id);
    }

    public int size() {
        return idToState.size();
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/EntitySpawner.java`  
- Path: `src/main/java/com/example/rpg/schematic/EntitySpawner.java`  
- Size: 3487 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic;

import com.example.rpg.schematic.nbt.NbtCompound;
import com.example.rpg.schematic.nbt.NbtList;
import java.util.List;
import java.util.logging.Logger;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.entity.ArmorStand;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.ItemFrame;
import org.bukkit.inventory.ItemStack;

public class EntitySpawner {
    private final Logger logger;

    public EntitySpawner(Logger logger) {
        this.logger = logger;
    }

    public void spawn(World world, Location origin, NbtCompound nbt, Transform transform, int width, int length) {
        String id = nbt.getString("Id", null);
        if (id == null) {
            id = nbt.getString("id", null);
        }
        if (id == null) {
            return;
        }
        EntityType type = EntityType.fromName(stripNamespace(id));
        if (type == null) {
            logger.warning("Unsupported entity type: " + id);
            return;
        }
        Location location = resolvePosition(origin, nbt, transform, width, length);
        if (location == null) {
            return;
        }
        Entity entity = world.spawnEntity(location, type);
        if (entity instanceof ArmorStand armorStand) {
            applyArmorStand(armorStand, nbt);
        } else if (entity instanceof ItemFrame itemFrame) {
            applyItemFrame(itemFrame, nbt);
        }
    }

    private Location resolvePosition(Location origin, NbtCompound nbt, Transform transform, int width, int length) {
        NbtList posList = nbt.getList("Pos");
        if (posList == null) {
            return null;
        }
        List<Double> coords = posList.doubles();
        if (coords.size() < 3) {
            return null;
        }
        int x = coords.get(0).intValue();
        int y = coords.get(1).intValue();
        int z = coords.get(2).intValue();
        int[] transformed = transform.apply(x, y, z, width, length);
        return origin.clone().add(transformed[0], transformed[1], transformed[2]);
    }

    private void applyArmorStand(ArmorStand armorStand, NbtCompound nbt) {
        armorStand.setSmall(nbt.getInt("Small", 0) == 1);
        armorStand.setInvisible(nbt.getInt("Invisible", 0) == 1);
        armorStand.setArms(nbt.getInt("ShowArms", 0) == 1);
        String customName = nbt.getString("CustomName", null);
        if (customName != null && !customName.isBlank()) {
            armorStand.setCustomNameVisible(true);
            armorStand.setCustomName(customName);
        }
    }

    private void applyItemFrame(ItemFrame itemFrame, NbtCompound nbt) {
        NbtCompound item = nbt.getCompound("Item");
        if (item == null) {
            return;
        }
        String id = item.getString("id", null);
        if (id == null) {
            return;
        }
        Material material = Material.matchMaterial(stripNamespace(id).toUpperCase());
        if (material == null) {
            logger.warning("Unknown item frame item: " + id);
            return;
        }
        int count = item.getInt("Count", 1);
        itemFrame.setItem(new ItemStack(material, Math.max(1, count)));
    }

    private String stripNamespace(String id) {
        if (id == null) {
            return null;
        }
        if (id.contains(":")) {
            return id.substring(id.indexOf(':') + 1);
        }
        return id;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtByte.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtByte.java`  
- Size: 172 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

public record NbtByte(byte value) implements NbtTag {
    @Override
    public byte typeId() {
        return NbtType.BYTE;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtByteArray.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtByteArray.java`  
- Size: 185 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

public record NbtByteArray(byte[] value) implements NbtTag {
    @Override
    public byte typeId() {
        return NbtType.BYTE_ARRAY;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtCompound.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtCompound.java`  
- Size: 2892 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class NbtCompound implements NbtTag {
    private final Map<String, NbtTag> values = new HashMap<>();

    @Override
    public byte typeId() {
        return NbtType.COMPOUND;
    }

    public void put(String name, NbtTag tag) {
        values.put(name, tag);
    }

    public Map<String, NbtTag> values() {
        return Collections.unmodifiableMap(values);
    }

    public NbtTag get(String name) {
        return values.get(name);
    }

    public String getString(String name, String fallback) {
        NbtTag tag = values.get(name);
        if (tag instanceof NbtString str) {
            return str.value();
        }
        return fallback;
    }

    public int getInt(String name, int fallback) {
        Number number = getNumber(name);
        return number != null ? number.intValue() : fallback;
    }

    public long getLong(String name, long fallback) {
        Number number = getNumber(name);
        return number != null ? number.longValue() : fallback;
    }

    public double getDouble(String name, double fallback) {
        Number number = getNumber(name);
        return number != null ? number.doubleValue() : fallback;
    }

    public Number getNumber(String name) {
        NbtTag tag = values.get(name);
        if (tag instanceof NbtByte b) {
            return b.value();
        }
        if (tag instanceof NbtShort s) {
            return s.value();
        }
        if (tag instanceof NbtInt i) {
            return i.value();
        }
        if (tag instanceof NbtLong l) {
            return l.value();
        }
        if (tag instanceof NbtFloat f) {
            return f.value();
        }
        if (tag instanceof NbtDouble d) {
            return d.value();
        }
        return null;
    }

    public NbtCompound getCompound(String name) {
        NbtTag tag = values.get(name);
        if (tag instanceof NbtCompound compound) {
            return compound;
        }
        return null;
    }

    public NbtList getList(String name) {
        NbtTag tag = values.get(name);
        if (tag instanceof NbtList list) {
            return list;
        }
        return null;
    }

    public byte[] getByteArray(String name) {
        NbtTag tag = values.get(name);
        if (tag instanceof NbtByteArray array) {
            return array.value();
        }
        return null;
    }

    public int[] getIntArray(String name) {
        NbtTag tag = values.get(name);
        if (tag instanceof NbtIntArray array) {
            return array.value();
        }
        return null;
    }

    public long[] getLongArray(String name) {
        NbtTag tag = values.get(name);
        if (tag instanceof NbtLongArray array) {
            return array.value();
        }
        return null;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtDouble.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtDouble.java`  
- Size: 178 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

public record NbtDouble(double value) implements NbtTag {
    @Override
    public byte typeId() {
        return NbtType.DOUBLE;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtFloat.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtFloat.java`  
- Size: 175 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

public record NbtFloat(float value) implements NbtTag {
    @Override
    public byte typeId() {
        return NbtType.FLOAT;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtInt.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtInt.java`  
- Size: 169 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

public record NbtInt(int value) implements NbtTag {
    @Override
    public byte typeId() {
        return NbtType.INT;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtIntArray.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtIntArray.java`  
- Size: 182 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

public record NbtIntArray(int[] value) implements NbtTag {
    @Override
    public byte typeId() {
        return NbtType.INT_ARRAY;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtList.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtList.java`  
- Size: 1778 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class NbtList implements NbtTag {
    private final byte elementType;
    private final List<NbtTag> values;

    public NbtList(byte elementType, List<NbtTag> values) {
        this.elementType = elementType;
        this.values = new ArrayList<>(values);
    }

    @Override
    public byte typeId() {
        return NbtType.LIST;
    }

    public byte elementType() {
        return elementType;
    }

    public List<NbtTag> values() {
        return Collections.unmodifiableList(values);
    }

    public int size() {
        return values.size();
    }

    public NbtTag get(int index) {
        return values.get(index);
    }

    public List<NbtCompound> compounds() {
        List<NbtCompound> result = new ArrayList<>();
        for (NbtTag tag : values) {
            if (tag instanceof NbtCompound compound) {
                result.add(compound);
            }
        }
        return result;
    }

    public List<String> strings() {
        List<String> result = new ArrayList<>();
        for (NbtTag tag : values) {
            if (tag instanceof NbtString str) {
                result.add(str.value());
            }
        }
        return result;
    }

    public List<Double> doubles() {
        List<Double> result = new ArrayList<>();
        for (NbtTag tag : values) {
            if (tag instanceof NbtDouble dbl) {
                result.add(dbl.value());
            } else if (tag instanceof NbtFloat fl) {
                result.add((double) fl.value());
            } else if (tag instanceof NbtInt i) {
                result.add((double) i.value());
            }
        }
        return result;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtLong.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtLong.java`  
- Size: 172 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

public record NbtLong(long value) implements NbtTag {
    @Override
    public byte typeId() {
        return NbtType.LONG;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtLongArray.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtLongArray.java`  
- Size: 185 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

public record NbtLongArray(long[] value) implements NbtTag {
    @Override
    public byte typeId() {
        return NbtType.LONG_ARRAY;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtShort.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtShort.java`  
- Size: 175 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

public record NbtShort(short value) implements NbtTag {
    @Override
    public byte typeId() {
        return NbtType.SHORT;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtString.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtString.java`  
- Size: 178 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

public record NbtString(String value) implements NbtTag {
    @Override
    public byte typeId() {
        return NbtType.STRING;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtTag.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtTag.java`  
- Size: 87 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

public interface NbtTag {
    byte typeId();
}

```

## File: `src/main/java/com/example/rpg/schematic/nbt/NbtType.java`  
- Path: `src/main/java/com/example/rpg/schematic/nbt/NbtType.java`  
- Size: 637 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic.nbt;

public final class NbtType {
    public static final byte END = 0;
    public static final byte BYTE = 1;
    public static final byte SHORT = 2;
    public static final byte INT = 3;
    public static final byte LONG = 4;
    public static final byte FLOAT = 5;
    public static final byte DOUBLE = 6;
    public static final byte BYTE_ARRAY = 7;
    public static final byte STRING = 8;
    public static final byte LIST = 9;
    public static final byte COMPOUND = 10;
    public static final byte INT_ARRAY = 11;
    public static final byte LONG_ARRAY = 12;

    private NbtType() {
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/NbtIO.java`  
- Path: `src/main/java/com/example/rpg/schematic/NbtIO.java`  
- Size: 4056 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic;

import com.example.rpg.schematic.nbt.*;
import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PushbackInputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.GZIPInputStream;

public final class NbtIO {
    private NbtIO() {
    }

    public static NbtCompound read(File file) throws IOException {
        try (InputStream input = openInputStream(file);
             DataInputStream data = new DataInputStream(input)) {
            byte type = data.readByte();
            if (type != NbtType.COMPOUND) {
                throw new IOException("Root tag is not a compound");
            }
            data.readUTF();
            return readCompound(data);
        }
    }

    private static InputStream openInputStream(File file) throws IOException {
        InputStream input = new BufferedInputStream(new FileInputStream(file));
        PushbackInputStream pushback = new PushbackInputStream(input, 2);
        byte[] header = new byte[2];
        int read = pushback.read(header);
        if (read > 0) {
            pushback.unread(header, 0, read);
        }
        if (read == 2 && (header[0] == (byte) 0x1f && header[1] == (byte) 0x8b)) {
            return new GZIPInputStream(pushback);
        }
        return pushback;
    }

    private static NbtTag readTagPayload(DataInputStream data, byte type) throws IOException {
        return switch (type) {
            case NbtType.BYTE -> new NbtByte(data.readByte());
            case NbtType.SHORT -> new NbtShort(data.readShort());
            case NbtType.INT -> new NbtInt(data.readInt());
            case NbtType.LONG -> new NbtLong(data.readLong());
            case NbtType.FLOAT -> new NbtFloat(data.readFloat());
            case NbtType.DOUBLE -> new NbtDouble(data.readDouble());
            case NbtType.STRING -> new NbtString(data.readUTF());
            case NbtType.BYTE_ARRAY -> new NbtByteArray(readByteArray(data));
            case NbtType.INT_ARRAY -> new NbtIntArray(readIntArray(data));
            case NbtType.LONG_ARRAY -> new NbtLongArray(readLongArray(data));
            case NbtType.LIST -> readList(data);
            case NbtType.COMPOUND -> readCompound(data);
            default -> throw new IOException("Unsupported NBT tag type: " + type);
        };
    }

    private static byte[] readByteArray(DataInputStream data) throws IOException {
        int length = data.readInt();
        byte[] values = new byte[length];
        data.readFully(values);
        return values;
    }

    private static int[] readIntArray(DataInputStream data) throws IOException {
        int length = data.readInt();
        int[] values = new int[length];
        for (int i = 0; i < length; i++) {
            values[i] = data.readInt();
        }
        return values;
    }

    private static long[] readLongArray(DataInputStream data) throws IOException {
        int length = data.readInt();
        long[] values = new long[length];
        for (int i = 0; i < length; i++) {
            values[i] = data.readLong();
        }
        return values;
    }

    private static NbtList readList(DataInputStream data) throws IOException {
        byte elementType = data.readByte();
        int length = data.readInt();
        List<NbtTag> values = new ArrayList<>(length);
        for (int i = 0; i < length; i++) {
            values.add(readTagPayload(data, elementType));
        }
        return new NbtList(elementType, values);
    }

    private static NbtCompound readCompound(DataInputStream data) throws IOException {
        NbtCompound compound = new NbtCompound();
        while (true) {
            byte type = data.readByte();
            if (type == NbtType.END) {
                break;
            }
            String name = data.readUTF();
            compound.put(name, readTagPayload(data, type));
        }
        return compound;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/Schematic.java`  
- Path: `src/main/java/com/example/rpg/schematic/Schematic.java`  
- Size: 294 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic;

import com.example.rpg.schematic.nbt.NbtCompound;
import java.util.List;

public record Schematic(int width, int height, int length, BlockPalette palette, int[] blocks,
                        List<NbtCompound> blockEntities, List<NbtCompound> entities) {
}

```

## File: `src/main/java/com/example/rpg/schematic/SchematicPaster.java`  
- Path: `src/main/java/com/example/rpg/schematic/SchematicPaster.java`  
- Size: 8733 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic;

import com.example.rpg.schematic.nbt.NbtCompound;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.logging.Logger;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.block.data.BlockData;
import org.bukkit.block.data.Directional;
import org.bukkit.block.data.Rotatable;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.block.BlockFace;

public class SchematicPaster {
    public record PasteOptions(boolean includeAir, Transform transform, UndoBuffer undoBuffer) {
    }

    private final JavaPlugin plugin;
    private final Logger logger;

    public SchematicPaster(JavaPlugin plugin) {
        this.plugin = plugin;
        this.logger = plugin.getLogger();
    }

    public CompletableFuture<Void> pasteInBatches(World world, Location origin, Schematic schematic, PasteOptions options, int batchSize) {
        CompletableFuture<Void> future = new CompletableFuture<>();
        int width = schematic.width();
        int height = schematic.height();
        int length = schematic.length();
        int[] blocks = schematic.blocks();
        BlockPalette palette = schematic.palette();
        ensureChunksLoaded(world, origin, schematic, options.transform());
        Iterator<BlockPlacement> iterator = new BlockIterator(width, height, length, blocks, palette, options.transform());
        new BukkitRunnable() {
            @Override
            public void run() {
                int placed = 0;
                while (iterator.hasNext() && placed < batchSize) {
                    BlockPlacement placement = iterator.next();
                    if (placement.blockData() == null) {
                        logger.warning("Missing palette entry for block index.");
                        continue;
                    }
                    if (!options.includeAir() && placement.isAir()) {
                        continue;
                    }
                    Block block = world.getBlockAt(origin.getBlockX() + placement.x(), origin.getBlockY() + placement.y(), origin.getBlockZ() + placement.z());
                    try {
                        if (options.undoBuffer() != null) {
                            options.undoBuffer().add(block.getLocation(), block.getBlockData());
                        }
                        BlockData data = Bukkit.createBlockData(placement.blockData());
                        data = rotateBlockData(data, options.transform().rotation());
                        block.setBlockData(data, false);
                    } catch (IllegalArgumentException ex) {
                        logger.warning("Invalid block data: " + placement.blockData());
                    }
                    placed++;
                }
                if (!iterator.hasNext()) {
                    applyBlockEntities(world, origin, schematic, options.transform());
                    spawnEntities(world, origin, schematic, options.transform());
                    future.complete(null);
                    cancel();
                }
            }
        }.runTaskTimer(plugin, 1L, 1L);
        return future;
    }

    private void applyBlockEntities(World world, Location origin, Schematic schematic, Transform transform) {
        List<NbtCompound> blockEntities = schematic.blockEntities();
        if (blockEntities == null || blockEntities.isEmpty()) {
            return;
        }
        BlockEntityApplier applier = new BlockEntityApplier(logger);
        for (NbtCompound blockEntity : blockEntities) {
            applier.apply(world, origin, blockEntity, transform, schematic.width(), schematic.length());
        }
    }

    private void spawnEntities(World world, Location origin, Schematic schematic, Transform transform) {
        List<NbtCompound> entities = schematic.entities();
        if (entities == null || entities.isEmpty()) {
            return;
        }
        EntitySpawner spawner = new EntitySpawner(logger);
        for (NbtCompound entity : entities) {
            spawner.spawn(world, origin, entity, transform, schematic.width(), schematic.length());
        }
    }

    private void ensureChunksLoaded(World world, Location origin, Schematic schematic, Transform transform) {
        int width = schematic.width();
        int length = schematic.length();
        int[] min = transform.apply(0, 0, 0, width, length);
        int[] max = transform.apply(width - 1, 0, length - 1, width, length);
        int minX = Math.min(min[0], max[0]) + origin.getBlockX();
        int maxX = Math.max(min[0], max[0]) + origin.getBlockX();
        int minZ = Math.min(min[2], max[2]) + origin.getBlockZ();
        int maxZ = Math.max(min[2], max[2]) + origin.getBlockZ();
        for (int x = minX >> 4; x <= maxX >> 4; x++) {
            for (int z = minZ >> 4; z <= maxZ >> 4; z++) {
                if (!world.isChunkLoaded(x, z)) {
                    world.getChunkAt(x, z);
                }
            }
        }
    }

    private static class BlockPlacement {
        private final int x;
        private final int y;
        private final int z;
        private final String blockData;
        private final boolean air;

        private BlockPlacement(int x, int y, int z, String blockData) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.blockData = blockData;
            this.air = blockData != null && (blockData.equals("minecraft:air") || blockData.equals("minecraft:cave_air")
                || blockData.equals("minecraft:void_air"));
        }

        public int x() {
            return x;
        }

        public int y() {
            return y;
        }

        public int z() {
            return z;
        }

        public String blockData() {
            return blockData;
        }

        public boolean isAir() {
            return air;
        }
    }

    private static class BlockIterator implements Iterator<BlockPlacement> {
        private final int width;
        private final int height;
        private final int length;
        private final int[] blocks;
        private final BlockPalette palette;
        private final Transform transform;
        private int index;

        private BlockIterator(int width, int height, int length, int[] blocks, BlockPalette palette, Transform transform) {
            this.width = width;
            this.height = height;
            this.length = length;
            this.blocks = blocks;
            this.palette = palette;
            this.transform = transform;
        }

        @Override
        public boolean hasNext() {
            return index < blocks.length;
        }

        @Override
        public BlockPlacement next() {
            int i = index++;
            int x = i % width;
            int z = (i / width) % length;
            int y = i / (width * length);
            int[] transformed = transform.apply(x, y, z, width, length);
            String blockData = palette.getState(blocks[i]);
            return new BlockPlacement(transformed[0], transformed[1], transformed[2], blockData);
        }
    }

    private BlockData rotateBlockData(BlockData data, Transform.Rotation rotation) {
        if (rotation == Transform.Rotation.NONE) {
            return data;
        }
        if (data instanceof Directional directional) {
            BlockFace face = directional.getFacing();
            BlockFace rotated = rotateFace(face, rotation);
            if (rotated != null) {
                directional.setFacing(rotated);
            }
        } else if (data instanceof Rotatable rotatable) {
            BlockFace face = rotatable.getRotation();
            BlockFace rotated = rotateFace(face, rotation);
            if (rotated != null) {
                rotatable.setRotation(rotated);
            }
        }
        return data;
    }

    private BlockFace rotateFace(BlockFace face, Transform.Rotation rotation) {
        if (face == null) {
            return null;
        }
        return switch (rotation) {
            case CLOCKWISE_90 -> rotateOnce(face);
            case CLOCKWISE_180 -> rotateOnce(rotateOnce(face));
            case CLOCKWISE_270 -> rotateOnce(rotateOnce(rotateOnce(face)));
            default -> face;
        };
    }

    private BlockFace rotateOnce(BlockFace face) {
        return switch (face) {
            case NORTH -> BlockFace.EAST;
            case EAST -> BlockFace.SOUTH;
            case SOUTH -> BlockFace.WEST;
            case WEST -> BlockFace.NORTH;
            default -> face;
        };
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/SpongeSchemLoader.java`  
- Path: `src/main/java/com/example/rpg/schematic/SpongeSchemLoader.java`  
- Size: 4345 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic;

import com.example.rpg.schematic.nbt.NbtCompound;
import com.example.rpg.schematic.nbt.NbtList;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SpongeSchemLoader {
    public Schematic load(File file) throws IOException {
        NbtCompound root = NbtIO.read(file);
        int width = root.getInt("Width", -1);
        int height = root.getInt("Height", -1);
        int length = root.getInt("Length", -1);
        if (width <= 0 || height <= 0 || length <= 0) {
            throw new IOException("Unsupported schematic format");
        }
        NbtCompound paletteTag = root.getCompound("Palette");
        if (paletteTag == null) {
            throw new IOException("Unsupported schematic format");
        }
        Map<Integer, String> paletteMap = new HashMap<>();
        for (var entry : paletteTag.values().entrySet()) {
            String blockState = entry.getKey();
            var tag = entry.getValue();
            if (tag instanceof com.example.rpg.schematic.nbt.NbtInt nbtInt) {
                paletteMap.put(nbtInt.value(), blockState);
            } else if (tag instanceof com.example.rpg.schematic.nbt.NbtShort nbtShort) {
                paletteMap.put((int) nbtShort.value(), blockState);
            }
        }
        BlockPalette palette = new BlockPalette(paletteMap);
        int total = width * height * length;
        int[] blocks = readBlocks(root, palette.size(), total);
        if (blocks.length != total) {
            throw new IOException("Unsupported schematic format");
        }
        List<NbtCompound> blockEntities = List.of();
        List<NbtCompound> entities = List.of();
        NbtList blockEntityList = root.getList("BlockEntities");
        if (blockEntityList != null) {
            blockEntities = blockEntityList.compounds();
        }
        NbtList entityList = root.getList("Entities");
        if (entityList != null) {
            entities = entityList.compounds();
        }
        return new Schematic(width, height, length, palette, blocks, blockEntities, entities);
    }

    private int[] readBlocks(NbtCompound root, int paletteSize, int totalBlocks) throws IOException {
        byte[] byteData = root.getByteArray("BlockData");
        if (byteData != null) {
            return decodeVarIntArray(byteData, totalBlocks);
        }
        long[] longData = root.getLongArray("BlockData");
        if (longData != null) {
            int bits = Math.max(4, 32 - Integer.numberOfLeadingZeros(Math.max(paletteSize - 1, 1)));
            return unpackLongArray(longData, bits, totalBlocks);
        }
        throw new IOException("Unsupported schematic format");
    }

    private int[] decodeVarIntArray(byte[] data, int expected) throws IOException {
        int[] values = new int[expected];
        int index = 0;
        int i = 0;
        while (i < data.length && index < expected) {
            int value = 0;
            int position = 0;
            byte current;
            do {
                if (i >= data.length) {
                    throw new IOException("Unexpected end of block data");
                }
                current = data[i++];
                value |= (current & 0x7F) << position;
                position += 7;
            } while ((current & 0x80) != 0);
            values[index++] = value;
        }
        if (index != expected) {
            throw new IOException("Block data length mismatch");
        }
        return values;
    }

    private int[] unpackLongArray(long[] data, int bits, int expected) {
        int[] values = new int[expected];
        long mask = (1L << bits) - 1L;
        int index = 0;
        int bitIndex = 0;
        while (index < expected) {
            int startLong = bitIndex >> 6;
            int startOffset = bitIndex & 63;
            if (startLong >= data.length) {
                break;
            }
            long value = data[startLong] >>> startOffset;
            int bitsLeft = 64 - startOffset;
            if (bitsLeft < bits && startLong + 1 < data.length) {
                value |= data[startLong + 1] << bitsLeft;
            }
            values[index++] = (int) (value & mask);
            bitIndex += bits;
        }
        return values;
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/Transform.java`  
- Path: `src/main/java/com/example/rpg/schematic/Transform.java`  
- Size: 1368 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic;

public class Transform {
    public enum Rotation {
        NONE,
        CLOCKWISE_90,
        CLOCKWISE_180,
        CLOCKWISE_270
    }

    private final Rotation rotation;
    private final int offsetX;
    private final int offsetY;
    private final int offsetZ;

    public Transform(Rotation rotation, int offsetX, int offsetY, int offsetZ) {
        this.rotation = rotation;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.offsetZ = offsetZ;
    }

    public Rotation rotation() {
        return rotation;
    }

    public int offsetX() {
        return offsetX;
    }

    public int offsetY() {
        return offsetY;
    }

    public int offsetZ() {
        return offsetZ;
    }

    public int[] apply(int x, int y, int z, int width, int length) {
        int rx = x;
        int rz = z;
        switch (rotation) {
            case CLOCKWISE_90 -> {
                rx = length - 1 - z;
                rz = x;
            }
            case CLOCKWISE_180 -> {
                rx = width - 1 - x;
                rz = length - 1 - z;
            }
            case CLOCKWISE_270 -> {
                rx = z;
                rz = width - 1 - x;
            }
            default -> {
            }
        }
        return new int[]{rx + offsetX, y + offsetY, rz + offsetZ};
    }
}

```

## File: `src/main/java/com/example/rpg/schematic/UndoBuffer.java`  
- Path: `src/main/java/com/example/rpg/schematic/UndoBuffer.java`  
- Size: 589 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.schematic;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.bukkit.Location;
import org.bukkit.block.data.BlockData;

public class UndoBuffer {
    public record BlockSnapshot(Location location, BlockData data) {
    }

    private final List<BlockSnapshot> snapshots = new ArrayList<>();

    public void add(Location location, BlockData data) {
        snapshots.add(new BlockSnapshot(location, data));
    }

    public List<BlockSnapshot> snapshots() {
        return Collections.unmodifiableList(snapshots);
    }
}

```

## File: `src/main/java/com/example/rpg/skill/effects/AggroEffect.java`  
- Path: `src/main/java/com/example/rpg/skill/effects/AggroEffect.java`  
- Size: 861 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.skill.effects;

import com.example.rpg.model.PlayerProfile;
import com.example.rpg.skill.SkillEffect;
import java.util.Map;
import org.bukkit.entity.Mob;
import org.bukkit.entity.Player;

public class AggroEffect implements SkillEffect {
    @Override
    public void apply(Player player, PlayerProfile profile, Map<String, Object> params) {
        double radius = parseDouble(params.getOrDefault("radius", 8));
        player.getNearbyEntities(radius, radius, radius).stream()
            .filter(entity -> entity instanceof Mob)
            .map(entity -> (Mob) entity)
            .forEach(mob -> mob.setTarget(player));
    }

    private double parseDouble(Object raw) {
        try {
            return Double.parseDouble(String.valueOf(raw));
        } catch (NumberFormatException e) {
            return 8.0;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/skill/effects/DamageEffect.java`  
- Path: `src/main/java/com/example/rpg/skill/effects/DamageEffect.java`  
- Size: 1982 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.skill.effects;

import com.example.rpg.model.PlayerProfile;
import com.example.rpg.skill.SkillEffect;
import java.util.Comparator;
import java.util.Map;
import org.bukkit.entity.Entity;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;

public class DamageEffect implements SkillEffect {
    @Override
    public void apply(Player player, PlayerProfile profile, Map<String, Object> params) {
        double amount = parseDouble(params.getOrDefault("amount", 4));
        double radius = parseDouble(params.getOrDefault("radius", 0));
        int maxTargets = parseInt(params.getOrDefault("maxTargets", 1));
        if (radius > 0) {
            player.getNearbyEntities(radius, radius, radius).stream()
                .filter(entity -> entity instanceof LivingEntity && !(entity instanceof Player))
                .sorted(Comparator.comparingDouble(entity -> entity.getLocation().distanceSquared(player.getLocation())))
                .limit(Math.max(1, maxTargets))
                .map(entity -> (LivingEntity) entity)
                .forEach(target -> target.damage(amount, player));
            return;
        }

        Entity target = player.getNearbyEntities(3, 2, 3).stream()
            .filter(entity -> entity instanceof LivingEntity && !(entity instanceof Player))
            .min(Comparator.comparingDouble(entity -> entity.getLocation().distanceSquared(player.getLocation())))
            .orElse(null);
        if (target instanceof LivingEntity living) {
            living.damage(amount, player);
        }
    }

    private double parseDouble(Object raw) {
        try {
            return Double.parseDouble(String.valueOf(raw));
        } catch (NumberFormatException e) {
            return 0.0;
        }
    }

    private int parseInt(Object raw) {
        try {
            return Integer.parseInt(String.valueOf(raw));
        } catch (NumberFormatException e) {
            return 1;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/skill/effects/HealEffect.java`  
- Path: `src/main/java/com/example/rpg/skill/effects/HealEffect.java`  
- Size: 951 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.skill.effects;

import com.example.rpg.model.PlayerProfile;
import com.example.rpg.skill.SkillEffect;
import java.util.Map;
import org.bukkit.attribute.Attribute;
import org.bukkit.entity.Player;

public class HealEffect implements SkillEffect {
    @Override
    public void apply(Player player, PlayerProfile profile, Map<String, Object> params) {
        double amount = parseDouble(params.getOrDefault("amount", 4));
        double maxHealth = player.getAttribute(Attribute.GENERIC_MAX_HEALTH) != null
            ? player.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue()
            : 20.0;
        double newHealth = Math.min(maxHealth, player.getHealth() + amount);
        player.setHealth(newHealth);
    }

    private double parseDouble(Object raw) {
        try {
            return Double.parseDouble(String.valueOf(raw));
        } catch (NumberFormatException e) {
            return 0.0;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/skill/effects/ParticleEffect.java`  
- Path: `src/main/java/com/example/rpg/skill/effects/ParticleEffect.java`  
- Size: 1310 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.skill.effects;

import com.example.rpg.model.PlayerProfile;
import com.example.rpg.skill.SkillEffect;
import java.util.Map;
import org.bukkit.Particle;
import org.bukkit.entity.Player;

public class ParticleEffect implements SkillEffect {
    @Override
    public void apply(Player player, PlayerProfile profile, Map<String, Object> params) {
        String typeName = String.valueOf(params.getOrDefault("type", "SPELL")).toUpperCase();
        int count = parseInt(params.getOrDefault("count", 10));
        double speed = parseDouble(params.getOrDefault("speed", 0.01));
        Particle particle;
        try {
            particle = Particle.valueOf(typeName);
        } catch (IllegalArgumentException e) {
            particle = Particle.SPELL;
        }
        player.getWorld().spawnParticle(particle, player.getLocation().add(0, 1.0, 0), count, 0.3, 0.6, 0.3, speed);
    }

    private int parseInt(Object raw) {
        try {
            return Integer.parseInt(String.valueOf(raw));
        } catch (NumberFormatException e) {
            return 10;
        }
    }

    private double parseDouble(Object raw) {
        try {
            return Double.parseDouble(String.valueOf(raw));
        } catch (NumberFormatException e) {
            return 0.01;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/skill/effects/PotionStatusEffect.java`  
- Path: `src/main/java/com/example/rpg/skill/effects/PotionStatusEffect.java`  
- Size: 1734 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.skill.effects;

import com.example.rpg.model.PlayerProfile;
import com.example.rpg.skill.SkillEffect;
import java.util.Map;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;

public class PotionStatusEffect implements SkillEffect {
    @Override
    public void apply(Player player, PlayerProfile profile, Map<String, Object> params) {
        String typeName = String.valueOf(params.getOrDefault("type", "SPEED")).toUpperCase();
        int duration = parseInt(params.getOrDefault("duration", 100));
        int amplifier = parseInt(params.getOrDefault("amplifier", 0));
        double radius = parseDouble(params.getOrDefault("radius", 0));
        PotionEffectType type = PotionEffectType.getByName(typeName);
        if (type == null) {
            return;
        }
        PotionEffect effect = new PotionEffect(type, duration, amplifier);
        if (radius > 0) {
            player.getNearbyEntities(radius, radius, radius).stream()
                .filter(entity -> entity instanceof LivingEntity)
                .map(entity -> (LivingEntity) entity)
                .forEach(target -> target.addPotionEffect(effect));
            return;
        }
        player.addPotionEffect(effect);
    }

    private int parseInt(Object raw) {
        try {
            return Integer.parseInt(String.valueOf(raw));
        } catch (NumberFormatException e) {
            return 0;
        }
    }

    private double parseDouble(Object raw) {
        try {
            return Double.parseDouble(String.valueOf(raw));
        } catch (NumberFormatException e) {
            return 0.0;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/skill/effects/ProjectileEffect.java`  
- Path: `src/main/java/com/example/rpg/skill/effects/ProjectileEffect.java`  
- Size: 770 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.skill.effects;

import com.example.rpg.model.PlayerProfile;
import com.example.rpg.skill.SkillEffect;
import java.util.Map;
import org.bukkit.entity.Player;
import org.bukkit.entity.SmallFireball;
import org.bukkit.entity.Snowball;

public class ProjectileEffect implements SkillEffect {
    @Override
    public void apply(Player player, PlayerProfile profile, Map<String, Object> params) {
        String type = String.valueOf(params.getOrDefault("type", "SNOWBALL")).toUpperCase();
        switch (type) {
            case "SMALL_FIREBALL" -> player.launchProjectile(SmallFireball.class);
            case "SNOWBALL" -> player.launchProjectile(Snowball.class);
            default -> player.launchProjectile(Snowball.class);
        }
    }
}

```

## File: `src/main/java/com/example/rpg/skill/effects/SoundEffect.java`  
- Path: `src/main/java/com/example/rpg/skill/effects/SoundEffect.java`  
- Size: 1090 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.skill.effects;

import com.example.rpg.model.PlayerProfile;
import com.example.rpg.skill.SkillEffect;
import java.util.Map;
import org.bukkit.Sound;
import org.bukkit.entity.Player;

public class SoundEffect implements SkillEffect {
    @Override
    public void apply(Player player, PlayerProfile profile, Map<String, Object> params) {
        String soundName = String.valueOf(params.getOrDefault("sound", "ENTITY_PLAYER_LEVELUP")).toUpperCase();
        float volume = parseFloat(params.getOrDefault("volume", 1.0));
        float pitch = parseFloat(params.getOrDefault("pitch", 1.0));
        Sound sound;
        try {
            sound = Sound.valueOf(soundName);
        } catch (IllegalArgumentException e) {
            sound = Sound.ENTITY_PLAYER_LEVELUP;
        }
        player.getWorld().playSound(player.getLocation(), sound, volume, pitch);
    }

    private float parseFloat(Object raw) {
        try {
            return Float.parseFloat(String.valueOf(raw));
        } catch (NumberFormatException e) {
            return 1.0f;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/skill/effects/VelocityEffect.java`  
- Path: `src/main/java/com/example/rpg/skill/effects/VelocityEffect.java`  
- Size: 1173 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.skill.effects;

import com.example.rpg.model.PlayerProfile;
import com.example.rpg.skill.SkillEffect;
import java.util.Map;
import org.bukkit.entity.Player;
import org.bukkit.util.Vector;

public class VelocityEffect implements SkillEffect {
    @Override
    public void apply(Player player, PlayerProfile profile, Map<String, Object> params) {
        double forward = parseDouble(params.getOrDefault("forward", 1.2));
        double up = parseDouble(params.getOrDefault("up", 0.3));
        boolean add = parseBoolean(params.getOrDefault("add", false));
        Vector direction = player.getLocation().getDirection().multiply(forward);
        direction.setY(up);
        if (add) {
            player.setVelocity(player.getVelocity().add(direction));
        } else {
            player.setVelocity(direction);
        }
    }

    private double parseDouble(Object raw) {
        try {
            return Double.parseDouble(String.valueOf(raw));
        } catch (NumberFormatException e) {
            return 0.0;
        }
    }

    private boolean parseBoolean(Object raw) {
        return Boolean.parseBoolean(String.valueOf(raw));
    }
}

```

## File: `src/main/java/com/example/rpg/skill/effects/XpEffect.java`  
- Path: `src/main/java/com/example/rpg/skill/effects/XpEffect.java`  
- Size: 671 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.skill.effects;

import com.example.rpg.model.PlayerProfile;
import com.example.rpg.skill.SkillEffect;
import java.util.Map;
import org.bukkit.entity.Player;

public class XpEffect implements SkillEffect {
    @Override
    public void apply(Player player, PlayerProfile profile, Map<String, Object> params) {
        int amount = parseInt(params.getOrDefault("amount", 0));
        if (amount > 0) {
            profile.addXp(amount);
        }
    }

    private int parseInt(Object raw) {
        try {
            return Integer.parseInt(String.valueOf(raw));
        } catch (NumberFormatException e) {
            return 0;
        }
    }
}

```

## File: `src/main/java/com/example/rpg/skill/SkillEffect.java`  
- Path: `src/main/java/com/example/rpg/skill/SkillEffect.java`  
- Size: 413 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.skill;

import com.example.rpg.model.PlayerProfile;
import java.util.List;
import java.util.Map;
import net.kyori.adventure.text.Component;
import org.bukkit.entity.Player;

public interface SkillEffect {
    void apply(Player player, PlayerProfile profile, Map<String, Object> params);

    default List<Component> describe(Map<String, Object> params) {
        return List.of();
    }
}

```

## File: `src/main/java/com/example/rpg/skill/SkillEffectConfig.java`  
- Path: `src/main/java/com/example/rpg/skill/SkillEffectConfig.java`  
- Size: 1076 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.skill;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

public class SkillEffectConfig {
    private SkillEffectType type;
    private Map<String, Object> params = new HashMap<>();

    public SkillEffectConfig(SkillEffectType type, Map<String, Object> params) {
        this.type = type;
        if (params != null) {
            this.params.putAll(params);
        }
    }

    public SkillEffectType type() {
        return type;
    }

    public void setType(SkillEffectType type) {
        this.type = type;
    }

    public Map<String, Object> params() {
        return params;
    }

    public void setParams(Map<String, Object> params) {
        this.params = params;
    }

    public String describe() {
        if (params.isEmpty()) {
            return type.name();
        }
        String joined = params.entrySet().stream()
            .map(entry -> entry.getKey() + "=" + entry.getValue())
            .collect(Collectors.joining(", "));
        return type.name() + " (" + joined + ")";
    }
}

```

## File: `src/main/java/com/example/rpg/skill/SkillEffectRegistry.java`  
- Path: `src/main/java/com/example/rpg/skill/SkillEffectRegistry.java`  
- Size: 695 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.skill;

import java.util.EnumMap;
import java.util.Map;

public class SkillEffectRegistry {
    private final Map<SkillEffectType, SkillEffect> effects = new EnumMap<>(SkillEffectType.class);

    public SkillEffectRegistry register(SkillEffectType type, SkillEffect effect) {
        effects.put(type, effect);
        return this;
    }

    public void apply(SkillEffectConfig config, org.bukkit.entity.Player player,
                      com.example.rpg.model.PlayerProfile profile) {
        SkillEffect effect = effects.get(config.type());
        if (effect == null) {
            return;
        }
        effect.apply(player, profile, config.params());
    }
}

```

## File: `src/main/java/com/example/rpg/skill/SkillEffectType.java`  
- Path: `src/main/java/com/example/rpg/skill/SkillEffectType.java`  
- Size: 171 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.skill;

public enum SkillEffectType {
    HEAL,
    DAMAGE,
    PROJECTILE,
    POTION,
    SOUND,
    XP,
    PARTICLE,
    VELOCITY,
    AGGRO
}

```

## File: `src/main/java/com/example/rpg/util/AuditLog.java`  
- Path: `src/main/java/com/example/rpg/util/AuditLog.java`  
- Size: 844 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.util;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.Instant;
import org.bukkit.command.CommandSender;
import org.bukkit.plugin.java.JavaPlugin;

public class AuditLog {
    private final File file;
    private final JavaPlugin plugin;

    public AuditLog(JavaPlugin plugin) {
        this.plugin = plugin;
        this.file = new File(plugin.getDataFolder(), "audit.log");
    }

    public void log(CommandSender sender, String action) {
        String line = Instant.now() + " | " + sender.getName() + " | " + action + System.lineSeparator();
        try (FileWriter writer = new FileWriter(file, true)) {
            writer.write(line);
        } catch (IOException e) {
            plugin.getLogger().warning("Audit log failed: " + e.getMessage());
        }
    }
}

```

## File: `src/main/java/com/example/rpg/util/EloCalculator.java`  
- Path: `src/main/java/com/example/rpg/util/EloCalculator.java`  
- Size: 371 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.util;

public final class EloCalculator {
    private EloCalculator() {}

    public static int calculateNewRating(int rating, int opponentRating, double score, int kFactor) {
        double expected = 1.0 / (1.0 + Math.pow(10.0, (opponentRating - rating) / 400.0));
        return (int) Math.round(rating + kFactor * (score - expected));
    }
}

```

## File: `src/main/java/com/example/rpg/util/ItemBuilder.java`  
- Path: `src/main/java/com/example/rpg/util/ItemBuilder.java`  
- Size: 1085 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.util;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import net.kyori.adventure.text.Component;
import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

public class ItemBuilder {
    private final ItemStack item;
    private final ItemMeta meta;
    private final List<Component> lore = new ArrayList<>();

    public ItemBuilder(Material material) {
        this.item = new ItemStack(material);
        this.meta = item.getItemMeta();
    }

    public ItemBuilder name(Component name) {
        meta.displayName(name);
        return this;
    }

    public ItemBuilder loreLine(Component line) {
        lore.add(line);
        return this;
    }

    public ItemBuilder loreLines(List<Component> lines) {
        lore.addAll(lines);
        return this;
    }

    public ItemStack build() {
        if (!lore.isEmpty()) {
            meta.lore(lore.stream().collect(Collectors.toList()));
        }
        item.setItemMeta(meta);
        return item;
    }
}

```

## File: `src/main/java/com/example/rpg/util/ItemGenerator.java`  
- Path: `src/main/java/com/example/rpg/util/ItemGenerator.java`  
- Size: 1772 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.util;

import com.example.rpg.model.Rarity;
import java.util.List;
import java.util.Random;
import net.kyori.adventure.text.Component;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataType;
import org.bukkit.plugin.java.JavaPlugin;

public class ItemGenerator {
    private final Random random = new Random();
    private final NamespacedKey itemKey;
    private final NamespacedKey rarityKey;
    private final com.example.rpg.manager.ItemStatManager itemStatManager;

    public ItemGenerator(JavaPlugin plugin, com.example.rpg.manager.ItemStatManager itemStatManager) {
        this.itemKey = new NamespacedKey(plugin, "rpg_item");
        this.rarityKey = new NamespacedKey(plugin, "rpg_rarity");
        this.itemStatManager = itemStatManager;
    }

    public ItemStack createRpgItem(Material material, Rarity rarity, int minLevel) {
        ItemStack item = new ItemStack(material);
        ItemMeta meta = item.getItemMeta();
        meta.displayName(Component.text(rarity.name() + " " + material.name()).color(rarity.color()));
        meta.lore(List.of(
            Component.text("Rarity: " + rarity.name()).color(rarity.color()),
            Component.text("Level " + minLevel)
        ));
        meta.getPersistentDataContainer().set(itemKey, PersistentDataType.INTEGER, 1);
        meta.getPersistentDataContainer().set(rarityKey, PersistentDataType.STRING, rarity.name());
        item.setItemMeta(meta);
        itemStatManager.applyAffixes(item);
        item.setAmount(1 + random.nextInt(1));
        return item;
    }

    public NamespacedKey itemKey() {
        return itemKey;
    }
}

```

## File: `src/main/java/com/example/rpg/util/PromptManager.java`  
- Path: `src/main/java/com/example/rpg/util/PromptManager.java`  
- Size: 853 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.util;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Consumer;
import net.kyori.adventure.text.Component;
import org.bukkit.entity.Player;

public class PromptManager {
    private final Map<UUID, Consumer<String>> prompts = new HashMap<>();

    public void prompt(Player player, Component message, Consumer<String> handler) {
        prompts.put(player.getUniqueId(), handler);
        player.sendMessage(message);
    }

    public boolean handle(Player player, String message) {
        Consumer<String> handler = prompts.remove(player.getUniqueId());
        if (handler == null) {
            return false;
        }
        handler.accept(message);
        return true;
    }

    public void cancel(Player player) {
        prompts.remove(player.getUniqueId());
    }
}

```

## File: `src/main/java/com/example/rpg/util/Text.java`  
- Path: `src/main/java/com/example/rpg/util/Text.java`  
- Size: 353 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.util;

import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.minimessage.MiniMessage;

public final class Text {
    private static final MiniMessage MINI = MiniMessage.miniMessage();

    private Text() {
    }

    public static Component mm(String input) {
        return MINI.deserialize(input);
    }
}

```

## File: `src/main/java/com/example/rpg/util/WorldUtils.java`  
- Path: `src/main/java/com/example/rpg/util/WorldUtils.java`  
- Size: 1405 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```java
package com.example.rpg.util;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Comparator;
import java.util.stream.Stream;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.entity.Player;

public class WorldUtils {
    public static void unloadAndDeleteWorld(World world, Location fallback) {
        if (world == null) {
            return;
        }

        for (Player player : world.getPlayers()) {
            if (fallback != null) {
                player.teleport(fallback);
            } else if (!Bukkit.getWorlds().isEmpty()) {
                player.teleport(Bukkit.getWorlds().get(0).getSpawnLocation());
            }
            player.sendMessage(Text.mm("<yellow>Der Dungeon lst sich auf..."));
        }

        Bukkit.unloadWorld(world, false);
        File worldFolder = world.getWorldFolder();
        deleteDirectory(worldFolder);
    }

    private static void deleteDirectory(File directory) {
        if (directory == null || !directory.exists()) {
            return;
        }
        try (Stream<Path> walk = Files.walk(directory.toPath())) {
            walk.sorted(Comparator.reverseOrder())
                .map(Path::toFile)
                .forEach(File::delete);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

## File: `src/main/resources/buildings.yml`  
- Path: `src/main/resources/buildings.yml`  
- Size: 1055 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
buildings:
  cottage:
    name: "Kleines Wohnhaus"
    category: RESIDENTIAL
    schematic: "cottage_ground.schem"
    floorSchematic: "cottage_floor.schem"
    minFloors: 1
    maxFloors: 2
    floorHeight: 5
    basement:
      schematic: "cottage_basement.schem"
      depth: 4
    offset:
      x: 0
      y: 0
      z: 0
    furniture:
      - schematic: "cottage_furniture.schem"
        x: 0
        y: 0
        z: 0
        rotation: 0
  market:
    name: "Marktstand"
    category: SHOP
    schematic: "market_stall.schem"
    minFloors: 1
    maxFloors: 1
    floorHeight: 4
  townhall:
    name: "Rathaus"
    category: PUBLIC
    schematic: "townhall_ground.schem"
    floorSchematic: "townhall_floor.schem"
    minFloors: 2
    maxFloors: 3
    floorHeight: 6
  forge:
    name: "Schmiede"
    category: CRAFTING
    schematic: "forge.schem"
    minFloors: 1
    maxFloors: 1
    floorHeight: 5
  testhouse:
    name: "Testhaus"
    category: RESIDENTIAL
    schematic: "testhouse.schem"
    minFloors: 1
    maxFloors: 1
    floorHeight: 5

```

## File: `src/main/resources/config.yml`  
- Path: `src/main/resources/config.yml`  
- Size: 1259 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
rpg:
  dataVersion: 1
  xp:
    mobBase: 10
    blockBreak: 1
    craft: 2
  manaRegenPerTick: 5
  party:
    xpSplit: true
lootchat:
  enabled: true
database:
  host: localhost
  port: 5432
  name: rpg
  user: rpg
  password: minecraft
  poolSize: 10
permissions:
  enabled: true
  defaultRole: player
  opBypass: true
  defaultDecision: DENY
  auditEnabled: true
  cacheTtlSeconds: 30
dungeon:
  wfc:
    width: 10
    height: 3
    depth: 10
    originY: 150
    boundaryHeight: 10
  fixedBaseY: 150
  seed: 424242
  roomCount: 12
  roomMinSize: [7, 7]
  roomMaxSize: [13, 13]
  corridorWidth: 3
  wallBlock: STONE_BRICKS
  floorBlock: DEEPSLATE_TILES
  door: OAK_DOOR
  light: SOUL_LANTERN
  water:
    enabled: true
    canalChance: 0.25
    floodRoomChance: 0.05
  mobs:
    enabled: true
    perCombatRoom: [2, 5]
    eliteChance: 0.15
    bossEnabled: true
  loot:
    enabled: true
    chestsPerLootRoom: [1, 3]
    table: "wcf_dungeon_default"
  debug:
    enabled: false
  themes:
    crypt:
      floor_material: STONE_BRICKS
      wall_material: COBBLESTONE
      corridor_material: COBBLESTONE
  entrance:
    world: world
    x: 0
    y: 64
    z: 0
  exit:
    world: world
    x: 0
    y: 64
    z: 0
building:
  schematicsFolder: schematics

```

## File: `src/main/resources/enchantments.yml`  
- Path: `src/main/resources/enchantments.yml`  
- Size: 715 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
RuneOfStrength:
  type: STAT_UPGRADE
  targetSlot: HAND
  statToImprove: STRENGTH
  minLevel: 1
  costGold: 250
  costItem: IRON_NUGGET:1
  effects:
    - type: SOUND
      params: { sound: ENTITY_PLAYER_LEVELUP, volume: 1.0, pitch: 1.5 }
RuneOfConstitution:
  type: STAT_UPGRADE
  targetSlot: ARMOR_CHEST
  statToImprove: CONSTITUTION
  minLevel: 1
  costGold: 200
  costItem: IRON_NUGGET:2
  effects:
    - type: SOUND
      params: { sound: ENTITY_ANVIL_USE, volume: 1.0, pitch: 1.2 }
RuneOfPrecision:
  type: AFFIX
  targetSlot: HAND
  affix: Praezision
  minLevel: 2
  costGold: 300
  costItem: GOLD_NUGGET:1
  effects:
    - type: SOUND
      params: { sound: ENTITY_PLAYER_LEVELUP, volume: 1.0, pitch: 1.8 }

```

## File: `src/main/resources/plugin.yml`  
- Path: `src/main/resources/plugin.yml`  
- Size: 1856 Bytes  
- Modified: 2025-12-27 12:36:42 UTC

```yaml
name: MineLauncherRPG
main: com.example.rpg.RPGPlugin
version: 1.0.0
author: LauncherTeam
api-version: 1.20
commands:
  rpg:
    description: Open RPG menu and use RPG commands
    usage: /rpg
  rpgadmin:
    description: Open RPG admin tools
    usage: /rpgadmin
  party:
    description: Party management
    usage: /party
  p:
    description: Party chat shortcut
    usage: /p <message>
  auction:
    description: Auction house
    usage: /auction <list|sell|buy>
  trade:
    description: Player trade
    usage: /trade <request|accept|offer|requestgold|ready|cancel>
  dungeon:
    description: Dungeon management
    usage: /dungeon <enter|leave|generate|queue|role|leavequeue>
  guild:
    description: Guild management
    usage: /guild <create|invite|accept|leave|disband|info|chat|bank|quest|hall>
  g:
    description: Guild chat shortcut
    usage: /g <message>
  pvp:
    description: PvP arenas
    usage: /pvp <join|top|season>
  behavior:
    description: Behavior tree editor
    usage: /behavior edit <tree>
  lootchat:
    description: Toggle loot chat
    usage: /lootchat [true|false]
  voicechat:
    description: Voice chat channels
    usage: /voicechat <party|guild|leave>
permissions:
  rpg.admin.*:
    description: Full RPG admin permissions
    default: op
    children:
      rpg.admin: true
      rpg.editor: true
      rpg.debug: true
  rpg.editor.*:
    description: Full RPG editor permissions
    default: op
    children:
      rpg.editor: true
  rpg.mod.*:
    description: RPG moderation permissions
    default: op
    children:
      rpg.mod: true
  rpg.admin:
    description: Access admin menu
    default: op
  rpg.editor:
    description: Access editor tools
    default: op
  rpg.mod:
    description: Access moderation tools
    default: op
  rpg.debug:
    description: Access debug overlay
    default: op

```

